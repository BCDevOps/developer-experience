{"_id":"ioredis","_rev":"279-97d277492ffa4de462cef54901932d18","name":"ioredis","description":"A robust, performance-focused and full-featured Redis client for Node.js.","dist-tags":{"latest":"4.16.1","next":"4.15.1"},"versions":{"1.0.0":{"name":"ioredis","version":"1.0.0","description":"A delightful, performance-focused Redis client for Node and io.js","main":"index.js","scripts":{"test":"mocha"},"keywords":["redis","node","io"],"author":{"name":"luin","email":"i@zihua.li","url":"http://zihua.li"},"license":"MIT","dependencies":{"fastqueue":"^0.1.0","ioredis-commands":"^3.0.0","lodash":"^3.6.0"},"_id":"ioredis@1.0.0","_shasum":"c10567814edf94f6814008913e919729cefcac54","_from":".","_npmVersion":"2.4.1","_nodeVersion":"1.1.0","_npmUser":{"name":"luin","email":"i@zihua.li"},"maintainers":[{"name":"luin","email":"i@zihua.li"}],"dist":{"shasum":"c10567814edf94f6814008913e919729cefcac54","tarball":"https://registry.npmjs.org/ioredis/-/ioredis-1.0.0.tgz"},"directories":{}},"0.0.1":{"name":"ioredis","version":"0.0.1","description":"A delightful, performance-focused Redis client for Node and io.js","main":"index.js","scripts":{"test":"mocha","generate-docs":"jsdoc --configure .jsdoc.json --verbose"},"keywords":["redis","node","io"],"author":{"name":"luin","email":"i@zihua.li","url":"http://zihua.li"},"license":"MIT","dependencies":{"bluebird":"^2.9.21","debug":"^2.1.3","fastqueue":"^0.1.0","flexbuffer":"0.0.6","ioredis-commands":"^3.0.0","lodash":"^3.6.0"},"devDependencies":{"chai":"^2.2.0","jaguarjs-jsdoc":"0.0.1","jsdoc":"^3.3.0-beta3","minami":"^1.1.0","mocha":"^2.2.1"},"gitHead":"63fd9fbe75d30aea156b43f07cb68d72f731d882","_id":"ioredis@0.0.1","_shasum":"f2d7c251c0797d230d07bc344553ea758efbacf5","_from":".","_npmVersion":"2.4.1","_nodeVersion":"1.1.0","_npmUser":{"name":"luin","email":"i@zihua.li"},"maintainers":[{"name":"luin","email":"i@zihua.li"}],"dist":{"shasum":"f2d7c251c0797d230d07bc344553ea758efbacf5","tarball":"https://registry.npmjs.org/ioredis/-/ioredis-0.0.1.tgz"},"directories":{}},"0.0.2":{"name":"ioredis","version":"0.0.2","description":"A delightful, performance-focused Redis client for Node and io.js","main":"index.js","scripts":{"test":"mocha","generate-docs":"jsdoc --configure .jsdoc.json --verbose"},"repository":{"type":"git","url":"git://github.com/luin/ioredis.git"},"keywords":["redis","node","io"],"author":{"name":"luin","email":"i@zihua.li","url":"http://zihua.li"},"license":"MIT","dependencies":{"bluebird":"^2.9.21","debug":"^2.1.3","fastqueue":"^0.1.0","flexbuffer":"0.0.6","ioredis-commands":"^3.0.0","lodash":"^3.6.0"},"devDependencies":{"chai":"^2.2.0","jaguarjs-jsdoc":"0.0.1","jsdoc":"^3.3.0-beta3","minami":"^1.1.0","mocha":"^2.2.1","sinon":"^1.14.1"},"engines":{"node":">= 0.11.16","iojs":">= 1.0.0"},"gitHead":"b34cee825e30d7cc1302572844522f9925f80fe6","bugs":{"url":"https://github.com/luin/ioredis/issues"},"homepage":"https://github.com/luin/ioredis","_id":"ioredis@0.0.2","_shasum":"54ccc3b126cad053bcdb38214146ca57f2dd0d80","_from":".","_npmVersion":"2.4.1","_nodeVersion":"1.1.0","_npmUser":{"name":"luin","email":"i@zihua.li"},"maintainers":[{"name":"luin","email":"i@zihua.li"}],"dist":{"shasum":"54ccc3b126cad053bcdb38214146ca57f2dd0d80","tarball":"https://registry.npmjs.org/ioredis/-/ioredis-0.0.2.tgz"},"directories":{}},"0.0.3":{"name":"ioredis","version":"0.0.3","description":"A delightful, performance-focused Redis client for Node and io.js","main":"index.js","scripts":{"test":"mocha","generate-docs":"jsdoc --configure .jsdoc.json --verbose"},"repository":{"type":"git","url":"git://github.com/luin/ioredis.git"},"keywords":["redis","node","io"],"author":{"name":"luin","email":"i@zihua.li","url":"http://zihua.li"},"license":"MIT","dependencies":{"bluebird":"^2.9.21","debug":"^2.1.3","fastqueue":"^0.1.0","flexbuffer":"0.0.6","ioredis-commands":"^3.0.0","lodash":"^3.6.0"},"devDependencies":{"chai":"^2.2.0","jaguarjs-jsdoc":"0.0.1","jsdoc":"^3.3.0-beta3","minami":"^1.1.0","mocha":"^2.2.1","sinon":"^1.14.1"},"engines":{"node":">= 0.11.16","iojs":">= 1.0.0"},"gitHead":"da4c46b8b17c5a3bef9f2c76909888912fd71b0a","bugs":{"url":"https://github.com/luin/ioredis/issues"},"homepage":"https://github.com/luin/ioredis","_id":"ioredis@0.0.3","_shasum":"5fa244cab5dbb768d4e5ddee3f7c12be1b821d76","_from":".","_npmVersion":"2.4.1","_nodeVersion":"1.1.0","_npmUser":{"name":"luin","email":"i@zihua.li"},"maintainers":[{"name":"luin","email":"i@zihua.li"}],"dist":{"shasum":"5fa244cab5dbb768d4e5ddee3f7c12be1b821d76","tarball":"https://registry.npmjs.org/ioredis/-/ioredis-0.0.3.tgz"},"directories":{}},"0.0.4":{"name":"ioredis","version":"0.0.4","description":"A delightful, performance-focused Redis client for Node and io.js","main":"index.js","scripts":{"test":"mocha","generate-docs":"jsdoc --configure .jsdoc.json --verbose"},"repository":{"type":"git","url":"git://github.com/luin/ioredis.git"},"keywords":["redis","node","io"],"author":{"name":"luin","email":"i@zihua.li","url":"http://zihua.li"},"license":"MIT","dependencies":{"bluebird":"^2.9.21","debug":"^2.1.3","fastqueue":"^0.1.0","flexbuffer":"0.0.6","ioredis-commands":"^3.0.0","lodash":"^3.6.0"},"devDependencies":{"chai":"^2.2.0","jaguarjs-jsdoc":"0.0.1","jsdoc":"^3.3.0-beta3","minami":"^1.1.0","mocha":"^2.2.1","sinon":"^1.14.1"},"engines":{"node":">= 0.11.16","iojs":">= 1.0.0"},"gitHead":"109d4f5eb1f44386d7f6e03b28ecb6e73923f9b6","bugs":{"url":"https://github.com/luin/ioredis/issues"},"homepage":"https://github.com/luin/ioredis","_id":"ioredis@0.0.4","_shasum":"026f5148af7197297dfcc66af61b5ea8f87cc700","_from":".","_npmVersion":"2.4.1","_nodeVersion":"1.1.0","_npmUser":{"name":"luin","email":"i@zihua.li"},"maintainers":[{"name":"luin","email":"i@zihua.li"}],"dist":{"shasum":"026f5148af7197297dfcc66af61b5ea8f87cc700","tarball":"https://registry.npmjs.org/ioredis/-/ioredis-0.0.4.tgz"},"directories":{}},"0.1.2":{"name":"ioredis","version":"0.1.2","description":"A delightful, performance-focused Redis client for Node and io.js","main":"index.js","scripts":{"test":"mocha","generate-docs":"jsdoc --configure .jsdoc.json --verbose"},"repository":{"type":"git","url":"git://github.com/luin/ioredis.git"},"keywords":["redis","node","io"],"author":{"name":"luin","email":"i@zihua.li","url":"http://zihua.li"},"license":"MIT","dependencies":{"bluebird":"^2.9.21","debug":"^2.1.3","fastqueue":"^0.1.0","flexbuffer":"0.0.6","ioredis-commands":"^3.0.0","lodash":"^3.6.0"},"devDependencies":{"chai":"^2.2.0","jsdoc":"^3.3.0-beta3","mocha":"^2.2.1","sinon":"^1.14.1"},"engines":{"node":">= 0.11.16","iojs":">= 1.0.0"},"gitHead":"345d9b2e5626c97207c8c709106ffea4125f16fa","bugs":{"url":"https://github.com/luin/ioredis/issues"},"homepage":"https://github.com/luin/ioredis","_id":"ioredis@0.1.2","_shasum":"cd0fdc6811e44e5cb2f2d268e64e00c1d1998841","_from":".","_npmVersion":"2.4.1","_nodeVersion":"1.1.0","_npmUser":{"name":"luin","email":"i@zihua.li"},"maintainers":[{"name":"luin","email":"i@zihua.li"}],"dist":{"shasum":"cd0fdc6811e44e5cb2f2d268e64e00c1d1998841","tarball":"https://registry.npmjs.org/ioredis/-/ioredis-0.1.2.tgz"},"directories":{}},"0.2.0":{"name":"ioredis","version":"0.2.0","description":"A delightful, performance-focused Redis client for Node and io.js","main":"index.js","scripts":{"test":"mocha","generate-docs":"jsdoc --configure .jsdoc.json --verbose"},"repository":{"type":"git","url":"git://github.com/luin/ioredis.git"},"keywords":["redis","node","io"],"author":{"name":"luin","email":"i@zihua.li","url":"http://zihua.li"},"license":"MIT","dependencies":{"bluebird":"^2.9.21","debug":"^2.1.3","fastqueue":"^0.1.0","flexbuffer":"0.0.6","ioredis-commands":"^3.0.0","lodash":"^3.6.0"},"devDependencies":{"chai":"^2.2.0","jsdoc":"^3.3.0-beta3","mocha":"^2.2.1","server-destroy":"^1.0.0","sinon":"^1.14.1"},"engines":{"node":">= 0.11.16","iojs":">= 1.0.0"},"gitHead":"f634f19d937466250652060e0b08fd43e0fe0959","bugs":{"url":"https://github.com/luin/ioredis/issues"},"homepage":"https://github.com/luin/ioredis","_id":"ioredis@0.2.0","_shasum":"c5461076b500d5614a96a0d18a4d65c80a3a5ecc","_from":".","_npmVersion":"2.4.1","_nodeVersion":"1.1.0","_npmUser":{"name":"luin","email":"i@zihua.li"},"maintainers":[{"name":"luin","email":"i@zihua.li"}],"dist":{"shasum":"c5461076b500d5614a96a0d18a4d65c80a3a5ecc","tarball":"https://registry.npmjs.org/ioredis/-/ioredis-0.2.0.tgz"},"directories":{}},"0.3.0":{"name":"ioredis","version":"0.3.0","description":"A delightful, performance-focused Redis client for Node and io.js","main":"index.js","scripts":{"test":"NODE_ENV=test mocha","test:debug":"NODE_ENV=test DEBUG=ioredis:* mocha","test:cov":"NODE_ENV=test node  ./node_modules/istanbul/lib/cli.js cover --preserve-comments ./node_modules/mocha/bin/_mocha -- -R spec","generate-docs":"jsdoc --configure .jsdoc.json --verbose"},"repository":{"type":"git","url":"git://github.com/luin/ioredis.git"},"keywords":["redis","node","io"],"author":{"name":"luin","email":"i@zihua.li","url":"http://zihua.li"},"license":"MIT","dependencies":{"bluebird":"^2.9.21","debug":"^2.1.3","fastqueue":"^0.1.0","flexbuffer":"0.0.6","ioredis-commands":"^3.0.0","lodash":"^3.6.0"},"devDependencies":{"chai":"^2.2.0","codeclimate-test-reporter":"0.0.4","istanbul":"^0.3.13","jsdoc":"^3.3.0-beta3","mocha":"^2.2.1","server-destroy":"^1.0.0","sinon":"^1.14.1"},"engines":{"node":">= 0.11.16","iojs":">= 1.0.0"},"gitHead":"578e82b0f90b4f86d628d5a9834688413328be07","bugs":{"url":"https://github.com/luin/ioredis/issues"},"homepage":"https://github.com/luin/ioredis","_id":"ioredis@0.3.0","_shasum":"ef8cd6f612fdd68beb899ac36bcf67f39288d234","_from":".","_npmVersion":"2.4.1","_nodeVersion":"1.1.0","_npmUser":{"name":"luin","email":"i@zihua.li"},"maintainers":[{"name":"luin","email":"i@zihua.li"}],"dist":{"shasum":"ef8cd6f612fdd68beb899ac36bcf67f39288d234","tarball":"https://registry.npmjs.org/ioredis/-/ioredis-0.3.0.tgz"},"directories":{}},"0.5.0":{"name":"ioredis","version":"0.5.0","description":"A delightful, performance-focused Redis client for Node and io.js","main":"index.js","scripts":{"test":"NODE_ENV=test mocha","test:debug":"NODE_ENV=test DEBUG=ioredis:* mocha","test:cov":"NODE_ENV=test node  ./node_modules/istanbul/lib/cli.js cover --preserve-comments ./node_modules/mocha/bin/_mocha -- -R spec","generate-docs":"jsdoc2md lib/redis.js lib/redis_cluster.js > API.md","bench":"matcha benchmark.js"},"repository":{"type":"git","url":"git://github.com/luin/ioredis.git"},"keywords":["redis","node","io"],"author":{"name":"luin","email":"i@zihua.li","url":"http://zihua.li"},"license":"MIT","dependencies":{"bluebird":"^2.9.21","debug":"^2.1.3","fastqueue":"^0.1.0","flexbuffer":"0.0.6","ioredis-commands":"^3.0.0","lodash":"^3.6.0"},"devDependencies":{"chai":"^2.2.0","codeclimate-test-reporter":"0.0.4","istanbul":"^0.3.13","jsdoc":"^3.3.0-beta3","matcha":"^0.6.0","mocha":"^2.2.1","server-destroy":"^1.0.0","sinon":"^1.14.1"},"engines":{"node":">= 0.11.16","iojs":">= 1.0.0"},"gitHead":"928a257e528c1d0b5f5adc573f462bb1589bdd45","bugs":{"url":"https://github.com/luin/ioredis/issues"},"homepage":"https://github.com/luin/ioredis","_id":"ioredis@0.5.0","_shasum":"5ab78161951e7873addd3172cb631a286d1c90e9","_from":".","_npmVersion":"2.7.4","_nodeVersion":"0.12.2","_npmUser":{"name":"luin","email":"i@zihua.li"},"maintainers":[{"name":"luin","email":"i@zihua.li"}],"dist":{"shasum":"5ab78161951e7873addd3172cb631a286d1c90e9","tarball":"https://registry.npmjs.org/ioredis/-/ioredis-0.5.0.tgz"},"directories":{}},"1.0.1":{"name":"ioredis","version":"1.0.1","description":"A delightful, performance-focused Redis client for Node and io.js","main":"index.js","scripts":{"test":"NODE_ENV=test mocha","test:debug":"NODE_ENV=test DEBUG=ioredis:* mocha","test:cov":"NODE_ENV=test node  ./node_modules/istanbul/lib/cli.js cover --preserve-comments ./node_modules/mocha/bin/_mocha -- -R spec","generate-docs":"jsdoc2md lib/redis.js lib/redis_cluster.js > API.md","bench":"matcha benchmark.js"},"repository":{"type":"git","url":"git://github.com/luin/ioredis.git"},"keywords":["redis","node","io"],"author":{"name":"luin","email":"i@zihua.li","url":"http://zihua.li"},"license":"MIT","dependencies":{"bluebird":"^2.9.21","debug":"^2.1.3","fastqueue":"^0.1.0","flexbuffer":"0.0.6","ioredis-commands":"^3.0.0","lodash":"^3.6.0"},"devDependencies":{"chai":"^2.2.0","codeclimate-test-reporter":"0.0.4","istanbul":"^0.3.13","jsdoc":"^3.3.0-beta3","matcha":"^0.6.0","mocha":"^2.2.1","server-destroy":"^1.0.0","sinon":"^1.14.1"},"engines":{"node":">= 0.11.16","iojs":">= 1.0.0"},"gitHead":"81fee29b7b6b431853c7af854904b4aa0b809ddc","bugs":{"url":"https://github.com/luin/ioredis/issues"},"homepage":"https://github.com/luin/ioredis","_id":"ioredis@1.0.1","_shasum":"9e0038d7d5ab1db390312cb352edb4037ee5755d","_from":".","_npmVersion":"2.7.4","_nodeVersion":"0.12.2","_npmUser":{"name":"luin","email":"i@zihua.li"},"maintainers":[{"name":"luin","email":"i@zihua.li"}],"dist":{"shasum":"9e0038d7d5ab1db390312cb352edb4037ee5755d","tarball":"https://registry.npmjs.org/ioredis/-/ioredis-1.0.1.tgz"},"directories":{}},"1.0.2":{"name":"ioredis","version":"1.0.2","description":"A delightful, performance-focused Redis client for Node and io.js","main":"index.js","scripts":{"test":"NODE_ENV=test mocha","test:debug":"NODE_ENV=test DEBUG=ioredis:* mocha","test:cov":"NODE_ENV=test node  ./node_modules/istanbul/lib/cli.js cover --preserve-comments ./node_modules/mocha/bin/_mocha -- -R spec","generate-docs":"jsdoc2md lib/redis.js lib/redis_cluster.js > API.md","bench":"matcha benchmark.js"},"repository":{"type":"git","url":"git://github.com/luin/ioredis.git"},"keywords":["redis","node","io"],"author":{"name":"luin","email":"i@zihua.li","url":"http://zihua.li"},"license":"MIT","dependencies":{"bluebird":"^2.9.21","debug":"^2.1.3","fastqueue":"^0.1.0","flexbuffer":"0.0.6","ioredis-commands":"^3.0.0","lodash":"^3.6.0"},"devDependencies":{"chai":"^2.2.0","codeclimate-test-reporter":"0.0.4","istanbul":"^0.3.13","jsdoc":"^3.3.0-beta3","matcha":"^0.6.0","mocha":"^2.2.1","server-destroy":"^1.0.0","sinon":"^1.14.1"},"engines":{"node":">= 0.11.16","iojs":">= 1.0.0"},"gitHead":"bf6879a52c69dee0813bada5249fcb42d3fc336f","bugs":{"url":"https://github.com/luin/ioredis/issues"},"homepage":"https://github.com/luin/ioredis","_id":"ioredis@1.0.2","_shasum":"352b8b1a48b21a4eb7ac14ff23a0fd2cd0301a97","_from":".","_npmVersion":"2.4.1","_nodeVersion":"1.1.0","_npmUser":{"name":"luin","email":"i@zihua.li"},"maintainers":[{"name":"luin","email":"i@zihua.li"}],"dist":{"shasum":"352b8b1a48b21a4eb7ac14ff23a0fd2cd0301a97","tarball":"https://registry.npmjs.org/ioredis/-/ioredis-1.0.2.tgz"},"directories":{}},"1.0.3":{"name":"ioredis","version":"1.0.3","description":"A delightful, performance-focused Redis client for Node and io.js","main":"index.js","scripts":{"test":"NODE_ENV=test mocha","test:debug":"NODE_ENV=test DEBUG=ioredis:* mocha","test:cov":"NODE_ENV=test node  ./node_modules/istanbul/lib/cli.js cover --preserve-comments ./node_modules/mocha/bin/_mocha -- -R spec","generate-docs":"jsdoc2md lib/redis.js lib/redis_cluster.js > API.md","bench":"matcha benchmark.js"},"repository":{"type":"git","url":"git://github.com/luin/ioredis.git"},"keywords":["redis","node","io"],"author":{"name":"luin","email":"i@zihua.li","url":"http://zihua.li"},"license":"MIT","dependencies":{"bluebird":"^2.9.21","debug":"^2.1.3","fastqueue":"^0.1.0","flexbuffer":"0.0.6","ioredis-commands":"^3.0.0","lodash":"^3.6.0"},"devDependencies":{"chai":"^2.2.0","codeclimate-test-reporter":"0.0.4","istanbul":"^0.3.13","jsdoc":"^3.3.0-beta3","matcha":"^0.6.0","mocha":"^2.2.1","server-destroy":"^1.0.0","sinon":"^1.14.1"},"engines":{"node":">= 0.11.16","iojs":">= 1.0.0"},"gitHead":"be33f1db9d66a2778b927b3236767a193ee14b77","bugs":{"url":"https://github.com/luin/ioredis/issues"},"homepage":"https://github.com/luin/ioredis","_id":"ioredis@1.0.3","_shasum":"02f3fdca3e1b572f928823db84d597dc0ffb061e","_from":".","_npmVersion":"2.7.4","_nodeVersion":"0.12.2","_npmUser":{"name":"luin","email":"i@zihua.li"},"maintainers":[{"name":"luin","email":"i@zihua.li"}],"dist":{"shasum":"02f3fdca3e1b572f928823db84d597dc0ffb061e","tarball":"https://registry.npmjs.org/ioredis/-/ioredis-1.0.3.tgz"},"directories":{}},"1.0.4":{"name":"ioredis","version":"1.0.4","description":"A delightful, performance-focused Redis client for Node and io.js","main":"index.js","scripts":{"test":"NODE_ENV=test mocha","test:debug":"NODE_ENV=test DEBUG=ioredis:* mocha","test:cov":"NODE_ENV=test node  ./node_modules/istanbul/lib/cli.js cover --preserve-comments ./node_modules/mocha/bin/_mocha -- -R spec","generate-docs":"jsdoc2md lib/redis.js lib/redis_cluster.js > API.md","bench":"matcha benchmark.js"},"repository":{"type":"git","url":"git://github.com/luin/ioredis.git"},"keywords":["redis","node","io"],"author":{"name":"luin","email":"i@zihua.li","url":"http://zihua.li"},"license":"MIT","dependencies":{"bluebird":"^2.9.21","debug":"^2.1.3","fastqueue":"^0.1.0","flexbuffer":"0.0.6","ioredis-commands":"^3.0.0","lodash":"^3.6.0"},"devDependencies":{"chai":"^2.2.0","codeclimate-test-reporter":"0.0.4","istanbul":"^0.3.13","jsdoc":"^3.3.0-beta3","matcha":"^0.6.0","mocha":"^2.2.1","server-destroy":"^1.0.0","sinon":"^1.14.1"},"engines":{"node":">= 0.11.16","iojs":">= 1.0.0"},"gitHead":"2c048ce9a9d84e535b55bf8da0099dfd0a049eff","bugs":{"url":"https://github.com/luin/ioredis/issues"},"homepage":"https://github.com/luin/ioredis","_id":"ioredis@1.0.4","_shasum":"c2ba414ca3cee0ceb06c5783258c121958b2e46c","_from":".","_npmVersion":"2.7.4","_nodeVersion":"0.12.2","_npmUser":{"name":"luin","email":"i@zihua.li"},"maintainers":[{"name":"luin","email":"i@zihua.li"}],"dist":{"shasum":"c2ba414ca3cee0ceb06c5783258c121958b2e46c","tarball":"https://registry.npmjs.org/ioredis/-/ioredis-1.0.4.tgz"},"directories":{}},"1.0.5":{"name":"ioredis","version":"1.0.5","description":"A delightful, performance-focused Redis client for Node and io.js","main":"index.js","scripts":{"test":"NODE_ENV=test mocha","test:debug":"NODE_ENV=test DEBUG=ioredis:* mocha","test:cov":"NODE_ENV=test node  ./node_modules/istanbul/lib/cli.js cover --preserve-comments ./node_modules/mocha/bin/_mocha -- -R spec","generate-docs":"jsdoc2md lib/redis.js lib/redis_cluster.js > API.md","bench":"matcha benchmark.js"},"repository":{"type":"git","url":"git://github.com/luin/ioredis.git"},"keywords":["redis","node","io","cluster","sentinel"],"author":{"name":"luin","email":"i@zihua.li","url":"http://zihua.li"},"license":"MIT","dependencies":{"bluebird":"^2.9.21","debug":"^2.1.3","fastqueue":"^0.1.0","flexbuffer":"0.0.6","ioredis-commands":"^3.0.0","lodash":"^3.6.0"},"devDependencies":{"chai":"^2.2.0","codeclimate-test-reporter":"0.0.4","istanbul":"^0.3.13","jsdoc":"^3.3.0-beta3","matcha":"^0.6.0","mocha":"^2.2.1","server-destroy":"^1.0.0","sinon":"^1.14.1"},"engines":{"node":">= 0.11.16","iojs":">= 1.0.0"},"gitHead":"30d654f1d601a62d3a9e70df0093a7ff530ee197","bugs":{"url":"https://github.com/luin/ioredis/issues"},"homepage":"https://github.com/luin/ioredis","_id":"ioredis@1.0.5","_shasum":"6acbf36be535a5e4271ad2b8c10c7a55be440e01","_from":".","_npmVersion":"2.7.4","_nodeVersion":"0.12.2","_npmUser":{"name":"luin","email":"i@zihua.li"},"maintainers":[{"name":"luin","email":"i@zihua.li"}],"dist":{"shasum":"6acbf36be535a5e4271ad2b8c10c7a55be440e01","tarball":"https://registry.npmjs.org/ioredis/-/ioredis-1.0.5.tgz"},"directories":{}},"1.0.6":{"name":"ioredis","version":"1.0.6","description":"A delightful, performance-focused Redis client for Node and io.js","main":"index.js","scripts":{"test":"NODE_ENV=test mocha","test:debug":"NODE_ENV=test DEBUG=ioredis:* mocha","test:cov":"NODE_ENV=test node  ./node_modules/istanbul/lib/cli.js cover --preserve-comments ./node_modules/mocha/bin/_mocha -- -R spec","generate-docs":"jsdoc2md lib/redis.js lib/redis_cluster.js > API.md","bench":"matcha benchmark.js"},"repository":{"type":"git","url":"git://github.com/luin/ioredis.git"},"keywords":["redis","node","io","cluster","sentinel"],"author":{"name":"luin","email":"i@zihua.li","url":"http://zihua.li"},"license":"MIT","dependencies":{"bluebird":"^2.9.21","debug":"^2.1.3","fastqueue":"^0.1.0","flexbuffer":"0.0.6","ioredis-commands":"^3.0.0","lodash":"^3.6.0"},"devDependencies":{"chai":"^2.2.0","codeclimate-test-reporter":"0.0.4","istanbul":"^0.3.13","jsdoc":"^3.3.0-beta3","matcha":"^0.6.0","mocha":"^2.2.1","server-destroy":"^1.0.0","sinon":"^1.14.1"},"engines":{"node":">= 0.11.16","iojs":">= 1.0.0"},"gitHead":"be6d5d11d9a1377d61afc18be7c59827f33a0c1f","bugs":{"url":"https://github.com/luin/ioredis/issues"},"homepage":"https://github.com/luin/ioredis","_id":"ioredis@1.0.6","_shasum":"a3f6a886a1403c5c35bb21143b030e78b932ebc3","_from":".","_npmVersion":"2.4.1","_nodeVersion":"1.1.0","_npmUser":{"name":"luin","email":"i@zihua.li"},"maintainers":[{"name":"luin","email":"i@zihua.li"}],"dist":{"shasum":"a3f6a886a1403c5c35bb21143b030e78b932ebc3","tarball":"https://registry.npmjs.org/ioredis/-/ioredis-1.0.6.tgz"},"directories":{}},"1.0.7":{"name":"ioredis","version":"1.0.7","description":"A delightful, performance-focused Redis client for Node and io.js","main":"index.js","scripts":{"test":"NODE_ENV=test mocha","test:debug":"NODE_ENV=test DEBUG=ioredis:* mocha","test:cov":"NODE_ENV=test node  ./node_modules/istanbul/lib/cli.js cover --preserve-comments ./node_modules/mocha/bin/_mocha -- -R spec","generate-docs":"jsdoc2md lib/redis.js lib/redis_cluster.js > API.md","bench":"matcha benchmark.js"},"repository":{"type":"git","url":"git://github.com/luin/ioredis.git"},"keywords":["redis","node","io","cluster","sentinel"],"author":{"name":"luin","email":"i@zihua.li","url":"http://zihua.li"},"license":"MIT","dependencies":{"bluebird":"^2.9.21","debug":"^2.1.3","fastqueue":"^0.1.0","flexbuffer":"0.0.6","ioredis-commands":"^3.0.0","lodash":"^3.6.0"},"devDependencies":{"chai":"^2.2.0","codeclimate-test-reporter":"0.0.4","istanbul":"^0.3.13","jsdoc":"^3.3.0-beta3","matcha":"^0.6.0","mocha":"^2.2.1","server-destroy":"^1.0.0","sinon":"^1.14.1"},"engines":{"node":">= 0.11.16","iojs":">= 1.0.0"},"gitHead":"a8761bde41f244673c1ea68f319ef88c8c4f2183","bugs":{"url":"https://github.com/luin/ioredis/issues"},"homepage":"https://github.com/luin/ioredis","_id":"ioredis@1.0.7","_shasum":"f425c1f2d83e28ebec0ccefffbd1ec5db8462c70","_from":".","_npmVersion":"2.4.1","_nodeVersion":"1.1.0","_npmUser":{"name":"luin","email":"i@zihua.li"},"maintainers":[{"name":"luin","email":"i@zihua.li"}],"dist":{"shasum":"f425c1f2d83e28ebec0ccefffbd1ec5db8462c70","tarball":"https://registry.npmjs.org/ioredis/-/ioredis-1.0.7.tgz"},"directories":{}},"1.0.8":{"name":"ioredis","version":"1.0.8","description":"A delightful, performance-focused Redis client for Node and io.js","main":"index.js","scripts":{"test":"NODE_ENV=test mocha","test:debug":"NODE_ENV=test DEBUG=ioredis:* mocha","test:cov":"NODE_ENV=test node  ./node_modules/istanbul/lib/cli.js cover --preserve-comments ./node_modules/mocha/bin/_mocha -- -R spec","generate-docs":"jsdoc2md lib/redis.js lib/redis_cluster.js > API.md","bench":"matcha benchmark.js"},"repository":{"type":"git","url":"git://github.com/luin/ioredis.git"},"keywords":["redis","node","io","cluster","sentinel"],"author":{"name":"luin","email":"i@zihua.li","url":"http://zihua.li"},"license":"MIT","dependencies":{"bluebird":"^2.9.21","debug":"^2.1.3","fastqueue":"^0.1.0","flexbuffer":"0.0.6","ioredis-commands":"^3.0.0","lodash":"^3.6.0"},"devDependencies":{"chai":"^2.2.0","codeclimate-test-reporter":"0.0.4","istanbul":"^0.3.13","jsdoc":"^3.3.0-beta3","matcha":"^0.6.0","mocha":"^2.2.1","server-destroy":"^1.0.0","sinon":"^1.14.1"},"engines":{"node":">= 0.11.16","iojs":">= 1.0.0"},"gitHead":"b16e25e63e30ebdfe6ccab35b1d9f8fc1dd75b6d","bugs":{"url":"https://github.com/luin/ioredis/issues"},"homepage":"https://github.com/luin/ioredis","_id":"ioredis@1.0.8","_shasum":"bdc0829af976bf6a912f8d82da6df21714cb8629","_from":".","_npmVersion":"2.4.1","_nodeVersion":"1.1.0","_npmUser":{"name":"luin","email":"i@zihua.li"},"maintainers":[{"name":"luin","email":"i@zihua.li"}],"dist":{"shasum":"bdc0829af976bf6a912f8d82da6df21714cb8629","tarball":"https://registry.npmjs.org/ioredis/-/ioredis-1.0.8.tgz"},"directories":{}},"1.0.9":{"name":"ioredis","version":"1.0.9","description":"A delightful, performance-focused Redis client for Node and io.js","main":"index.js","scripts":{"test":"NODE_ENV=test mocha","test:debug":"NODE_ENV=test DEBUG=ioredis:* mocha","test:cov":"NODE_ENV=test node  ./node_modules/istanbul/lib/cli.js cover --preserve-comments ./node_modules/mocha/bin/_mocha -- -R spec","generate-docs":"jsdoc2md lib/redis.js lib/redis_cluster.js > API.md","bench":"matcha benchmark.js"},"repository":{"type":"git","url":"git://github.com/luin/ioredis.git"},"keywords":["redis","node","io","cluster","sentinel"],"author":{"name":"luin","email":"i@zihua.li","url":"http://zihua.li"},"license":"MIT","dependencies":{"bluebird":"^2.9.21","debug":"^2.1.3","fastqueue":"^0.1.0","flexbuffer":"0.0.6","ioredis-commands":"4.0.0","lodash":"^3.6.0"},"devDependencies":{"chai":"^2.2.0","codeclimate-test-reporter":"0.0.4","istanbul":"^0.3.13","jsdoc":"^3.3.0-beta3","matcha":"^0.6.0","mocha":"^2.2.1","server-destroy":"^1.0.0","sinon":"^1.14.1"},"engines":{"node":">= 0.11.16","iojs":">= 1.0.0"},"gitHead":"2cec70bb826d4c26ded5c6067a4397a4cd91a78a","bugs":{"url":"https://github.com/luin/ioredis/issues"},"homepage":"https://github.com/luin/ioredis","_id":"ioredis@1.0.9","_shasum":"084be5d706c688f798fd7f9621699e1446b58a0c","_from":".","_npmVersion":"2.4.1","_nodeVersion":"1.1.0","_npmUser":{"name":"luin","email":"i@zihua.li"},"maintainers":[{"name":"luin","email":"i@zihua.li"}],"dist":{"shasum":"084be5d706c688f798fd7f9621699e1446b58a0c","tarball":"https://registry.npmjs.org/ioredis/-/ioredis-1.0.9.tgz"},"directories":{}},"1.0.10":{"name":"ioredis","version":"1.0.10","description":"A delightful, performance-focused Redis client for Node and io.js","main":"index.js","scripts":{"test":"NODE_ENV=test mocha","test:debug":"NODE_ENV=test DEBUG=ioredis:* mocha","test:cov":"NODE_ENV=test node  ./node_modules/istanbul/lib/cli.js cover --preserve-comments ./node_modules/mocha/bin/_mocha -- -R spec","generate-docs":"jsdoc2md lib/redis.js lib/redis_cluster.js > API.md","bench":"matcha benchmark.js"},"repository":{"type":"git","url":"git://github.com/luin/ioredis.git"},"keywords":["redis","node","io","cluster","sentinel"],"author":{"name":"luin","email":"i@zihua.li","url":"http://zihua.li"},"license":"MIT","dependencies":{"bluebird":"^2.9.21","debug":"^2.1.3","fastqueue":"^0.1.0","flexbuffer":"0.0.6","ioredis-commands":"4.0.0","lodash":"^3.6.0"},"devDependencies":{"chai":"^2.2.0","codeclimate-test-reporter":"0.0.4","istanbul":"^0.3.13","jsdoc":"^3.3.0-beta3","matcha":"^0.6.0","mocha":"^2.2.1","server-destroy":"^1.0.0","sinon":"^1.14.1"},"engines":{"node":">= 0.11.16","iojs":">= 1.0.0"},"gitHead":"5b64b47e9d8d4f647a6006f8427dc45723bdda99","bugs":{"url":"https://github.com/luin/ioredis/issues"},"homepage":"https://github.com/luin/ioredis","_id":"ioredis@1.0.10","_shasum":"9c8db9dc78f7e00619891f5150129f65368682ff","_from":".","_npmVersion":"2.4.1","_nodeVersion":"1.1.0","_npmUser":{"name":"luin","email":"i@zihua.li"},"maintainers":[{"name":"luin","email":"i@zihua.li"}],"dist":{"shasum":"9c8db9dc78f7e00619891f5150129f65368682ff","tarball":"https://registry.npmjs.org/ioredis/-/ioredis-1.0.10.tgz"},"directories":{}},"1.0.11":{"name":"ioredis","version":"1.0.11","description":"A delightful, performance-focused Redis client for Node and io.js","main":"index.js","scripts":{"test":"NODE_ENV=test mocha","test:debug":"NODE_ENV=test DEBUG=ioredis:* mocha","test:cov":"NODE_ENV=test node  ./node_modules/istanbul/lib/cli.js cover --preserve-comments ./node_modules/mocha/bin/_mocha -- -R spec","generate-docs":"jsdoc2md lib/redis.js lib/redis_cluster.js > API.md","bench":"matcha benchmark.js"},"repository":{"type":"git","url":"git://github.com/luin/ioredis.git"},"keywords":["redis","node","io","cluster","sentinel"],"author":{"name":"luin","email":"i@zihua.li","url":"http://zihua.li"},"license":"MIT","dependencies":{"bluebird":"^2.9.21","debug":"^2.1.3","fastqueue":"^0.1.0","flexbuffer":"0.0.6","ioredis-commands":"4.0.0","lodash":"^3.6.0"},"devDependencies":{"chai":"^2.2.0","codeclimate-test-reporter":"0.0.4","istanbul":"^0.3.13","jsdoc":"^3.3.0-beta3","matcha":"^0.6.0","mocha":"^2.2.1","server-destroy":"^1.0.0","sinon":"^1.14.1"},"engines":{"node":">= 0.11.16","iojs":">= 1.0.0"},"gitHead":"b6d63199ea6f8c8da67906529256f215df68c1ed","bugs":{"url":"https://github.com/luin/ioredis/issues"},"homepage":"https://github.com/luin/ioredis","_id":"ioredis@1.0.11","_shasum":"2af1cddc7f6667763348d8b90444ff88f747f6d6","_from":".","_npmVersion":"2.4.1","_nodeVersion":"1.1.0","_npmUser":{"name":"luin","email":"i@zihua.li"},"maintainers":[{"name":"luin","email":"i@zihua.li"}],"dist":{"shasum":"2af1cddc7f6667763348d8b90444ff88f747f6d6","tarball":"https://registry.npmjs.org/ioredis/-/ioredis-1.0.11.tgz"},"directories":{}},"1.0.12":{"name":"ioredis","version":"1.0.12","description":"A delightful, performance-focused Redis client for Node and io.js","main":"index.js","scripts":{"test":"NODE_ENV=test mocha","test:debug":"NODE_ENV=test DEBUG=ioredis:* mocha","test:cov":"NODE_ENV=test node  ./node_modules/istanbul/lib/cli.js cover --preserve-comments ./node_modules/mocha/bin/_mocha -- -R spec","generate-docs":"jsdoc2md lib/redis.js lib/redis_cluster.js lib/commander.js > API.md","bench":"matcha benchmark.js"},"repository":{"type":"git","url":"git://github.com/luin/ioredis.git"},"keywords":["redis","node","io","cluster","sentinel"],"author":{"name":"luin","email":"i@zihua.li","url":"http://zihua.li"},"license":"MIT","dependencies":{"bluebird":"^2.9.21","debug":"^2.1.3","flexbuffer":"0.0.6","ioredis-commands":"4.0.0","lodash":"^3.6.0"},"devDependencies":{"chai":"^2.2.0","codeclimate-test-reporter":"0.0.4","istanbul":"^0.3.13","jsdoc":"^3.3.0-beta3","jsdoc-to-markdown":"^1.0.3","matcha":"^0.6.0","mocha":"^2.2.1","sinon":"^1.14.1"},"engines":{"node":">= 0.11.16","iojs":">= 1.0.0"},"gitHead":"a8b070d18dca7e736687e9fc7907965d5e0b21d4","bugs":{"url":"https://github.com/luin/ioredis/issues"},"homepage":"https://github.com/luin/ioredis","_id":"ioredis@1.0.12","_shasum":"f2dc188ec9332b0194d6313d6c2bc24399a04d00","_from":".","_npmVersion":"2.4.1","_nodeVersion":"1.1.0","_npmUser":{"name":"luin","email":"i@zihua.li"},"maintainers":[{"name":"luin","email":"i@zihua.li"}],"dist":{"shasum":"f2dc188ec9332b0194d6313d6c2bc24399a04d00","tarball":"https://registry.npmjs.org/ioredis/-/ioredis-1.0.12.tgz"},"directories":{}},"1.0.13":{"name":"ioredis","version":"1.0.13","description":"A delightful, performance-focused Redis client for Node and io.js","main":"index.js","scripts":{"test":"NODE_ENV=test DEBUG=ioredis:* mocha","test:cov":"NODE_ENV=test DEBUG=ioredis:* node ./node_modules/istanbul/lib/cli.js cover --preserve-comments ./node_modules/mocha/bin/_mocha -- -R spec","generate-docs":"jsdoc2md lib/redis.js lib/redis_cluster.js lib/commander.js > API.md","bench":"matcha benchmark.js"},"repository":{"type":"git","url":"git://github.com/luin/ioredis.git"},"keywords":["redis","node","io","cluster","sentinel"],"author":{"name":"luin","email":"i@zihua.li","url":"http://zihua.li"},"license":"MIT","dependencies":{"bluebird":"^2.9.21","debug":"^2.1.3","flexbuffer":"0.0.6","ioredis-commands":"4.0.0","lodash":"^3.6.0"},"devDependencies":{"chai":"^2.2.0","codeclimate-test-reporter":"0.0.4","istanbul":"^0.3.13","jsdoc":"^3.3.0-beta3","jsdoc-to-markdown":"^1.0.3","matcha":"^0.6.0","mocha":"^2.2.1","server-destroy":"^1.0.0","sinon":"^1.14.1"},"engines":{"node":">= 0.11.16","iojs":">= 1.0.0"},"gitHead":"cfde97780909b1e869d61603f26e750a30be5475","bugs":{"url":"https://github.com/luin/ioredis/issues"},"homepage":"https://github.com/luin/ioredis","_id":"ioredis@1.0.13","_shasum":"2711f22deddcd08d1a7102797f802120343f1ff2","_from":".","_npmVersion":"2.4.1","_nodeVersion":"1.1.0","_npmUser":{"name":"luin","email":"i@zihua.li"},"maintainers":[{"name":"luin","email":"i@zihua.li"}],"dist":{"shasum":"2711f22deddcd08d1a7102797f802120343f1ff2","tarball":"https://registry.npmjs.org/ioredis/-/ioredis-1.0.13.tgz"},"directories":{}},"1.1.0":{"name":"ioredis","version":"1.1.0","description":"A delightful, performance-focused Redis client for Node and io.js","main":"index.js","scripts":{"test":"NODE_ENV=test DEBUG=ioredis:* mocha","test:cov":"NODE_ENV=test DEBUG=ioredis:* node ./node_modules/istanbul/lib/cli.js cover --preserve-comments ./node_modules/mocha/bin/_mocha -- -R spec","generate-docs":"jsdoc2md lib/redis.js lib/redis_cluster.js lib/commander.js > API.md","bench":"matcha benchmarks/*.js"},"repository":{"type":"git","url":"git://github.com/luin/ioredis.git"},"keywords":["redis","cluster","sentinel","pipelining"],"author":{"name":"luin","email":"i@zihua.li","url":"http://zihua.li"},"license":"MIT","dependencies":{"bluebird":"^2.9.21","debug":"^2.1.3","flexbuffer":"0.0.6","ioredis-commands":"4.0.0","lodash":"^3.6.0"},"devDependencies":{"chai":"^2.2.0","codeclimate-test-reporter":"0.0.4","istanbul":"^0.3.13","jsdoc":"^3.3.0-beta3","jsdoc-to-markdown":"^1.0.3","matcha":"^0.6.0","mocha":"^2.2.1","server-destroy":"^1.0.0","sinon":"^1.14.1"},"engines":{"node":">= 0.11.16","iojs":">= 1.0.0"},"gitHead":"71b1d3a142f5c3bb2dedcfc7165576f1de84c8ba","bugs":{"url":"https://github.com/luin/ioredis/issues"},"homepage":"https://github.com/luin/ioredis","_id":"ioredis@1.1.0","_shasum":"62988b82cc74c6da2228eea7930044d3f30b7350","_from":".","_npmVersion":"2.4.1","_nodeVersion":"1.1.0","_npmUser":{"name":"luin","email":"i@zihua.li"},"maintainers":[{"name":"luin","email":"i@zihua.li"}],"dist":{"shasum":"62988b82cc74c6da2228eea7930044d3f30b7350","tarball":"https://registry.npmjs.org/ioredis/-/ioredis-1.1.0.tgz"},"directories":{}},"1.1.1":{"name":"ioredis","version":"1.1.1","description":"A delightful, performance-focused Redis client for Node and io.js","main":"index.js","scripts":{"test":"NODE_ENV=test DEBUG=ioredis:* mocha","test:cov":"NODE_ENV=test DEBUG=ioredis:* node ./node_modules/istanbul/lib/cli.js cover --preserve-comments ./node_modules/mocha/bin/_mocha -- -R spec","generate-docs":"jsdoc2md lib/redis.js lib/redis_cluster.js lib/commander.js > API.md","bench":"matcha benchmarks/*.js"},"repository":{"type":"git","url":"git://github.com/luin/ioredis.git"},"keywords":["redis","cluster","sentinel","pipelining"],"author":{"name":"luin","email":"i@zihua.li","url":"http://zihua.li"},"license":"MIT","dependencies":{"bluebird":"^2.9.21","debug":"^2.1.3","flexbuffer":"0.0.6","ioredis-commands":"4.0.0","lodash":"^3.6.0"},"devDependencies":{"chai":"^2.2.0","codeclimate-test-reporter":"0.0.4","istanbul":"^0.3.13","jsdoc":"^3.3.0-beta3","jsdoc-to-markdown":"^1.0.3","matcha":"^0.6.0","mocha":"^2.2.1","server-destroy":"^1.0.0","sinon":"^1.14.1"},"engines":{"node":">= 0.11.16","iojs":">= 1.0.0"},"gitHead":"a11ff358098fd47179fa147ccc0fd0fc622097bb","bugs":{"url":"https://github.com/luin/ioredis/issues"},"homepage":"https://github.com/luin/ioredis","_id":"ioredis@1.1.1","_shasum":"b393a1e9260c3a87ee76ba3b1bf9264b7a01e6ab","_from":".","_npmVersion":"2.4.1","_nodeVersion":"1.1.0","_npmUser":{"name":"luin","email":"i@zihua.li"},"maintainers":[{"name":"luin","email":"i@zihua.li"}],"dist":{"shasum":"b393a1e9260c3a87ee76ba3b1bf9264b7a01e6ab","tarball":"https://registry.npmjs.org/ioredis/-/ioredis-1.1.1.tgz"},"directories":{}},"1.1.2":{"name":"ioredis","version":"1.1.2","description":"A delightful, performance-focused Redis client for Node and io.js","main":"index.js","scripts":{"test":"NODE_ENV=test DEBUG=ioredis:* mocha","test:cov":"NODE_ENV=test DEBUG=ioredis:* node ./node_modules/istanbul/lib/cli.js cover --preserve-comments ./node_modules/mocha/bin/_mocha -- -R spec","generate-docs":"jsdoc2md lib/redis.js lib/redis_cluster.js lib/commander.js > API.md","bench":"matcha benchmarks/*.js"},"repository":{"type":"git","url":"git://github.com/luin/ioredis.git"},"keywords":["redis","cluster","sentinel","pipelining"],"author":{"name":"luin","email":"i@zihua.li","url":"http://zihua.li"},"license":"MIT","dependencies":{"bluebird":"^2.9.21","debug":"^2.1.3","flexbuffer":"0.0.6","ioredis-commands":"4.0.0","lodash":"^3.6.0"},"devDependencies":{"chai":"^2.2.0","codeclimate-test-reporter":"0.0.4","istanbul":"^0.3.13","jsdoc":"^3.3.0-beta3","jsdoc-to-markdown":"^1.0.3","matcha":"^0.6.0","mocha":"^2.2.1","server-destroy":"^1.0.0","sinon":"^1.14.1"},"engines":{"node":">= 0.11.16","iojs":">= 1.0.0"},"gitHead":"f57f2eae89f69f748ee3f98ec4f074d2af5ca54b","bugs":{"url":"https://github.com/luin/ioredis/issues"},"homepage":"https://github.com/luin/ioredis","_id":"ioredis@1.1.2","_shasum":"f15523da610dc01141cc987b726bf74ffc9471cc","_from":".","_npmVersion":"2.4.1","_nodeVersion":"1.1.0","_npmUser":{"name":"luin","email":"i@zihua.li"},"maintainers":[{"name":"luin","email":"i@zihua.li"}],"dist":{"shasum":"f15523da610dc01141cc987b726bf74ffc9471cc","tarball":"https://registry.npmjs.org/ioredis/-/ioredis-1.1.2.tgz"},"directories":{}},"1.1.3":{"name":"ioredis","version":"1.1.3","description":"A delightful, performance-focused Redis client for Node and io.js","main":"index.js","scripts":{"test":"NODE_ENV=test DEBUG=ioredis:* mocha","test:cov":"NODE_ENV=test DEBUG=ioredis:* node ./node_modules/istanbul/lib/cli.js cover --preserve-comments ./node_modules/mocha/bin/_mocha -- -R spec","generate-docs":"jsdoc2md lib/redis.js lib/redis_cluster.js lib/commander.js > API.md","bench":"matcha benchmarks/*.js"},"repository":{"type":"git","url":"git://github.com/luin/ioredis.git"},"keywords":["redis","cluster","sentinel","pipelining"],"author":{"name":"luin","email":"i@zihua.li","url":"http://zihua.li"},"license":"MIT","dependencies":{"bluebird":"^2.9.21","debug":"^2.1.3","flexbuffer":"0.0.6","ioredis-commands":"4.0.0","lodash":"^3.6.0"},"devDependencies":{"chai":"^2.2.0","codeclimate-test-reporter":"0.0.4","istanbul":"^0.3.13","jsdoc":"^3.3.0-beta3","jsdoc-to-markdown":"^1.0.3","matcha":"^0.6.0","mocha":"^2.2.1","server-destroy":"^1.0.0","sinon":"^1.14.1"},"engines":{"node":">= 0.11.16","iojs":">= 1.0.0"},"gitHead":"888d71000c7c5875dc2ea3389bca3d1c2e94e1ad","bugs":{"url":"https://github.com/luin/ioredis/issues"},"homepage":"https://github.com/luin/ioredis","_id":"ioredis@1.1.3","_shasum":"cd7c8ceac78fe8745543b45d7254d6b136c8063c","_from":".","_npmVersion":"2.4.1","_nodeVersion":"1.1.0","_npmUser":{"name":"luin","email":"i@zihua.li"},"maintainers":[{"name":"luin","email":"i@zihua.li"}],"dist":{"shasum":"cd7c8ceac78fe8745543b45d7254d6b136c8063c","tarball":"https://registry.npmjs.org/ioredis/-/ioredis-1.1.3.tgz"},"directories":{}},"1.1.4":{"name":"ioredis","version":"1.1.4","description":"A delightful, performance-focused Redis client for Node and io.js","main":"index.js","scripts":{"test":"NODE_ENV=test DEBUG=ioredis:* mocha","test:cov":"NODE_ENV=test DEBUG=ioredis:* node ./node_modules/istanbul/lib/cli.js cover --preserve-comments ./node_modules/mocha/bin/_mocha -- -R spec","generate-docs":"jsdoc2md lib/redis.js lib/redis_cluster.js lib/commander.js > API.md","bench":"matcha benchmarks/*.js"},"repository":{"type":"git","url":"git://github.com/luin/ioredis.git"},"keywords":["redis","cluster","sentinel","pipelining"],"author":{"name":"luin","email":"i@zihua.li","url":"http://zihua.li"},"license":"MIT","dependencies":{"bluebird":"^2.9.21","debug":"^2.1.3","flexbuffer":"0.0.6","ioredis-commands":"4.0.0","lodash":"^3.6.0"},"devDependencies":{"chai":"^2.2.0","codeclimate-test-reporter":"0.0.4","istanbul":"^0.3.13","jsdoc":"^3.3.0-beta3","jsdoc-to-markdown":"^1.0.3","matcha":"^0.6.0","mocha":"^2.2.1","server-destroy":"^1.0.0","sinon":"^1.14.1"},"engines":{"node":">= 0.11.16","iojs":">= 1.0.0"},"gitHead":"3294a1167b41e881ddaaa39c3e5f93fd65bcae21","bugs":{"url":"https://github.com/luin/ioredis/issues"},"homepage":"https://github.com/luin/ioredis","_id":"ioredis@1.1.4","_shasum":"a4ad7f80ecc1b042b16e530e23315be56b254daf","_from":".","_npmVersion":"2.4.1","_nodeVersion":"1.1.0","_npmUser":{"name":"luin","email":"i@zihua.li"},"maintainers":[{"name":"luin","email":"i@zihua.li"}],"dist":{"shasum":"a4ad7f80ecc1b042b16e530e23315be56b254daf","tarball":"https://registry.npmjs.org/ioredis/-/ioredis-1.1.4.tgz"},"directories":{}},"1.2.0":{"name":"ioredis","version":"1.2.0","description":"A delightful, performance-focused Redis client for Node and io.js","main":"index.js","scripts":{"test":"NODE_ENV=test DEBUG=ioredis:* mocha","test:cov":"NODE_ENV=test DEBUG=ioredis:* node ./node_modules/istanbul/lib/cli.js cover --preserve-comments ./node_modules/mocha/bin/_mocha -- -R spec","generate-docs":"jsdoc2md lib/redis.js lib/redis_cluster.js lib/commander.js > API.md","bench":"matcha benchmarks/*.js"},"repository":{"type":"git","url":"git://github.com/luin/ioredis.git"},"keywords":["redis","cluster","sentinel","pipelining"],"author":{"name":"luin","email":"i@zihua.li","url":"http://zihua.li"},"license":"MIT","dependencies":{"bluebird":"^2.9.21","debug":"^2.1.3","flexbuffer":"0.0.6","ioredis-commands":"4.0.0","lodash":"^3.6.0"},"devDependencies":{"chai":"^2.2.0","codeclimate-test-reporter":"0.0.4","istanbul":"^0.3.13","jsdoc":"^3.3.0-beta3","jsdoc-to-markdown":"^1.0.3","matcha":"^0.6.0","mocha":"^2.2.1","server-destroy":"^1.0.0","sinon":"^1.14.1"},"engines":{"node":">= 0.11.16","iojs":">= 1.0.0"},"gitHead":"b92603a93694fdebf00f7a76c025c0f517f12f75","bugs":{"url":"https://github.com/luin/ioredis/issues"},"homepage":"https://github.com/luin/ioredis","_id":"ioredis@1.2.0","_shasum":"54b1ac86ca51fd232df6242832cb7cf008a59c83","_from":".","_npmVersion":"2.4.1","_nodeVersion":"1.1.0","_npmUser":{"name":"luin","email":"i@zihua.li"},"maintainers":[{"name":"luin","email":"i@zihua.li"}],"dist":{"shasum":"54b1ac86ca51fd232df6242832cb7cf008a59c83","tarball":"https://registry.npmjs.org/ioredis/-/ioredis-1.2.0.tgz"},"directories":{}},"1.2.1":{"name":"ioredis","version":"1.2.1","description":"A delightful, performance-focused Redis client for Node and io.js","main":"index.js","scripts":{"test":"NODE_ENV=test DEBUG=ioredis:* mocha","test:cov":"NODE_ENV=test DEBUG=ioredis:* node ./node_modules/istanbul/lib/cli.js cover --preserve-comments ./node_modules/mocha/bin/_mocha -- -R spec","generate-docs":"jsdoc2md lib/redis.js lib/redis_cluster.js lib/commander.js > API.md","bench":"matcha benchmarks/*.js"},"repository":{"type":"git","url":"git://github.com/luin/ioredis.git"},"keywords":["redis","cluster","sentinel","pipelining"],"author":{"name":"luin","email":"i@zihua.li","url":"http://zihua.li"},"license":"MIT","dependencies":{"bluebird":"^2.9.21","debug":"^2.1.3","flexbuffer":"0.0.6","ioredis-commands":"4.0.0","lodash":"^3.6.0"},"devDependencies":{"chai":"^2.2.0","codeclimate-test-reporter":"0.0.4","istanbul":"^0.3.13","jsdoc":"^3.3.0-beta3","jsdoc-to-markdown":"^1.0.3","matcha":"^0.6.0","mocha":"^2.2.1","server-destroy":"^1.0.0","sinon":"^1.14.1"},"engines":{"node":">= 0.11.16","iojs":">= 1.0.0"},"gitHead":"44fb5780836c3d62fa03ecebdb02159445ab8dee","bugs":{"url":"https://github.com/luin/ioredis/issues"},"homepage":"https://github.com/luin/ioredis","_id":"ioredis@1.2.1","_shasum":"034d1079fd7b44f015a927d051ac938dc0fcfd00","_from":".","_npmVersion":"2.4.1","_nodeVersion":"1.1.0","_npmUser":{"name":"luin","email":"i@zihua.li"},"maintainers":[{"name":"luin","email":"i@zihua.li"}],"dist":{"shasum":"034d1079fd7b44f015a927d051ac938dc0fcfd00","tarball":"https://registry.npmjs.org/ioredis/-/ioredis-1.2.1.tgz"},"directories":{}},"1.2.2":{"name":"ioredis","version":"1.2.2","description":"A delightful, performance-focused Redis client for Node and io.js","main":"index.js","scripts":{"test":"NODE_ENV=test DEBUG=ioredis:* mocha","test:cov":"NODE_ENV=test DEBUG=ioredis:* node ./node_modules/istanbul/lib/cli.js cover --preserve-comments ./node_modules/mocha/bin/_mocha -- -R spec","generate-docs":"jsdoc2md lib/redis.js lib/redis_cluster.js lib/commander.js > API.md","bench":"matcha benchmarks/*.js"},"repository":{"type":"git","url":"git://github.com/luin/ioredis.git"},"keywords":["redis","cluster","sentinel","pipelining"],"author":{"name":"luin","email":"i@zihua.li","url":"http://zihua.li"},"license":"MIT","dependencies":{"bluebird":"^2.9.21","debug":"^2.1.3","flexbuffer":"0.0.6","ioredis-commands":"4.0.0","lodash":"^3.6.0"},"devDependencies":{"chai":"^2.2.0","codeclimate-test-reporter":"0.0.4","istanbul":"^0.3.13","jsdoc":"^3.3.0-beta3","jsdoc-to-markdown":"^1.0.3","matcha":"^0.6.0","mocha":"^2.2.1","server-destroy":"^1.0.0","sinon":"^1.14.1"},"engines":{"node":">= 0.11.16","iojs":">= 1.0.0"},"gitHead":"1e583e8ccaf879fb0d8596ceae3ad52a44dee64f","bugs":{"url":"https://github.com/luin/ioredis/issues"},"homepage":"https://github.com/luin/ioredis","_id":"ioredis@1.2.2","_shasum":"c7117c21ef258a972b6f7f0f060f1f4d53fc6d92","_from":".","_npmVersion":"2.4.1","_nodeVersion":"1.1.0","_npmUser":{"name":"luin","email":"i@zihua.li"},"maintainers":[{"name":"luin","email":"i@zihua.li"}],"dist":{"shasum":"c7117c21ef258a972b6f7f0f060f1f4d53fc6d92","tarball":"https://registry.npmjs.org/ioredis/-/ioredis-1.2.2.tgz"},"directories":{}},"1.2.3":{"name":"ioredis","version":"1.2.3","description":"A delightful, performance-focused Redis client for Node and io.js","main":"index.js","scripts":{"test":"NODE_ENV=test DEBUG=ioredis:* mocha","test:cov":"NODE_ENV=test DEBUG=ioredis:* node ./node_modules/istanbul/lib/cli.js cover --preserve-comments ./node_modules/mocha/bin/_mocha -- -R spec","generate-docs":"jsdoc2md lib/redis.js lib/redis_cluster.js lib/commander.js > API.md","bench":"matcha benchmarks/*.js"},"repository":{"type":"git","url":"git://github.com/luin/ioredis.git"},"keywords":["redis","cluster","sentinel","pipelining"],"author":{"name":"luin","email":"i@zihua.li","url":"http://zihua.li"},"license":"MIT","dependencies":{"bluebird":"^2.9.21","debug":"^2.1.3","flexbuffer":"0.0.6","ioredis-commands":"4.0.0","lodash":"^3.6.0"},"devDependencies":{"chai":"^2.2.0","codeclimate-test-reporter":"0.0.4","istanbul":"^0.3.13","jsdoc":"^3.3.0-beta3","jsdoc-to-markdown":"^1.0.3","matcha":"^0.6.0","mocha":"^2.2.1","server-destroy":"^1.0.0","sinon":"^1.14.1"},"engines":{"node":">= 0.11.16","iojs":">= 1.0.0"},"gitHead":"a6cb94e66802546b8e79aa5eb7261deb43d02cdd","bugs":{"url":"https://github.com/luin/ioredis/issues"},"homepage":"https://github.com/luin/ioredis","_id":"ioredis@1.2.3","_shasum":"3ccc8b35e1f05a19612242e6c13d73e47cdc8927","_from":".","_npmVersion":"2.4.1","_nodeVersion":"1.1.0","_npmUser":{"name":"luin","email":"i@zihua.li"},"maintainers":[{"name":"luin","email":"i@zihua.li"}],"dist":{"shasum":"3ccc8b35e1f05a19612242e6c13d73e47cdc8927","tarball":"https://registry.npmjs.org/ioredis/-/ioredis-1.2.3.tgz"},"directories":{}},"1.2.4":{"name":"ioredis","version":"1.2.4","description":"A delightful, performance-focused Redis client for Node and io.js","main":"index.js","scripts":{"test":"NODE_ENV=test DEBUG=ioredis:* mocha","test:cov":"NODE_ENV=test DEBUG=ioredis:* node ./node_modules/istanbul/lib/cli.js cover --preserve-comments ./node_modules/mocha/bin/_mocha -- -R spec","generate-docs":"jsdoc2md lib/redis.js lib/cluster.js lib/commander.js > API.md","bench":"matcha benchmarks/*.js"},"repository":{"type":"git","url":"git://github.com/luin/ioredis.git"},"keywords":["redis","cluster","sentinel","pipelining"],"author":{"name":"luin","email":"i@zihua.li","url":"http://zihua.li"},"license":"MIT","dependencies":{"bluebird":"^2.9.21","debug":"^2.1.3","flexbuffer":"0.0.6","ioredis-commands":"4.0.0","lodash":"^3.6.0"},"devDependencies":{"chai":"^2.2.0","codeclimate-test-reporter":"0.0.4","istanbul":"^0.3.13","jsdoc":"^3.3.0-beta3","jsdoc-to-markdown":"^1.0.3","matcha":"^0.6.0","mocha":"^2.2.1","server-destroy":"^1.0.0","sinon":"^1.14.1"},"engines":{"node":">= 0.11.16","iojs":">= 1.0.0"},"gitHead":"4cd42ab96a0533956ed8cb704b457f27da61e6e1","bugs":{"url":"https://github.com/luin/ioredis/issues"},"homepage":"https://github.com/luin/ioredis","_id":"ioredis@1.2.4","_shasum":"b40f97bdc15545acf7a2f59216ce3178747893ae","_from":".","_npmVersion":"2.4.1","_nodeVersion":"1.1.0","_npmUser":{"name":"luin","email":"i@zihua.li"},"maintainers":[{"name":"luin","email":"i@zihua.li"}],"dist":{"shasum":"b40f97bdc15545acf7a2f59216ce3178747893ae","tarball":"https://registry.npmjs.org/ioredis/-/ioredis-1.2.4.tgz"},"directories":{}},"1.2.5":{"name":"ioredis","version":"1.2.5","description":"A delightful, performance-focused Redis client for Node and io.js","main":"index.js","scripts":{"test":"NODE_ENV=test DEBUG=ioredis:* mocha","test:cov":"NODE_ENV=test DEBUG=ioredis:* node ./node_modules/istanbul/lib/cli.js cover --preserve-comments ./node_modules/mocha/bin/_mocha -- -R spec","generate-docs":"jsdoc2md lib/redis.js lib/cluster.js lib/commander.js > API.md","bench":"matcha benchmarks/*.js"},"repository":{"type":"git","url":"git://github.com/luin/ioredis.git"},"keywords":["redis","cluster","sentinel","pipelining"],"author":{"name":"luin","email":"i@zihua.li","url":"http://zihua.li"},"license":"MIT","dependencies":{"bluebird":"^2.9.21","debug":"^2.1.3","flexbuffer":"0.0.6","ioredis-commands":"4.0.0","lodash":"^3.6.0"},"devDependencies":{"chai":"^2.2.0","codeclimate-test-reporter":"0.0.4","istanbul":"^0.3.13","jsdoc":"^3.3.0-beta3","jsdoc-to-markdown":"^1.0.3","matcha":"^0.6.0","mocha":"^2.2.1","server-destroy":"^1.0.0","sinon":"^1.14.1"},"engines":{"node":">= 0.11.16","iojs":">= 1.0.0"},"gitHead":"ee506f96999cfe67786cd6129dbedac53d09550d","bugs":{"url":"https://github.com/luin/ioredis/issues"},"homepage":"https://github.com/luin/ioredis","_id":"ioredis@1.2.5","_shasum":"195744f344e8abc8e2b37001e7692e1cd6e04a36","_from":".","_npmVersion":"2.4.1","_nodeVersion":"1.1.0","_npmUser":{"name":"luin","email":"i@zihua.li"},"maintainers":[{"name":"luin","email":"i@zihua.li"}],"dist":{"shasum":"195744f344e8abc8e2b37001e7692e1cd6e04a36","tarball":"https://registry.npmjs.org/ioredis/-/ioredis-1.2.5.tgz"},"directories":{}},"1.2.6":{"name":"ioredis","version":"1.2.6","description":"A delightful, performance-focused Redis client for Node and io.js","main":"index.js","scripts":{"test":"NODE_ENV=test DEBUG=ioredis:* mocha","test:cov":"NODE_ENV=test DEBUG=ioredis:* node ./node_modules/istanbul/lib/cli.js cover --preserve-comments ./node_modules/mocha/bin/_mocha -- -R spec","generate-docs":"jsdoc2md lib/redis.js lib/cluster.js lib/commander.js > API.md","bench":"matcha benchmarks/*.js"},"repository":{"type":"git","url":"git://github.com/luin/ioredis.git"},"keywords":["redis","cluster","sentinel","pipelining"],"author":{"name":"luin","email":"i@zihua.li","url":"http://zihua.li"},"license":"MIT","dependencies":{"bluebird":"^2.9.21","debug":"^2.1.3","flexbuffer":"0.0.6","ioredis-commands":"4.0.0","lodash":"^3.6.0"},"devDependencies":{"chai":"^2.2.0","codeclimate-test-reporter":"0.0.4","istanbul":"^0.3.13","jsdoc":"^3.3.0-beta3","jsdoc-to-markdown":"^1.0.3","matcha":"^0.6.0","mocha":"^2.2.1","server-destroy":"^1.0.0","sinon":"^1.14.1"},"engines":{"node":">= 0.11.16","iojs":">= 1.0.0"},"gitHead":"c9e586a0224cbb48a1ad24c7ec424ede4d798396","bugs":{"url":"https://github.com/luin/ioredis/issues"},"homepage":"https://github.com/luin/ioredis","_id":"ioredis@1.2.6","_shasum":"ee7160575a8390ea581c256cf1ac5339f1b212e7","_from":".","_npmVersion":"2.4.1","_nodeVersion":"1.1.0","_npmUser":{"name":"luin","email":"i@zihua.li"},"maintainers":[{"name":"luin","email":"i@zihua.li"}],"dist":{"shasum":"ee7160575a8390ea581c256cf1ac5339f1b212e7","tarball":"https://registry.npmjs.org/ioredis/-/ioredis-1.2.6.tgz"},"directories":{}},"1.2.7":{"name":"ioredis","version":"1.2.7","description":"A delightful, performance-focused Redis client for Node and io.js","main":"index.js","scripts":{"test":"NODE_ENV=test DEBUG=ioredis:* mocha","test:cov":"NODE_ENV=test DEBUG=ioredis:* node ./node_modules/istanbul/lib/cli.js cover --preserve-comments ./node_modules/mocha/bin/_mocha -- -R spec","generate-docs":"jsdoc2md lib/redis.js lib/cluster.js lib/commander.js > API.md","build":"node tools/build > commands.js","bench":"matcha benchmarks/*.js"},"repository":{"type":"git","url":"git://github.com/luin/ioredis.git"},"keywords":["redis","cluster","sentinel","pipelining"],"author":{"name":"luin","email":"i@zihua.li","url":"http://zihua.li"},"license":"MIT","dependencies":{"bluebird":"^2.9.21","debug":"^2.1.3","flexbuffer":"0.0.6","lodash":"^3.6.0"},"devDependencies":{"chai":"^2.2.0","codeclimate-test-reporter":"0.0.4","istanbul":"^0.3.13","jsdoc":"^3.3.0-beta3","jsdoc-to-markdown":"^1.0.3","matcha":"^0.6.0","mocha":"^2.2.1","server-destroy":"^1.0.0","sinon":"^1.14.1"},"engines":{"node":">= 0.11.16","iojs":">= 1.0.0"},"gitHead":"a5fad8d3f481c427a437f3213f640bf861524d3d","bugs":{"url":"https://github.com/luin/ioredis/issues"},"homepage":"https://github.com/luin/ioredis","_id":"ioredis@1.2.7","_shasum":"a7b7d6b67ccbe5341f1d76accfeaec97e2802d28","_from":".","_npmVersion":"2.4.1","_nodeVersion":"1.1.0","_npmUser":{"name":"luin","email":"i@zihua.li"},"maintainers":[{"name":"luin","email":"i@zihua.li"}],"dist":{"shasum":"a7b7d6b67ccbe5341f1d76accfeaec97e2802d28","tarball":"https://registry.npmjs.org/ioredis/-/ioredis-1.2.7.tgz"},"directories":{}},"1.3.0":{"name":"ioredis","version":"1.3.0","description":"A delightful, performance-focused Redis client for Node and io.js","main":"index.js","scripts":{"test":"NODE_ENV=test DEBUG=ioredis:* mocha","test:cov":"NODE_ENV=test DEBUG=ioredis:* node ./node_modules/istanbul/lib/cli.js cover --preserve-comments ./node_modules/mocha/bin/_mocha -- -R spec","generate-docs":"jsdoc2md lib/redis.js lib/cluster.js lib/commander.js > API.md","build":"node tools/build > commands.js","bench":"matcha benchmarks/*.js"},"repository":{"type":"git","url":"git://github.com/luin/ioredis.git"},"keywords":["redis","cluster","sentinel","pipelining"],"author":{"name":"luin","email":"i@zihua.li","url":"http://zihua.li"},"license":"MIT","dependencies":{"bluebird":"^2.9.21","debug":"^2.1.3","flexbuffer":"0.0.6","lodash":"^3.6.0"},"devDependencies":{"chai":"^2.2.0","codeclimate-test-reporter":"0.0.4","istanbul":"^0.3.13","jsdoc":"^3.3.0-beta3","jsdoc-to-markdown":"^1.0.3","matcha":"^0.6.0","mocha":"^2.2.1","server-destroy":"^1.0.0","sinon":"^1.14.1"},"engines":{"node":">= 0.11.16","iojs":">= 1.0.0"},"gitHead":"b1c8d047f2e69b25b11c1d3d6fbd38b8cda9e976","bugs":{"url":"https://github.com/luin/ioredis/issues"},"homepage":"https://github.com/luin/ioredis","_id":"ioredis@1.3.0","_shasum":"3f622148748d3c9c79e1919d77e7911583430bd4","_from":".","_npmVersion":"2.4.1","_nodeVersion":"1.1.0","_npmUser":{"name":"luin","email":"i@zihua.li"},"maintainers":[{"name":"luin","email":"i@zihua.li"}],"dist":{"shasum":"3f622148748d3c9c79e1919d77e7911583430bd4","tarball":"https://registry.npmjs.org/ioredis/-/ioredis-1.3.0.tgz"},"directories":{}},"1.3.1":{"name":"ioredis","version":"1.3.1","description":"A delightful, performance-focused Redis client for Node and io.js","main":"index.js","scripts":{"test":"NODE_ENV=test DEBUG=ioredis:* mocha","test:cov":"NODE_ENV=test DEBUG=ioredis:* node ./node_modules/istanbul/lib/cli.js cover --preserve-comments ./node_modules/mocha/bin/_mocha -- -R spec","generate-docs":"jsdoc2md lib/redis.js lib/cluster.js lib/commander.js > API.md","build":"node tools/build > commands.js","bench":"matcha benchmarks/*.js"},"repository":{"type":"git","url":"git://github.com/luin/ioredis.git"},"keywords":["redis","cluster","sentinel","pipelining"],"author":{"name":"luin","email":"i@zihua.li","url":"http://zihua.li"},"license":"MIT","dependencies":{"bluebird":"^2.9.21","debug":"^2.1.3","flexbuffer":"0.0.6","lodash":"^3.6.0"},"devDependencies":{"chai":"^2.2.0","codeclimate-test-reporter":"0.0.4","istanbul":"^0.3.13","jsdoc":"^3.3.0-beta3","jsdoc-to-markdown":"^1.0.3","matcha":"^0.6.0","mocha":"^2.2.1","server-destroy":"^1.0.0","sinon":"^1.14.1"},"engines":{"node":">= 0.11.16","iojs":">= 1.0.0"},"gitHead":"20df742f7e5df53e5a4f8f7e2793d14702c97f4b","bugs":{"url":"https://github.com/luin/ioredis/issues"},"homepage":"https://github.com/luin/ioredis","_id":"ioredis@1.3.1","_shasum":"edeb33010cef491ef24bb7244e7568430aefe3bd","_from":".","_npmVersion":"2.4.1","_nodeVersion":"1.1.0","_npmUser":{"name":"luin","email":"i@zihua.li"},"maintainers":[{"name":"luin","email":"i@zihua.li"}],"dist":{"shasum":"edeb33010cef491ef24bb7244e7568430aefe3bd","tarball":"https://registry.npmjs.org/ioredis/-/ioredis-1.3.1.tgz"},"directories":{}},"1.3.2":{"name":"ioredis","version":"1.3.2","description":"A delightful, performance-focused Redis client for Node and io.js","main":"index.js","scripts":{"test":"NODE_ENV=test DEBUG=ioredis:* mocha","test:cov":"NODE_ENV=test DEBUG=ioredis:* node ./node_modules/istanbul/lib/cli.js cover --preserve-comments ./node_modules/mocha/bin/_mocha -- -R spec","generate-docs":"jsdoc2md lib/redis.js lib/cluster.js lib/commander.js > API.md","build":"node tools/build > commands.js","bench":"matcha benchmarks/*.js"},"repository":{"type":"git","url":"git://github.com/luin/ioredis.git"},"keywords":["redis","cluster","sentinel","pipelining"],"author":{"name":"luin","email":"i@zihua.li","url":"http://zihua.li"},"license":"MIT","dependencies":{"bluebird":"^2.9.21","debug":"^2.1.3","flexbuffer":"0.0.6","lodash":"^3.6.0"},"devDependencies":{"chai":"^2.2.0","codeclimate-test-reporter":"0.0.4","istanbul":"^0.3.13","jsdoc":"^3.3.0-beta3","jsdoc-to-markdown":"^1.0.3","matcha":"^0.6.0","mocha":"^2.2.1","server-destroy":"^1.0.0","sinon":"^1.14.1"},"engines":{"node":">= 0.11.16","iojs":">= 1.0.0"},"gitHead":"7023f557950911c4e0fc4df6d90136b2eed9088f","bugs":{"url":"https://github.com/luin/ioredis/issues"},"homepage":"https://github.com/luin/ioredis","_id":"ioredis@1.3.2","_shasum":"82c80c6c1242638c9209d4fff7d9c9b4d0c2e40b","_from":".","_npmVersion":"2.4.1","_nodeVersion":"1.1.0","_npmUser":{"name":"luin","email":"i@zihua.li"},"maintainers":[{"name":"luin","email":"i@zihua.li"}],"dist":{"shasum":"82c80c6c1242638c9209d4fff7d9c9b4d0c2e40b","tarball":"https://registry.npmjs.org/ioredis/-/ioredis-1.3.2.tgz"},"directories":{}},"1.3.3":{"name":"ioredis","version":"1.3.3","description":"A delightful, performance-focused Redis client for Node and io.js","main":"index.js","scripts":{"test":"NODE_ENV=test DEBUG=ioredis:* mocha","test:cov":"NODE_ENV=test DEBUG=ioredis:* node ./node_modules/istanbul/lib/cli.js cover --preserve-comments ./node_modules/mocha/bin/_mocha -- -R spec","generate-docs":"jsdoc2md lib/redis.js lib/cluster.js lib/commander.js > API.md","build":"node tools/build > commands.js","bench":"matcha benchmarks/*.js"},"repository":{"type":"git","url":"git://github.com/luin/ioredis.git"},"keywords":["redis","cluster","sentinel","pipelining"],"author":{"name":"luin","email":"i@zihua.li","url":"http://zihua.li"},"license":"MIT","dependencies":{"bluebird":"^2.9.21","debug":"^2.1.3","flexbuffer":"0.0.6","lodash":"^3.6.0"},"devDependencies":{"chai":"^2.2.0","codeclimate-test-reporter":"0.0.4","istanbul":"^0.3.13","jsdoc":"^3.3.0-beta3","jsdoc-to-markdown":"^1.0.3","matcha":"^0.6.0","mocha":"^2.2.1","server-destroy":"^1.0.0","sinon":"^1.14.1"},"engines":{"node":">= 0.11.16","iojs":">= 1.0.0"},"gitHead":"f663fe236d4b83d3f836e61748906eb9952a6211","bugs":{"url":"https://github.com/luin/ioredis/issues"},"homepage":"https://github.com/luin/ioredis","_id":"ioredis@1.3.3","_shasum":"b66063ffa858bbaffec8bca6630d13e9080fc098","_from":".","_npmVersion":"2.4.1","_nodeVersion":"1.1.0","_npmUser":{"name":"luin","email":"i@zihua.li"},"maintainers":[{"name":"luin","email":"i@zihua.li"}],"dist":{"shasum":"b66063ffa858bbaffec8bca6630d13e9080fc098","tarball":"https://registry.npmjs.org/ioredis/-/ioredis-1.3.3.tgz"},"directories":{}},"1.3.4":{"name":"ioredis","version":"1.3.4","description":"A delightful, performance-focused Redis client for Node and io.js","main":"index.js","scripts":{"test":"NODE_ENV=test DEBUG=ioredis:* mocha","test:cov":"NODE_ENV=test DEBUG=ioredis:* node ./node_modules/istanbul/lib/cli.js cover --preserve-comments ./node_modules/mocha/bin/_mocha -- -R spec","generate-docs":"jsdoc2md lib/redis.js lib/cluster.js lib/commander.js > API.md","build":"node tools/build > commands.js","bench":"matcha benchmarks/*.js"},"repository":{"type":"git","url":"git://github.com/luin/ioredis.git"},"keywords":["redis","cluster","sentinel","pipelining"],"author":{"name":"luin","email":"i@zihua.li","url":"http://zihua.li"},"license":"MIT","dependencies":{"bluebird":"^2.9.21","debug":"^2.1.3","flexbuffer":"0.0.6","lodash":"^3.6.0"},"devDependencies":{"chai":"^2.2.0","codeclimate-test-reporter":"0.0.4","istanbul":"^0.3.13","jsdoc":"^3.3.0-beta3","jsdoc-to-markdown":"^1.0.3","matcha":"^0.6.0","mocha":"^2.2.1","server-destroy":"^1.0.0","sinon":"^1.14.1"},"engines":{"node":">= 0.11.16","iojs":">= 1.0.0"},"gitHead":"230b6fbe03b685d0a5c6dee0702120867471a58c","bugs":{"url":"https://github.com/luin/ioredis/issues"},"homepage":"https://github.com/luin/ioredis","_id":"ioredis@1.3.4","_shasum":"09853a6a9fd546591e5ebc2d71356c1de7844d7c","_from":".","_npmVersion":"2.4.1","_nodeVersion":"1.1.0","_npmUser":{"name":"luin","email":"i@zihua.li"},"maintainers":[{"name":"luin","email":"i@zihua.li"}],"dist":{"shasum":"09853a6a9fd546591e5ebc2d71356c1de7844d7c","tarball":"https://registry.npmjs.org/ioredis/-/ioredis-1.3.4.tgz"},"directories":{}},"1.3.5":{"name":"ioredis","version":"1.3.5","description":"A delightful, performance-focused Redis client for Node and io.js","main":"index.js","scripts":{"test":"NODE_ENV=test DEBUG=ioredis:* mocha","test:cov":"NODE_ENV=test DEBUG=ioredis:* node ./node_modules/istanbul/lib/cli.js cover --preserve-comments ./node_modules/mocha/bin/_mocha -- -R spec","generate-docs":"jsdoc2md lib/redis.js lib/cluster.js lib/commander.js > API.md","build":"node tools/build > commands.js","bench":"matcha benchmarks/*.js"},"repository":{"type":"git","url":"git://github.com/luin/ioredis.git"},"keywords":["redis","cluster","sentinel","pipelining"],"author":{"name":"luin","email":"i@zihua.li","url":"http://zihua.li"},"license":"MIT","dependencies":{"bluebird":"^2.9.21","debug":"^2.1.3","flexbuffer":"0.0.6","lodash":"^3.6.0"},"devDependencies":{"chai":"^2.2.0","codeclimate-test-reporter":"0.0.4","istanbul":"^0.3.13","jsdoc":"^3.3.0-beta3","jsdoc-to-markdown":"^1.0.3","matcha":"^0.6.0","mocha":"^2.2.1","server-destroy":"^1.0.0","sinon":"^1.14.1"},"engines":{"node":">= 0.11.16","iojs":">= 1.0.0"},"gitHead":"b48576ec749dc0b900d54d95d5cc7d6de1295e44","bugs":{"url":"https://github.com/luin/ioredis/issues"},"homepage":"https://github.com/luin/ioredis","_id":"ioredis@1.3.5","_shasum":"499ffea9d9177d5139368dac7d4ee4f00951c8b8","_from":".","_npmVersion":"2.4.1","_nodeVersion":"1.1.0","_npmUser":{"name":"luin","email":"i@zihua.li"},"maintainers":[{"name":"luin","email":"i@zihua.li"}],"dist":{"shasum":"499ffea9d9177d5139368dac7d4ee4f00951c8b8","tarball":"https://registry.npmjs.org/ioredis/-/ioredis-1.3.5.tgz"},"directories":{}},"1.3.6":{"name":"ioredis","version":"1.3.6","description":"A delightful, performance-focused Redis client for Node and io.js","main":"index.js","scripts":{"test":"NODE_ENV=test DEBUG=ioredis:* mocha","test:cov":"NODE_ENV=test DEBUG=ioredis:* node ./node_modules/istanbul/lib/cli.js cover --preserve-comments ./node_modules/mocha/bin/_mocha -- -R spec","generate-docs":"jsdoc2md lib/redis.js lib/cluster.js lib/commander.js > API.md","build":"node tools/build > commands.js","bench":"matcha benchmarks/*.js"},"repository":{"type":"git","url":"git://github.com/luin/ioredis.git"},"keywords":["redis","cluster","sentinel","pipelining"],"author":{"name":"luin","email":"i@zihua.li","url":"http://zihua.li"},"license":"MIT","dependencies":{"bluebird":"^2.9.21","debug":"^2.1.3","flexbuffer":"0.0.6","lodash":"^3.6.0"},"devDependencies":{"chai":"^2.2.0","codeclimate-test-reporter":"0.0.4","istanbul":"^0.3.13","jsdoc":"^3.3.0-beta3","jsdoc-to-markdown":"^1.0.3","matcha":"^0.6.0","mocha":"^2.2.1","server-destroy":"^1.0.0","sinon":"^1.14.1"},"engines":{"node":">= 0.11.16","iojs":">= 1.0.0"},"gitHead":"9466feb3032c23f25de7659e72838812da46a149","bugs":{"url":"https://github.com/luin/ioredis/issues"},"homepage":"https://github.com/luin/ioredis","_id":"ioredis@1.3.6","_shasum":"67c303e39c5153a8f767f14547568ee224cf5cad","_from":".","_npmVersion":"2.4.1","_nodeVersion":"1.1.0","_npmUser":{"name":"luin","email":"i@zihua.li"},"maintainers":[{"name":"luin","email":"i@zihua.li"}],"dist":{"shasum":"67c303e39c5153a8f767f14547568ee224cf5cad","tarball":"https://registry.npmjs.org/ioredis/-/ioredis-1.3.6.tgz"},"directories":{}},"1.4.0":{"name":"ioredis","version":"1.4.0","description":"A delightful, performance-focused Redis client for Node and io.js","main":"index.js","scripts":{"test":"NODE_ENV=test DEBUG=ioredis:* mocha","test:cov":"NODE_ENV=test DEBUG=ioredis:* node ./node_modules/istanbul/lib/cli.js cover --preserve-comments ./node_modules/mocha/bin/_mocha -- -R spec","generate-docs":"jsdoc2md lib/redis.js lib/cluster.js lib/commander.js > API.md","build":"node tools/build > commands.js","bench":"matcha benchmarks/*.js"},"repository":{"type":"git","url":"git://github.com/luin/ioredis.git"},"keywords":["redis","cluster","sentinel","pipelining"],"author":{"name":"luin","email":"i@zihua.li","url":"http://zihua.li"},"license":"MIT","dependencies":{"bluebird":"^2.9.21","debug":"^2.1.3","flexbuffer":"0.0.6","lodash":"^3.6.0"},"devDependencies":{"chai":"^2.2.0","codeclimate-test-reporter":"0.0.4","istanbul":"^0.3.13","jsdoc":"^3.3.0-beta3","jsdoc-to-markdown":"^1.0.3","matcha":"^0.6.0","mocha":"^2.2.1","server-destroy":"^1.0.0","sinon":"^1.14.1"},"engines":{"node":">= 0.10.16","iojs":">= 1.0.0"},"gitHead":"9cdc5d1bd2a61f827b291b42abc0f2d3c1a825ae","bugs":{"url":"https://github.com/luin/ioredis/issues"},"homepage":"https://github.com/luin/ioredis","_id":"ioredis@1.4.0","_shasum":"9bc990955c16f922ef20247f5e6cf6f8f9923643","_from":".","_npmVersion":"2.4.1","_nodeVersion":"1.1.0","_npmUser":{"name":"luin","email":"i@zihua.li"},"maintainers":[{"name":"luin","email":"i@zihua.li"}],"dist":{"shasum":"9bc990955c16f922ef20247f5e6cf6f8f9923643","tarball":"https://registry.npmjs.org/ioredis/-/ioredis-1.4.0.tgz"},"directories":{}},"1.5.0":{"name":"ioredis","version":"1.5.0","description":"A delightful, performance-focused Redis client for Node and io.js","main":"index.js","scripts":{"test":"NODE_ENV=test DEBUG=ioredis:* mocha","test:cov":"NODE_ENV=test DEBUG=ioredis:* node ./node_modules/istanbul/lib/cli.js cover --preserve-comments ./node_modules/mocha/bin/_mocha -- -R spec","generate-docs":"jsdoc2md lib/redis.js lib/cluster.js lib/commander.js > API.md","build":"node tools/build > commands.js","bench":"matcha benchmarks/*.js"},"repository":{"type":"git","url":"git://github.com/luin/ioredis.git"},"keywords":["redis","cluster","sentinel","pipelining"],"author":{"name":"luin","email":"i@zihua.li","url":"http://zihua.li"},"license":"MIT","dependencies":{"bluebird":"^2.9.21","debug":"^2.1.3","double-ended-queue":"^2.1.0-0","flexbuffer":"0.0.6","lodash":"^3.6.0"},"devDependencies":{"chai":"^2.2.0","codeclimate-test-reporter":"0.0.4","istanbul":"^0.3.13","jsdoc":"^3.3.0-beta3","jsdoc-to-markdown":"^1.0.3","matcha":"^0.6.0","mocha":"^2.2.1","server-destroy":"^1.0.0","sinon":"^1.14.1"},"engines":{"node":">= 0.10.16","iojs":">= 1.0.0"},"gitHead":"41f332590dfd7e01e48eb56471617a2cf415723e","bugs":{"url":"https://github.com/luin/ioredis/issues"},"homepage":"https://github.com/luin/ioredis","_id":"ioredis@1.5.0","_shasum":"98aaa3b8134ea6e57bce477bfdb9112dd4065116","_from":".","_npmVersion":"2.4.1","_nodeVersion":"1.1.0","_npmUser":{"name":"luin","email":"i@zihua.li"},"maintainers":[{"name":"luin","email":"i@zihua.li"}],"dist":{"shasum":"98aaa3b8134ea6e57bce477bfdb9112dd4065116","tarball":"https://registry.npmjs.org/ioredis/-/ioredis-1.5.0.tgz"},"directories":{}},"1.5.1":{"name":"ioredis","version":"1.5.1","description":"A delightful, performance-focused Redis client for Node and io.js","main":"index.js","scripts":{"test":"NODE_ENV=test DEBUG=ioredis:* mocha","test:cov":"NODE_ENV=test DEBUG=ioredis:* node ./node_modules/istanbul/lib/cli.js cover --preserve-comments ./node_modules/mocha/bin/_mocha -- -R spec","generate-docs":"jsdoc2md lib/redis.js lib/cluster.js lib/commander.js > API.md","build":"node tools/build > commands.js","bench":"matcha benchmarks/*.js"},"repository":{"type":"git","url":"git://github.com/luin/ioredis.git"},"keywords":["redis","cluster","sentinel","pipelining"],"author":{"name":"luin","email":"i@zihua.li","url":"http://zihua.li"},"license":"MIT","dependencies":{"bluebird":"^2.9.21","debug":"^2.1.3","double-ended-queue":"^2.1.0-0","flexbuffer":"0.0.6","lodash":"^3.6.0"},"devDependencies":{"chai":"^2.2.0","codeclimate-test-reporter":"0.0.4","istanbul":"^0.3.13","jsdoc":"^3.3.0-beta3","jsdoc-to-markdown":"^1.0.3","matcha":"^0.6.0","mocha":"^2.2.1","server-destroy":"^1.0.0","sinon":"^1.14.1"},"engines":{"node":">= 0.10.16","iojs":">= 1.0.0"},"gitHead":"c19b0989c718422ab058ed661a0c70d529addf96","bugs":{"url":"https://github.com/luin/ioredis/issues"},"homepage":"https://github.com/luin/ioredis","_id":"ioredis@1.5.1","_shasum":"0a724b550586a49155c5d520a445d27409ea37ce","_from":".","_npmVersion":"2.4.1","_nodeVersion":"1.1.0","_npmUser":{"name":"luin","email":"i@zihua.li"},"maintainers":[{"name":"luin","email":"i@zihua.li"}],"dist":{"shasum":"0a724b550586a49155c5d520a445d27409ea37ce","tarball":"https://registry.npmjs.org/ioredis/-/ioredis-1.5.1.tgz"},"directories":{}},"1.5.2":{"name":"ioredis","version":"1.5.2","description":"A delightful, performance-focused Redis client for Node and io.js","main":"index.js","scripts":{"test":"NODE_ENV=test DEBUG=ioredis:* mocha","test:cov":"NODE_ENV=test DEBUG=ioredis:* node ./node_modules/istanbul/lib/cli.js cover --preserve-comments ./node_modules/mocha/bin/_mocha -- -R spec","generate-docs":"jsdoc2md lib/redis.js lib/cluster.js lib/commander.js > API.md","build":"node tools/build > commands.js","bench":"matcha benchmarks/*.js"},"repository":{"type":"git","url":"git://github.com/luin/ioredis.git"},"keywords":["redis","cluster","sentinel","pipelining"],"author":{"name":"luin","email":"i@zihua.li","url":"http://zihua.li"},"license":"MIT","dependencies":{"bluebird":"^2.9.21","debug":"^2.1.3","double-ended-queue":"^2.1.0-0","flexbuffer":"0.0.6","lodash":"^3.6.0"},"devDependencies":{"chai":"^2.2.0","codeclimate-test-reporter":"0.0.4","istanbul":"^0.3.13","jsdoc":"^3.3.0-beta3","jsdoc-to-markdown":"^1.0.3","matcha":"^0.6.0","mocha":"^2.2.1","server-destroy":"^1.0.0","sinon":"^1.14.1"},"engines":{"node":">= 0.10.16","iojs":">= 1.0.0"},"gitHead":"150d8620e2a06738ab822d0c1bda1ee3d3103fc4","bugs":{"url":"https://github.com/luin/ioredis/issues"},"homepage":"https://github.com/luin/ioredis","_id":"ioredis@1.5.2","_shasum":"26d05b123d381e8a3c9f85734bf2ab24e3f31ab6","_from":".","_npmVersion":"2.4.1","_nodeVersion":"1.1.0","_npmUser":{"name":"luin","email":"i@zihua.li"},"maintainers":[{"name":"luin","email":"i@zihua.li"}],"dist":{"shasum":"26d05b123d381e8a3c9f85734bf2ab24e3f31ab6","tarball":"https://registry.npmjs.org/ioredis/-/ioredis-1.5.2.tgz"},"directories":{}},"1.5.3":{"name":"ioredis","version":"1.5.3","description":"A delightful, performance-focused Redis client for Node and io.js","main":"index.js","scripts":{"test":"NODE_ENV=test DEBUG=ioredis:* mocha","test:cov":"NODE_ENV=test DEBUG=ioredis:* node ./node_modules/istanbul/lib/cli.js cover --preserve-comments ./node_modules/mocha/bin/_mocha -- -R spec","generate-docs":"jsdoc2md lib/redis.js lib/cluster.js lib/commander.js > API.md","build":"node tools/build > commands.js","bench":"matcha benchmarks/*.js"},"repository":{"type":"git","url":"git://github.com/luin/ioredis.git"},"keywords":["redis","cluster","sentinel","pipelining"],"author":{"name":"luin","email":"i@zihua.li","url":"http://zihua.li"},"license":"MIT","dependencies":{"bluebird":"^2.9.21","debug":"^2.1.3","double-ended-queue":"^2.1.0-0","flexbuffer":"0.0.6","lodash":"^3.6.0"},"devDependencies":{"chai":"^2.2.0","codeclimate-test-reporter":"0.0.4","istanbul":"^0.3.13","jsdoc":"^3.3.0-beta3","jsdoc-to-markdown":"^1.0.3","matcha":"^0.6.0","mocha":"^2.2.1","server-destroy":"^1.0.0","sinon":"^1.14.1"},"engines":{"node":">= 0.10.16","iojs":">= 1.0.0"},"gitHead":"0a983b0fcee2a6b4a1426e22718bb9174cc1cadb","bugs":{"url":"https://github.com/luin/ioredis/issues"},"homepage":"https://github.com/luin/ioredis","_id":"ioredis@1.5.3","_shasum":"b24f0f2ed561faa207c32d20b6ec5e41c95a1b3a","_from":".","_npmVersion":"2.4.1","_nodeVersion":"1.1.0","_npmUser":{"name":"luin","email":"i@zihua.li"},"maintainers":[{"name":"luin","email":"i@zihua.li"}],"dist":{"shasum":"b24f0f2ed561faa207c32d20b6ec5e41c95a1b3a","tarball":"https://registry.npmjs.org/ioredis/-/ioredis-1.5.3.tgz"},"directories":{}},"1.5.4":{"name":"ioredis","version":"1.5.4","description":"A delightful, performance-focused Redis client for Node and io.js","main":"index.js","scripts":{"test":"NODE_ENV=test DEBUG=ioredis:* mocha","test:cov":"NODE_ENV=test DEBUG=ioredis:* node ./node_modules/istanbul/lib/cli.js cover --preserve-comments ./node_modules/mocha/bin/_mocha -- -R spec","generate-docs":"jsdoc2md lib/redis.js lib/cluster.js lib/commander.js > API.md","build":"node tools/build > commands.js","bench":"matcha benchmarks/*.js"},"repository":{"type":"git","url":"git://github.com/luin/ioredis.git"},"keywords":["redis","cluster","sentinel","pipelining"],"author":{"name":"luin","email":"i@zihua.li","url":"http://zihua.li"},"license":"MIT","dependencies":{"bluebird":"^2.9.21","debug":"^2.1.3","double-ended-queue":"^2.1.0-0","flexbuffer":"0.0.6","lodash":"^3.6.0"},"devDependencies":{"chai":"^2.2.0","codeclimate-test-reporter":"0.0.4","istanbul":"^0.3.13","jsdoc":"^3.3.0-beta3","jsdoc-to-markdown":"^1.0.3","matcha":"^0.6.0","mocha":"^2.2.1","server-destroy":"^1.0.0","sinon":"^1.14.1"},"engines":{"node":">= 0.10.16","iojs":">= 1.0.0"},"gitHead":"fb657a60aba7cebd570c46516e8d171feb7f6edf","bugs":{"url":"https://github.com/luin/ioredis/issues"},"homepage":"https://github.com/luin/ioredis","_id":"ioredis@1.5.4","_shasum":"570d510dbd36de00b8ef9e3a3e99cafec872ca4b","_from":".","_npmVersion":"2.4.1","_nodeVersion":"1.1.0","_npmUser":{"name":"luin","email":"i@zihua.li"},"maintainers":[{"name":"luin","email":"i@zihua.li"}],"dist":{"shasum":"570d510dbd36de00b8ef9e3a3e99cafec872ca4b","tarball":"https://registry.npmjs.org/ioredis/-/ioredis-1.5.4.tgz"},"directories":{}},"1.5.5":{"name":"ioredis","version":"1.5.5","description":"A delightful, performance-focused Redis client for Node and io.js","main":"index.js","scripts":{"test":"NODE_ENV=test DEBUG=ioredis:* mocha","test:cov":"NODE_ENV=test DEBUG=ioredis:* node ./node_modules/istanbul/lib/cli.js cover --preserve-comments ./node_modules/mocha/bin/_mocha -- -R spec","generate-docs":"jsdoc2md lib/redis.js lib/cluster.js lib/commander.js > API.md","build":"node tools/build > commands.js","bench":"matcha benchmarks/*.js"},"repository":{"type":"git","url":"git://github.com/luin/ioredis.git"},"keywords":["redis","cluster","sentinel","pipelining"],"author":{"name":"luin","email":"i@zihua.li","url":"http://zihua.li"},"license":"MIT","dependencies":{"bluebird":"^2.9.21","debug":"^2.1.3","double-ended-queue":"^2.1.0-0","flexbuffer":"0.0.6","lodash":"^3.6.0"},"devDependencies":{"chai":"^2.2.0","codeclimate-test-reporter":"0.0.4","istanbul":"^0.3.13","jsdoc":"^3.3.0-beta3","jsdoc-to-markdown":"^1.0.3","matcha":"^0.6.0","mocha":"^2.2.1","server-destroy":"^1.0.0","sinon":"^1.14.1"},"engines":{"node":">= 0.10.16","iojs":">= 1.0.0"},"gitHead":"c1ff9f282a7825c8071d39671907a093616b9a09","bugs":{"url":"https://github.com/luin/ioredis/issues"},"homepage":"https://github.com/luin/ioredis","_id":"ioredis@1.5.5","_shasum":"8f3f93f6fc2965b99c4cb0e6c726734f608259be","_from":".","_npmVersion":"2.4.1","_nodeVersion":"1.1.0","_npmUser":{"name":"luin","email":"i@zihua.li"},"maintainers":[{"name":"luin","email":"i@zihua.li"}],"dist":{"shasum":"8f3f93f6fc2965b99c4cb0e6c726734f608259be","tarball":"https://registry.npmjs.org/ioredis/-/ioredis-1.5.5.tgz"},"directories":{}},"1.5.6":{"name":"ioredis","version":"1.5.6","description":"A delightful, performance-focused Redis client for Node and io.js","main":"index.js","scripts":{"test":"NODE_ENV=test DEBUG=ioredis:* mocha","test:cov":"NODE_ENV=test DEBUG=ioredis:* node ./node_modules/istanbul/lib/cli.js cover --preserve-comments ./node_modules/mocha/bin/_mocha -- -R spec","generate-docs":"jsdoc2md lib/redis.js lib/cluster.js lib/commander.js > API.md","build":"node tools/build > commands.js","bench":"matcha benchmarks/*.js"},"repository":{"type":"git","url":"git://github.com/luin/ioredis.git"},"keywords":["redis","cluster","sentinel","pipelining"],"author":{"name":"luin","email":"i@zihua.li","url":"http://zihua.li"},"license":"MIT","dependencies":{"bluebird":"^2.9.21","debug":"^2.1.3","double-ended-queue":"^2.1.0-0","flexbuffer":"0.0.6","lodash":"^3.6.0"},"devDependencies":{"chai":"^2.2.0","codeclimate-test-reporter":"0.0.4","istanbul":"^0.3.13","jsdoc":"^3.3.0-beta3","jsdoc-to-markdown":"^1.0.3","matcha":"^0.6.0","mocha":"^2.2.1","server-destroy":"^1.0.0","sinon":"^1.14.1"},"engines":{"node":">= 0.10.16","iojs":">= 1.0.0"},"gitHead":"36b379f2c96bd07110c5f458e775380cfc1f4850","bugs":{"url":"https://github.com/luin/ioredis/issues"},"homepage":"https://github.com/luin/ioredis","_id":"ioredis@1.5.6","_shasum":"cc6593ce84b775d8137347700b80ebaa35b6600b","_from":".","_npmVersion":"2.4.1","_nodeVersion":"1.1.0","_npmUser":{"name":"luin","email":"i@zihua.li"},"maintainers":[{"name":"luin","email":"i@zihua.li"}],"dist":{"shasum":"cc6593ce84b775d8137347700b80ebaa35b6600b","tarball":"https://registry.npmjs.org/ioredis/-/ioredis-1.5.6.tgz"},"directories":{}},"1.5.7":{"name":"ioredis","version":"1.5.7","description":"A delightful, performance-focused Redis client for Node and io.js","main":"index.js","scripts":{"test":"NODE_ENV=test DEBUG=ioredis:* mocha","test:cov":"NODE_ENV=test DEBUG=ioredis:* node ./node_modules/istanbul/lib/cli.js cover --preserve-comments ./node_modules/mocha/bin/_mocha -- -R spec","generate-docs":"jsdoc2md lib/redis.js lib/cluster.js lib/commander.js > API.md","build":"node tools/build > commands.js","bench":"matcha benchmarks/*.js"},"repository":{"type":"git","url":"git://github.com/luin/ioredis.git"},"keywords":["redis","cluster","sentinel","pipelining"],"author":{"name":"luin","email":"i@zihua.li","url":"http://zihua.li"},"license":"MIT","dependencies":{"bluebird":"^2.9.21","debug":"^2.1.3","double-ended-queue":"^2.1.0-0","flexbuffer":"0.0.6","lodash":"^3.6.0"},"devDependencies":{"chai":"^2.2.0","codeclimate-test-reporter":"0.0.4","istanbul":"^0.3.13","jsdoc":"^3.3.0-beta3","jsdoc-to-markdown":"^1.0.3","matcha":"^0.6.0","mocha":"^2.2.1","server-destroy":"^1.0.0","sinon":"^1.14.1"},"engines":{"node":">= 0.10.16","iojs":">= 1.0.0"},"gitHead":"814210af486d0d69b500741713b645cd5948a51e","bugs":{"url":"https://github.com/luin/ioredis/issues"},"homepage":"https://github.com/luin/ioredis","_id":"ioredis@1.5.7","_shasum":"276fa7b3692757dde74fb91cc3c883d02969edd8","_from":".","_npmVersion":"2.4.1","_nodeVersion":"1.1.0","_npmUser":{"name":"luin","email":"i@zihua.li"},"maintainers":[{"name":"luin","email":"i@zihua.li"}],"dist":{"shasum":"276fa7b3692757dde74fb91cc3c883d02969edd8","tarball":"https://registry.npmjs.org/ioredis/-/ioredis-1.5.7.tgz"},"directories":{}},"1.5.8":{"name":"ioredis","version":"1.5.8","description":"A delightful, performance-focused Redis client for Node and io.js","main":"index.js","scripts":{"test":"NODE_ENV=test DEBUG=ioredis:* mocha","test:cov":"NODE_ENV=test DEBUG=ioredis:* node ./node_modules/istanbul/lib/cli.js cover --preserve-comments ./node_modules/mocha/bin/_mocha -- -R spec","generate-docs":"jsdoc2md lib/redis.js lib/cluster.js lib/commander.js > API.md","build":"node tools/build > commands.js","bench":"matcha benchmarks/*.js"},"repository":{"type":"git","url":"git://github.com/luin/ioredis.git"},"keywords":["redis","cluster","sentinel","pipelining"],"author":{"name":"luin","email":"i@zihua.li","url":"http://zihua.li"},"license":"MIT","dependencies":{"bluebird":"^2.9.21","debug":"^2.1.3","double-ended-queue":"^2.1.0-0","flexbuffer":"0.0.6","lodash":"^3.6.0"},"devDependencies":{"chai":"^2.2.0","codeclimate-test-reporter":"0.0.4","istanbul":"^0.3.13","jsdoc":"^3.3.0-beta3","jsdoc-to-markdown":"^1.0.3","matcha":"^0.6.0","mocha":"^2.2.1","server-destroy":"^1.0.0","sinon":"^1.14.1"},"engines":{"node":">= 0.10.16","iojs":">= 1.0.0"},"gitHead":"88e65edeabb57be510b66e4f30a2d7e3b7d7b618","bugs":{"url":"https://github.com/luin/ioredis/issues"},"homepage":"https://github.com/luin/ioredis","_id":"ioredis@1.5.8","_shasum":"e815c69b07231d180e02a2cbd5cc2a6f030673fd","_from":".","_npmVersion":"2.4.1","_nodeVersion":"1.1.0","_npmUser":{"name":"luin","email":"i@zihua.li"},"maintainers":[{"name":"luin","email":"i@zihua.li"}],"dist":{"shasum":"e815c69b07231d180e02a2cbd5cc2a6f030673fd","tarball":"https://registry.npmjs.org/ioredis/-/ioredis-1.5.8.tgz"},"directories":{}},"1.5.9":{"name":"ioredis","version":"1.5.9","description":"A delightful, performance-focused Redis client for Node and io.js","main":"index.js","scripts":{"test":"NODE_ENV=test DEBUG=ioredis:* mocha","test:cov":"NODE_ENV=test DEBUG=ioredis:* node ./node_modules/istanbul/lib/cli.js cover --preserve-comments ./node_modules/mocha/bin/_mocha -- -R spec","generate-docs":"jsdoc2md lib/redis.js lib/cluster.js lib/commander.js > API.md","build":"node tools/build > commands.js","bench":"matcha benchmarks/*.js"},"repository":{"type":"git","url":"git://github.com/luin/ioredis.git"},"keywords":["redis","cluster","sentinel","pipelining"],"author":{"name":"luin","email":"i@zihua.li","url":"http://zihua.li"},"license":"MIT","dependencies":{"bluebird":"^2.9.21","debug":"^2.1.3","double-ended-queue":"^2.1.0-0","flexbuffer":"0.0.6","lodash":"^3.6.0"},"devDependencies":{"chai":"^2.2.0","codeclimate-test-reporter":"0.0.4","istanbul":"^0.3.13","jsdoc":"^3.3.0-beta3","jsdoc-to-markdown":"^1.0.3","matcha":"^0.6.0","mocha":"^2.2.1","server-destroy":"^1.0.0","sinon":"^1.14.1"},"engines":{"node":">= 0.10.16","iojs":">= 1.0.0"},"gitHead":"ca8dd99518b9a3847db419b80732c79ba4441e31","bugs":{"url":"https://github.com/luin/ioredis/issues"},"homepage":"https://github.com/luin/ioredis","_id":"ioredis@1.5.9","_shasum":"44a11282cfcd66d9471e9bf799b9353a18fb3435","_from":".","_npmVersion":"2.4.1","_nodeVersion":"1.1.0","_npmUser":{"name":"luin","email":"i@zihua.li"},"maintainers":[{"name":"luin","email":"i@zihua.li"}],"dist":{"shasum":"44a11282cfcd66d9471e9bf799b9353a18fb3435","tarball":"https://registry.npmjs.org/ioredis/-/ioredis-1.5.9.tgz"},"directories":{}},"1.5.10":{"name":"ioredis","version":"1.5.10","description":"A delightful, performance-focused Redis client for Node and io.js","main":"index.js","scripts":{"test":"NODE_ENV=test DEBUG=ioredis:* mocha","test:cov":"NODE_ENV=test DEBUG=ioredis:* node ./node_modules/istanbul/lib/cli.js cover --preserve-comments ./node_modules/mocha/bin/_mocha -- -R spec","generate-docs":"jsdoc2md lib/redis.js lib/cluster.js lib/commander.js > API.md","build":"node tools/build > commands.js","bench":"matcha benchmarks/*.js"},"repository":{"type":"git","url":"git://github.com/luin/ioredis.git"},"keywords":["redis","cluster","sentinel","pipelining"],"author":{"name":"luin","email":"i@zihua.li","url":"http://zihua.li"},"license":"MIT","dependencies":{"bluebird":"^2.9.21","debug":"^2.1.3","double-ended-queue":"^2.1.0-0","flexbuffer":"0.0.6","lodash":"^3.6.0"},"devDependencies":{"chai":"^2.2.0","codeclimate-test-reporter":"0.0.4","istanbul":"^0.3.13","jsdoc":"^3.3.0-beta3","jsdoc-to-markdown":"^1.0.3","matcha":"^0.6.0","mocha":"^2.2.1","server-destroy":"^1.0.0","sinon":"^1.14.1"},"engines":{"node":">= 0.10.16","iojs":">= 1.0.0"},"gitHead":"7092668970c71cd2d65dad7a51d814463a55540e","bugs":{"url":"https://github.com/luin/ioredis/issues"},"homepage":"https://github.com/luin/ioredis","_id":"ioredis@1.5.10","_shasum":"012465efa1b47fd78674d8b496eb268b7169e825","_from":".","_npmVersion":"2.4.1","_nodeVersion":"1.1.0","_npmUser":{"name":"luin","email":"i@zihua.li"},"maintainers":[{"name":"luin","email":"i@zihua.li"}],"dist":{"shasum":"012465efa1b47fd78674d8b496eb268b7169e825","tarball":"https://registry.npmjs.org/ioredis/-/ioredis-1.5.10.tgz"},"directories":{}},"1.5.11":{"name":"ioredis","version":"1.5.11","description":"A delightful, performance-focused Redis client for Node and io.js","main":"index.js","scripts":{"test":"NODE_ENV=test DEBUG=ioredis:* mocha","test:cov":"NODE_ENV=test DEBUG=ioredis:* node ./node_modules/istanbul/lib/cli.js cover --preserve-comments ./node_modules/mocha/bin/_mocha -- -R spec","generate-docs":"jsdoc2md lib/redis.js lib/cluster.js lib/commander.js > API.md","build":"node tools/build > commands.js","bench":"matcha benchmarks/*.js"},"repository":{"type":"git","url":"git://github.com/luin/ioredis.git"},"keywords":["redis","cluster","sentinel","pipelining"],"author":{"name":"luin","email":"i@zihua.li","url":"http://zihua.li"},"license":"MIT","dependencies":{"bluebird":"^2.9.21","debug":"^2.1.3","double-ended-queue":"^2.1.0-0","flexbuffer":"0.0.6","lodash":"^3.6.0"},"devDependencies":{"chai":"^2.2.0","codeclimate-test-reporter":"0.0.4","istanbul":"^0.3.13","jsdoc":"^3.3.0-beta3","jsdoc-to-markdown":"^1.0.3","matcha":"^0.6.0","mocha":"^2.2.1","server-destroy":"^1.0.0","sinon":"^1.14.1"},"engines":{"node":">= 0.10.16","iojs":">= 1.0.0"},"gitHead":"40419a86fa126b95094ed91df9c1a39d165cecd5","bugs":{"url":"https://github.com/luin/ioredis/issues"},"homepage":"https://github.com/luin/ioredis","_id":"ioredis@1.5.11","_shasum":"1e37fea55f1a615e5e7292ab960f5a7c6691d40e","_from":".","_npmVersion":"2.4.1","_nodeVersion":"1.1.0","_npmUser":{"name":"luin","email":"i@zihua.li"},"maintainers":[{"name":"luin","email":"i@zihua.li"}],"dist":{"shasum":"1e37fea55f1a615e5e7292ab960f5a7c6691d40e","tarball":"https://registry.npmjs.org/ioredis/-/ioredis-1.5.11.tgz"},"directories":{}},"1.5.12":{"name":"ioredis","version":"1.5.12","description":"A delightful, performance-focused Redis client for Node and io.js","main":"index.js","scripts":{"test":"NODE_ENV=test DEBUG=ioredis:* mocha","test:cov":"NODE_ENV=test DEBUG=ioredis:* node ./node_modules/istanbul/lib/cli.js cover --preserve-comments ./node_modules/mocha/bin/_mocha -- -R spec","generate-docs":"jsdoc2md lib/redis.js lib/cluster.js lib/commander.js > API.md","build":"node tools/build > commands.js","bench":"matcha benchmarks/*.js"},"repository":{"type":"git","url":"git://github.com/luin/ioredis.git"},"keywords":["redis","cluster","sentinel","pipelining"],"author":{"name":"luin","email":"i@zihua.li","url":"http://zihua.li"},"license":"MIT","dependencies":{"bluebird":"^2.9.21","debug":"^2.1.3","double-ended-queue":"^2.1.0-0","flexbuffer":"0.0.6","lodash":"^3.6.0"},"devDependencies":{"chai":"^2.2.0","codeclimate-test-reporter":"0.0.4","istanbul":"^0.3.13","jsdoc":"^3.3.0-beta3","jsdoc-to-markdown":"^1.0.3","matcha":"^0.6.0","mocha":"^2.2.1","server-destroy":"^1.0.0","sinon":"^1.14.1"},"engines":{"node":">= 0.10.16","iojs":">= 1.0.0"},"gitHead":"f09777926066fc20533fae28df4b7cfd3d466665","bugs":{"url":"https://github.com/luin/ioredis/issues"},"homepage":"https://github.com/luin/ioredis","_id":"ioredis@1.5.12","_shasum":"439c8f2e0e90d9870859cb547e8dbc16911f8a8b","_from":".","_npmVersion":"2.4.1","_nodeVersion":"1.1.0","_npmUser":{"name":"luin","email":"i@zihua.li"},"maintainers":[{"name":"luin","email":"i@zihua.li"}],"dist":{"shasum":"439c8f2e0e90d9870859cb547e8dbc16911f8a8b","tarball":"https://registry.npmjs.org/ioredis/-/ioredis-1.5.12.tgz"},"directories":{}},"1.6.0":{"name":"ioredis","version":"1.6.0","description":"A delightful, performance-focused Redis client for Node and io.js","main":"index.js","scripts":{"test":"NODE_ENV=test DEBUG=ioredis:* mocha","test:cov":"NODE_ENV=test DEBUG=ioredis:* node ./node_modules/istanbul/lib/cli.js cover --preserve-comments ./node_modules/mocha/bin/_mocha -- -R spec","generate-docs":"jsdoc2md lib/redis.js lib/cluster.js lib/commander.js > API.md","build":"node tools/build > commands.js","bench":"matcha benchmarks/*.js"},"repository":{"type":"git","url":"git://github.com/luin/ioredis.git"},"keywords":["redis","cluster","sentinel","pipelining"],"author":{"name":"luin","email":"i@zihua.li","url":"http://zihua.li"},"license":"MIT","dependencies":{"bluebird":"^2.9.21","debug":"^2.1.3","double-ended-queue":"^2.1.0-0","flexbuffer":"0.0.6","lodash":"^3.6.0"},"devDependencies":{"chai":"^2.2.0","codeclimate-test-reporter":"0.0.4","istanbul":"^0.3.13","jsdoc":"^3.3.0-beta3","jsdoc-to-markdown":"^1.0.3","matcha":"^0.6.0","mocha":"^2.2.1","server-destroy":"^1.0.0","sinon":"^1.14.1"},"engines":{"node":">= 0.10.16","iojs":">= 1.0.0"},"gitHead":"54f6d6a5ce781cedbad3e15a75465cfefee778af","bugs":{"url":"https://github.com/luin/ioredis/issues"},"homepage":"https://github.com/luin/ioredis#readme","_id":"ioredis@1.6.0","_shasum":"8235df6c21326f624953478a7292b61486303aa6","_from":".","_npmVersion":"2.11.3","_nodeVersion":"2.3.3","_npmUser":{"name":"luin","email":"i@zihua.li"},"dist":{"shasum":"8235df6c21326f624953478a7292b61486303aa6","tarball":"https://registry.npmjs.org/ioredis/-/ioredis-1.6.0.tgz"},"maintainers":[{"name":"luin","email":"i@zihua.li"}],"directories":{}},"1.6.1":{"name":"ioredis","version":"1.6.1","description":"A delightful, performance-focused Redis client for Node and io.js","main":"index.js","scripts":{"test":"NODE_ENV=test DEBUG=ioredis:* mocha","test:cov":"NODE_ENV=test DEBUG=ioredis:* node ./node_modules/istanbul/lib/cli.js cover --preserve-comments ./node_modules/mocha/bin/_mocha -- -R spec","generate-docs":"jsdoc2md lib/redis.js lib/cluster.js lib/commander.js > API.md","build":"node tools/build > commands.js","bench":"matcha benchmarks/*.js"},"repository":{"type":"git","url":"git://github.com/luin/ioredis.git"},"keywords":["redis","cluster","sentinel","pipelining"],"author":{"name":"luin","email":"i@zihua.li","url":"http://zihua.li"},"license":"MIT","dependencies":{"bluebird":"^2.9.21","debug":"^2.1.3","double-ended-queue":"^2.1.0-0","flexbuffer":"0.0.6","lodash":"^3.6.0"},"devDependencies":{"chai":"^2.2.0","codeclimate-test-reporter":"0.0.4","istanbul":"^0.3.13","jsdoc":"^3.3.0-beta3","jsdoc-to-markdown":"^1.0.3","matcha":"^0.6.0","mocha":"^2.2.1","server-destroy":"^1.0.0","sinon":"^1.14.1"},"engines":{"node":">= 0.10.16","iojs":">= 1.0.0"},"gitHead":"1fb0bf4e600059e04f7b94a0db8109238436d8ed","bugs":{"url":"https://github.com/luin/ioredis/issues"},"homepage":"https://github.com/luin/ioredis#readme","_id":"ioredis@1.6.1","_shasum":"08f56d0c19ecbc946198d12e4acfc0c45618cd88","_from":".","_npmVersion":"2.11.3","_nodeVersion":"0.12.7","_npmUser":{"name":"luin","email":"i@zihua.li"},"dist":{"shasum":"08f56d0c19ecbc946198d12e4acfc0c45618cd88","tarball":"https://registry.npmjs.org/ioredis/-/ioredis-1.6.1.tgz"},"maintainers":[{"name":"luin","email":"i@zihua.li"}],"directories":{}},"1.7.0":{"name":"ioredis","version":"1.7.0","description":"A delightful, performance-focused Redis client for Node and io.js","main":"index.js","scripts":{"test":"NODE_ENV=test DEBUG=ioredis:* mocha","test:cov":"NODE_ENV=test DEBUG=ioredis:* node ./node_modules/istanbul/lib/cli.js cover --preserve-comments ./node_modules/mocha/bin/_mocha -- -R spec","generate-docs":"jsdoc2md lib/redis.js lib/cluster.js lib/commander.js > API.md","build":"node tools/build > commands.js","bench":"matcha benchmarks/*.js"},"repository":{"type":"git","url":"git://github.com/luin/ioredis.git"},"keywords":["redis","cluster","sentinel","pipelining"],"author":{"name":"luin","email":"i@zihua.li","url":"http://zihua.li"},"license":"MIT","dependencies":{"bluebird":"^2.9.21","debug":"^2.1.3","double-ended-queue":"^2.1.0-0","flexbuffer":"0.0.6","lodash":"^3.6.0"},"devDependencies":{"chai":"^2.2.0","codeclimate-test-reporter":"0.0.4","istanbul":"^0.3.13","jsdoc":"^3.3.0-beta3","jsdoc-to-markdown":"^1.0.3","matcha":"^0.6.0","mocha":"^2.2.1","server-destroy":"^1.0.0","sinon":"^1.14.1"},"engines":{"node":">= 0.10.16","iojs":">= 1.0.0"},"gitHead":"d63697008e561beda415db51413207855431adaa","bugs":{"url":"https://github.com/luin/ioredis/issues"},"homepage":"https://github.com/luin/ioredis#readme","_id":"ioredis@1.7.0","_shasum":"6eaa41a051113210628b8da2871b85cd837a627b","_from":".","_npmVersion":"2.11.3","_nodeVersion":"2.3.3","_npmUser":{"name":"luin","email":"i@zihua.li"},"dist":{"shasum":"6eaa41a051113210628b8da2871b85cd837a627b","tarball":"https://registry.npmjs.org/ioredis/-/ioredis-1.7.0.tgz"},"maintainers":[{"name":"luin","email":"i@zihua.li"}],"directories":{}},"1.7.1":{"name":"ioredis","version":"1.7.1","description":"A delightful, performance-focused Redis client for Node and io.js","main":"index.js","scripts":{"test":"NODE_ENV=test DEBUG=ioredis:* mocha","test:cov":"NODE_ENV=test DEBUG=ioredis:* node ./node_modules/istanbul/lib/cli.js cover --preserve-comments ./node_modules/mocha/bin/_mocha -- -R spec","generate-docs":"jsdoc2md lib/redis.js lib/cluster.js lib/commander.js > API.md","build":"node tools/build > commands.js","bench":"matcha benchmarks/*.js"},"repository":{"type":"git","url":"git://github.com/luin/ioredis.git"},"keywords":["redis","cluster","sentinel","pipelining"],"author":{"name":"luin","email":"i@zihua.li","url":"http://zihua.li"},"license":"MIT","dependencies":{"bluebird":"^2.9.21","debug":"^2.1.3","double-ended-queue":"^2.1.0-0","flexbuffer":"0.0.6","lodash":"^3.6.0"},"devDependencies":{"chai":"^2.2.0","codeclimate-test-reporter":"0.0.4","istanbul":"^0.3.13","jsdoc":"^3.3.0-beta3","jsdoc-to-markdown":"^1.0.3","matcha":"^0.6.0","mocha":"^2.2.1","server-destroy":"^1.0.0","sinon":"^1.14.1"},"engines":{"node":">= 0.10.16","iojs":">= 1.0.0"},"gitHead":"7caa5df0c6b832d94580ce4f81cb5c9455fcbf2d","bugs":{"url":"https://github.com/luin/ioredis/issues"},"homepage":"https://github.com/luin/ioredis#readme","_id":"ioredis@1.7.1","_shasum":"579e7c1acdc947f64bd8e8680a8c6c73401f03de","_from":".","_npmVersion":"2.11.3","_nodeVersion":"2.3.3","_npmUser":{"name":"luin","email":"i@zihua.li"},"dist":{"shasum":"579e7c1acdc947f64bd8e8680a8c6c73401f03de","tarball":"https://registry.npmjs.org/ioredis/-/ioredis-1.7.1.tgz"},"maintainers":[{"name":"luin","email":"i@zihua.li"}],"directories":{}},"1.7.2":{"name":"ioredis","version":"1.7.2","description":"A delightful, performance-focused Redis client for Node and io.js","main":"index.js","scripts":{"test":"NODE_ENV=test DEBUG=ioredis:* mocha","test:cov":"NODE_ENV=test DEBUG=ioredis:* node ./node_modules/istanbul/lib/cli.js cover --preserve-comments ./node_modules/mocha/bin/_mocha -- -R spec","generate-docs":"jsdoc2md lib/redis.js lib/cluster.js lib/commander.js > API.md","build":"node tools/build > commands.js","bench":"matcha benchmarks/*.js"},"repository":{"type":"git","url":"git://github.com/luin/ioredis.git"},"keywords":["redis","cluster","sentinel","pipelining"],"author":{"name":"luin","email":"i@zihua.li","url":"http://zihua.li"},"license":"MIT","dependencies":{"bluebird":"^2.9.21","debug":"^2.1.3","double-ended-queue":"^2.1.0-0","flexbuffer":"0.0.6","lodash":"^3.6.0"},"devDependencies":{"chai":"^2.2.0","codeclimate-test-reporter":"0.0.4","istanbul":"^0.3.13","jsdoc":"^3.3.0-beta3","jsdoc-to-markdown":"^1.0.3","matcha":"^0.6.0","mocha":"^2.2.1","server-destroy":"^1.0.0","sinon":"^1.14.1"},"engines":{"node":">= 0.10.16","iojs":">= 1.0.0"},"gitHead":"c00d110d7942443978bf85cfe4a11c954774dd2b","bugs":{"url":"https://github.com/luin/ioredis/issues"},"homepage":"https://github.com/luin/ioredis#readme","_id":"ioredis@1.7.2","_shasum":"5ca8f85b9fbd75ab4c91510bc863360ea82d3ef9","_from":".","_npmVersion":"2.11.3","_nodeVersion":"2.3.3","_npmUser":{"name":"luin","email":"i@zihua.li"},"dist":{"shasum":"5ca8f85b9fbd75ab4c91510bc863360ea82d3ef9","tarball":"https://registry.npmjs.org/ioredis/-/ioredis-1.7.2.tgz"},"maintainers":[{"name":"luin","email":"i@zihua.li"}],"directories":{}},"1.7.3":{"name":"ioredis","version":"1.7.3","description":"A delightful, performance-focused Redis client for Node and io.js","main":"index.js","scripts":{"test":"NODE_ENV=test DEBUG=ioredis:* mocha","test:cov":"NODE_ENV=test DEBUG=ioredis:* node ./node_modules/istanbul/lib/cli.js cover --preserve-comments ./node_modules/mocha/bin/_mocha -- -R spec","generate-docs":"jsdoc2md lib/redis.js lib/cluster.js lib/commander.js > API.md","build":"node tools/build > commands.js","bench":"matcha benchmarks/*.js"},"repository":{"type":"git","url":"git://github.com/luin/ioredis.git"},"keywords":["redis","cluster","sentinel","pipelining"],"author":{"name":"luin","email":"i@zihua.li","url":"http://zihua.li"},"license":"MIT","dependencies":{"bluebird":"^2.9.21","debug":"^2.1.3","double-ended-queue":"^2.1.0-0","flexbuffer":"0.0.6","lodash":"^3.6.0"},"devDependencies":{"chai":"^2.2.0","codeclimate-test-reporter":"0.0.4","istanbul":"^0.3.13","jsdoc":"^3.3.0-beta3","jsdoc-to-markdown":"^1.0.3","matcha":"^0.6.0","mocha":"^2.2.1","server-destroy":"^1.0.0","sinon":"^1.14.1"},"engines":{"node":">= 0.10.16","iojs":">= 1.0.0"},"gitHead":"1e7961e9c91155fc780e86b64ca5323e9099234d","bugs":{"url":"https://github.com/luin/ioredis/issues"},"homepage":"https://github.com/luin/ioredis#readme","_id":"ioredis@1.7.3","_shasum":"cf535762c0d7eeb8211b5a6dc812ad6acf0f0c35","_from":".","_npmVersion":"2.11.3","_nodeVersion":"2.3.3","_npmUser":{"name":"luin","email":"i@zihua.li"},"dist":{"shasum":"cf535762c0d7eeb8211b5a6dc812ad6acf0f0c35","tarball":"https://registry.npmjs.org/ioredis/-/ioredis-1.7.3.tgz"},"maintainers":[{"name":"luin","email":"i@zihua.li"}],"directories":{}},"1.7.4":{"name":"ioredis","version":"1.7.4","description":"A delightful, performance-focused Redis client for Node and io.js","main":"index.js","scripts":{"test":"NODE_ENV=test DEBUG=ioredis:* mocha","test:cov":"NODE_ENV=test DEBUG=ioredis:* node ./node_modules/istanbul/lib/cli.js cover --preserve-comments ./node_modules/mocha/bin/_mocha -- -R spec","generate-docs":"jsdoc2md lib/redis.js lib/cluster.js lib/commander.js > API.md","build":"node tools/build > commands.js","bench":"matcha benchmarks/*.js"},"repository":{"type":"git","url":"git://github.com/luin/ioredis.git"},"keywords":["redis","cluster","sentinel","pipelining"],"author":{"name":"luin","email":"i@zihua.li","url":"http://zihua.li"},"license":"MIT","dependencies":{"bluebird":"^2.9.21","debug":"^2.1.3","double-ended-queue":"^2.1.0-0","flexbuffer":"0.0.6","lodash":"^3.6.0"},"devDependencies":{"chai":"^2.2.0","codeclimate-test-reporter":"0.0.4","istanbul":"^0.3.13","jsdoc":"^3.3.0-beta3","jsdoc-to-markdown":"^1.0.3","matcha":"^0.6.0","mocha":"^2.2.1","server-destroy":"^1.0.0","sinon":"^1.14.1"},"engines":{"node":">= 0.10.16","iojs":">= 1.0.0"},"gitHead":"6976e0a9cbdeb4834c5a5f74481b941fa9f92e28","bugs":{"url":"https://github.com/luin/ioredis/issues"},"homepage":"https://github.com/luin/ioredis#readme","_id":"ioredis@1.7.4","_shasum":"7845dcf24f4537d099ac5951c14e81782c3c633a","_from":".","_npmVersion":"2.12.1","_nodeVersion":"0.12.7","_npmUser":{"name":"luin","email":"i@zihua.li"},"dist":{"shasum":"7845dcf24f4537d099ac5951c14e81782c3c633a","tarball":"https://registry.npmjs.org/ioredis/-/ioredis-1.7.4.tgz"},"maintainers":[{"name":"luin","email":"i@zihua.li"}],"directories":{}},"1.7.5":{"name":"ioredis","version":"1.7.5","description":"A delightful, performance-focused Redis client for Node and io.js","main":"index.js","scripts":{"test":"NODE_ENV=test DEBUG=ioredis:* mocha","test:cov":"NODE_ENV=test DEBUG=ioredis:* node ./node_modules/istanbul/lib/cli.js cover --preserve-comments ./node_modules/mocha/bin/_mocha -- -R spec","generate-docs":"jsdoc2md lib/redis.js lib/cluster.js lib/commander.js > API.md","build":"node tools/build > commands.js","bench":"matcha benchmarks/*.js"},"repository":{"type":"git","url":"git://github.com/luin/ioredis.git"},"keywords":["redis","cluster","sentinel","pipelining"],"author":{"name":"luin","email":"i@zihua.li","url":"http://zihua.li"},"license":"MIT","dependencies":{"bluebird":"^2.9.21","debug":"^2.1.3","double-ended-queue":"^2.1.0-0","flexbuffer":"0.0.6","lodash":"^3.6.0"},"devDependencies":{"chai":"^2.2.0","codeclimate-test-reporter":"0.0.4","istanbul":"^0.3.13","jsdoc":"^3.3.0-beta3","jsdoc-to-markdown":"^1.0.3","matcha":"^0.6.0","mocha":"^2.2.1","server-destroy":"^1.0.0","sinon":"^1.14.1"},"engines":{"node":">= 0.10.16","iojs":">= 1.0.0"},"gitHead":"f1770395c544d824bbddd40ca7bfeb26d2556dba","bugs":{"url":"https://github.com/luin/ioredis/issues"},"homepage":"https://github.com/luin/ioredis#readme","_id":"ioredis@1.7.5","_shasum":"f7701ca855ce8646468fb280f37a5ac26ecd254a","_from":".","_npmVersion":"2.13.2","_nodeVersion":"2.5.0","_npmUser":{"name":"luin","email":"i@zihua.li"},"dist":{"shasum":"f7701ca855ce8646468fb280f37a5ac26ecd254a","tarball":"https://registry.npmjs.org/ioredis/-/ioredis-1.7.5.tgz"},"maintainers":[{"name":"luin","email":"i@zihua.li"}],"directories":{}},"1.7.6":{"name":"ioredis","version":"1.7.6","description":"A delightful, performance-focused Redis client for Node and io.js","main":"index.js","scripts":{"test":"NODE_ENV=test DEBUG=ioredis:* mocha","test:cov":"NODE_ENV=test DEBUG=ioredis:* node ./node_modules/istanbul/lib/cli.js cover --preserve-comments ./node_modules/mocha/bin/_mocha -- -R spec","generate-docs":"jsdoc2md lib/redis.js lib/cluster.js lib/commander.js > API.md","build":"node tools/build > commands.js","bench":"matcha benchmarks/*.js"},"repository":{"type":"git","url":"git://github.com/luin/ioredis.git"},"keywords":["redis","cluster","sentinel","pipelining"],"author":{"name":"luin","email":"i@zihua.li","url":"http://zihua.li"},"license":"MIT","dependencies":{"bluebird":"^2.9.21","debug":"^2.1.3","double-ended-queue":"^2.1.0-0","flexbuffer":"0.0.6","lodash":"^3.6.0"},"devDependencies":{"chai":"^2.2.0","codeclimate-test-reporter":"0.0.4","istanbul":"^0.3.13","jsdoc":"^3.3.0-beta3","jsdoc-to-markdown":"^1.0.3","matcha":"^0.6.0","mocha":"^2.2.1","server-destroy":"^1.0.0","sinon":"^1.14.1"},"engines":{"node":">= 0.10.16","iojs":">= 1.0.0"},"gitHead":"ac7f5c95a483e575960e4e0945fa79ab43aedc6d","bugs":{"url":"https://github.com/luin/ioredis/issues"},"homepage":"https://github.com/luin/ioredis#readme","_id":"ioredis@1.7.6","_shasum":"bafee9f2e49cfd8dd3c1a55b6ea2b1ee0ef79147","_from":".","_npmVersion":"2.13.2","_nodeVersion":"2.5.0","_npmUser":{"name":"luin","email":"i@zihua.li"},"dist":{"shasum":"bafee9f2e49cfd8dd3c1a55b6ea2b1ee0ef79147","tarball":"https://registry.npmjs.org/ioredis/-/ioredis-1.7.6.tgz"},"maintainers":[{"name":"luin","email":"i@zihua.li"}],"directories":{}},"1.8.0":{"name":"ioredis","version":"1.8.0","description":"A delightful, performance-focused Redis client for Node and io.js","main":"index.js","scripts":{"test":"NODE_ENV=test DEBUG=ioredis:* mocha","test:cov":"NODE_ENV=test DEBUG=ioredis:* node ./node_modules/istanbul/lib/cli.js cover --preserve-comments ./node_modules/mocha/bin/_mocha -- -R spec","generate-docs":"jsdoc2md lib/redis.js lib/cluster.js lib/commander.js > API.md","build":"node tools/build > commands.js","bench":"matcha benchmarks/*.js"},"repository":{"type":"git","url":"git://github.com/luin/ioredis.git"},"keywords":["redis","cluster","sentinel","pipelining"],"author":{"name":"luin","email":"i@zihua.li","url":"http://zihua.li"},"license":"MIT","dependencies":{"bluebird":"^2.9.21","debug":"^2.1.3","double-ended-queue":"^2.1.0-0","flexbuffer":"0.0.6","lodash":"^3.6.0"},"devDependencies":{"chai":"^2.2.0","codeclimate-test-reporter":"0.0.4","istanbul":"^0.3.13","jsdoc":"^3.3.0-beta3","jsdoc-to-markdown":"^1.0.3","matcha":"^0.6.0","mocha":"^2.2.1","server-destroy":"^1.0.0","sinon":"^1.14.1"},"engines":{"node":">= 0.10.16","iojs":">= 1.0.0"},"gitHead":"a0d7dbfa34fcbc81def010e1a1969683cd20d1f3","bugs":{"url":"https://github.com/luin/ioredis/issues"},"homepage":"https://github.com/luin/ioredis#readme","_id":"ioredis@1.8.0","_shasum":"726dc721fa4a080eda5aec19f267890d63301212","_from":".","_npmVersion":"2.14.2","_nodeVersion":"4.0.0","_npmUser":{"name":"luin","email":"i@zihua.li"},"dist":{"shasum":"726dc721fa4a080eda5aec19f267890d63301212","tarball":"https://registry.npmjs.org/ioredis/-/ioredis-1.8.0.tgz"},"maintainers":[{"name":"luin","email":"i@zihua.li"}],"directories":{}},"1.9.0":{"name":"ioredis","version":"1.9.0","description":"A delightful, performance-focused Redis client for Node and io.js","main":"index.js","scripts":{"test":"NODE_ENV=test DEBUG=ioredis:* mocha","test:cov":"NODE_ENV=test DEBUG=ioredis:* node ./node_modules/istanbul/lib/cli.js cover --preserve-comments ./node_modules/mocha/bin/_mocha -- -R spec","generate-docs":"jsdoc2md lib/redis.js lib/cluster.js lib/commander.js > API.md","build":"node tools/build > commands.js","bench":"matcha benchmarks/*.js"},"repository":{"type":"git","url":"git://github.com/luin/ioredis.git"},"keywords":["redis","cluster","sentinel","pipelining"],"author":{"name":"luin","email":"i@zihua.li","url":"http://zihua.li"},"license":"MIT","dependencies":{"bluebird":"^2.9.21","debug":"^2.1.3","double-ended-queue":"^2.1.0-0","flexbuffer":"0.0.6","lodash":"^3.6.0"},"devDependencies":{"chai":"^2.2.0","codeclimate-test-reporter":"0.0.4","istanbul":"^0.3.13","jsdoc":"^3.3.0-beta3","jsdoc-to-markdown":"^1.0.3","matcha":"^0.6.0","mocha":"^2.2.1","server-destroy":"^1.0.0","sinon":"^1.14.1"},"engines":{"node":">= 0.10.16","iojs":">= 1.0.0"},"gitHead":"04aa66fa636d68cabecfa18f639fc032273305ad","bugs":{"url":"https://github.com/luin/ioredis/issues"},"homepage":"https://github.com/luin/ioredis#readme","_id":"ioredis@1.9.0","_shasum":"493eda994d15b23e487b5e83e71ba505b0934b81","_from":".","_npmVersion":"2.14.2","_nodeVersion":"4.0.0","_npmUser":{"name":"luin","email":"i@zihua.li"},"dist":{"shasum":"493eda994d15b23e487b5e83e71ba505b0934b81","tarball":"https://registry.npmjs.org/ioredis/-/ioredis-1.9.0.tgz"},"maintainers":[{"name":"luin","email":"i@zihua.li"}],"directories":{}},"1.9.1":{"name":"ioredis","version":"1.9.1","description":"A delightful, performance-focused Redis client for Node and io.js","main":"index.js","scripts":{"test":"NODE_ENV=test DEBUG=ioredis:* mocha","test:cov":"NODE_ENV=test DEBUG=ioredis:* node ./node_modules/istanbul/lib/cli.js cover --preserve-comments ./node_modules/mocha/bin/_mocha -- -R spec","generate-docs":"jsdoc2md lib/redis.js lib/cluster.js lib/commander.js > API.md","build":"node tools/build > commands.js","bench":"matcha benchmarks/*.js"},"repository":{"type":"git","url":"git://github.com/luin/ioredis.git"},"keywords":["redis","cluster","sentinel","pipelining"],"author":{"name":"luin","email":"i@zihua.li","url":"http://zihua.li"},"license":"MIT","dependencies":{"bluebird":"^2.9.21","debug":"^2.1.3","double-ended-queue":"^2.1.0-0","flexbuffer":"0.0.6","lodash":"^3.6.0"},"devDependencies":{"chai":"^2.2.0","codeclimate-test-reporter":"0.0.4","istanbul":"^0.3.13","jsdoc":"^3.3.0-beta3","jsdoc-to-markdown":"^1.0.3","matcha":"^0.6.0","mocha":"^2.2.1","server-destroy":"^1.0.0","sinon":"^1.14.1"},"engines":{"node":">= 0.10.16","iojs":">= 1.0.0"},"gitHead":"41f4d8efca89cbef422ad50dc2b66654a2e6d848","bugs":{"url":"https://github.com/luin/ioredis/issues"},"homepage":"https://github.com/luin/ioredis#readme","_id":"ioredis@1.9.1","_shasum":"32fafda3620ecb625ba0e16a018e141fb6c5faf6","_from":".","_npmVersion":"2.14.2","_nodeVersion":"4.0.0","_npmUser":{"name":"luin","email":"i@zihua.li"},"dist":{"shasum":"32fafda3620ecb625ba0e16a018e141fb6c5faf6","tarball":"https://registry.npmjs.org/ioredis/-/ioredis-1.9.1.tgz"},"maintainers":[{"name":"luin","email":"i@zihua.li"}],"directories":{}},"1.10.0":{"name":"ioredis","version":"1.10.0","description":"A delightful, performance-focused Redis client for Node and io.js","main":"index.js","scripts":{"test":"NODE_ENV=test DEBUG=ioredis:* mocha","test:cov":"NODE_ENV=test DEBUG=ioredis:* node ./node_modules/istanbul/lib/cli.js cover --preserve-comments ./node_modules/mocha/bin/_mocha -- -R spec","generate-docs":"jsdoc2md lib/redis.js lib/cluster.js lib/commander.js > API.md","build":"node tools/build > commands.js","bench":"matcha benchmarks/*.js"},"repository":{"type":"git","url":"git://github.com/luin/ioredis.git"},"keywords":["redis","cluster","sentinel","pipelining"],"author":{"name":"luin","email":"i@zihua.li","url":"http://zihua.li"},"license":"MIT","dependencies":{"bluebird":"^2.9.21","debug":"^2.1.3","double-ended-queue":"^2.1.0-0","flexbuffer":"0.0.6","lodash":"^3.6.0"},"devDependencies":{"chai":"^2.2.0","codeclimate-test-reporter":"0.0.4","istanbul":"^0.3.13","jsdoc":"^3.3.0-beta3","jsdoc-to-markdown":"^1.0.3","matcha":"^0.6.0","mocha":"^2.2.1","server-destroy":"^1.0.0","sinon":"^1.14.1"},"engines":{"node":">= 0.10.16","iojs":">= 1.0.0"},"gitHead":"c6a64e8c18ec008c47ef25bf4e35e6a517d2a1f0","bugs":{"url":"https://github.com/luin/ioredis/issues"},"homepage":"https://github.com/luin/ioredis#readme","_id":"ioredis@1.10.0","_shasum":"e3260b963b07a7346e6b9658f25db6d89819ea7b","_from":".","_npmVersion":"2.14.2","_nodeVersion":"4.0.0","_npmUser":{"name":"luin","email":"i@zihua.li"},"dist":{"shasum":"e3260b963b07a7346e6b9658f25db6d89819ea7b","tarball":"https://registry.npmjs.org/ioredis/-/ioredis-1.10.0.tgz"},"maintainers":[{"name":"luin","email":"i@zihua.li"}],"directories":{}},"1.11.0":{"name":"ioredis","version":"1.11.0","description":"A delightful, performance-focused Redis client for Node and io.js","main":"index.js","scripts":{"test":"NODE_ENV=test DEBUG=ioredis:* mocha","test:cov":"NODE_ENV=test DEBUG=ioredis:* node ./node_modules/istanbul/lib/cli.js cover --preserve-comments ./node_modules/mocha/bin/_mocha -- -R spec","generate-docs":"jsdoc2md lib/redis.js lib/cluster.js lib/commander.js > API.md","build":"node tools/build > commands.js","bench":"matcha benchmarks/*.js"},"repository":{"type":"git","url":"git://github.com/luin/ioredis.git"},"keywords":["redis","cluster","sentinel","pipelining"],"author":{"name":"luin","email":"i@zihua.li","url":"http://zihua.li"},"license":"MIT","dependencies":{"bluebird":"^2.9.34","debug":"^2.2.0","double-ended-queue":"^2.1.0-0","flexbuffer":"0.0.6","lodash":"^3.6.0"},"devDependencies":{"chai":"^2.2.0","codeclimate-test-reporter":"0.0.4","istanbul":"^0.3.13","jsdoc":"^3.3.0-beta3","jsdoc-to-markdown":"^1.0.3","matcha":"^0.6.0","mocha":"^2.2.1","redis":"^2.2.5","server-destroy":"^1.0.0","sinon":"^1.14.1"},"engines":{"node":">= 0.10.16","iojs":">= 1.0.0"},"gitHead":"939f289989973c1bda99642e468c5f4f9bec47a6","bugs":{"url":"https://github.com/luin/ioredis/issues"},"homepage":"https://github.com/luin/ioredis#readme","_id":"ioredis@1.11.0","_shasum":"b7c412383c4bccc387aa47e07495cd153125e17c","_from":".","_npmVersion":"2.14.7","_nodeVersion":"4.2.1","_npmUser":{"name":"luin","email":"i@zihua.li"},"dist":{"shasum":"b7c412383c4bccc387aa47e07495cd153125e17c","tarball":"https://registry.npmjs.org/ioredis/-/ioredis-1.11.0.tgz"},"maintainers":[{"name":"luin","email":"i@zihua.li"}],"directories":{}},"1.11.1":{"name":"ioredis","version":"1.11.1","description":"A delightful, performance-focused Redis client for Node and io.js","main":"index.js","scripts":{"test":"NODE_ENV=test DEBUG=ioredis:* mocha","test:cov":"NODE_ENV=test DEBUG=ioredis:* node ./node_modules/istanbul/lib/cli.js cover --preserve-comments ./node_modules/mocha/bin/_mocha -- -R spec","generate-docs":"jsdoc2md lib/redis.js lib/cluster.js lib/commander.js > API.md","build":"node tools/build > commands.js","bench":"matcha benchmarks/*.js"},"repository":{"type":"git","url":"git://github.com/luin/ioredis.git"},"keywords":["redis","cluster","sentinel","pipelining"],"author":{"name":"luin","email":"i@zihua.li","url":"http://zihua.li"},"license":"MIT","dependencies":{"bluebird":"^2.9.34","debug":"^2.2.0","double-ended-queue":"^2.1.0-0","flexbuffer":"0.0.6","lodash":"^3.6.0"},"devDependencies":{"chai":"^2.2.0","codeclimate-test-reporter":"0.0.4","istanbul":"^0.3.13","jsdoc":"^3.3.0-beta3","jsdoc-to-markdown":"^1.0.3","matcha":"^0.6.0","mocha":"^2.2.1","redis":"^2.2.5","server-destroy":"^1.0.0","sinon":"^1.14.1"},"engines":{"node":">= 0.10.16","iojs":">= 1.0.0"},"gitHead":"cf13fc6f7dabedac53a1bdd7987f26776ea625bb","bugs":{"url":"https://github.com/luin/ioredis/issues"},"homepage":"https://github.com/luin/ioredis#readme","_id":"ioredis@1.11.1","_shasum":"c3739ad2b714bd2f96de889037aab8111e6a5ccd","_from":".","_npmVersion":"2.14.2","_nodeVersion":"4.0.0","_npmUser":{"name":"luin","email":"i@zihua.li"},"dist":{"shasum":"c3739ad2b714bd2f96de889037aab8111e6a5ccd","tarball":"https://registry.npmjs.org/ioredis/-/ioredis-1.11.1.tgz"},"maintainers":[{"name":"luin","email":"i@zihua.li"}],"directories":{}},"1.12.1":{"name":"ioredis","version":"1.12.1","description":"A delightful, performance-focused Redis client for Node and io.js","main":"index.js","scripts":{"test":"NODE_ENV=test DEBUG=ioredis:* mocha","test:cov":"NODE_ENV=test DEBUG=ioredis:* node ./node_modules/istanbul/lib/cli.js cover --preserve-comments ./node_modules/mocha/bin/_mocha -- -R spec","generate-docs":"jsdoc2md lib/redis.js lib/cluster.js lib/commander.js > API.md","build":"node tools/build > commands.js","bench":"matcha benchmarks/*.js"},"repository":{"type":"git","url":"git://github.com/luin/ioredis.git"},"keywords":["redis","cluster","sentinel","pipelining"],"author":{"name":"luin","email":"i@zihua.li","url":"http://zihua.li"},"license":"MIT","dependencies":{"bluebird":"^2.9.34","debug":"^2.2.0","double-ended-queue":"^2.1.0-0","flexbuffer":"0.0.6","lodash":"^3.6.0"},"devDependencies":{"chai":"^2.2.0","codeclimate-test-reporter":"0.0.4","istanbul":"^0.3.13","jsdoc":"^3.3.0-beta3","jsdoc-to-markdown":"^1.0.3","matcha":"^0.6.0","mocha":"^2.2.1","redis":"^2.2.5","server-destroy":"^1.0.0","sinon":"^1.14.1"},"engines":{"node":">= 0.10.16","iojs":">= 1.0.0"},"gitHead":"bb04217a9b91bbf0e5082f6201ff86b69dacdcbc","bugs":{"url":"https://github.com/luin/ioredis/issues"},"homepage":"https://github.com/luin/ioredis#readme","_id":"ioredis@1.12.1","_shasum":"1d0d7ffc82cb37bb8385e2da0a351b55b02fb656","_from":".","_npmVersion":"2.14.2","_nodeVersion":"4.0.0","_npmUser":{"name":"luin","email":"i@zihua.li"},"dist":{"shasum":"1d0d7ffc82cb37bb8385e2da0a351b55b02fb656","tarball":"https://registry.npmjs.org/ioredis/-/ioredis-1.12.1.tgz"},"maintainers":[{"name":"luin","email":"i@zihua.li"}],"directories":{}},"1.12.2":{"name":"ioredis","version":"1.12.2","description":"A delightful, performance-focused Redis client for Node and io.js","main":"index.js","scripts":{"test":"NODE_ENV=test DEBUG=ioredis:* mocha","test:cov":"NODE_ENV=test DEBUG=ioredis:* node ./node_modules/istanbul/lib/cli.js cover --preserve-comments ./node_modules/mocha/bin/_mocha -- -R spec","generate-docs":"jsdoc2md lib/redis.js lib/cluster.js lib/commander.js > API.md","build":"node tools/build > commands.js","bench":"matcha benchmarks/*.js"},"repository":{"type":"git","url":"git://github.com/luin/ioredis.git"},"keywords":["redis","cluster","sentinel","pipelining"],"author":{"name":"luin","email":"i@zihua.li","url":"http://zihua.li"},"license":"MIT","dependencies":{"bluebird":"^2.9.34","debug":"^2.2.0","double-ended-queue":"^2.1.0-0","flexbuffer":"0.0.6","lodash":"^3.6.0"},"devDependencies":{"chai":"^2.2.0","codeclimate-test-reporter":"0.0.4","istanbul":"^0.3.13","jsdoc":"^3.3.0-beta3","jsdoc-to-markdown":"^1.0.3","matcha":"^0.6.0","mocha":"^2.2.1","redis":"^2.2.5","server-destroy":"^1.0.0","sinon":"^1.14.1"},"engines":{"node":">= 0.10.16","iojs":">= 1.0.0"},"gitHead":"bcea39495522f9daad49ef719607e9f4f7c7c5f0","bugs":{"url":"https://github.com/luin/ioredis/issues"},"homepage":"https://github.com/luin/ioredis#readme","_id":"ioredis@1.12.2","_shasum":"6d6b326ad906bc17f48e5c9cdfe23069f47a640a","_from":".","_npmVersion":"2.14.2","_nodeVersion":"4.0.0","_npmUser":{"name":"luin","email":"i@zihua.li"},"dist":{"shasum":"6d6b326ad906bc17f48e5c9cdfe23069f47a640a","tarball":"https://registry.npmjs.org/ioredis/-/ioredis-1.12.2.tgz"},"maintainers":[{"name":"luin","email":"i@zihua.li"}],"directories":{}},"1.13.0":{"name":"ioredis","version":"1.13.0","description":"A delightful, performance-focused Redis client for Node and io.js","main":"index.js","scripts":{"test":"NODE_ENV=test DEBUG=ioredis:* mocha","test:cov":"NODE_ENV=test DEBUG=ioredis:* node ./node_modules/istanbul/lib/cli.js cover --preserve-comments ./node_modules/mocha/bin/_mocha -- -R spec","generate-docs":"jsdoc2md lib/redis.js lib/cluster.js lib/commander.js > API.md","build":"node tools/build > commands.js","bench":"matcha benchmarks/*.js"},"repository":{"type":"git","url":"git://github.com/luin/ioredis.git"},"keywords":["redis","cluster","sentinel","pipelining"],"author":{"name":"luin","email":"i@zihua.li","url":"http://zihua.li"},"license":"MIT","dependencies":{"bluebird":"^2.9.34","debug":"^2.2.0","double-ended-queue":"^2.1.0-0","flexbuffer":"0.0.6","lodash":"^3.6.0"},"devDependencies":{"chai":"^2.2.0","codeclimate-test-reporter":"0.0.4","istanbul":"^0.3.13","jsdoc":"^3.3.0-beta3","jsdoc-to-markdown":"^1.0.3","matcha":"^0.6.0","mocha":"^2.2.1","redis":"^2.2.5","server-destroy":"^1.0.0","sinon":"^1.14.1"},"engines":{"node":">= 0.10.16","iojs":">= 1.0.0"},"gitHead":"b2f804435282bfdf3f1bc6b5e02ceb03046d0f7c","bugs":{"url":"https://github.com/luin/ioredis/issues"},"homepage":"https://github.com/luin/ioredis#readme","_id":"ioredis@1.13.0","_shasum":"242e150dde90255f2f8eefa8e60fb8ec7dd4a3d5","_from":".","_npmVersion":"2.14.7","_nodeVersion":"4.2.1","_npmUser":{"name":"luin","email":"i@zihua.li"},"dist":{"shasum":"242e150dde90255f2f8eefa8e60fb8ec7dd4a3d5","tarball":"https://registry.npmjs.org/ioredis/-/ioredis-1.13.0.tgz"},"maintainers":[{"name":"luin","email":"i@zihua.li"}],"directories":{}},"1.13.1":{"name":"ioredis","version":"1.13.1","description":"A delightful, performance-focused Redis client for Node and io.js","main":"index.js","scripts":{"test":"NODE_ENV=test DEBUG=ioredis:* mocha","test:cov":"NODE_ENV=test DEBUG=ioredis:* node ./node_modules/istanbul/lib/cli.js cover --preserve-comments ./node_modules/mocha/bin/_mocha -- -R spec","generate-docs":"jsdoc2md lib/redis.js lib/cluster.js lib/commander.js > API.md","build":"node tools/build > commands.js","bench":"matcha benchmarks/*.js"},"repository":{"type":"git","url":"git://github.com/luin/ioredis.git"},"keywords":["redis","cluster","sentinel","pipelining"],"author":{"name":"luin","email":"i@zihua.li","url":"http://zihua.li"},"license":"MIT","dependencies":{"bluebird":"^2.9.34","debug":"^2.2.0","double-ended-queue":"^2.1.0-0","flexbuffer":"0.0.6","lodash":"^3.6.0"},"devDependencies":{"chai":"^2.2.0","codeclimate-test-reporter":"0.0.4","istanbul":"^0.3.13","jsdoc":"^3.3.0-beta3","jsdoc-to-markdown":"^1.0.3","matcha":"^0.6.0","mocha":"^2.2.1","redis":"^2.2.5","server-destroy":"^1.0.0","sinon":"^1.14.1"},"engines":{"node":">= 0.10.16","iojs":">= 1.0.0"},"gitHead":"f52b802f19ee3f8c27713f78f36cb39ed4204246","bugs":{"url":"https://github.com/luin/ioredis/issues"},"homepage":"https://github.com/luin/ioredis#readme","_id":"ioredis@1.13.1","_shasum":"0aa30f6667322d50783ab5be7f17856ab79d5830","_from":".","_npmVersion":"2.14.7","_nodeVersion":"4.2.1","_npmUser":{"name":"luin","email":"i@zihua.li"},"dist":{"shasum":"0aa30f6667322d50783ab5be7f17856ab79d5830","tarball":"https://registry.npmjs.org/ioredis/-/ioredis-1.13.1.tgz"},"maintainers":[{"name":"luin","email":"i@zihua.li"}],"directories":{}},"1.13.2":{"name":"ioredis","version":"1.13.2","description":"A delightful, performance-focused Redis client for Node and io.js","main":"index.js","scripts":{"test":"NODE_ENV=test DEBUG=ioredis:* mocha","test:cov":"NODE_ENV=test DEBUG=ioredis:* node ./node_modules/istanbul/lib/cli.js cover --preserve-comments ./node_modules/mocha/bin/_mocha -- -R spec","generate-docs":"jsdoc2md lib/redis.js lib/cluster.js lib/commander.js > API.md","build":"node tools/build > commands.js","bench":"matcha benchmarks/*.js"},"repository":{"type":"git","url":"git://github.com/luin/ioredis.git"},"keywords":["redis","cluster","sentinel","pipelining"],"author":{"name":"luin","email":"i@zihua.li","url":"http://zihua.li"},"license":"MIT","dependencies":{"bluebird":"^2.9.34","debug":"^2.2.0","double-ended-queue":"^2.1.0-0","flexbuffer":"0.0.6","lodash":"^3.6.0"},"devDependencies":{"chai":"^2.2.0","codeclimate-test-reporter":"0.0.4","istanbul":"^0.3.13","jsdoc":"^3.3.0-beta3","jsdoc-to-markdown":"^1.0.3","matcha":"^0.6.0","mocha":"^2.2.1","redis":"^2.2.5","server-destroy":"^1.0.0","sinon":"^1.14.1"},"engines":{"node":">= 0.10.16","iojs":">= 1.0.0"},"gitHead":"31f3b0608b96566f64da1e30bbf7e53a03d53938","bugs":{"url":"https://github.com/luin/ioredis/issues"},"homepage":"https://github.com/luin/ioredis#readme","_id":"ioredis@1.13.2","_shasum":"4510396fcf92ac653589e7e355b0cb08dceca972","_from":".","_npmVersion":"2.14.7","_nodeVersion":"4.2.1","_npmUser":{"name":"luin","email":"i@zihua.li"},"dist":{"shasum":"4510396fcf92ac653589e7e355b0cb08dceca972","tarball":"https://registry.npmjs.org/ioredis/-/ioredis-1.13.2.tgz"},"maintainers":[{"name":"luin","email":"i@zihua.li"}],"directories":{}},"1.14.0":{"name":"ioredis","version":"1.14.0","description":"A delightful, performance-focused Redis client for Node and io.js","main":"index.js","scripts":{"test":"NODE_ENV=test DEBUG=ioredis:* mocha","test:cov":"NODE_ENV=test DEBUG=ioredis:* node ./node_modules/istanbul/lib/cli.js cover --preserve-comments ./node_modules/mocha/bin/_mocha -- -R spec","generate-docs":"jsdoc2md lib/redis.js lib/cluster.js lib/commander.js > API.md","build":"node tools/build > commands.js","bench":"matcha benchmarks/*.js"},"repository":{"type":"git","url":"git://github.com/luin/ioredis.git"},"keywords":["redis","cluster","sentinel","pipelining"],"author":{"name":"luin","email":"i@zihua.li","url":"http://zihua.li"},"license":"MIT","dependencies":{"bluebird":"^2.9.34","debug":"^2.2.0","double-ended-queue":"^2.1.0-0","flexbuffer":"0.0.6","lodash":"^3.6.0"},"devDependencies":{"chai":"^2.2.0","codeclimate-test-reporter":"0.0.4","istanbul":"^0.3.13","jsdoc":"^3.3.0-beta3","jsdoc-to-markdown":"^1.0.3","matcha":"^0.6.0","mocha":"^2.2.1","redis":"^2.2.5","server-destroy":"^1.0.0","sinon":"^1.14.1"},"engines":{"node":">= 0.10.16","iojs":">= 1.0.0"},"gitHead":"3cb6956da0c1035281c4a09dbe456622e51355d3","bugs":{"url":"https://github.com/luin/ioredis/issues"},"homepage":"https://github.com/luin/ioredis#readme","_id":"ioredis@1.14.0","_shasum":"d531d62ae5f1abe4eac054312c3e5648130bd248","_from":".","_npmVersion":"2.14.7","_nodeVersion":"4.2.1","_npmUser":{"name":"luin","email":"i@zihua.li"},"dist":{"shasum":"d531d62ae5f1abe4eac054312c3e5648130bd248","tarball":"https://registry.npmjs.org/ioredis/-/ioredis-1.14.0.tgz"},"maintainers":[{"name":"luin","email":"i@zihua.li"}],"directories":{}},"1.15.0":{"name":"ioredis","version":"1.15.0","description":"A delightful, performance-focused Redis client for Node and io.js","main":"index.js","scripts":{"test":"NODE_ENV=test DEBUG=ioredis:* mocha","test:cov":"NODE_ENV=test DEBUG=ioredis:* node ./node_modules/istanbul/lib/cli.js cover --preserve-comments ./node_modules/mocha/bin/_mocha -- -R spec","generate-docs":"jsdoc2md lib/redis.js lib/cluster.js lib/commander.js > API.md","build":"node tools/build > commands.js","bench":"matcha benchmarks/*.js"},"repository":{"type":"git","url":"git://github.com/luin/ioredis.git"},"keywords":["redis","cluster","sentinel","pipelining"],"author":{"name":"luin","email":"i@zihua.li","url":"http://zihua.li"},"license":"MIT","dependencies":{"bluebird":"^2.9.34","debug":"^2.2.0","double-ended-queue":"^2.1.0-0","flexbuffer":"0.0.6","lodash":"^3.6.0"},"devDependencies":{"chai":"^2.2.0","codeclimate-test-reporter":"0.0.4","cz-conventional-changelog":"^1.1.5","istanbul":"^0.3.13","jsdoc":"^3.3.0-beta3","jsdoc-to-markdown":"^1.0.3","matcha":"^0.6.0","mocha":"^2.2.1","redis":"^2.2.5","server-destroy":"^1.0.0","sinon":"^1.14.1"},"engines":{"node":">= 0.10.16","iojs":">= 1.0.0"},"config":{"commitizen":{"path":"./node_modules/cz-conventional-changelog"}},"gitHead":"51e341d697cd7d5bdf1aac969d0533c91dda2f65","bugs":{"url":"https://github.com/luin/ioredis/issues"},"homepage":"https://github.com/luin/ioredis#readme","_id":"ioredis@1.15.0","_shasum":"8084fe5cfd9318d25c941f68341c055de76325f8","_from":".","_npmVersion":"2.14.7","_nodeVersion":"4.2.1","_npmUser":{"name":"luin","email":"i@zihua.li"},"dist":{"shasum":"8084fe5cfd9318d25c941f68341c055de76325f8","tarball":"https://registry.npmjs.org/ioredis/-/ioredis-1.15.0.tgz"},"maintainers":[{"name":"luin","email":"i@zihua.li"}],"directories":{}},"2.0.0-alpha1":{"name":"ioredis","version":"2.0.0-alpha1","description":"A delightful, performance-focused Redis client for Node and io.js","main":"index.js","scripts":{"test":"NODE_ENV=test DEBUG=ioredis:* mocha","test:cov":"NODE_ENV=test DEBUG=ioredis:* node ./node_modules/istanbul/lib/cli.js cover --preserve-comments ./node_modules/mocha/bin/_mocha -- -R spec","generate-docs":"jsdoc2md lib/redis.js lib/cluster/index.js lib/commander.js > API.md","build":"node tools/build > commands.js","bench":"matcha benchmarks/*.js"},"repository":{"type":"git","url":"git://github.com/luin/ioredis.git"},"keywords":["redis","cluster","sentinel","pipelining"],"author":{"name":"luin","email":"i@zihua.li","url":"http://zihua.li"},"license":"MIT","dependencies":{"bluebird":"^3.2.1","debug":"^2.2.0","double-ended-queue":"^2.1.0-0","flexbuffer":"0.0.6","lodash":"^4.2.1","redis-commands":"^1.1.0","redis-parser":"^1.1.0"},"devDependencies":{"chai":"^2.2.0","codeclimate-test-reporter":"0.0.4","cz-conventional-changelog":"^1.1.5","istanbul":"^0.3.13","jsdoc":"^3.3.0-beta3","jsdoc-to-markdown":"^1.0.3","matcha":"^0.6.0","mocha":"^2.2.1","redis":"^2.2.5","server-destroy":"^1.0.0","sinon":"^1.14.1"},"engines":{"node":">= 0.10.16","iojs":">= 1.0.0"},"config":{"commitizen":{"path":"./node_modules/cz-conventional-changelog"}},"gitHead":"4dec37b5c06af83dc09ed9d0b8fb914db500bc70","bugs":{"url":"https://github.com/luin/ioredis/issues"},"homepage":"https://github.com/luin/ioredis#readme","_id":"ioredis@2.0.0-alpha1","_shasum":"322abdb331dbd8be45ee2a43b001922ed5a8aeb2","_from":".","_npmVersion":"2.14.7","_nodeVersion":"4.2.1","_npmUser":{"name":"luin","email":"i@zihua.li"},"dist":{"shasum":"322abdb331dbd8be45ee2a43b001922ed5a8aeb2","tarball":"https://registry.npmjs.org/ioredis/-/ioredis-2.0.0-alpha1.tgz"},"maintainers":[{"name":"luin","email":"i@zihua.li"}],"_npmOperationalInternal":{"host":"packages-6-west.internal.npmjs.com","tmp":"tmp/ioredis-2.0.0-alpha1.tgz_1455089217669_0.09528569714166224"},"directories":{}},"1.15.1":{"name":"ioredis","version":"1.15.1","description":"A delightful, performance-focused Redis client for Node and io.js","main":"index.js","scripts":{"test":"NODE_ENV=test DEBUG=ioredis:* mocha","test:cov":"NODE_ENV=test DEBUG=ioredis:* node ./node_modules/istanbul/lib/cli.js cover --preserve-comments ./node_modules/mocha/bin/_mocha -- -R spec","generate-docs":"jsdoc2md lib/redis.js lib/cluster.js lib/commander.js > API.md","build":"node tools/build > commands.js","bench":"matcha benchmarks/*.js"},"repository":{"type":"git","url":"git://github.com/luin/ioredis.git"},"keywords":["redis","cluster","sentinel","pipelining"],"author":{"name":"luin","email":"i@zihua.li","url":"http://zihua.li"},"license":"MIT","dependencies":{"bluebird":"^2.9.34","debug":"^2.2.0","double-ended-queue":"^2.1.0-0","flexbuffer":"0.0.6","lodash":"^3.6.0"},"devDependencies":{"chai":"^2.2.0","codeclimate-test-reporter":"0.0.4","cz-conventional-changelog":"^1.1.5","istanbul":"^0.3.13","jsdoc":"^3.3.0-beta3","jsdoc-to-markdown":"^1.0.3","matcha":"^0.6.0","mocha":"^2.2.1","redis":"^2.2.5","server-destroy":"^1.0.0","sinon":"^1.14.1"},"engines":{"node":">= 0.10.16","iojs":">= 1.0.0"},"config":{"commitizen":{"path":"./node_modules/cz-conventional-changelog"}},"gitHead":"b6e255021c94ad72ac7c00655e13191c61afa0fb","bugs":{"url":"https://github.com/luin/ioredis/issues"},"homepage":"https://github.com/luin/ioredis#readme","_id":"ioredis@1.15.1","_shasum":"525255cccd557bdd38a0ed3466199f59eb0b9d1c","_from":".","_npmVersion":"2.14.12","_nodeVersion":"4.2.6","_npmUser":{"name":"luin","email":"i@zihua.li"},"dist":{"shasum":"525255cccd557bdd38a0ed3466199f59eb0b9d1c","tarball":"https://registry.npmjs.org/ioredis/-/ioredis-1.15.1.tgz"},"maintainers":[{"name":"luin","email":"i@zihua.li"}],"_npmOperationalInternal":{"host":"packages-9-west.internal.npmjs.com","tmp":"tmp/ioredis-1.15.1.tgz_1455857810930_0.19729826459661126"},"directories":{}},"2.0.0-alpha2":{"name":"ioredis","version":"2.0.0-alpha2","description":"A delightful, performance-focused Redis client for Node and io.js","main":"index.js","scripts":{"test":"NODE_ENV=test DEBUG=ioredis:* mocha","test:cov":"NODE_ENV=test DEBUG=ioredis:* node ./node_modules/istanbul/lib/cli.js cover --preserve-comments ./node_modules/mocha/bin/_mocha -- -R spec","generate-docs":"jsdoc2md lib/redis.js lib/cluster/index.js lib/commander.js > API.md","build":"node tools/build > commands.js","bench":"matcha benchmarks/*.js"},"repository":{"type":"git","url":"git://github.com/luin/ioredis.git"},"keywords":["redis","cluster","sentinel","pipelining"],"author":{"name":"luin","email":"i@zihua.li","url":"http://zihua.li"},"license":"MIT","dependencies":{"bluebird":"^3.2.1","debug":"^2.2.0","double-ended-queue":"^2.1.0-0","flexbuffer":"0.0.6","lodash":"^4.2.1","redis-commands":"^1.1.0","redis-parser":"^1.1.0"},"devDependencies":{"chai":"^2.2.0","codeclimate-test-reporter":"0.0.4","cz-conventional-changelog":"^1.1.5","istanbul":"^0.3.13","jsdoc":"^3.3.0-beta3","jsdoc-to-markdown":"^1.0.3","matcha":"^0.6.0","mocha":"^2.2.1","redis":"^2.2.5","server-destroy":"^1.0.0","sinon":"^1.14.1"},"engines":{"node":">= 0.10.16","iojs":">= 1.0.0"},"config":{"commitizen":{"path":"./node_modules/cz-conventional-changelog"}},"gitHead":"433a2d047cf80830fdefe20a65b8f8856bdf874c","bugs":{"url":"https://github.com/luin/ioredis/issues"},"homepage":"https://github.com/luin/ioredis#readme","_id":"ioredis@2.0.0-alpha2","_shasum":"b2b75272600ba1f60c1593fc561ce15b82761a39","_from":".","_npmVersion":"2.14.12","_nodeVersion":"4.2.6","_npmUser":{"name":"luin","email":"i@zihua.li"},"dist":{"shasum":"b2b75272600ba1f60c1593fc561ce15b82761a39","tarball":"https://registry.npmjs.org/ioredis/-/ioredis-2.0.0-alpha2.tgz"},"maintainers":[{"name":"luin","email":"i@zihua.li"}],"_npmOperationalInternal":{"host":"packages-5-east.internal.npmjs.com","tmp":"tmp/ioredis-2.0.0-alpha2.tgz_1456761686007_0.051741276402026415"},"directories":{}},"2.0.0-alpha3":{"name":"ioredis","version":"2.0.0-alpha3","description":"A delightful, performance-focused Redis client for Node and io.js","main":"index.js","scripts":{"test":"NODE_ENV=test mocha","test:cov":"NODE_ENV=test DEBUG=ioredis:* node ./node_modules/istanbul/lib/cli.js cover --preserve-comments ./node_modules/mocha/bin/_mocha -- -R spec","generate-docs":"jsdoc2md lib/redis.js lib/cluster/index.js lib/commander.js > API.md","build":"node tools/build > commands.js","bench":"matcha benchmarks/*.js"},"repository":{"type":"git","url":"git://github.com/luin/ioredis.git"},"keywords":["redis","cluster","sentinel","pipelining"],"author":{"name":"luin","email":"i@zihua.li","url":"http://zihua.li"},"license":"MIT","dependencies":{"bluebird":"^3.2.1","debug":"^2.2.0","double-ended-queue":"^2.1.0-0","flexbuffer":"0.0.6","lodash":"^4.2.1","redis-commands":"^1.1.0","redis-parser":"^1.1.0"},"devDependencies":{"chai":"^2.2.0","codeclimate-test-reporter":"0.0.4","cz-conventional-changelog":"^1.1.5","istanbul":"^0.3.13","jsdoc":"^3.3.0-beta3","jsdoc-to-markdown":"^1.0.3","matcha":"^0.6.0","mocha":"^2.2.1","redis":"^2.2.5","server-destroy":"^1.0.0","sinon":"^1.14.1"},"engines":{"node":">= 0.10.16","iojs":">= 1.0.0"},"config":{"commitizen":{"path":"./node_modules/cz-conventional-changelog"}},"gitHead":"9c1048779a6cb3145f871f990ca0df449f8b0f46","bugs":{"url":"https://github.com/luin/ioredis/issues"},"homepage":"https://github.com/luin/ioredis#readme","_id":"ioredis@2.0.0-alpha3","_shasum":"1293fe1b3374f0c7dc7d2f92c23d8fbb41348736","_from":".","_npmVersion":"2.14.7","_nodeVersion":"4.2.1","_npmUser":{"name":"luin","email":"i@zihua.li"},"dist":{"shasum":"1293fe1b3374f0c7dc7d2f92c23d8fbb41348736","tarball":"https://registry.npmjs.org/ioredis/-/ioredis-2.0.0-alpha3.tgz"},"maintainers":[{"name":"luin","email":"i@zihua.li"}],"_npmOperationalInternal":{"host":"packages-12-west.internal.npmjs.com","tmp":"tmp/ioredis-2.0.0-alpha3.tgz_1457854075044_0.4012816892936826"},"directories":{}},"2.0.0-rc1":{"name":"ioredis","version":"2.0.0-rc1","description":"A delightful, performance-focused Redis client for Node and io.js","main":"index.js","scripts":{"test":"NODE_ENV=test mocha","test:cov":"NODE_ENV=test DEBUG=ioredis:* node ./node_modules/istanbul/lib/cli.js cover --preserve-comments ./node_modules/mocha/bin/_mocha -- -R spec","generate-docs":"jsdoc2md lib/redis.js lib/cluster/index.js lib/commander.js > API.md","build":"node tools/build > commands.js","bench":"matcha benchmarks/*.js"},"repository":{"type":"git","url":"git://github.com/luin/ioredis.git"},"keywords":["redis","cluster","sentinel","pipelining"],"author":{"name":"luin","email":"i@zihua.li","url":"http://zihua.li"},"license":"MIT","dependencies":{"bluebird":"^3.3.4","debug":"^2.2.0","double-ended-queue":"^2.1.0-0","flexbuffer":"0.0.6","lodash":"^4.6.1","redis-commands":"^1.1.0","redis-parser":"^1.1.0"},"devDependencies":{"chai":"^3.5.0","codeclimate-test-reporter":"0.3.1","cz-conventional-changelog":"^1.1.5","istanbul":"^0.4.2","jsdoc":"^3.4.0","jsdoc-to-markdown":"^1.3.3","matcha":"^0.7.0","mocha":"^2.4.5","redis":"^2.4.2","server-destroy":"^1.0.1","sinon":"^1.17.3"},"engines":{"node":">= 0.10.16","iojs":">= 1.0.0"},"config":{"commitizen":{"path":"./node_modules/cz-conventional-changelog"}},"gitHead":"012ad51d0c4a803f08949e1a1e85f6084ed98369","bugs":{"url":"https://github.com/luin/ioredis/issues"},"homepage":"https://github.com/luin/ioredis#readme","_id":"ioredis@2.0.0-rc1","_shasum":"92b6b60dd33327c1eb396486b723744543cc0071","_from":".","_npmVersion":"2.14.7","_nodeVersion":"4.2.1","_npmUser":{"name":"luin","email":"i@zihua.li"},"dist":{"shasum":"92b6b60dd33327c1eb396486b723744543cc0071","tarball":"https://registry.npmjs.org/ioredis/-/ioredis-2.0.0-rc1.tgz"},"maintainers":[{"name":"luin","email":"i@zihua.li"}],"_npmOperationalInternal":{"host":"packages-12-west.internal.npmjs.com","tmp":"tmp/ioredis-2.0.0-rc1.tgz_1458270222505_0.8214839450083673"},"directories":{}},"2.0.0-rc2":{"name":"ioredis","version":"2.0.0-rc2","description":"A delightful, performance-focused Redis client for Node and io.js","main":"index.js","scripts":{"test":"NODE_ENV=test mocha","test:cov":"NODE_ENV=test node ./node_modules/istanbul/lib/cli.js cover --preserve-comments ./node_modules/mocha/bin/_mocha -- -R spec","generate-docs":"jsdoc2md lib/redis.js lib/cluster/index.js lib/commander.js > API.md","build":"node tools/build > commands.js","bench":"matcha benchmarks/*.js"},"repository":{"type":"git","url":"git://github.com/luin/ioredis.git"},"keywords":["redis","cluster","sentinel","pipelining"],"author":{"name":"luin","email":"i@zihua.li","url":"http://zihua.li"},"license":"MIT","dependencies":{"bluebird":"^3.3.4","debug":"^2.2.0","double-ended-queue":"^2.1.0-0","flexbuffer":"0.0.6","lodash":"^4.8.2","redis-commands":"^1.1.0","redis-parser":"^1.3.0"},"devDependencies":{"chai":"^3.5.0","codeclimate-test-reporter":"0.3.1","cz-conventional-changelog":"^1.1.5","istanbul":"^0.4.2","jsdoc":"^3.4.0","jsdoc-to-markdown":"^1.3.3","matcha":"^0.7.0","mocha":"^2.4.5","redis":"^2.4.2","server-destroy":"^1.0.1","sinon":"^1.17.3"},"engines":{"node":">= 0.10.16","iojs":">= 1.0.0"},"config":{"commitizen":{"path":"./node_modules/cz-conventional-changelog"}},"gitHead":"c5502704ddaa14bfaf5490cbd84eef9997f44818","bugs":{"url":"https://github.com/luin/ioredis/issues"},"homepage":"https://github.com/luin/ioredis#readme","_id":"ioredis@2.0.0-rc2","_shasum":"b4ab826449c5801b77207a610f616f79d679809e","_from":".","_npmVersion":"2.14.2","_nodeVersion":"4.0.0","_npmUser":{"name":"luin","email":"i@zihua.li"},"dist":{"shasum":"b4ab826449c5801b77207a610f616f79d679809e","tarball":"https://registry.npmjs.org/ioredis/-/ioredis-2.0.0-rc2.tgz"},"maintainers":[{"name":"luin","email":"i@zihua.li"}],"_npmOperationalInternal":{"host":"packages-12-west.internal.npmjs.com","tmp":"tmp/ioredis-2.0.0-rc2.tgz_1460303728730_0.2904816495720297"},"directories":{}},"2.0.0-rc3":{"name":"ioredis","version":"2.0.0-rc3","description":"A delightful, performance-focused Redis client for Node and io.js","main":"index.js","scripts":{"test":"NODE_ENV=test mocha","test:cov":"NODE_ENV=test node ./node_modules/istanbul/lib/cli.js cover --preserve-comments ./node_modules/mocha/bin/_mocha -- -R spec","generate-docs":"jsdoc2md lib/redis.js lib/cluster/index.js lib/commander.js > API.md","bench":"matcha benchmarks/*.js"},"repository":{"type":"git","url":"git://github.com/luin/ioredis.git"},"keywords":["redis","cluster","sentinel","pipelining"],"author":{"name":"luin","email":"i@zihua.li","url":"http://zihua.li"},"license":"MIT","dependencies":{"bluebird":"^3.3.4","debug":"^2.2.0","double-ended-queue":"^2.1.0-0","flexbuffer":"0.0.6","lodash":"^4.8.2","redis-commands":"^1.2.0","redis-parser":"^1.3.0"},"devDependencies":{"chai":"^3.5.0","codeclimate-test-reporter":"0.3.1","cz-conventional-changelog":"^1.1.5","istanbul":"^0.4.2","jsdoc":"^3.4.0","jsdoc-to-markdown":"^1.3.3","matcha":"^0.7.0","mocha":"^2.4.5","redis":"^2.4.2","server-destroy":"^1.0.1","sinon":"^1.17.3"},"engines":{"node":">= 0.10.16","iojs":">= 1.0.0"},"config":{"commitizen":{"path":"./node_modules/cz-conventional-changelog"}},"gitHead":"bffd4b90ecb401e21200a03dfa069558fd817b0b","bugs":{"url":"https://github.com/luin/ioredis/issues"},"homepage":"https://github.com/luin/ioredis#readme","_id":"ioredis@2.0.0-rc3","_shasum":"0f7e902b739aa7681508b956862780eeb8dee471","_from":".","_npmVersion":"2.14.2","_nodeVersion":"4.0.0","_npmUser":{"name":"luin","email":"i@zihua.li"},"dist":{"shasum":"0f7e902b739aa7681508b956862780eeb8dee471","tarball":"https://registry.npmjs.org/ioredis/-/ioredis-2.0.0-rc3.tgz"},"maintainers":[{"name":"luin","email":"i@zihua.li"}],"_npmOperationalInternal":{"host":"packages-12-west.internal.npmjs.com","tmp":"tmp/ioredis-2.0.0-rc3.tgz_1462201894983_0.06999879679642618"},"directories":{}},"2.0.0-rc4":{"name":"ioredis","version":"2.0.0-rc4","description":"A delightful, performance-focused Redis client for Node and io.js","main":"index.js","scripts":{"test":"NODE_ENV=test mocha","test:cov":"NODE_ENV=test node ./node_modules/istanbul/lib/cli.js cover --preserve-comments ./node_modules/mocha/bin/_mocha -- -R spec","generate-docs":"jsdoc2md lib/redis.js lib/cluster/index.js lib/commander.js > API.md","bench":"matcha benchmarks/*.js"},"repository":{"type":"git","url":"git://github.com/luin/ioredis.git"},"keywords":["redis","cluster","sentinel","pipelining"],"author":{"name":"luin","email":"i@zihua.li","url":"http://zihua.li"},"license":"MIT","dependencies":{"bluebird":"^3.3.4","debug":"^2.2.0","double-ended-queue":"^2.1.0-0","flexbuffer":"0.0.6","lodash":"^4.8.2","redis-commands":"^1.2.0","redis-parser":"^1.3.0"},"devDependencies":{"chai":"^3.5.0","codeclimate-test-reporter":"0.3.1","cz-conventional-changelog":"^1.1.5","istanbul":"^0.4.2","jsdoc":"^3.4.0","jsdoc-to-markdown":"^1.3.3","matcha":"^0.7.0","mocha":"^2.4.5","redis":"^2.4.2","server-destroy":"^1.0.1","sinon":"^1.17.3"},"engines":{"node":">= 0.10.16","iojs":">= 1.0.0"},"config":{"commitizen":{"path":"./node_modules/cz-conventional-changelog"}},"gitHead":"eb21cf2c3db10b926f608dfe405bff41e6c258fe","bugs":{"url":"https://github.com/luin/ioredis/issues"},"homepage":"https://github.com/luin/ioredis#readme","_id":"ioredis@2.0.0-rc4","_shasum":"65325508c975eae1372584c4c6a959da44d5c309","_from":".","_npmVersion":"3.8.6","_nodeVersion":"6.1.0","_npmUser":{"name":"luin","email":"i@zihua.li"},"dist":{"shasum":"65325508c975eae1372584c4c6a959da44d5c309","tarball":"https://registry.npmjs.org/ioredis/-/ioredis-2.0.0-rc4.tgz"},"maintainers":[{"name":"luin","email":"i@zihua.li"}],"_npmOperationalInternal":{"host":"packages-16-east.internal.npmjs.com","tmp":"tmp/ioredis-2.0.0-rc4.tgz_1462727033230_0.2577476785518229"},"directories":{}},"2.0.0":{"name":"ioredis","version":"2.0.0","description":"A delightful, performance-focused Redis client for Node and io.js","main":"index.js","scripts":{"test":"NODE_ENV=test mocha","test:cov":"NODE_ENV=test node ./node_modules/istanbul/lib/cli.js cover --preserve-comments ./node_modules/mocha/bin/_mocha -- -R spec","generate-docs":"jsdoc2md lib/redis.js lib/cluster/index.js lib/commander.js > API.md","bench":"matcha benchmarks/*.js"},"repository":{"type":"git","url":"git://github.com/luin/ioredis.git"},"keywords":["redis","cluster","sentinel","pipelining"],"author":{"name":"luin","email":"i@zihua.li","url":"http://zihua.li"},"license":"MIT","dependencies":{"bluebird":"^3.3.4","debug":"^2.2.0","double-ended-queue":"^2.1.0-0","flexbuffer":"0.0.6","lodash":"^4.8.2","redis-commands":"^1.2.0","redis-parser":"^1.3.0"},"devDependencies":{"chai":"^3.5.0","codeclimate-test-reporter":"0.3.1","cz-conventional-changelog":"^1.1.5","istanbul":"^0.4.2","jsdoc":"^3.4.0","jsdoc-to-markdown":"^1.3.3","matcha":"^0.7.0","mocha":"^2.4.5","redis":"^2.4.2","server-destroy":"^1.0.1","sinon":"^1.17.3"},"engines":{"node":">= 0.10.16","iojs":">= 1.0.0"},"config":{"commitizen":{"path":"./node_modules/cz-conventional-changelog"}},"gitHead":"c941362506efe04b3768ce66e93641a1691efd9f","bugs":{"url":"https://github.com/luin/ioredis/issues"},"homepage":"https://github.com/luin/ioredis#readme","_id":"ioredis@2.0.0","_shasum":"42d647af6f2b81feac12176c2938b9666781871a","_from":".","_npmVersion":"2.15.5","_nodeVersion":"4.4.5","_npmUser":{"name":"luin","email":"i@zihua.li"},"dist":{"shasum":"42d647af6f2b81feac12176c2938b9666781871a","tarball":"https://registry.npmjs.org/ioredis/-/ioredis-2.0.0.tgz"},"maintainers":[{"name":"luin","email":"i@zihua.li"}],"_npmOperationalInternal":{"host":"packages-16-east.internal.npmjs.com","tmp":"tmp/ioredis-2.0.0.tgz_1464519194218_0.5099528774153441"},"directories":{}},"2.0.1":{"name":"ioredis","version":"2.0.1","description":"A delightful, performance-focused Redis client for Node and io.js","main":"index.js","scripts":{"test":"NODE_ENV=test mocha","test:cov":"NODE_ENV=test node ./node_modules/istanbul/lib/cli.js cover --preserve-comments ./node_modules/mocha/bin/_mocha -- -R spec","generate-docs":"jsdoc2md lib/redis.js lib/cluster/index.js lib/commander.js > API.md","bench":"matcha benchmarks/*.js"},"repository":{"type":"git","url":"git://github.com/luin/ioredis.git"},"keywords":["redis","cluster","sentinel","pipelining"],"author":{"name":"luin","email":"i@zihua.li","url":"http://zihua.li"},"license":"MIT","dependencies":{"bluebird":"^3.3.4","debug":"^2.2.0","double-ended-queue":"^2.1.0-0","flexbuffer":"0.0.6","lodash":"^4.8.2","redis-commands":"^1.2.0","redis-parser":"^1.3.0"},"devDependencies":{"chai":"^3.5.0","codeclimate-test-reporter":"0.3.1","cz-conventional-changelog":"^1.1.5","istanbul":"^0.4.2","jsdoc":"^3.4.0","jsdoc-to-markdown":"^1.3.3","matcha":"^0.7.0","mocha":"^2.4.5","redis":"^2.4.2","server-destroy":"^1.0.1","sinon":"^1.17.3"},"engines":{"node":">= 0.10.16","iojs":">= 1.0.0"},"config":{"commitizen":{"path":"./node_modules/cz-conventional-changelog"}},"gitHead":"a5b72d37c9fa22d2b618fdce61743e58a603456a","bugs":{"url":"https://github.com/luin/ioredis/issues"},"homepage":"https://github.com/luin/ioredis#readme","_id":"ioredis@2.0.1","_shasum":"3451acc89925e287bc009102b732d7ec8e9f491a","_from":".","_npmVersion":"2.15.5","_nodeVersion":"4.4.5","_npmUser":{"name":"luin","email":"i@zihua.li"},"dist":{"shasum":"3451acc89925e287bc009102b732d7ec8e9f491a","tarball":"https://registry.npmjs.org/ioredis/-/ioredis-2.0.1.tgz"},"maintainers":[{"name":"luin","email":"i@zihua.li"}],"_npmOperationalInternal":{"host":"packages-16-east.internal.npmjs.com","tmp":"tmp/ioredis-2.0.1.tgz_1464743696894_0.21593199903145432"},"directories":{}},"2.1.0":{"name":"ioredis","version":"2.1.0","description":"A delightful, performance-focused Redis client for Node and io.js","main":"index.js","scripts":{"test":"NODE_ENV=test mocha","test:cov":"NODE_ENV=test node ./node_modules/istanbul/lib/cli.js cover --preserve-comments ./node_modules/mocha/bin/_mocha -- -R spec","generate-docs":"jsdoc2md lib/redis.js lib/cluster/index.js lib/commander.js > API.md","bench":"matcha benchmarks/*.js"},"repository":{"type":"git","url":"git://github.com/luin/ioredis.git"},"keywords":["redis","cluster","sentinel","pipelining"],"author":{"name":"luin","email":"i@zihua.li","url":"http://zihua.li"},"license":"MIT","dependencies":{"bluebird":"^3.3.4","cluster-key-slot":"^1.0.5","debug":"^2.2.0","double-ended-queue":"^2.1.0-0","flexbuffer":"0.0.6","lodash":"^4.8.2","redis-commands":"^1.2.0","redis-parser":"^1.3.0"},"devDependencies":{"chai":"^3.5.0","codeclimate-test-reporter":"0.3.1","cz-conventional-changelog":"^1.1.5","istanbul":"^0.4.2","jsdoc":"^3.4.0","jsdoc-to-markdown":"^1.3.3","matcha":"^0.7.0","mocha":"^2.4.5","redis":"^2.4.2","server-destroy":"^1.0.1","sinon":"^1.17.3"},"engines":{"node":">= 0.10.16","iojs":">= 1.0.0"},"config":{"commitizen":{"path":"./node_modules/cz-conventional-changelog"}},"gitHead":"472626c65497d2d9f1ac5a54c78291eeaa81170b","bugs":{"url":"https://github.com/luin/ioredis/issues"},"homepage":"https://github.com/luin/ioredis#readme","_id":"ioredis@2.1.0","_shasum":"e3daed67f307096e1e31004ed85526d27f11a332","_from":".","_npmVersion":"2.15.5","_nodeVersion":"4.4.5","_npmUser":{"name":"luin","email":"i@zihua.li"},"dist":{"shasum":"e3daed67f307096e1e31004ed85526d27f11a332","tarball":"https://registry.npmjs.org/ioredis/-/ioredis-2.1.0.tgz"},"maintainers":[{"name":"luin","email":"i@zihua.li"}],"_npmOperationalInternal":{"host":"packages-16-east.internal.npmjs.com","tmp":"tmp/ioredis-2.1.0.tgz_1466568350420_0.39180931611917913"},"directories":{}},"2.2.0":{"name":"ioredis","version":"2.2.0","description":"A delightful, performance-focused Redis client for Node and io.js","main":"index.js","scripts":{"test":"NODE_ENV=test mocha","test:cov":"NODE_ENV=test node ./node_modules/istanbul/lib/cli.js cover --preserve-comments ./node_modules/mocha/bin/_mocha -- -R spec","generate-docs":"jsdoc2md lib/redis.js lib/cluster/index.js lib/commander.js > API.md","bench":"matcha benchmarks/*.js"},"repository":{"type":"git","url":"git://github.com/luin/ioredis.git"},"keywords":["redis","cluster","sentinel","pipelining"],"author":{"name":"luin","email":"i@zihua.li","url":"http://zihua.li"},"license":"MIT","dependencies":{"bluebird":"^3.3.4","cluster-key-slot":"^1.0.6","debug":"^2.2.0","double-ended-queue":"^2.1.0-0","flexbuffer":"0.0.6","lodash":"^4.8.2","redis-commands":"^1.2.0","redis-parser":"^1.3.0"},"devDependencies":{"chai":"^3.5.0","codeclimate-test-reporter":"0.3.1","cz-conventional-changelog":"^1.1.5","istanbul":"^0.4.2","jsdoc":"^3.4.0","jsdoc-to-markdown":"^1.3.3","matcha":"^0.7.0","mocha":"^2.4.5","redis":"^2.4.2","server-destroy":"^1.0.1","sinon":"^1.17.3"},"engines":{"node":">= 0.10.16","iojs":">= 1.0.0"},"config":{"commitizen":{"path":"./node_modules/cz-conventional-changelog"}},"gitHead":"b969c1eb3d53742314bfbf328cdba09a353fbb1f","bugs":{"url":"https://github.com/luin/ioredis/issues"},"homepage":"https://github.com/luin/ioredis#readme","_id":"ioredis@2.2.0","_shasum":"7b3db7346bc4d165a5ed7ed18c7a754e2dacf0c8","_from":".","_npmVersion":"2.14.12","_nodeVersion":"4.2.6","_npmUser":{"name":"luin","email":"i@zihua.li"},"dist":{"shasum":"7b3db7346bc4d165a5ed7ed18c7a754e2dacf0c8","tarball":"https://registry.npmjs.org/ioredis/-/ioredis-2.2.0.tgz"},"maintainers":[{"name":"luin","email":"i@zihua.li"}],"_npmOperationalInternal":{"host":"packages-12-west.internal.npmjs.com","tmp":"tmp/ioredis-2.2.0.tgz_1467124968126_0.03901334339752793"},"directories":{}},"2.3.0":{"name":"ioredis","version":"2.3.0","description":"A delightful, performance-focused Redis client for Node and io.js","main":"index.js","scripts":{"test":"NODE_ENV=test mocha","test:cov":"NODE_ENV=test node ./node_modules/istanbul/lib/cli.js cover --preserve-comments ./node_modules/mocha/bin/_mocha -- -R spec","generate-docs":"jsdoc2md lib/redis.js lib/cluster/index.js lib/commander.js > API.md","bench":"matcha benchmarks/*.js"},"repository":{"type":"git","url":"git://github.com/luin/ioredis.git"},"keywords":["redis","cluster","sentinel","pipelining"],"author":{"name":"luin","email":"i@zihua.li","url":"http://zihua.li"},"license":"MIT","dependencies":{"bluebird":"^3.3.4","cluster-key-slot":"^1.0.6","debug":"^2.2.0","double-ended-queue":"^2.1.0-0","flexbuffer":"0.0.6","lodash":"^4.8.2","redis-commands":"^1.2.0","redis-parser":"^1.3.0"},"devDependencies":{"chai":"^3.5.0","codeclimate-test-reporter":"0.3.1","cz-conventional-changelog":"^1.1.5","istanbul":"^0.4.2","jsdoc":"^3.4.0","jsdoc-to-markdown":"^1.3.3","matcha":"^0.7.0","mocha":"^2.4.5","redis":"^2.4.2","server-destroy":"^1.0.1","sinon":"^1.17.3"},"engines":{"node":">= 0.10.16","iojs":">= 1.0.0"},"config":{"commitizen":{"path":"./node_modules/cz-conventional-changelog"}},"gitHead":"b216e4eb61d05ff639b162f23751acb111dde6e8","bugs":{"url":"https://github.com/luin/ioredis/issues"},"homepage":"https://github.com/luin/ioredis#readme","_id":"ioredis@2.3.0","_shasum":"5a365d32832cb4b20605c7b66aeb1c0a6576149b","_from":".","_npmVersion":"2.15.5","_nodeVersion":"4.4.5","_npmUser":{"name":"luin","email":"i@zihua.li"},"dist":{"shasum":"5a365d32832cb4b20605c7b66aeb1c0a6576149b","tarball":"https://registry.npmjs.org/ioredis/-/ioredis-2.3.0.tgz"},"maintainers":[{"name":"luin","email":"i@zihua.li"}],"_npmOperationalInternal":{"host":"packages-12-west.internal.npmjs.com","tmp":"tmp/ioredis-2.3.0.tgz_1470928059050_0.5332338178995997"},"directories":{}},"2.3.1":{"name":"ioredis","version":"2.3.1","description":"A delightful, performance-focused Redis client for Node and io.js","main":"index.js","scripts":{"test":"NODE_ENV=test mocha","test:cov":"NODE_ENV=test node ./node_modules/istanbul/lib/cli.js cover --preserve-comments ./node_modules/mocha/bin/_mocha -- -R spec","generate-docs":"jsdoc2md lib/redis.js lib/cluster/index.js lib/commander.js > API.md","bench":"matcha benchmarks/*.js"},"repository":{"type":"git","url":"git://github.com/luin/ioredis.git"},"keywords":["redis","cluster","sentinel","pipelining"],"author":{"name":"luin","email":"i@zihua.li","url":"http://zihua.li"},"license":"MIT","dependencies":{"bluebird":"^3.3.4","cluster-key-slot":"^1.0.6","debug":"^2.2.0","double-ended-queue":"^2.1.0-0","flexbuffer":"0.0.6","lodash":"^4.8.2","redis-commands":"^1.2.0","redis-parser":"^1.3.0"},"devDependencies":{"chai":"^3.5.0","codeclimate-test-reporter":"0.3.1","cz-conventional-changelog":"^1.1.5","istanbul":"^0.4.2","jsdoc":"^3.4.0","jsdoc-to-markdown":"^1.3.3","matcha":"^0.7.0","mocha":"^2.4.5","redis":"^2.4.2","server-destroy":"^1.0.1","sinon":"^1.17.3"},"engines":{"node":">= 0.10.16","iojs":">= 1.0.0"},"config":{"commitizen":{"path":"./node_modules/cz-conventional-changelog"}},"gitHead":"8718567aec40ee948933ef8ed2f957723902c353","bugs":{"url":"https://github.com/luin/ioredis/issues"},"homepage":"https://github.com/luin/ioredis#readme","_id":"ioredis@2.3.1","_shasum":"67e8196799b6000420608e53673bf5511ccbd568","_from":".","_npmVersion":"2.15.5","_nodeVersion":"4.4.5","_npmUser":{"name":"luin","email":"i@zihua.li"},"dist":{"shasum":"67e8196799b6000420608e53673bf5511ccbd568","tarball":"https://registry.npmjs.org/ioredis/-/ioredis-2.3.1.tgz"},"maintainers":[{"name":"luin","email":"i@zihua.li"}],"_npmOperationalInternal":{"host":"packages-16-east.internal.npmjs.com","tmp":"tmp/ioredis-2.3.1.tgz_1474734852676_0.18043272430077195"},"directories":{}},"2.4.0":{"name":"ioredis","version":"2.4.0","description":"A delightful, performance-focused Redis client for Node and io.js","main":"index.js","scripts":{"test":"NODE_ENV=test mocha","test:cov":"NODE_ENV=test node ./node_modules/istanbul/lib/cli.js cover --preserve-comments ./node_modules/mocha/bin/_mocha -- -R spec","generate-docs":"jsdoc2md lib/redis.js lib/cluster/index.js lib/commander.js > API.md","bench":"matcha benchmarks/*.js"},"repository":{"type":"git","url":"git://github.com/luin/ioredis.git"},"keywords":["redis","cluster","sentinel","pipelining"],"author":{"name":"luin","email":"i@zihua.li","url":"http://zihua.li"},"license":"MIT","dependencies":{"bluebird":"^3.3.4","cluster-key-slot":"^1.0.6","debug":"^2.2.0","double-ended-queue":"^2.1.0-0","flexbuffer":"0.0.6","lodash":"^4.8.2","redis-commands":"^1.2.0","redis-parser":"^1.3.0"},"devDependencies":{"chai":"^3.5.0","codeclimate-test-reporter":"0.3.1","cz-conventional-changelog":"^1.1.5","istanbul":"^0.4.2","jsdoc":"^3.4.0","jsdoc-to-markdown":"^1.3.3","matcha":"^0.7.0","mocha":"^2.4.5","redis":"^2.4.2","server-destroy":"^1.0.1","sinon":"^1.17.3"},"engines":{"node":">= 0.10.16","iojs":">= 1.0.0"},"config":{"commitizen":{"path":"./node_modules/cz-conventional-changelog"}},"gitHead":"5f740758593bb0e2342d25c1f84e43418d6cb868","bugs":{"url":"https://github.com/luin/ioredis/issues"},"homepage":"https://github.com/luin/ioredis#readme","_id":"ioredis@2.4.0","_shasum":"963f7bfbc86e5c40ea586857e14ebfb548142a88","_from":".","_npmVersion":"2.15.5","_nodeVersion":"4.4.5","_npmUser":{"name":"luin","email":"i@zihua.li"},"dist":{"shasum":"963f7bfbc86e5c40ea586857e14ebfb548142a88","tarball":"https://registry.npmjs.org/ioredis/-/ioredis-2.4.0.tgz"},"maintainers":[{"name":"luin","email":"i@zihua.li"}],"_npmOperationalInternal":{"host":"packages-12-west.internal.npmjs.com","tmp":"tmp/ioredis-2.4.0.tgz_1474739985114_0.7134720231406391"},"directories":{}},"2.4.1":{"name":"ioredis","version":"2.4.1","description":"A delightful, performance-focused Redis client for Node and io.js","main":"index.js","files":["index.js","lib/"],"scripts":{"test":"NODE_ENV=test mocha","test:cov":"NODE_ENV=test node ./node_modules/istanbul/lib/cli.js cover --preserve-comments ./node_modules/mocha/bin/_mocha -- -R spec","generate-docs":"jsdoc2md lib/redis.js lib/cluster/index.js lib/commander.js > API.md","bench":"matcha benchmarks/*.js"},"repository":{"type":"git","url":"git://github.com/luin/ioredis.git"},"keywords":["redis","cluster","sentinel","pipelining"],"author":{"name":"luin","email":"i@zihua.li","url":"http://zihua.li"},"license":"MIT","dependencies":{"bluebird":"^3.3.4","cluster-key-slot":"^1.0.6","debug":"^2.2.0","double-ended-queue":"^2.1.0-0","flexbuffer":"0.0.6","lodash":"^4.8.2","redis-commands":"^1.2.0","redis-parser":"^1.3.0"},"devDependencies":{"chai":"^3.5.0","codeclimate-test-reporter":"0.3.1","cz-conventional-changelog":"^1.1.5","istanbul":"^0.4.2","jsdoc":"^3.4.0","jsdoc-to-markdown":"^1.3.3","matcha":"^0.7.0","mocha":"^2.4.5","redis":"^2.4.2","server-destroy":"^1.0.1","sinon":"^1.17.3"},"engines":{"node":">= 0.10.16","iojs":">= 1.0.0"},"config":{"commitizen":{"path":"./node_modules/cz-conventional-changelog"}},"gitHead":"bbab295f17bd00175dc6b44f903c876bb75c5918","bugs":{"url":"https://github.com/luin/ioredis/issues"},"homepage":"https://github.com/luin/ioredis#readme","_id":"ioredis@2.4.1","_shasum":"8311d5f5dd534acd835c51253bdc8a0d01d1e7c4","_from":".","_npmVersion":"2.14.12","_nodeVersion":"4.2.6","_npmUser":{"name":"luin","email":"i@zihua.li"},"dist":{"shasum":"8311d5f5dd534acd835c51253bdc8a0d01d1e7c4","tarball":"https://registry.npmjs.org/ioredis/-/ioredis-2.4.1.tgz"},"maintainers":[{"name":"luin","email":"i@zihua.li"}],"_npmOperationalInternal":{"host":"packages-12-west.internal.npmjs.com","tmp":"tmp/ioredis-2.4.1.tgz_1480814512673_0.9596550418063998"},"directories":{}},"2.4.2":{"name":"ioredis","version":"2.4.2","description":"A delightful, performance-focused Redis client for Node and io.js","main":"index.js","files":["index.js","lib/"],"scripts":{"test":"NODE_ENV=test mocha","test:cov":"NODE_ENV=test node ./node_modules/istanbul/lib/cli.js cover --preserve-comments ./node_modules/mocha/bin/_mocha -- -R spec","generate-docs":"jsdoc2md lib/redis.js lib/cluster/index.js lib/commander.js > API.md","bench":"matcha benchmarks/*.js"},"repository":{"type":"git","url":"git://github.com/luin/ioredis.git"},"keywords":["redis","cluster","sentinel","pipelining"],"author":{"name":"luin","email":"i@zihua.li","url":"http://zihua.li"},"license":"MIT","dependencies":{"bluebird":"^3.3.4","cluster-key-slot":"^1.0.6","debug":"^2.2.0","double-ended-queue":"^2.1.0-0","flexbuffer":"0.0.6","lodash":"^4.8.2","redis-commands":"^1.2.0","redis-parser":"^1.3.0"},"devDependencies":{"chai":"^3.5.0","codeclimate-test-reporter":"0.3.1","cz-conventional-changelog":"^1.1.5","istanbul":"^0.4.2","jsdoc":"^3.4.0","jsdoc-to-markdown":"^1.3.3","matcha":"^0.7.0","mocha":"^2.4.5","redis":"^2.4.2","server-destroy":"^1.0.1","sinon":"^1.17.3"},"engines":{"node":">= 0.10.16","iojs":">= 1.0.0"},"config":{"commitizen":{"path":"./node_modules/cz-conventional-changelog"}},"gitHead":"0b50a562ecd988d418cb6172fcd6b30e496374f1","bugs":{"url":"https://github.com/luin/ioredis/issues"},"homepage":"https://github.com/luin/ioredis#readme","_id":"ioredis@2.4.2","_shasum":"3f0e0c7199ddd9c7e8962a51febbe28decf5c761","_from":".","_npmVersion":"2.14.12","_nodeVersion":"4.2.6","_npmUser":{"name":"luin","email":"i@zihua.li"},"dist":{"shasum":"3f0e0c7199ddd9c7e8962a51febbe28decf5c761","tarball":"https://registry.npmjs.org/ioredis/-/ioredis-2.4.2.tgz"},"maintainers":[{"name":"luin","email":"i@zihua.li"}],"_npmOperationalInternal":{"host":"packages-12-west.internal.npmjs.com","tmp":"tmp/ioredis-2.4.2.tgz_1480824337057_0.29521067230962217"},"directories":{}},"2.4.3":{"name":"ioredis","version":"2.4.3","description":"A delightful, performance-focused Redis client for Node and io.js","main":"index.js","files":["index.js","lib/"],"scripts":{"test":"NODE_ENV=test mocha","test:cov":"NODE_ENV=test node ./node_modules/istanbul/lib/cli.js cover --preserve-comments ./node_modules/mocha/bin/_mocha -- -R spec","generate-docs":"jsdoc2md lib/redis.js lib/cluster/index.js lib/commander.js > API.md","bench":"matcha benchmarks/*.js"},"repository":{"type":"git","url":"git://github.com/luin/ioredis.git"},"keywords":["redis","cluster","sentinel","pipelining"],"author":{"name":"luin","email":"i@zihua.li","url":"http://zihua.li"},"license":"MIT","dependencies":{"bluebird":"^3.3.4","cluster-key-slot":"^1.0.6","debug":"^2.2.0","double-ended-queue":"^2.1.0-0","flexbuffer":"0.0.6","lodash":"^4.8.2","redis-commands":"^1.2.0","redis-parser":"^1.3.0"},"devDependencies":{"chai":"^3.5.0","codeclimate-test-reporter":"0.3.1","cz-conventional-changelog":"^1.1.5","istanbul":"^0.4.2","jsdoc":"^3.4.0","jsdoc-to-markdown":"^1.3.3","matcha":"^0.7.0","mocha":"^2.4.5","redis":"^2.4.2","server-destroy":"^1.0.1","sinon":"^1.17.3"},"engines":{"node":">= 0.10.16","iojs":">= 1.0.0"},"config":{"commitizen":{"path":"./node_modules/cz-conventional-changelog"}},"gitHead":"f526ae1384889f6befad6d5f5cf12ec5f063f109","bugs":{"url":"https://github.com/luin/ioredis/issues"},"homepage":"https://github.com/luin/ioredis#readme","_id":"ioredis@2.4.3","_shasum":"a0f0aedf0b14825bc5b17efbffa2591b90528be4","_from":".","_npmVersion":"2.14.12","_nodeVersion":"4.2.6","_npmUser":{"name":"luin","email":"i@zihua.li"},"dist":{"shasum":"a0f0aedf0b14825bc5b17efbffa2591b90528be4","tarball":"https://registry.npmjs.org/ioredis/-/ioredis-2.4.3.tgz"},"maintainers":[{"name":"luin","email":"i@zihua.li"}],"_npmOperationalInternal":{"host":"packages-18-east.internal.npmjs.com","tmp":"tmp/ioredis-2.4.3.tgz_1481819589379_0.22508284426294267"},"directories":{}},"2.5.0":{"name":"ioredis","version":"2.5.0","description":"A delightful, performance-focused Redis client for Node and io.js","main":"index.js","files":["index.js","lib/"],"scripts":{"test":"NODE_ENV=test mocha","test:cov":"NODE_ENV=test node ./node_modules/istanbul/lib/cli.js cover --preserve-comments ./node_modules/mocha/bin/_mocha -- -R spec","generate-docs":"jsdoc2md lib/redis.js lib/cluster/index.js lib/commander.js > API.md","bench":"matcha benchmarks/*.js"},"repository":{"type":"git","url":"git://github.com/luin/ioredis.git"},"keywords":["redis","cluster","sentinel","pipelining"],"author":{"name":"luin","email":"i@zihua.li","url":"http://zihua.li"},"license":"MIT","dependencies":{"bluebird":"^3.3.4","cluster-key-slot":"^1.0.6","debug":"^2.2.0","double-ended-queue":"^2.1.0-0","flexbuffer":"0.0.6","lodash":"^4.8.2","redis-commands":"^1.2.0","redis-parser":"^1.3.0"},"devDependencies":{"chai":"^3.5.0","codeclimate-test-reporter":"0.3.1","cz-conventional-changelog":"^1.1.5","istanbul":"^0.4.2","jsdoc":"^3.4.0","jsdoc-to-markdown":"^1.3.3","matcha":"^0.7.0","mocha":"^2.4.5","redis":"^2.4.2","server-destroy":"^1.0.1","sinon":"^1.17.3"},"engines":{"node":">= 0.10.16","iojs":">= 1.0.0"},"config":{"commitizen":{"path":"./node_modules/cz-conventional-changelog"}},"gitHead":"865219c7776cc8378dd51ab1c1cf89a0db3f7496","bugs":{"url":"https://github.com/luin/ioredis/issues"},"homepage":"https://github.com/luin/ioredis#readme","_id":"ioredis@2.5.0","_shasum":"fb6fdf0a1a7e0974614c67b6e5e11308a8cf95b9","_from":".","_npmVersion":"2.14.12","_nodeVersion":"4.2.6","_npmUser":{"name":"luin","email":"i@zihua.li"},"dist":{"shasum":"fb6fdf0a1a7e0974614c67b6e5e11308a8cf95b9","tarball":"https://registry.npmjs.org/ioredis/-/ioredis-2.5.0.tgz"},"maintainers":[{"name":"luin","email":"i@zihua.li"}],"_npmOperationalInternal":{"host":"packages-18-east.internal.npmjs.com","tmp":"tmp/ioredis-2.5.0.tgz_1483670671313_0.47516395919956267"},"directories":{}},"3.0.0-0":{"name":"ioredis","version":"3.0.0-0","description":"A delightful, performance-focused Redis client for Node and io.js","main":"index.js","files":["index.js","lib/"],"scripts":{"test":"NODE_ENV=test mocha","test:cov":"NODE_ENV=test node ./node_modules/istanbul/lib/cli.js cover --preserve-comments ./node_modules/mocha/bin/_mocha -- -R spec","generate-docs":"jsdoc2md lib/redis.js lib/cluster/index.js lib/commander.js > API.md","bench":"matcha benchmarks/*.js"},"repository":{"type":"git","url":"git://github.com/luin/ioredis.git"},"keywords":["redis","cluster","sentinel","pipelining"],"author":{"name":"luin","email":"i@zihua.li","url":"http://zihua.li"},"license":"MIT","dependencies":{"bluebird":"^3.3.4","cluster-key-slot":"^1.0.6","debug":"^2.2.0","denque":"^1.1.0","flexbuffer":"0.0.6","lodash":"^4.8.2","redis-commands":"^1.2.0","redis-parser":"^2.4.0"},"devDependencies":{"chai":"^3.5.0","codeclimate-test-reporter":"0.4.0","cz-conventional-changelog":"^1.1.5","istanbul":"^0.4.2","jsdoc":"^3.4.0","jsdoc-to-markdown":"^2.0.0","matcha":"^0.7.0","mocha":"^3.1.1","redis":"^2.4.2","server-destroy":"^1.0.1","sinon":"^1.17.3"},"engines":{"node":">= 0.10.16","iojs":">= 1.0.0"},"config":{"commitizen":{"path":"./node_modules/cz-conventional-changelog"}},"gitHead":"245e139899f9fb00ce5aec12c188f7ec7f592874","bugs":{"url":"https://github.com/luin/ioredis/issues"},"homepage":"https://github.com/luin/ioredis#readme","_id":"ioredis@3.0.0-0","_shasum":"edea4b6fadb37f91665160dda8d51a1d248bd3d7","_from":".","_npmVersion":"2.15.5","_nodeVersion":"4.4.5","_npmUser":{"name":"luin","email":"i@zihua.li"},"dist":{"shasum":"edea4b6fadb37f91665160dda8d51a1d248bd3d7","tarball":"https://registry.npmjs.org/ioredis/-/ioredis-3.0.0-0.tgz"},"maintainers":[{"name":"luin","email":"i@zihua.li"}],"_npmOperationalInternal":{"host":"packages-18-east.internal.npmjs.com","tmp":"tmp/ioredis-3.0.0-0.tgz_1485408295133_0.2973112310282886"},"directories":{}},"3.0.0-1":{"name":"ioredis","version":"3.0.0-1","description":"A delightful, performance-focused Redis client for Node and io.js","main":"index.js","files":["index.js","lib/"],"scripts":{"test":"NODE_ENV=test mocha","test:cov":"NODE_ENV=test node ./node_modules/istanbul/lib/cli.js cover --preserve-comments ./node_modules/mocha/bin/_mocha -- -R spec","generate-docs":"jsdoc2md lib/redis.js lib/cluster/index.js lib/commander.js > API.md","bench":"matcha benchmarks/*.js"},"repository":{"type":"git","url":"git://github.com/luin/ioredis.git"},"keywords":["redis","cluster","sentinel","pipelining"],"author":{"name":"luin","email":"i@zihua.li","url":"http://zihua.li"},"license":"MIT","dependencies":{"bluebird":"^3.3.4","cluster-key-slot":"^1.0.6","debug":"^2.2.0","denque":"^1.1.0","flexbuffer":"0.0.6","lodash":"^4.8.2","redis-commands":"^1.2.0","redis-parser":"^2.4.0"},"devDependencies":{"chai":"^3.5.0","codeclimate-test-reporter":"0.4.0","cz-conventional-changelog":"^1.1.5","istanbul":"^0.4.2","jsdoc":"^3.4.0","jsdoc-to-markdown":"^2.0.0","matcha":"^0.7.0","mocha":"^3.1.1","redis":"^2.4.2","server-destroy":"^1.0.1","sinon":"^1.17.3"},"engines":{"node":">= 0.10.16","iojs":">= 1.0.0"},"config":{"commitizen":{"path":"./node_modules/cz-conventional-changelog"}},"gitHead":"d1c781ee6681834a68850c2e056099ecb319c6ff","bugs":{"url":"https://github.com/luin/ioredis/issues"},"homepage":"https://github.com/luin/ioredis#readme","_id":"ioredis@3.0.0-1","_shasum":"a09a9fb0deb092f2603dbd9bd43e615a6b2eeb22","_from":".","_npmVersion":"2.15.11","_nodeVersion":"4.8.2","_npmUser":{"name":"luin","email":"i@zihua.li"},"dist":{"shasum":"a09a9fb0deb092f2603dbd9bd43e615a6b2eeb22","tarball":"https://registry.npmjs.org/ioredis/-/ioredis-3.0.0-1.tgz"},"maintainers":[{"name":"luin","email":"i@zihua.li"}],"_npmOperationalInternal":{"host":"packages-18-east.internal.npmjs.com","tmp":"tmp/ioredis-3.0.0-1.tgz_1492326274517_0.9830153896473348"},"directories":{}},"3.0.0-2":{"name":"ioredis","version":"3.0.0-2","description":"A delightful, performance-focused Redis client for Node and io.js","main":"index.js","files":["index.js","lib/"],"scripts":{"test":"NODE_ENV=test mocha","test:cov":"NODE_ENV=test node ./node_modules/istanbul/lib/cli.js cover --preserve-comments ./node_modules/mocha/bin/_mocha -- -R spec","generate-docs":"jsdoc2md lib/redis.js lib/cluster/index.js lib/commander.js > API.md","bench":"matcha benchmarks/*.js"},"repository":{"type":"git","url":"git://github.com/luin/ioredis.git"},"keywords":["redis","cluster","sentinel","pipelining"],"author":{"name":"luin","email":"i@zihua.li","url":"http://zihua.li"},"license":"MIT","dependencies":{"bluebird":"^3.3.4","cluster-key-slot":"^1.0.6","debug":"^2.2.0","denque":"^1.1.0","flexbuffer":"0.0.6","lodash":"^4.8.2","redis-commands":"^1.2.0","redis-parser":"^2.4.0"},"devDependencies":{"chai":"^3.5.0","codeclimate-test-reporter":"0.4.0","cz-conventional-changelog":"^1.1.5","istanbul":"^0.4.2","jsdoc":"^3.4.0","jsdoc-to-markdown":"^2.0.0","matcha":"^0.7.0","mocha":"^3.1.1","redis":"^2.4.2","server-destroy":"^1.0.1","sinon":"^1.17.3"},"engines":{"node":">= 0.10.16","iojs":">= 1.0.0"},"config":{"commitizen":{"path":"./node_modules/cz-conventional-changelog"}},"gitHead":"e6054a3763ba7975016ba63d4f0e8c59979ea5e1","bugs":{"url":"https://github.com/luin/ioredis/issues"},"homepage":"https://github.com/luin/ioredis#readme","_id":"ioredis@3.0.0-2","_shasum":"30c84c34db57b60f066220893b946f77a96e9355","_from":".","_npmVersion":"2.15.5","_nodeVersion":"4.4.5","_npmUser":{"name":"luin","email":"i@zihua.li"},"dist":{"shasum":"30c84c34db57b60f066220893b946f77a96e9355","tarball":"https://registry.npmjs.org/ioredis/-/ioredis-3.0.0-2.tgz"},"maintainers":[{"name":"luin","email":"i@zihua.li"}],"_npmOperationalInternal":{"host":"packages-12-west.internal.npmjs.com","tmp":"tmp/ioredis-3.0.0-2.tgz_1493826178187_0.5891208639368415"},"directories":{}},"3.0.0":{"name":"ioredis","version":"3.0.0","description":"A delightful, performance-focused Redis client for Node and io.js","main":"index.js","files":["index.js","lib/"],"scripts":{"test":"NODE_ENV=test mocha","test:cov":"NODE_ENV=test node ./node_modules/istanbul/lib/cli.js cover --preserve-comments ./node_modules/mocha/bin/_mocha -- -R spec","generate-docs":"jsdoc2md lib/redis.js lib/cluster/index.js lib/commander.js > API.md","bench":"matcha benchmarks/*.js"},"repository":{"type":"git","url":"git://github.com/luin/ioredis.git"},"keywords":["redis","cluster","sentinel","pipelining"],"author":{"name":"luin","email":"i@zihua.li","url":"http://zihua.li"},"license":"MIT","dependencies":{"bluebird":"^3.3.4","cluster-key-slot":"^1.0.6","debug":"^2.2.0","denque":"^1.1.0","flexbuffer":"0.0.6","lodash":"^4.8.2","redis-commands":"^1.2.0","redis-parser":"^2.4.0"},"devDependencies":{"chai":"^3.5.0","codeclimate-test-reporter":"0.4.0","cz-conventional-changelog":"^1.1.5","istanbul":"^0.4.2","jsdoc":"^3.4.0","jsdoc-to-markdown":"^2.0.0","matcha":"^0.7.0","mocha":"^3.1.1","redis":"^2.4.2","server-destroy":"^1.0.1","sinon":"^1.17.3"},"engines":{"node":">= 0.10.16","iojs":">= 1.0.0"},"config":{"commitizen":{"path":"./node_modules/cz-conventional-changelog"}},"gitHead":"38db0cc8d86592d7799af2bc27421dfe187ef6d2","bugs":{"url":"https://github.com/luin/ioredis/issues"},"homepage":"https://github.com/luin/ioredis#readme","_id":"ioredis@3.0.0","_shasum":"ecbfd5e1e89df94f55723bb4d81761b183609a0d","_from":".","_npmVersion":"2.15.5","_nodeVersion":"4.4.5","_npmUser":{"name":"luin","email":"i@zihua.li"},"dist":{"shasum":"ecbfd5e1e89df94f55723bb4d81761b183609a0d","tarball":"https://registry.npmjs.org/ioredis/-/ioredis-3.0.0.tgz"},"maintainers":[{"name":"luin","email":"i@zihua.li"}],"_npmOperationalInternal":{"host":"packages-12-west.internal.npmjs.com","tmp":"tmp/ioredis-3.0.0.tgz_1495125147925_0.3838677918538451"},"directories":{}},"3.1.0":{"name":"ioredis","version":"3.1.0","description":"A delightful, performance-focused Redis client for Node and io.js","main":"index.js","files":["index.js","lib/"],"scripts":{"test":"NODE_ENV=test mocha","test:cov":"NODE_ENV=test node ./node_modules/istanbul/lib/cli.js cover --preserve-comments ./node_modules/mocha/bin/_mocha -- -R spec","generate-docs":"jsdoc2md lib/redis.js lib/cluster/index.js lib/commander.js > API.md","bench":"matcha benchmarks/*.js"},"repository":{"type":"git","url":"git://github.com/luin/ioredis.git"},"keywords":["redis","cluster","sentinel","pipelining"],"author":{"name":"luin","email":"i@zihua.li","url":"http://zihua.li"},"license":"MIT","dependencies":{"bluebird":"^3.3.4","cluster-key-slot":"^1.0.6","debug":"^2.2.0","denque":"^1.1.0","flexbuffer":"0.0.6","lodash":"^4.8.2","redis-commands":"^1.2.0","redis-parser":"^2.4.0"},"devDependencies":{"chai":"^3.5.0","codeclimate-test-reporter":"0.4.0","cz-conventional-changelog":"^1.1.5","istanbul":"^0.4.2","jsdoc":"^3.4.0","jsdoc-to-markdown":"^2.0.0","matcha":"^0.7.0","mocha":"^3.1.1","redis":"^2.4.2","server-destroy":"^1.0.1","sinon":"^1.17.3"},"engines":{"node":">= 0.10.16","iojs":">= 1.0.0"},"config":{"commitizen":{"path":"./node_modules/cz-conventional-changelog"}},"gitHead":"f6fdc8234dceed2c0b34fe562a4e7021b476547c","bugs":{"url":"https://github.com/luin/ioredis/issues"},"homepage":"https://github.com/luin/ioredis#readme","_id":"ioredis@3.1.0","_shasum":"ecedda4587b028bf95c2a6f86edee0665f4089b1","_from":".","_npmVersion":"2.15.5","_nodeVersion":"4.4.5","_npmUser":{"name":"luin","email":"i@zihua.li"},"dist":{"shasum":"ecedda4587b028bf95c2a6f86edee0665f4089b1","tarball":"https://registry.npmjs.org/ioredis/-/ioredis-3.1.0.tgz"},"maintainers":[{"name":"luin","email":"i@zihua.li"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/ioredis-3.1.0.tgz_1496123859864_0.6282729278318584"},"directories":{}},"3.1.1":{"name":"ioredis","version":"3.1.1","description":"A delightful, performance-focused Redis client for Node and io.js","main":"index.js","files":["index.js","lib/"],"scripts":{"test":"NODE_ENV=test mocha","test:cov":"NODE_ENV=test node ./node_modules/istanbul/lib/cli.js cover --preserve-comments ./node_modules/mocha/bin/_mocha -- -R spec","generate-docs":"jsdoc2md lib/redis.js lib/cluster/index.js lib/commander.js > API.md","bench":"matcha benchmarks/*.js"},"repository":{"type":"git","url":"git://github.com/luin/ioredis.git"},"keywords":["redis","cluster","sentinel","pipelining"],"author":{"name":"luin","email":"i@zihua.li","url":"http://zihua.li"},"license":"MIT","dependencies":{"bluebird":"^3.3.4","cluster-key-slot":"^1.0.6","debug":"^2.2.0","denque":"^1.1.0","flexbuffer":"0.0.6","lodash":"^4.8.2","redis-commands":"^1.2.0","redis-parser":"^2.4.0"},"devDependencies":{"chai":"^3.5.0","codeclimate-test-reporter":"0.4.0","cz-conventional-changelog":"^1.1.5","istanbul":"^0.4.2","jsdoc":"^3.4.0","jsdoc-to-markdown":"^2.0.0","matcha":"^0.7.0","mocha":"^3.1.1","redis":"^2.4.2","server-destroy":"^1.0.1","sinon":"^1.17.3"},"engines":{"node":">= 0.10.16","iojs":">= 1.0.0"},"config":{"commitizen":{"path":"./node_modules/cz-conventional-changelog"}},"gitHead":"d287fdc7edaab7bad29a0abaa9cf89976b266a75","bugs":{"url":"https://github.com/luin/ioredis/issues"},"homepage":"https://github.com/luin/ioredis#readme","_id":"ioredis@3.1.1","_shasum":"cc2f1d3232b8c95cc153046bce168f2baa1186e8","_from":".","_npmVersion":"2.15.5","_nodeVersion":"4.4.5","_npmUser":{"name":"luin","email":"i@zihua.li"},"dist":{"shasum":"cc2f1d3232b8c95cc153046bce168f2baa1186e8","tarball":"https://registry.npmjs.org/ioredis/-/ioredis-3.1.1.tgz"},"maintainers":[{"name":"luin","email":"i@zihua.li"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/ioredis-3.1.1.tgz_1496209512354_0.7852453412488103"},"directories":{}},"3.1.2":{"name":"ioredis","version":"3.1.2","description":"A delightful, performance-focused Redis client for Node and io.js","main":"index.js","files":["index.js","lib/"],"scripts":{"test":"NODE_ENV=test mocha","test:cov":"NODE_ENV=test node ./node_modules/istanbul/lib/cli.js cover --preserve-comments ./node_modules/mocha/bin/_mocha -- -R spec","generate-docs":"jsdoc2md lib/redis.js lib/cluster/index.js lib/commander.js > API.md","bench":"matcha benchmarks/*.js"},"repository":{"type":"git","url":"git://github.com/luin/ioredis.git"},"keywords":["redis","cluster","sentinel","pipelining"],"author":{"name":"luin","email":"i@zihua.li","url":"http://zihua.li"},"license":"MIT","dependencies":{"bluebird":"^3.3.4","cluster-key-slot":"^1.0.6","debug":"^2.2.0","denque":"^1.1.0","flexbuffer":"0.0.6","lodash":"^4.8.2","redis-commands":"^1.2.0","redis-parser":"^2.4.0"},"devDependencies":{"chai":"^3.5.0","codeclimate-test-reporter":"0.4.0","cz-conventional-changelog":"^1.1.5","istanbul":"^0.4.2","jsdoc":"^3.4.0","jsdoc-to-markdown":"^2.0.0","matcha":"^0.7.0","mocha":"^3.1.1","redis":"^2.4.2","server-destroy":"^1.0.1","sinon":"^1.17.3"},"engines":{"node":">= 0.10.16","iojs":">= 1.0.0"},"config":{"commitizen":{"path":"./node_modules/cz-conventional-changelog"}},"gitHead":"f4f8cba90fd3f34adaecf0ea6ada8a1f5a2bc620","bugs":{"url":"https://github.com/luin/ioredis/issues"},"homepage":"https://github.com/luin/ioredis#readme","_id":"ioredis@3.1.2","_npmVersion":"5.0.3","_nodeVersion":"8.1.0","_npmUser":{"name":"luin","email":"i@zihua.li"},"dist":{"integrity":"sha512-YZlF/P58/DKBvRnXTFeMVo759c5BeJvD0ao9pLiHRM8Mpfxx7mMktdLdWtDcqLATnLVaUbWw/pZS8R66TBIe/w==","shasum":"2579e3eba6dc490f68f14c7b51346281332b467b","tarball":"https://registry.npmjs.org/ioredis/-/ioredis-3.1.2.tgz"},"maintainers":[{"name":"luin","email":"i@zihua.li"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/ioredis-3.1.2.tgz_1501033408032_0.30520045035518706"},"directories":{}},"3.1.3":{"name":"ioredis","version":"3.1.3","description":"A delightful, performance-focused Redis client for Node and io.js","main":"index.js","files":["index.js","lib/"],"scripts":{"test":"NODE_ENV=test mocha","test:cov":"NODE_ENV=test node ./node_modules/istanbul/lib/cli.js cover --preserve-comments ./node_modules/mocha/bin/_mocha -- -R spec","generate-docs":"jsdoc2md lib/redis.js lib/cluster/index.js lib/commander.js > API.md","bench":"matcha benchmarks/*.js"},"repository":{"type":"git","url":"git://github.com/luin/ioredis.git"},"keywords":["redis","cluster","sentinel","pipelining"],"author":{"name":"luin","email":"i@zihua.li","url":"http://zihua.li"},"license":"MIT","dependencies":{"bluebird":"^3.3.4","cluster-key-slot":"^1.0.6","debug":"^2.2.0","denque":"^1.1.0","flexbuffer":"0.0.6","lodash.bind":"^4.2.1","lodash.clone":"^4.5.0","lodash.clonedeep":"^4.5.0","lodash.defaults":"^4.2.0","lodash.difference":"^4.5.0","lodash.flatten":"^4.4.0","lodash.foreach":"^4.5.0","lodash.isempty":"^4.4.0","lodash.keys":"^4.2.0","lodash.partial":"^4.2.1","lodash.pick":"^4.4.0","lodash.sample":"^4.2.1","lodash.shuffle":"^4.2.0","lodash.values":"^4.3.0","redis-commands":"^1.2.0","redis-parser":"^2.4.0"},"devDependencies":{"chai":"^4.1.1","codeclimate-test-reporter":"^0.5.0","cz-conventional-changelog":"^2.0.0","istanbul":"^0.4.2","jsdoc":"^3.4.0","jsdoc-to-markdown":"^3.0.0","matcha":"^0.7.0","mocha":"^3.1.1","server-destroy":"^1.0.1","sinon":"^1.17.3"},"engines":{"node":">= 0.10.16","iojs":">= 1.0.0"},"config":{"commitizen":{"path":"./node_modules/cz-conventional-changelog"}},"false":{},"gitHead":"4aa4d3d3bd922b9ed1a79ace79488e57f12cdd44","bugs":{"url":"https://github.com/luin/ioredis/issues"},"homepage":"https://github.com/luin/ioredis#readme","_id":"ioredis@3.1.3","_npmVersion":"5.0.3","_nodeVersion":"8.1.0","_npmUser":{"name":"luin","email":"i@zihua.li"},"dist":{"integrity":"sha512-kpFJO1n+sj8moNLWy2W/BmHeq4TbiZCkdxIA2sIo96iWUE+Tz79iGwXGLSU9qNi3vL85zsbNCCij1uPdQ+zF1g==","shasum":"363a07cee979517ed6268e50bee5ee472df5ecd1","tarball":"https://registry.npmjs.org/ioredis/-/ioredis-3.1.3.tgz"},"maintainers":[{"name":"luin","email":"i@zihua.li"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/ioredis-3.1.3.tgz_1502631940676_0.870764849241823"},"deprecated":"v3.1.3 is not compatible with Node.js v0.x. Upgrading to v3.1.4 to fix this issue","directories":{}},"3.1.4":{"name":"ioredis","version":"3.1.4","description":"A delightful, performance-focused Redis client for Node and io.js","main":"index.js","files":["index.js","lib/"],"scripts":{"test":"NODE_ENV=test mocha","test:cov":"NODE_ENV=test node ./node_modules/istanbul/lib/cli.js cover --preserve-comments ./node_modules/mocha/bin/_mocha -- -R spec","generate-docs":"jsdoc2md lib/redis.js lib/cluster/index.js lib/commander.js > API.md","bench":"matcha benchmarks/*.js"},"repository":{"type":"git","url":"git://github.com/luin/ioredis.git"},"keywords":["redis","cluster","sentinel","pipelining"],"author":{"name":"luin","email":"i@zihua.li","url":"http://zihua.li"},"license":"MIT","dependencies":{"bluebird":"^3.3.4","cluster-key-slot":"^1.0.6","debug":"^2.2.0","denque":"^1.1.0","flexbuffer":"0.0.6","lodash.assign":"^4.2.0","lodash.bind":"^4.2.1","lodash.clone":"^4.5.0","lodash.clonedeep":"^4.5.0","lodash.defaults":"^4.2.0","lodash.difference":"^4.5.0","lodash.flatten":"^4.4.0","lodash.foreach":"^4.5.0","lodash.isempty":"^4.4.0","lodash.keys":"^4.2.0","lodash.noop":"^3.0.1","lodash.partial":"^4.2.1","lodash.pick":"^4.4.0","lodash.sample":"^4.2.1","lodash.shuffle":"^4.2.0","lodash.values":"^4.3.0","redis-commands":"^1.2.0","redis-parser":"^2.4.0"},"devDependencies":{"chai":"^4.1.1","codeclimate-test-reporter":"^0.5.0","cz-conventional-changelog":"^2.0.0","istanbul":"^0.4.2","jsdoc":"^3.4.0","jsdoc-to-markdown":"^3.0.0","matcha":"^0.7.0","mocha":"^3.1.1","server-destroy":"^1.0.1","sinon":"^1.17.3"},"engines":{"node":">= 0.10.16","iojs":">= 1.0.0"},"config":{"commitizen":{"path":"./node_modules/cz-conventional-changelog"}},"gitHead":"b488e08b02e20413cd7ddcf206d05465f7d5864b","bugs":{"url":"https://github.com/luin/ioredis/issues"},"homepage":"https://github.com/luin/ioredis#readme","_id":"ioredis@3.1.4","_npmVersion":"5.0.3","_nodeVersion":"8.1.0","_npmUser":{"name":"luin","email":"i@zihua.li"},"dist":{"integrity":"sha512-gz9h5BVDh5DVfzGAzyUsE/NBABLuDN5inIFKKRq66h9mqtpBFSM5HaOxKgkJLwMhQihZPkadq/xaZP4dlrHwXA==","shasum":"8688293f5f2f1757e1c812ad17cce49f46d811bc","tarball":"https://registry.npmjs.org/ioredis/-/ioredis-3.1.4.tgz"},"maintainers":[{"name":"luin","email":"i@zihua.li"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/ioredis-3.1.4.tgz_1502633317650_0.8194012444000691"},"directories":{}},"3.2.0":{"name":"ioredis","version":"3.2.0","description":"A delightful, performance-focused Redis client for Node and io.js","main":"index.js","files":["index.js","lib/"],"scripts":{"test":"NODE_ENV=test mocha","test:cov":"NODE_ENV=test node ./node_modules/istanbul/lib/cli.js cover --preserve-comments ./node_modules/mocha/bin/_mocha -- -R spec","generate-docs":"jsdoc2md lib/redis.js lib/cluster/index.js lib/commander.js > API.md","bench":"matcha benchmarks/*.js"},"repository":{"type":"git","url":"git://github.com/luin/ioredis.git"},"keywords":["redis","cluster","sentinel","pipelining"],"author":{"name":"luin","email":"i@zihua.li","url":"http://zihua.li"},"license":"MIT","dependencies":{"bluebird":"^3.3.4","cluster-key-slot":"^1.0.6","debug":"^2.2.0","denque":"^1.1.0","flexbuffer":"0.0.6","lodash.assign":"^4.2.0","lodash.bind":"^4.2.1","lodash.clone":"^4.5.0","lodash.clonedeep":"^4.5.0","lodash.defaults":"^4.2.0","lodash.difference":"^4.5.0","lodash.flatten":"^4.4.0","lodash.foreach":"^4.5.0","lodash.isempty":"^4.4.0","lodash.keys":"^4.2.0","lodash.noop":"^3.0.1","lodash.partial":"^4.2.1","lodash.pick":"^4.4.0","lodash.sample":"^4.2.1","lodash.shuffle":"^4.2.0","lodash.values":"^4.3.0","redis-commands":"^1.2.0","redis-parser":"^2.4.0"},"devDependencies":{"chai":"^3.5.0","codeclimate-test-reporter":"^0.5.0","cz-conventional-changelog":"^2.0.0","istanbul":"^0.4.2","jsdoc":"^3.4.0","jsdoc-to-markdown":"^3.0.0","matcha":"^0.7.0","mocha":"^3.1.1","server-destroy":"^1.0.1","sinon":"^1.17.3"},"engines":{"node":">= 0.10.16","iojs":">= 1.0.0"},"config":{"commitizen":{"path":"./node_modules/cz-conventional-changelog"}},"gitHead":"a79024ab7a75f69d457b5ccf936012e867a3ef03","bugs":{"url":"https://github.com/luin/ioredis/issues"},"homepage":"https://github.com/luin/ioredis#readme","_id":"ioredis@3.2.0","_npmVersion":"5.3.0","_nodeVersion":"8.4.0","_npmUser":{"name":"luin","email":"i@zihua.li"},"dist":{"integrity":"sha512-CT2+QC7B8IqBl0YTASGqJBbDJ90Lcv4CAIjzmgnVBK+VoBQf1kZGXYfqiiUj/kNvj0XK1Y7rhO6LATqU2yNIPg==","shasum":"27ef0af9394ad5e9cdbc40f3ff4c16c03b32af99","tarball":"https://registry.npmjs.org/ioredis/-/ioredis-3.2.0.tgz"},"maintainers":[{"name":"luin","email":"i@zihua.li"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/ioredis-3.2.0.tgz_1508776111995_0.933149847202003"},"directories":{}},"3.2.1":{"name":"ioredis","version":"3.2.1","description":"A delightful, performance-focused Redis client for Node and io.js","main":"index.js","files":["index.js","lib/"],"scripts":{"test":"NODE_ENV=test mocha","test:cov":"NODE_ENV=test node ./node_modules/istanbul/lib/cli.js cover --preserve-comments ./node_modules/mocha/bin/_mocha -- -R spec","generate-docs":"jsdoc2md lib/redis.js lib/cluster/index.js lib/commander.js > API.md","bench":"matcha benchmarks/*.js"},"repository":{"type":"git","url":"git://github.com/luin/ioredis.git"},"keywords":["redis","cluster","sentinel","pipelining"],"author":{"name":"luin","email":"i@zihua.li","url":"http://zihua.li"},"license":"MIT","dependencies":{"bluebird":"^3.3.4","cluster-key-slot":"^1.0.6","debug":"^2.2.0","denque":"^1.1.0","flexbuffer":"0.0.6","lodash.assign":"^4.2.0","lodash.bind":"^4.2.1","lodash.clone":"^4.5.0","lodash.clonedeep":"^4.5.0","lodash.defaults":"^4.2.0","lodash.difference":"^4.5.0","lodash.flatten":"^4.4.0","lodash.foreach":"^4.5.0","lodash.isempty":"^4.4.0","lodash.keys":"^4.2.0","lodash.noop":"^3.0.1","lodash.partial":"^4.2.1","lodash.pick":"^4.4.0","lodash.sample":"^4.2.1","lodash.shuffle":"^4.2.0","lodash.values":"^4.3.0","redis-commands":"^1.2.0","redis-parser":"^2.4.0"},"devDependencies":{"chai":"^3.5.0","codeclimate-test-reporter":"^0.5.0","cz-conventional-changelog":"^2.0.0","istanbul":"^0.4.2","jsdoc":"^3.4.0","jsdoc-to-markdown":"^3.0.0","matcha":"^0.7.0","mocha":"^3.1.1","server-destroy":"^1.0.1","sinon":"^1.17.3"},"engines":{"node":">= 0.10.16","iojs":">= 1.0.0"},"config":{"commitizen":{"path":"./node_modules/cz-conventional-changelog"}},"gitHead":"e5e3c14eea6b46b90bd1b9a31bb0707c528fe83b","bugs":{"url":"https://github.com/luin/ioredis/issues"},"homepage":"https://github.com/luin/ioredis#readme","_id":"ioredis@3.2.1","_npmVersion":"5.3.0","_nodeVersion":"8.4.0","_npmUser":{"name":"luin","email":"i@zihua.li"},"dist":{"integrity":"sha512-4H87hqglDvOmrlWdFWijnc7VJnaf20bdl6UWhSFaB6XnEGFIKXXoFQyrJECJvVtUl9Rwv9TA0exiEusslOgm5g==","shasum":"4c10bcce9659fdb0af923b0e7915208fe023d3f0","tarball":"https://registry.npmjs.org/ioredis/-/ioredis-3.2.1.tgz"},"maintainers":[{"name":"luin","email":"i@zihua.li"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/ioredis-3.2.1.tgz_1508776136152_0.21906627784483135"},"directories":{}},"3.2.2":{"name":"ioredis","version":"3.2.2","description":"A delightful, performance-focused Redis client for Node and io.js","main":"index.js","files":["index.js","lib/"],"scripts":{"test":"NODE_ENV=test mocha","test:cov":"NODE_ENV=test node ./node_modules/istanbul/lib/cli.js cover --preserve-comments ./node_modules/mocha/bin/_mocha -- -R spec","generate-docs":"jsdoc2md lib/redis.js lib/cluster/index.js lib/commander.js > API.md","bench":"matcha benchmarks/*.js"},"repository":{"type":"git","url":"git://github.com/luin/ioredis.git"},"keywords":["redis","cluster","sentinel","pipelining"],"author":{"name":"luin","email":"i@zihua.li","url":"http://zihua.li"},"license":"MIT","dependencies":{"bluebird":"^3.3.4","cluster-key-slot":"^1.0.6","debug":"^2.6.9","denque":"^1.1.0","flexbuffer":"0.0.6","lodash.assign":"^4.2.0","lodash.bind":"^4.2.1","lodash.clone":"^4.5.0","lodash.clonedeep":"^4.5.0","lodash.defaults":"^4.2.0","lodash.difference":"^4.5.0","lodash.flatten":"^4.4.0","lodash.foreach":"^4.5.0","lodash.isempty":"^4.4.0","lodash.keys":"^4.2.0","lodash.noop":"^3.0.1","lodash.partial":"^4.2.1","lodash.pick":"^4.4.0","lodash.sample":"^4.2.1","lodash.shuffle":"^4.2.0","lodash.values":"^4.3.0","redis-commands":"^1.2.0","redis-parser":"^2.4.0"},"devDependencies":{"chai":"^3.5.0","codeclimate-test-reporter":"^0.5.0","cz-conventional-changelog":"^2.0.0","istanbul":"^0.4.2","jsdoc":"^3.4.0","jsdoc-to-markdown":"^3.0.0","matcha":"^0.7.0","mocha":"^3.1.1","server-destroy":"^1.0.1","sinon":"^1.17.3"},"engines":{"node":">= 0.10.16","iojs":">= 1.0.0"},"config":{"commitizen":{"path":"./node_modules/cz-conventional-changelog"}},"gitHead":"e16cf7e296234dd65b8127e8b5fb793f406b06e8","bugs":{"url":"https://github.com/luin/ioredis/issues"},"homepage":"https://github.com/luin/ioredis#readme","_id":"ioredis@3.2.2","_npmVersion":"5.5.1","_nodeVersion":"8.1.0","_npmUser":{"name":"luin","email":"i@zihua.li"},"dist":{"integrity":"sha512-g+ShTQYLsCcOUkNOK6CCEZbj3aRDVPw3WOwXk+LxlUKvuS9ujEqP2MppBHyRVYrNNFW/vcPaTBUZ2ctGNSiOCA==","shasum":"b7d5ff3afd77bb9718bb2821329b894b9a44c00b","tarball":"https://registry.npmjs.org/ioredis/-/ioredis-3.2.2.tgz"},"maintainers":[{"name":"luin","email":"i@zihua.li"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/ioredis-3.2.2.tgz_1512018277358_0.08935638726688921"},"directories":{}},"4.0.0-0":{"name":"ioredis","version":"4.0.0-0","description":"A delightful, performance-focused Redis client for Node and io.js","main":"index.js","files":["index.js","lib/"],"scripts":{"test":"NODE_ENV=test mocha --exit","test:cov":"NODE_ENV=test node ./node_modules/istanbul/lib/cli.js cover --preserve-comments ./node_modules/mocha/bin/_mocha -- -R spec --exit","generate-docs":"jsdoc2md lib/redis.js lib/cluster/index.js lib/commander.js > API.md","bench":"matcha benchmarks/*.js"},"repository":{"type":"git","url":"git://github.com/luin/ioredis.git"},"keywords":["redis","cluster","sentinel","pipelining"],"author":{"name":"luin","email":"i@zihua.li","url":"http://zihua.li"},"license":"MIT","dependencies":{"cluster-key-slot":"^1.0.6","debug":"^3.1.0","denque":"^1.1.0","flexbuffer":"0.0.6","lodash.bind":"^4.2.1","lodash.clone":"^4.5.0","lodash.clonedeep":"^4.5.0","lodash.defaults":"^4.2.0","lodash.difference":"^4.5.0","lodash.flatten":"^4.4.0","lodash.foreach":"^4.5.0","lodash.isempty":"^4.4.0","lodash.partial":"^4.2.1","lodash.pick":"^4.4.0","lodash.sample":"^4.2.1","lodash.shuffle":"^4.2.0","lodash.values":"^4.3.0","redis-commands":"^1.2.0","redis-parser":"^2.6.0","standard-as-callback":"^1.0.0"},"devDependencies":{"bluebird":"^3.5.1","chai":"^3.5.0","cz-conventional-changelog":"^2.0.0","istanbul":"^0.4.2","jsdoc":"^3.4.0","jsdoc-to-markdown":"^4.0.1","mocha":"^5.2.0","server-destroy":"^1.0.1","sinon":"^1.17.3"},"engines":{"node":">=4"},"config":{"commitizen":{"path":"./node_modules/cz-conventional-changelog"}},"readme":"[![ioredis](https://cdn.rawgit.com/luin/ioredis/57b5b89e3e9111ff25d8c62c0bc58ed42e5b8d1e/logo.svg)](https://github.com/luin/ioredis)\n\n[![Build Status](https://travis-ci.org/luin/ioredis.svg?branch=master)](https://travis-ci.org/luin/ioredis)\n[![Test Coverage](https://codeclimate.com/github/luin/ioredis/badges/coverage.svg)](https://codeclimate.com/github/luin/ioredis)\n[![Code Climate](https://codeclimate.com/github/luin/ioredis/badges/gpa.svg)](https://codeclimate.com/github/luin/ioredis)\n[![Commitizen friendly](https://img.shields.io/badge/commitizen-friendly-brightgreen.svg)](http://commitizen.github.io/cz-cli/)\n[![Join the chat at https://gitter.im/luin/ioredis](https://badges.gitter.im/Join%20Chat.svg)](https://gitter.im/luin/ioredis?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge)\n\nA robust, performance-focused and full-featured [Redis](http://redis.io) client for [Node](https://nodejs.org) and [io.js](https://iojs.org).\n\nSupports Redis >= 2.6.12 and (Node.js >= 0.10.16).\n\n# Features\nioredis is a robust, full-featured Redis client that is\nused in the world's biggest online commerce company [Alibaba](http://www.alibaba.com/) and many other awesome companies.\n\n0. Full-featured. It supports [Cluster](http://redis.io/topics/cluster-tutorial), [Sentinel](http://redis.io/topics/sentinel), [Pipelining](http://redis.io/topics/pipelining) and of course [Lua scripting](http://redis.io/commands/eval) & [Pub/Sub](http://redis.io/topics/pubsub) (with the support of binary messages).\n0. High performance.\n0. Delightful API. It works with Node callbacks and Native promises.\n0. Transformation of command arguments and replies.\n0. Transparent key prefixing.\n0. Abstraction for Lua scripting, allowing you to define custom commands.\n0. Support for binary data.\n0. Support for TLS.\n0. Support for offline queue and ready checking.\n0. Support for ES6 types, such as `Map` and `Set`.\n0. Support for GEO commands (Redis 3.2 Unstable).\n0. Sophisticated error handling strategy.\n\n# Links\n* [API Documentation](API.md)\n* [Changelog](Changelog.md)\n* [Migrating from node_redis](https://github.com/luin/ioredis/wiki/Migrating-from-node_redis)\n* [Error Handling](#error-handling)\n\n## Become a Sponsor to Support ioredis's Development\nOpen source is hard and time-consuming. If you want to invest in ioredis's future you can become a sponsor and make us spend more time on this library's improvements and new features.\n\n<a href=\"https://opencollective.com/ioredis\"><img src=\"https://opencollective.com/ioredis/tiers/sponsor.svg?avatarHeight=36\"></a>\n\nThank you for using ioredis :-)\n\n<hr>\n<a href=\"https://itunes.apple.com/app/medis-gui-for-redis/id1063631769\"><img align=\"right\" src=\"medis.png\" alt=\"Download on the App Store\"></a>\n\n\n### Advertisement\n\nLooking for a Redis GUI manager for OS X, Windows and Linux? Here's [Medis](https://itunes.apple.com/us/app/medis-gui-for-redis/id1063631769)!\n\nMedis is an open-sourced, beautiful, easy-to-use Redis GUI management application.\n\nMedis starts with all the basic features you need:\n\n* Keys viewing/editing\n* SSH Tunnel for connecting with remote servers\n* Terminal for executing custom commands\n* JSON/MessagePack format viewing/editing and built-in highlighting/validator\n* And other awesome features...\n\n[Medis is open sourced on GitHub](https://github.com/luin/medis)\n\n<hr>\n\n# Quick Start\n\n## Install\n```shell\n$ npm install ioredis\n```\n\n## Basic Usage\n\n```javascript\nvar Redis = require('ioredis');\nvar redis = new Redis();\n\nredis.set('foo', 'bar');\nredis.get('foo', function (err, result) {\n  console.log(result);\n});\n\n// Or using a promise if the last argument isn't a function\nredis.get('foo').then(function (result) {\n  console.log(result);\n});\n\n// Arguments to commands are flattened, so the following are the same:\nredis.sadd('set', 1, 3, 5, 7);\nredis.sadd('set', [1, 3, 5, 7]);\n\n// All arguments are passed directly to the redis server:\nredis.set('key', 100, 'EX', 10);\n```\n\nSee the `examples/` folder for more examples.\n\n## Connect to Redis\nWhen a new `Redis` instance is created,\na connection to Redis will be created at the same time.\nYou can specify which Redis to connect to by:\n\n```javascript\nnew Redis()       // Connect to 127.0.0.1:6379\nnew Redis(6380)   // 127.0.0.1:6380\nnew Redis(6379, '192.168.1.1')        // 192.168.1.1:6379\nnew Redis('/tmp/redis.sock')\nnew Redis({\n  port: 6379,          // Redis port\n  host: '127.0.0.1',   // Redis host\n  family: 4,           // 4 (IPv4) or 6 (IPv6)\n  password: 'auth',\n  db: 0\n})\n```\n\nYou can also specify connection options as a [`redis://` URL](http://www.iana.org/assignments/uri-schemes/prov/redis):\n\n```javascript\n// Connect to 127.0.0.1:6380, db 4, using password \"authpassword\":\nnew Redis('redis://:authpassword@127.0.0.1:6380/4')\n```\n\nSee [API Documentation](API.md#new_Redis) for all available options.\n\n## Pub/Sub\n\nHere is a simple example of the API for publish/subscribe.\nThe following program opens two client connections.\nIt subscribes to a channel with one connection\nand publishes to that channel with the other:\n\n```javascript\nvar Redis = require('ioredis');\nvar redis = new Redis();\nvar pub = new Redis();\nredis.subscribe('news', 'music', function (err, count) {\n  // Now we are subscribed to both the 'news' and 'music' channels.\n  // `count` represents the number of channels we are currently subscribed to.\n\n  pub.publish('news', 'Hello world!');\n  pub.publish('music', 'Hello again!');\n});\n\nredis.on('message', function (channel, message) {\n  // Receive message Hello world! from channel news\n  // Receive message Hello again! from channel music\n  console.log('Receive message %s from channel %s', message, channel);\n});\n\n// There's also an event called 'messageBuffer', which is the same as 'message' except\n// it returns buffers instead of strings.\nredis.on('messageBuffer', function (channel, message) {\n  // Both `channel` and `message` are buffers.\n});\n```\n\n`PSUBSCRIBE` is also supported in a similar way:\n\n```javascript\nredis.psubscribe('pat?ern', function (err, count) {});\nredis.on('pmessage', function (pattern, channel, message) {});\nredis.on('pmessageBuffer', function (pattern, channel, message) {});\n```\n\nWhen a client issues a SUBSCRIBE or PSUBSCRIBE, that connection is put into a \"subscriber\" mode.\nAt that point, only commands that modify the subscription set are valid.\nWhen the subscription set is empty, the connection is put back into regular mode.\n\nIf you need to send regular commands to Redis while in subscriber mode, just open another connection.\n\n## Handle Binary Data\nArguments can be buffers:\n```javascript\nredis.set('foo', new Buffer('bar'));\n```\n\nAnd every command has a method that returns a Buffer (by adding a suffix of \"Buffer\" to the command name).\nTo get a buffer instead of a utf8 string:\n\n```javascript\nredis.getBuffer('foo', function (err, result) {\n  // result is a buffer.\n});\n```\n\n## Pipelining\nIf you want to send a batch of commands (e.g. > 5), you can use pipelining to queue\nthe commands in memory and then send them to Redis all at once. This way the performance improves by 50%~300% (See [benchmark section](#benchmark)).\n\n`redis.pipeline()` creates a `Pipeline` instance. You can call any Redis\ncommands on it just like the `Redis` instance. The commands are queued in memory\nand flushed to Redis by calling the `exec` method:\n\n```javascript\nvar pipeline = redis.pipeline();\npipeline.set('foo', 'bar');\npipeline.del('cc');\npipeline.exec(function (err, results) {\n  // `err` is always null, and `results` is an array of responses\n  // corresponding to the sequence of queued commands.\n  // Each response follows the format `[err, result]`.\n});\n\n// You can even chain the commands:\nredis.pipeline().set('foo', 'bar').del('cc').exec(function (err, results) {\n});\n\n// `exec` also returns a Promise:\nvar promise = redis.pipeline().set('foo', 'bar').get('foo').exec();\npromise.then(function (result) {\n  // result === [[null, 'OK'], [null, 'bar']]\n});\n```\n\nEach chained command can also have a callback, which will be invoked when the command\ngets a reply:\n\n```javascript\nredis.pipeline().set('foo', 'bar').get('foo', function (err, result) {\n  // result === 'bar'\n}).exec(function (err, result) {\n  // result[1][1] === 'bar'\n});\n```\n\nIn addition to adding commands to the `pipeline` queue individually, you can also pass an array of commands and arguments to the constructor:\n\n```javascript\nredis.pipeline([\n  ['set', 'foo', 'bar'],\n  ['get', 'foo']\n]).exec(function () { /* ... */ });\n```\n\n`#length` property shows how many commands in the pipeline:\n\n```javascript\nconst length = redis.pipeline().set('foo', 'bar').get('foo').length;\n// length === 2\n```\n\n\n## Transaction\nMost of the time, the transaction commands `multi` & `exec` are used together with pipeline.\nTherefore, when `multi` is called, a `Pipeline` instance is created automatically by default,\nso you can use `multi` just like `pipeline`:\n\n```javascript\nredis.multi().set('foo', 'bar').get('foo').exec(function (err, results) {\n  // results === [[null, 'OK'], [null, 'bar']]\n});\n```\nIf there's a syntax error in the transaction's command chain (e.g. wrong number of arguments, wrong command name, etc),\nthen none of the commands would be executed, and an error is returned:\n\n```javascript\nredis.multi().set('foo').set('foo', 'new value').exec(function (err, results) {\n  // err:\n  //  { [ReplyError: EXECABORT Transaction discarded because of previous errors.]\n  //    name: 'ReplyError',\n  //    message: 'EXECABORT Transaction discarded because of previous errors.',\n  //    command: { name: 'exec', args: [] },\n  //    previousErrors:\n  //     [ { [ReplyError: ERR wrong number of arguments for 'set' command]\n  //         name: 'ReplyError',\n  //         message: 'ERR wrong number of arguments for \\'set\\' command',\n  //         command: [Object] } ] }\n});\n```\n\nIn terms of the interface, `multi` differs from `pipeline` in that when specifying a callback\nto each chained command, the queueing state is passed to the callback instead of the result of the command:\n\n```javascript\nredis.multi().set('foo', 'bar', function (err, result) {\n  // result === 'QUEUED'\n}).exec(/* ... */);\n```\n\nIf you want to use transaction without pipeline, pass `{ pipeline: false }` to `multi`,\nand every command will be sent to Redis immediately without waiting for an `exec` invocation:\n\n```javascript\nredis.multi({ pipeline: false });\nredis.set('foo', 'bar');\nredis.get('foo');\nredis.exec(function (err, result) {\n  // result === [[null, 'OK'], [null, 'bar']]\n});\n```\n\nThe constructor of `multi` also accepts a batch of commands:\n\n```javascript\nredis.multi([\n  ['set', 'foo', 'bar'],\n  ['get', 'foo']\n]).exec(function () { /* ... */ });\n```\n\nInline transactions are supported by pipeline, which means you can group a subset of commands\nin the pipeline into a transaction:\n\n```javascript\nredis.pipeline().get('foo').multi().set('foo', 'bar').get('foo').exec().get('foo').exec();\n```\n\n## Lua Scripting\nioredis supports all of the scripting commands such as `EVAL`, `EVALSHA` and `SCRIPT`.\nHowever, it's tedious to use in real world scenarios since developers have to take\ncare of script caching and to detect when to use `EVAL` and when to use `EVALSHA`.\nioredis expose a `defineCommand` method to make scripting much easier to use:\n\n```javascript\nvar redis = new Redis();\n\n// This will define a command echo:\nredis.defineCommand('echo', {\n  numberOfKeys: 2,\n  lua: 'return {KEYS[1],KEYS[2],ARGV[1],ARGV[2]}'\n});\n\n// Now `echo` can be used just like any other ordinary command,\n// and ioredis will try to use `EVALSHA` internally when possible for better performance.\nredis.echo('k1', 'k2', 'a1', 'a2', function (err, result) {\n  // result === ['k1', 'k2', 'a1', 'a2']\n});\n\n// `echoBuffer` is also defined automatically to return buffers instead of strings:\nredis.echoBuffer('k1', 'k2', 'a1', 'a2', function (err, result) {\n  // result[0] === new Buffer('k1');\n});\n\n// And of course it works with pipeline:\nredis.pipeline().set('foo', 'bar').echo('k1', 'k2', 'a1', 'a2').exec();\n```\n\nIf the number of keys can't be determined when defining a command, you can\nomit the `numberOfKeys` property and pass the number of keys as the first argument\nwhen you call the command:\n\n```javascript\nredis.defineCommand('echoDynamicKeyNumber', {\n  lua: 'return {KEYS[1],KEYS[2],ARGV[1],ARGV[2]}'\n});\n\n// Now you have to pass the number of keys as the first argument every time\n// you invoke the `echoDynamicKeyNumber` command:\nredis.echoDynamicKeyNumber(2, 'k1', 'k2', 'a1', 'a2', function (err, result) {\n  // result === ['k1', 'k2', 'a1', 'a2']\n});\n```\n\n## Transparent Key Prefixing\nThis feature allows you to specify a string that will automatically be prepended\nto all the keys in a command, which makes it easier to manage your key\nnamespaces.\n\n**Warning** This feature won't apply to commands like [KEYS](http://redis.io/commands/KEYS) and [SCAN](http://redis.io/commands/scan) that take patterns rather than actual keys([#239](https://github.com/luin/ioredis/issues/239)),\nand this feature also won't apply to the replies of commands even they are key names ([#325](https://github.com/luin/ioredis/issues/325)).\n\n```javascript\nvar fooRedis = new Redis({ keyPrefix: 'foo:' });\nfooRedis.set('bar', 'baz');  // Actually sends SET foo:bar baz\n\nfooRedis.defineCommand('echo', {\n  numberOfKeys: 2,\n  lua: 'return {KEYS[1],KEYS[2],ARGV[1],ARGV[2]}'\n});\n\n// Works well with pipelining/transaction\nfooRedis.pipeline()\n  // Sends SORT foo:list BY foo:weight_*->fieldname\n  .sort('list', 'BY', 'weight_*->fieldname')\n  // Supports custom commands\n  // Sends EVALSHA xxx foo:k1 foo:k2 a1 a2\n  .echo('k1', 'k2', 'a1', 'a2')\n  .exec()\n```\n\n## Transforming Arguments & Replies\nMost Redis commands take one or more Strings as arguments,\nand replies are sent back as a single String or an Array of Strings. However, sometimes\nyou may want something different. For instance, it would be more convenient if the `HGETALL`\ncommand returns a hash (e.g. `{ key: val1, key2: v2 }`) rather than an array of key values (e.g. `[key1, val1, key2, val2]`).\n\nioredis has a flexible system for transforming arguments and replies. There are two types\nof transformers, argument transformer and reply transformer:\n\n```javascript\nvar Redis = require('ioredis');\n\n// Here's the built-in argument transformer converting\n// hmset('key', { k1: 'v1', k2: 'v2' })\n// or\n// hmset('key', new Map([['k1', 'v1'], ['k2', 'v2']]))\n// into\n// hmset('key', 'k1', 'v1', 'k2', 'v2')\nRedis.Command.setArgumentTransformer('hmset', function (args) {\n  if (args.length === 2) {\n    if (typeof Map !== 'undefined' && args[1] instanceof Map) {\n      // utils is a internal module of ioredis\n      return [args[0]].concat(utils.convertMapToArray(args[1]));\n    }\n    if ( typeof args[1] === 'object' && args[1] !== null) {\n      return [args[0]].concat(utils.convertObjectToArray(args[1]));\n    }\n  }\n  return args;\n});\n\n// Here's the built-in reply transformer converting the HGETALL reply\n// ['k1', 'v1', 'k2', 'v2']\n// into\n// { k1: 'v1', 'k2': 'v2' }\nRedis.Command.setReplyTransformer('hgetall', function (result) {\n  if (Array.isArray(result)) {\n    var obj = {};\n    for (var i = 0; i < result.length; i += 2) {\n      obj[result[i]] = result[i + 1];\n    }\n    return obj;\n  }\n  return result;\n});\n```\n\nThere are three built-in transformers, two argument transformers for `hmset` & `mset` and\na reply transformer for `hgetall`. Transformers for `hmset` and `hgetall` were mentioned\nabove, and the transformer for `mset` is similar to the one for `hmset`:\n\n```javascript\nredis.mset({ k1: 'v1', k2: 'v2' });\nredis.get('k1', function (err, result) {\n  // result === 'v1';\n});\n\nredis.mset(new Map([['k3', 'v3'], ['k4', 'v4']]));\nredis.get('k3', function (err, result) {\n  // result === 'v3';\n});\n```\n\nAnother useful example of a reply transformer is one that changes `hgetall` to return array of arrays instead of objects which avoids a unwanted conversation of hash keys to strings when dealing with binary hash keys:\n\n```javascript\nRedis.Command.setReplyTransformer('hgetall', function (result) {\n  var arr = [];\n  for (var i = 0; i < result.length; i += 2) {\n    arr.push([result[i], result[i + 1]]);\n  }\n  return arr;\n});\nredis.hset('h1', Buffer.from([0x01]), Buffer.from([0x02]));\nredis.hset('h1', Buffer.from([0x03]), Buffer.from([0x04]));\nredis.hgetallBuffer('h1', function (err, result) {\n  // result === [ [ <Buffer 01>, <Buffer 02> ], [ <Buffer 03>, <Buffer 04> ] ];\n});\n```\n\n## Monitor\nRedis supports the MONITOR command,\nwhich lets you see all commands received by the Redis server across all client connections,\nincluding from other client libraries and other computers.\n\nThe `monitor` method returns a monitor instance.\nAfter you send the MONITOR command, no other commands are valid on that connection. ioredis will emit a monitor event for every new monitor message that comes across.\nThe callback for the monitor event takes a timestamp from the Redis server and an array of command arguments.\n\nHere is a simple example:\n\n```javascript\nredis.monitor(function (err, monitor) {\n  monitor.on('monitor', function (time, args, source, database) {\n  });\n});\n```\n\n## Streamify Scanning\nRedis 2.8 added the `SCAN` command to incrementally iterate through the keys in the database. It's different from `KEYS` in that\n`SCAN` only returns a small number of elements each call, so it can be used in production without the downside\nof blocking the server for a long time. However, it requires recording the cursor on the client side each time\nthe `SCAN` command is called in order to iterate through all the keys correctly. Since it's a relatively common use case, ioredis\nprovides a streaming interface for the `SCAN` command to make things much easier. A readable stream can be created by calling `scanStream`:\n\n```javascript\nvar redis = new Redis();\n// Create a readable stream (object mode)\nvar stream = redis.scanStream();\nvar keys = [];\nstream.on('data', function (resultKeys) {\n  // `resultKeys` is an array of strings representing key names.\n  // Note that resultKeys may contain 0 keys.\n  for (var i = 0; i < resultKeys.length; i++) {\n    keys.push(resultKeys[i]);\n  }\n});\nstream.on('end', function () {\n  console.log('done with the keys: ', keys);\n});\n```\n\n`scanStream` accepts an option, with which you can specify the `MATCH` pattern and the `COUNT` argument:\n\n```javascript\nvar stream = redis.scanStream({\n  // only returns keys following the pattern of `user:*`\n  match: 'user:*',\n  // returns approximately 100 elements per call\n  count: 100\n});\n```\n\nJust like other commands, `scanStream` has a binary version `scanBufferStream`, which returns an array of buffers. It's useful when\nthe key names are not utf8 strings.\n\nThere are also `hscanStream`, `zscanStream` and `sscanStream` to iterate through elements in a hash, zset and set. The interface of each is\nsimilar to `scanStream` except the first argument is the key name:\n\n```javascript\nvar stream = redis.hscanStream('myhash', {\n  match: 'age:??'\n});\n```\n\nYou can learn more from the [Redis documentation](http://redis.io/commands/scan).\n\n**Useful Tips**\nIt's pretty common that doing an async task in the `data` handler. We'd like the scanning process to be paused until the async task to be finished. `Stream#pause()` and `Stream.resume()` do the trick. For example if we want to migrate data in Redis to MySQL:\n\n```javascript\nvar stream = redis.scanStream();\nstream.on('data', function (resultKeys) {\n  // Pause the stream from scanning more keys until we've migrated the current keys.\n  stream.pause();\n\n  Promise.all(resultKeys.map(migrateKeyToMySQL)).then(() => {\n    // Resume the stream here.\n    stream.resume();\n  });\n});\n\nstream.on('end', function () {\n  console.log('done migration');\n});\n```\n\n## Auto-reconnect\nBy default, ioredis will try to reconnect when the connection to Redis is lost\nexcept when the connection is closed manually by `redis.disconnect()` or `redis.quit()`.\n\nIt's very flexible to control how long to wait to reconnect after disconnection\nusing the `retryStrategy` option:\n\n```javascript\nvar redis = new Redis({\n  // This is the default value of `retryStrategy`\n  retryStrategy: function (times) {\n    var delay = Math.min(times * 50, 2000);\n    return delay;\n  }\n});\n```\n\n`retryStrategy` is a function that will be called when the connection is lost.\nThe argument `times` means this is the nth reconnection being made and\nthe return value represents how long (in ms) to wait to reconnect. When the\nreturn value isn't a number, ioredis will stop trying to reconnect, and the connection\nwill be lost forever if the user doesn't call `redis.connect()` manually.\n\nWhen reconnected, the client will auto subscribe to channels that the previous connection subscribed to.\nThis behavior can be disabled by setting the `autoResubscribe` option to `false`.\n\nAnd if the previous connection has some unfulfilled commands (most likely blocking commands such as `brpop` and `blpop`),\nthe client will resend them when reconnected. This behavior can be disabled by setting the `autoResendUnfulfilledCommands` option to `false`.\n\nBy default, all pending commands will be flushed with an error every 20 retry attempts. That makes sure commands won't wait forever when the connection is down. You can change this behavior by setting `maxRetriesPerRequest`:\n\n```javascript\nvar redis = new Redis({\n  maxRetriesPerRequest: 1\n});\n```\n\nSet maxRetriesPerRequest to `null` to disable this behavior, and every command will wait forever until the connection is alive again (which is the default behavior before ioredis v4).\n\n### Reconnect on error\n\nBesides auto-reconnect when the connection is closed, ioredis supports reconnecting on the specified errors by the `reconnectOnError` option. Here's an example that will reconnect when receiving `READONLY` error:\n\n```javascript\nvar redis = new Redis({\n  reconnectOnError: function (err) {\n    var targetError = 'READONLY';\n    if (err.message.slice(0, targetError.length) === targetError) {\n      // Only reconnect when the error starts with \"READONLY\"\n      return true; // or `return 1;`\n    }\n  }\n});\n```\n\nThis feature is useful when using Amazon ElastiCache. Once failover happens, Amazon ElastiCache will switch the master we currently connected with to a slave, leading to the following writes fails with the error `READONLY`. Using `reconnectOnError`, we can force the connection to reconnect on this error in order to connect to the new master.\n\nFurthermore, if the `reconnectOnError` returns `2`, ioredis will resend the failed command after reconnecting.\n\n## Connection Events\nThe Redis instance will emit some events about the state of the connection to the Redis server.\n\nEvent    | Description\n:------------- | :-------------\nconnect  | emits when a connection is established to the Redis server.\nready    | If `enableReadyCheck` is `true`, client will emit `ready` when the server reports that it is ready to receive commands (e.g. finish loading data from disk).<br>Otherwise, `ready` will be emitted immediately right after the `connect` event.\nerror    | emits when an error occurs while connecting.<br>However, ioredis emits all `error` events silently (only emits when there's at least one listener) so that your application won't crash if you're not listening to the `error` event.\nclose    | emits when an established Redis server connection has closed.\nreconnecting | emits after `close` when a reconnection will be made. The argument of the event is the time (in ms) before reconnecting.\nend     | emits after `close` when no more reconnections will be made, or the connection is failed to establish.\n\nYou can also check out the `Redis#status` property to get the current connection status.\n\nBesides the above connection events, there are several other custom events:\n\nEvent    | Description\n:------------- | :-------------\nselect   | emits when the database changed. The argument is the new db number.\n\n## Offline Queue\nWhen a command can't be processed by Redis (being sent before the `ready` event), by default, it's added to the offline queue and will be\nexecuted when it can be processed. You can disable this feature by setting the `enableOfflineQueue`\noption to `false`:\n\n```javascript\nvar redis = new Redis({ enableOfflineQueue: false });\n```\n\n## TLS Options\nRedis doesn't support TLS natively, however if the redis server you want to connect to is hosted behind a TLS proxy (e.g. [stunnel](https://www.stunnel.org/)) or is offered by a PaaS service that supports TLS connection (e.g. [Redis Labs](https://redislabs.com/)), you can set the `tls` option:\n\n```javascript\nvar redis = new Redis({\n  host: 'localhost',\n  tls: {\n    // Refer to `tls.connect()` section in\n    // https://nodejs.org/api/tls.html\n    // for all supported options\n    ca: fs.readFileSync('cert.pem')\n  }\n});\n```\n\n<hr>\n\n## Sentinel\nioredis supports Sentinel out of the box. It works transparently as all features that work when\nyou connect to a single node also work when you connect to a sentinel group. Make sure to run Redis >= 2.8.12 if you want to use this feature. Sentinels have a default port of 26379.\n\nTo connect using Sentinel, use:\n\n```javascript\nvar redis = new Redis({\n  sentinels: [{ host: 'localhost', port: 26379 }, { host: 'localhost', port: 26380 }],\n  name: 'mymaster'\n});\n\nredis.set('foo', 'bar');\n```\n\nThe arguments passed to the constructor are different from the ones you use to connect to a single node, where:\n\n* `name` identifies a group of Redis instances composed of a master and one or more slaves (`mymaster` in the example);\n* `sentinels` are a list of sentinels to connect to. The list does not need to enumerate all your sentinel instances, but a few so that if one is down the client will try the next one.\n* `role` (optional) with a value of `slave` will return a random slave from the Sentinel group.\n* `preferredSlaves` (optional) can be used to prefer a particular slave or set of slaves based on priority. It accepts a function or array.\n\nioredis **guarantees** that the node you connected to is always a master even after a failover. When a failover happens, instead of trying to reconnect to the failed node (which will be demoted to slave when it's available again), ioredis will ask sentinels for the new master node and connect to it. All commands sent during the failover are queued and will be executed when the new connection is established so that none of the commands will be lost.\n\nIt's possible to connect to a slave instead of a master by specifying the option `role` with the value of `slave` and ioredis will try to connect to a random slave of the specified master, with the guarantee that the connected node is always a slave. If the current node is promoted to master due to a failover, ioredis will disconnect from it and ask the sentinels for another slave node to connect to.\n\nIf you specify the option `preferredSlaves` along with `role: 'slave'` ioredis will attempt to use this value when selecting the slave from the pool of available slaves. The value of `preferredSlaves` should either be a function that accepts an array of avaiable slaves and returns a single result, or an array of slave values priorities by the lowest `prio` value first with a default value of `1`.\n\n```javascript\n// available slaves format\nvar availableSlaves = [{ ip: '127.0.0.1', port: '31231', flags: 'slave' }];\n\n// preferredSlaves array format\nvar preferredSlaves = [\n  { ip: '127.0.0.1', port: '31231', prio: 1 },\n  { ip: '127.0.0.1', port: '31232', prio: 2 }\n];\n\n// preferredSlaves function format\npreferredSlaves = function(availableSlaves) {\n  for (var i = 0; i < availableSlaves.length; i++) {\n    var slave = availableSlaves[i];\n    if (slave.ip === '127.0.0.1') {\n      if (slave.port === '31234') {\n        return slave;\n      }\n    }\n  }\n  // if no preferred slaves are available a random one is used\n  return false;\n};\n\nvar redis = new Redis({\n  sentinels: [{ host: '127.0.0.1', port: 26379 }, { host: '127.0.0.1', port: 26380 }],\n  name: 'mymaster',\n  role: 'slave',\n  preferredSlaves: preferredSlaves\n});\n```\n\nBesides the `retryStrategy` option, there's also a `sentinelRetryStrategy` in Sentinel mode which will be invoked when all the sentinel nodes are unreachable during connecting. If `sentinelRetryStrategy` returns a valid delay time, ioredis will try to reconnect from scratch. The default value of `sentinelRetryStrategy` is:\n\n```javascript\nfunction (times) {\n  var delay = Math.min(times * 10, 1000);\n  return delay;\n}\n```\n\n## Cluster\nRedis Cluster provides a way to run a Redis installation where data is automatically sharded across multiple Redis nodes.\nYou can connect to a Redis Cluster like this:\n\n```javascript\nvar Redis = require('ioredis');\n\nvar cluster = new Redis.Cluster([{\n  port: 6380,\n  host: '127.0.0.1'\n}, {\n  port: 6381,\n  host: '127.0.0.1'\n}]);\n\ncluster.set('foo', 'bar');\ncluster.get('foo', function (err, res) {\n  // res === 'bar'\n});\n```\n\n`Cluster` constructor accepts two arguments, where:\n\n0. The first argument is a list of nodes of the cluster you want to connect to.\nJust like Sentinel, the list does not need to enumerate all your cluster nodes,\nbut a few so that if one is unreachable the client will try the next one, and the client will discover other nodes automatically when at least one node is connected.\n0. The second argument is the options, where:\n\n    * `clusterRetryStrategy`: When none of the startup nodes are reachable, `clusterRetryStrategy` will be invoked. When a number is returned,\n    ioredis will try to reconnect to the startup nodes from scratch after the specified delay (in ms). Otherwise, an error of \"None of startup nodes is available\" will be returned.\n    The default value of this option is:\n\n        ```javascript\n        function (times) {\n          var delay = Math.min(100 + times * 2, 2000);\n          return delay;\n        }\n        ```\n\n        It's possible to modify the `startupNodes` property in order to switch to another set of nodes here:\n\n        ```javascript\n        function (times) {\n          this.startupNodes = [{ port: 6790, host: '127.0.0.1' }];\n          return Math.min(100 + times * 2, 2000);\n        }\n        ```\n\n    * `enableOfflineQueue`: Similar to the `enableOfflineQueue` option of `Redis` class.\n    * `enableReadyCheck`: When enabled, \"ready\" event will only be emitted when `CLUSTER INFO` command\n    reporting the cluster is ready for handling commands. Otherwise, it will be emitted immediately after \"connect\" is emitted.\n    * `scaleReads`: Config where to send the read queries. See below for more details.\n    * `maxRedirections`: When a cluster related error (e.g. `MOVED`, `ASK` and `CLUSTERDOWN` etc.) is received, the client will redirect the\n    command to another node. This option limits the max redirections allowed when sending a command. The default value is `16`.\n    * `retryDelayOnFailover`: If the target node is disconnected when sending a command,\n    ioredis will retry after the specified delay. The default value is `100`. You should make sure `retryDelayOnFailover * maxRedirections > cluster-node-timeout`\n    to insure that no command will fail during a failover.\n    * `retryDelayOnClusterDown`: When a cluster is down, all commands will be rejected with the error of `CLUSTERDOWN`. If this option is a number (by default, it is `100`), the client\n    will resend the commands after the specified time (in ms).\n    * `retryDelayOnTryAgain`: If this option is a number (by default, it is `100`), the client\n    will resend the commands rejected with `TRYAGAIN` error after the specified time (in ms).\n    * `redisOptions`: Default options passed to the constructor of `Redis` when connecting to a node.\n    * `slotsRefreshTimeout`: Milliseconds before a timeout occurs while refreshing slots from the cluster (default `1000`)\n    * `slotsRefreshInterval`: Milliseconds between every automatic slots refresh (default `5000`)\n\n### Read-write splitting\n\nA typical redis cluster contains three or more masters and several slaves for each master. It's possible to scale out redis cluster by sending read queries to slaves and write queries to masters by setting the `scaleReads` option.\n\n`scaleReads` is \"master\" by default, which means ioredis will never send any queries to slaves. There are other three available options:\n\n1. \"all\": Send write queries to masters and read queries to masters or slaves randomly.\n2. \"slave\": Send write queries to masters and read queries to slaves.\n3. a custom `function(nodes, command): node`: Will choose the custom function to select to which node to send read queries (write queries keep being sent to master). The first node in `nodes` is always the master serving the relevant slots. If the function returns an array of nodes, a random node of that list will be selected.\n\nFor example:\n\n```javascript\nvar cluster = new Redis.Cluster([/* nodes */], {\n  scaleReads: 'slave'\n});\ncluster.set('foo', 'bar'); // This query will be sent to one of the masters.\ncluster.get('foo', function (err, res) {\n  // This query will be sent to one of the slaves.\n});\n```\n\n**NB** In the code snippet above, the `res` may not be equal to \"bar\" because of the lag of replication between the master and slaves.\n\n### Running commands to multiple nodes\n\nEvery command will be sent to exactly one node. For commands containing keys, (e.g. `GET`, `SET` and `HGETALL`), ioredis sends them to the node that serving the keys, and for other commands not containing keys, (e.g. `INFO`, `KEYS` and `FLUSHDB`), ioredis sends them to a random node.\n\nSometimes you may want to send a command to multiple nodes (masters or slaves) of the cluster, you can get the nodes via `Cluster#nodes()` method.\n\n`Cluster#nodes()` accepts a parameter role, which can be \"master\", \"slave\" and \"all\" (default), and returns an array of `Redis` instance. For example:\n\n```javascript\n// Send `FLUSHDB` command to all slaves:\nvar slaves = cluster.nodes('slave');\nPromise.all(slaves.map(function (node) {\n  return node.flushdb();\n}));\n\n// Get keys of all the masters:\nvar masters = cluster.nodes('master');\nPromise.all(masters.map(function (node) {\n  return node.keys();\n})).then(function (keys) {\n  // keys: [['key1', 'key2'], ['key3', 'key4']]\n});\n```\n\n### Transaction and pipeline in Cluster mode\nAlmost all features that are supported by `Redis` are also supported by `Redis.Cluster`, e.g. custom commands, transaction and pipeline.\nHowever there are some differences when using transaction and pipeline in Cluster mode:\n\n0. All keys in a pipeline should belong to the same slot since ioredis sends all commands in a pipeline to the same node.\n0. You can't use `multi` without pipeline (aka `cluster.multi({ pipeline: false })`). This is because when you call `cluster.multi({ pipeline: false })`, ioredis doesn't know which node the `multi` command should be sent to.\n0. Chaining custom commands in the pipeline is not supported in Cluster mode.\n\nWhen any commands in a pipeline receives a `MOVED` or `ASK` error, ioredis will resend the whole pipeline to the specified node automatically if all of the following conditions are satisfied:\n\n0. All errors received in the pipeline are the same. For example, we won't resend the pipeline if we got two `MOVED` errors pointing to different nodes.\n0. All commands executed successfully are readonly commands. This makes sure that resending the pipeline won't have side effects.\n\n### Pub/Sub\nPub/Sub in cluster mode works exactly as the same as in standalone mode. Internally, when a node of the cluster receives a message, it will broadcast the message to the other nodes. ioredis makes sure that each message will only be received once by strictly subscribing one node at the same time.\n\n```javascript\nvar nodes = [/* nodes */];\nvar pub = new Redis.Cluster(nodes);\nvar sub = new Redis.Cluster(nodes);\nsub.on('message', function (channel, message) {\n  console.log(channel, message);\n});\n\nsub.subscribe('news', function () {\n  pub.publish('news', 'highlights');\n});\n```\n\n### Events\n\nEvent    | Description\n:------------- | :-------------\nconnect  | emits when a connection is established to the Redis server.\nready    | emits when `CLUSTER INFO` reporting the cluster is able to receive commands (if `enableReadyCheck` is `true`) or immediately after `connect` event (if `enableReadyCheck` is false).\nerror    | emits when an error occurs while connecting with a property of `lastNodeError` representing the last node error received. This event is emitted silently (only emitting if there's at least one listener).\nclose    | emits when an established Redis server connection has closed.\nreconnecting | emits after `close` when a reconnection will be made. The argument of the event is the time (in ms) before reconnecting.\nend     | emits after `close` when no more reconnections will be made.\n+node   | emits when a new node is connected.\n-node   | emits when a node is disconnected.\nnode error | emits when an error occurs when connecting to a node\n\n### Password\nSetting the `password` option to access password-proctected clusters:\n\n```javascript\nvar Redis = require('ioredis');\nvar cluster = new Redis.Cluster(nodes, {\n  redisOptions: {\n    password: 'your-cluster-password'\n  }\n});\n```\n\nIf some of nodes in the cluster using a different password, you should specify them in the first parameter:\n\n```javascript\nvar Redis = require('ioredis');\nvar cluster = new Redis.Cluster([\n  // Use password \"password-for-30001\" for 30001\n  { port: 30001, password: 'password-for-30001'},\n  // Don't use password when accessing 30002\n  { port: 30002, password: null }\n  // Other nodes will use \"fallback-password\"\n], {\n  redisOptions: {\n    password: 'fallback-password'\n  }\n});\n```\n\n<hr>\n\n# Error Handling\nAll the errors returned by the Redis server are instances of `ReplyError`, which can be accessed via `Redis`:\n\n```javascript\nvar Redis = require('ioredis');\nvar redis = new Redis();\n// This command causes a reply error since the SET command requires two arguments.\nredis.set('foo', function (err) {\n  err instanceof Redis.ReplyError\n});\n```\n\nWhen a reply error is not handled (no callback is specified, and no `catch` method is chained),\nthe error will be logged to stderr. For instance:\n\n```javascript\nvar Redis = require('ioredis');\nvar redis = new Redis();\nredis.set('foo');\n```\n\nThe following error will be printed:\n\n```\nUnhandled rejection ReplyError: ERR wrong number of arguments for 'set' command\n    at ReplyParser._parseResult (/app/node_modules/ioredis/lib/parsers/javascript.js:60:14)\n    at ReplyParser.execute (/app/node_modules/ioredis/lib/parsers/javascript.js:178:20)\n    at Socket.<anonymous> (/app/node_modules/ioredis/lib/redis/event_handler.js:99:22)\n    at Socket.emit (events.js:97:17)\n    at readableAddChunk (_stream_readable.js:143:16)\n    at Socket.Readable.push (_stream_readable.js:106:10)\n    at TCP.onread (net.js:509:20)\n```\n\nBut the error stack doesn't make any sense because the whole stack happens in the ioredis\nmodule itself, not in your code. So it's not easy to find out where the error happens in your code.\nioredis provides an option `showFriendlyErrorStack` to solve the problem. When you enable\n`showFriendlyErrorStack`, ioredis will optimize the error stack for you:\n\n```javascript\nvar Redis = require('ioredis');\nvar redis = new Redis({ showFriendlyErrorStack: true });\nredis.set('foo');\n```\n\nAnd the output will be:\n\n```\nUnhandled rejection ReplyError: ERR wrong number of arguments for 'set' command\n    at Object.<anonymous> (/app/index.js:3:7)\n    at Module._compile (module.js:446:26)\n    at Object.Module._extensions..js (module.js:464:10)\n    at Module.load (module.js:341:32)\n    at Function.Module._load (module.js:296:12)\n    at Function.Module.runMain (module.js:487:10)\n    at startup (node.js:111:16)\n    at node.js:799:3\n```\n\nThis time the stack tells you that the error happens on the third line in your code. Pretty sweet!\nHowever, it would decrease the performance significantly to optimize the error stack. So by\ndefault, this option is disabled and can only be used for debugging purposes. You **shouldn't** use this feature in a production environment.\n\nIf you want to catch all unhandled errors without decreased performance, there's another way:\n\n```javascript\nvar Redis = require('ioredis');\nRedis.Promise.onPossiblyUnhandledRejection(function (error) {\n  // you can log the error here.\n  // error.command.name is the command name, here is 'set'\n  // error.command.args is the command arguments, here is ['foo']\n});\nvar redis = new Redis();\nredis.set('foo');\n```\n\n# Plugging in your own Promises Library\nIf you're an advanced user, you may want to plug in your own promise library like [bluebird](https://www.npmjs.com/package/bluebird). Just set Redis.Promise to your favorite ES6-style promise constructor and ioredis will use it.\n\n```javascript\nconst Redis = require('ioredis')\nRedis.Promise = require('bluebird')\n\nconst redis = new Redis()\n\n// Use bluebird\nassert.equal(redis.get().constructor, require('bluebird'))\n\n// You can change the Promise implementation at any time:\nRedis.Promise = global.Promise\nassert.equal(redis.get().constructor, global.Promise)\n```\n\n\n# Running tests\n\nStart a Redis server on 127.0.0.1:6379, and then:\n\n```shell\n$ npm test\n```\n\n`FLUSH ALL` will be invoked after each test, so make sure there's no valuable data in it before running tests.\n\nIf your testing environment does not let you spin up a Redis server [ioredis-mock](https://github.com/stipsan/ioredis-mock) is a drop-in replacement you can use in your tests. It aims to behave identically to ioredis connected to a Redis server so that your integration tests is easier to write and of better quality.\n\n# Debug\n\nYou can set the `DEBUG` env to `ioredis:*` to print debug info:\n\n```shell\n$ DEBUG=ioredis:* node app.js\n```\n\n# Consolidation: It's time for celebration\n\nRight now there are two great redis clients around and both have some advantages above each other. We speak about [node_redis](https://github.com/NodeRedis/node_redis) and ioredis. So after talking to each other about how we could improve in working together we (that is [@BridgeAR](https://github.com/BridgeAR) and [@luin](https://github.com/luin)) decided to work towards a single library on the long run. But step by step.\n\nFirst of all, we want to split small parts of our libraries into others so that we're both able to use the same code. Those libraries are going to be maintained under the NodeRedis organization. This is going to reduce the maintance overhead, allows others to use the very same code, if they need it and it's way easier for others to contribute to both libraries.\n\nWe're very happy about this step towards working together as we both want to give you the best redis experience possible.\n\nIf you want to join our cause by help maintaining something, please don't hesitate to contact either one of us.\n\n# Join in!\n\nI'm happy to receive bug reports, fixes, documentation enhancements, and any other improvements.\n\nAnd since I'm not a native English speaker, if you find any grammar mistakes in the documentation, please also let me know. :)\n\n# Contributors\n\nThis project exists thanks to all the people who contribute:\n\n<table><tr><td width=\"20%\"><a href=\"https://github.com/luin\"><img src=\"https://avatars2.githubusercontent.com/u/635902?v=4\" /></a><p align=\"center\">luin</p></td><td width=\"20%\"><a href=\"https://github.com/shaharmor\"><img src=\"https://avatars3.githubusercontent.com/u/10861920?v=4\" /></a><p align=\"center\">shaharmor</p></td><td width=\"20%\"><a href=\"https://github.com/iamjochem\"><img src=\"https://avatars0.githubusercontent.com/u/792188?v=4\" /></a><p align=\"center\">iamjochem</p></td><td width=\"20%\"><a href=\"https://github.com/doublesharp\"><img src=\"https://avatars3.githubusercontent.com/u/571472?v=4\" /></a><p align=\"center\">doublesharp</p></td><td width=\"20%\"><a href=\"https://github.com/nakulgan\"><img src=\"https://avatars3.githubusercontent.com/u/189836?v=4\" /></a><p align=\"center\">nakulgan</p></td></tr><tr><td width=\"20%\"><a href=\"https://github.com/AVVS\"><img src=\"https://avatars1.githubusercontent.com/u/1713617?v=4\" /></a><p align=\"center\">AVVS</p></td><td width=\"20%\"><a href=\"https://github.com/ramonsnir\"><img src=\"https://avatars1.githubusercontent.com/u/1024028?v=4\" /></a><p align=\"center\">ramonsnir</p></td><td width=\"20%\"><a href=\"https://github.com/hayeah\"><img src=\"https://avatars2.githubusercontent.com/u/50120?v=4\" /></a><p align=\"center\">hayeah</p></td><td width=\"20%\"><a href=\"https://github.com/albin3\"><img src=\"https://avatars3.githubusercontent.com/u/6190670?v=4\" /></a><p align=\"center\">albin3</p></td><td width=\"20%\"><a href=\"https://github.com/phlip9\"><img src=\"https://avatars0.githubusercontent.com/u/918989?v=4\" /></a><p align=\"center\">phlip9</p></td></tr><tr><td width=\"20%\"><a href=\"https://github.com/chris-olszewski\"><img src=\"https://avatars1.githubusercontent.com/u/4131117?v=4\" /></a><p align=\"center\">chris-olszewski</p></td><td width=\"20%\"><a href=\"https://github.com/fracmak\"><img src=\"https://avatars1.githubusercontent.com/u/378178?v=4\" /></a><p align=\"center\">fracmak</p></td><td width=\"20%\"><a href=\"https://github.com/ddunkin\"><img src=\"https://avatars2.githubusercontent.com/u/264744?v=4\" /></a><p align=\"center\">ddunkin</p></td><td width=\"20%\"><a href=\"https://github.com/ruimarinho\"><img src=\"https://avatars0.githubusercontent.com/u/288709?v=4\" /></a><p align=\"center\">ruimarinho</p></td><td width=\"20%\"><a href=\"https://github.com/suprememoocow\"><img src=\"https://avatars0.githubusercontent.com/u/594566?v=4\" /></a><p align=\"center\">suprememoocow</p></td></tr><tr><td width=\"20%\"><a href=\"https://github.com/jpallen\"><img src=\"https://avatars0.githubusercontent.com/u/31305?v=4\" /></a><p align=\"center\">jpallen</p></td><td width=\"20%\"><a href=\"https://github.com/reconbot\"><img src=\"https://avatars2.githubusercontent.com/u/25966?v=4\" /></a><p align=\"center\">reconbot</p></td><td width=\"20%\"><a href=\"https://github.com/lpinca\"><img src=\"https://avatars0.githubusercontent.com/u/1443911?v=4\" /></a><p align=\"center\">lpinca</p></td><td width=\"20%\"><a href=\"https://github.com/frankvm04\"><img src=\"https://avatars1.githubusercontent.com/u/796475?v=4\" /></a><p align=\"center\">frankvm04</p></td><td width=\"20%\"><a href=\"https://github.com/jeffjen\"><img src=\"https://avatars3.githubusercontent.com/u/5814507?v=4\" /></a><p align=\"center\">jeffjen</p></td></tr><tr><td width=\"20%\"><a href=\"https://github.com/SamBergeron\"><img src=\"https://avatars1.githubusercontent.com/u/3879294?v=4\" /></a><p align=\"center\">SamBergeron</p></td><td width=\"20%\"><a href=\"https://github.com/seoker\"><img src=\"https://avatars1.githubusercontent.com/u/7975797?v=4\" /></a><p align=\"center\">seoker</p></td><td width=\"20%\"><a href=\"https://github.com/southpolesteve\"><img src=\"https://avatars1.githubusercontent.com/u/471400?v=4\" /></a><p align=\"center\">southpolesteve</p></td><td width=\"20%\"><a href=\"https://github.com/devaos\"><img src=\"https://avatars0.githubusercontent.com/u/5412167?v=4\" /></a><p align=\"center\">devaos</p></td><td width=\"20%\"><a href=\"https://github.com/headquarters\"><img src=\"https://avatars0.githubusercontent.com/u/347079?v=4\" /></a><p align=\"center\">headquarters</p></td></tr><tr><td width=\"20%\"><a href=\"https://github.com/9point6\"><img src=\"https://avatars1.githubusercontent.com/u/627697?v=4\" /></a><p align=\"center\">9point6</p></td><td width=\"20%\"><a href=\"https://github.com/horx\"><img src=\"https://avatars2.githubusercontent.com/u/1332618?v=4\" /></a><p align=\"center\">horx</p></td><td width=\"20%\"><a href=\"https://github.com/darrachequesne\"><img src=\"https://avatars3.githubusercontent.com/u/13031701?v=4\" /></a><p align=\"center\">darrachequesne</p></td><td width=\"20%\"><a href=\"https://github.com/damianhodgkiss\"><img src=\"https://avatars2.githubusercontent.com/u/4359427?v=4\" /></a><p align=\"center\">damianhodgkiss</p></td><td width=\"20%\"><a href=\"https://github.com/ColmHally\"><img src=\"https://avatars3.githubusercontent.com/u/20333?v=4\" /></a><p align=\"center\">ColmHally</p></td></tr><tr><td width=\"20%\"><a href=\"https://github.com/klinquist\"><img src=\"https://avatars2.githubusercontent.com/u/1343376?v=4\" /></a><p align=\"center\">klinquist</p></td><td width=\"20%\"><a href=\"https://github.com/alsotang\"><img src=\"https://avatars1.githubusercontent.com/u/1147375?v=4\" /></a><p align=\"center\">alsotang</p></td><td width=\"20%\"><a href=\"https://github.com/zhuangya\"><img src=\"https://avatars2.githubusercontent.com/u/499038?v=4\" /></a><p align=\"center\">zhuangya</p></td><td width=\"20%\"><a href=\"https://github.com/taichunmin\"><img src=\"https://avatars3.githubusercontent.com/u/2192626?v=4\" /></a><p align=\"center\">taichunmin</p></td><td width=\"20%\"><a href=\"https://github.com/Gerhut\"><img src=\"https://avatars1.githubusercontent.com/u/2500247?v=4\" /></a><p align=\"center\">Gerhut</p></td></tr><tr><td width=\"20%\"><a href=\"https://github.com/barwin\"><img src=\"https://avatars3.githubusercontent.com/u/3289?v=4\" /></a><p align=\"center\">barwin</p></td><td width=\"20%\"><a href=\"https://github.com/jcperez\"><img src=\"https://avatars0.githubusercontent.com/u/4073359?v=4\" /></a><p align=\"center\">jcperez</p></td><td width=\"20%\"><a href=\"https://github.com/pensierinmusica\"><img src=\"https://avatars1.githubusercontent.com/u/3594037?v=4\" /></a><p align=\"center\">pensierinmusica</p></td><td width=\"20%\"><a href=\"https://github.com/TeeAaTeeUu\"><img src=\"https://avatars1.githubusercontent.com/u/997511?v=4\" /></a><p align=\"center\">TeeAaTeeUu</p></td><td width=\"20%\"><a href=\"https://github.com/henstock\"><img src=\"https://avatars3.githubusercontent.com/u/13809467?v=4\" /></a><p align=\"center\">henstock</p></td></tr><tr><td width=\"20%\"><a href=\"https://github.com/i5ting\"><img src=\"https://avatars3.githubusercontent.com/u/3118295?v=4\" /></a><p align=\"center\">i5ting</p></td><td width=\"20%\"><a href=\"https://github.com/devoto13\"><img src=\"https://avatars1.githubusercontent.com/u/823594?v=4\" /></a><p align=\"center\">devoto13</p></td><td width=\"20%\"><a href=\"https://github.com/tkalfigo\"><img src=\"https://avatars2.githubusercontent.com/u/3481553?v=4\" /></a><p align=\"center\">tkalfigo</p></td><td width=\"20%\"><a href=\"https://github.com/ArtskydJ\"><img src=\"https://avatars2.githubusercontent.com/u/1833684?v=4\" /></a><p align=\"center\">ArtskydJ</p></td><td width=\"20%\"><a href=\"https://github.com/nswbmw\"><img src=\"https://avatars0.githubusercontent.com/u/4279697?v=4\" /></a><p align=\"center\">nswbmw</p></td></tr><tr><td width=\"20%\"><a href=\"https://github.com/igrcic\"><img src=\"https://avatars1.githubusercontent.com/u/394398?v=4\" /></a><p align=\"center\">igrcic</p></td><td width=\"20%\"><a href=\"https://github.com/VikramTiwari\"><img src=\"https://avatars3.githubusercontent.com/u/1330677?v=4\" /></a><p align=\"center\">VikramTiwari</p></td><td width=\"20%\"><a href=\"https://github.com/mtlima\"><img src=\"https://avatars0.githubusercontent.com/u/9111440?v=4\" /></a><p align=\"center\">mtlima</p></td><td width=\"20%\"><a href=\"https://github.com/pra85\"><img src=\"https://avatars2.githubusercontent.com/u/829526?v=4\" /></a><p align=\"center\">pra85</p></td><td width=\"20%\"><a href=\"https://github.com/joeledwards\"><img src=\"https://avatars3.githubusercontent.com/u/412853?v=4\" /></a><p align=\"center\">joeledwards</p></td></tr><tr><td width=\"20%\"><a href=\"https://github.com/dguo\"><img src=\"https://avatars0.githubusercontent.com/u/2763135?v=4\" /></a><p align=\"center\">dguo</p></td><td width=\"20%\"><a href=\"https://github.com/stipsan\"><img src=\"https://avatars2.githubusercontent.com/u/81981?v=4\" /></a><p align=\"center\">stipsan</p></td><td width=\"20%\"><a href=\"https://github.com/bradvogel\"><img src=\"https://avatars1.githubusercontent.com/u/821706?v=4\" /></a><p align=\"center\">bradvogel</p></td><td width=\"20%\"><a href=\"https://github.com/pyros2097\"><img src=\"https://avatars0.githubusercontent.com/u/1687946?v=4\" /></a><p align=\"center\">pyros2097</p></td><td width=\"20%\"><a href=\"https://github.com/tempname11\"><img src=\"https://avatars0.githubusercontent.com/u/8409150?v=4\" /></a><p align=\"center\">tempname11</p></td></tr></table>\n\n# License\n\nMIT\n","readmeFilename":"README.md","gitHead":"84a9d6202301c2d578c59388bf5f4ad2049a15be","bugs":{"url":"https://github.com/luin/ioredis/issues"},"homepage":"https://github.com/luin/ioredis#readme","_id":"ioredis@4.0.0-0","_npmVersion":"5.6.0","_nodeVersion":"8.1.0","_npmUser":{"name":"luin","email":"i@zihua.li"},"dist":{"integrity":"sha512-9fFH62SoET+sTuynVsYWKXBALFhXOpemnQ/RuV+YnOU1k8l4m5YDw5q10D/vNaOWgdn6vWZ4KlX3wnpfmJ8wNA==","shasum":"cabad20db54ed178ff8fb6299265b36e399dacd6","tarball":"https://registry.npmjs.org/ioredis/-/ioredis-4.0.0-0.tgz","fileCount":27,"unpackedSize":188612,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJbOQyGCRA9TVsSAnZWagAAErwP/3V51VePc3DFIdHDDOxt\nwzjd/PzAB+7aPqTCXqgo/t04YlzhcenurDfzKibfEz/dna0keM19GJH1zx6l\njfdEeIYoET82BjjMqs2w65V+useRnVwmbOhHXnjoId5DK719wTbqeasj+iFn\nj3Biwno6mArYZzXbdt+ukeMbF1i0PmBgxdf6n6wtoVPRdTG+WEffh6k3T12A\nUXiWFPm/EDY0I/PgF3ThJulR9DdKasMFW5ukyP3HFWv9Oko5iD1oIZgqkTzJ\nOB/txUS3XYTRtVHjZpRSTHLeAk7F0HvzV/nAO9VjmKq+XM+DsY3epvjeniHY\nRgvHZdhLXBo9O7AYDGPx8NqM7EzkMSuYA1h/xeQRqf8jsgEpw8Z2MQ/OKykV\n1Q7dMkmqd3AhOjtybrn9JVdDMyDcSKHZ08Y9hc5aAc9EIPFCw2pY+/1VRVgk\ntC2z0euW4XOUs+eHMgjEijnKAQ/R8vp53sVhZGq8HdWyqC1B/7RYICCz22Zr\nBMpzeJJZKhRpM0PdE46QziZX0aQTh6kyjQSrI91DSQOfugS0luCn5V/p9KFo\nM1M95gGD5Eftp3/dRJ3o88L89yM/fyIYgbsrF/mbyNbniPmM1bVdkwGSSn0f\nlWRgEF9l/JiEW9PhlsN/IUZw/OfQdl5mAsnxtHJSKc8a7gbrQt0FxNIFl3Nv\nlwdM\r\n=kdXN\r\n-----END PGP SIGNATURE-----\r\n"},"maintainers":[{"name":"luin","email":"i@zihua.li"}],"directories":{},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/ioredis_4.0.0-0_1530465413067_0.13227909957266037"},"_hasShrinkwrap":false},"4.0.0-1":{"name":"ioredis","version":"4.0.0-1","description":"A delightful, performance-focused Redis client for Node and io.js","main":"index.js","files":["index.js","lib/"],"scripts":{"test":"NODE_ENV=test mocha --exit","test:cov":"NODE_ENV=test node ./node_modules/istanbul/lib/cli.js cover --preserve-comments ./node_modules/mocha/bin/_mocha -- -R spec --exit","generate-docs":"jsdoc2md lib/redis.js lib/cluster/index.js lib/commander.js > API.md","bench":"matcha benchmarks/*.js"},"repository":{"type":"git","url":"git://github.com/luin/ioredis.git"},"keywords":["redis","cluster","sentinel","pipelining"],"author":{"name":"luin","email":"i@zihua.li","url":"http://zihua.li"},"license":"MIT","dependencies":{"cluster-key-slot":"^1.0.6","debug":"^3.1.0","denque":"^1.1.0","flexbuffer":"0.0.6","lodash.bind":"^4.2.1","lodash.clone":"^4.5.0","lodash.clonedeep":"^4.5.0","lodash.defaults":"^4.2.0","lodash.difference":"^4.5.0","lodash.flatten":"^4.4.0","lodash.foreach":"^4.5.0","lodash.isempty":"^4.4.0","lodash.partial":"^4.2.1","lodash.pick":"^4.4.0","lodash.sample":"^4.2.1","lodash.shuffle":"^4.2.0","lodash.values":"^4.3.0","redis-commands":"^1.2.0","redis-parser":"^2.6.0","standard-as-callback":"^1.0.0"},"devDependencies":{"bluebird":"^3.5.1","chai":"^3.5.0","cz-conventional-changelog":"^2.0.0","istanbul":"^0.4.2","jsdoc":"^3.4.0","jsdoc-to-markdown":"^4.0.1","mocha":"^5.2.0","server-destroy":"^1.0.1","sinon":"^1.17.3"},"engines":{"node":">=4"},"config":{"commitizen":{"path":"./node_modules/cz-conventional-changelog"}},"readme":"[![ioredis](https://cdn.rawgit.com/luin/ioredis/57b5b89e3e9111ff25d8c62c0bc58ed42e5b8d1e/logo.svg)](https://github.com/luin/ioredis)\n\n[![Build Status](https://travis-ci.org/luin/ioredis.svg?branch=master)](https://travis-ci.org/luin/ioredis)\n[![Test Coverage](https://codeclimate.com/github/luin/ioredis/badges/coverage.svg)](https://codeclimate.com/github/luin/ioredis)\n[![Code Climate](https://codeclimate.com/github/luin/ioredis/badges/gpa.svg)](https://codeclimate.com/github/luin/ioredis)\n[![Commitizen friendly](https://img.shields.io/badge/commitizen-friendly-brightgreen.svg)](http://commitizen.github.io/cz-cli/)\n[![Join the chat at https://gitter.im/luin/ioredis](https://badges.gitter.im/Join%20Chat.svg)](https://gitter.im/luin/ioredis?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge)\n\nA robust, performance-focused and full-featured [Redis](http://redis.io) client for [Node](https://nodejs.org) and [io.js](https://iojs.org).\n\nSupports Redis >= 2.6.12 and (Node.js >= 6).\n\n# Features\nioredis is a robust, full-featured Redis client that is\nused in the world's biggest online commerce company [Alibaba](http://www.alibaba.com/) and many other awesome companies.\n\n0. Full-featured. It supports [Cluster](http://redis.io/topics/cluster-tutorial), [Sentinel](http://redis.io/topics/sentinel), [Pipelining](http://redis.io/topics/pipelining) and of course [Lua scripting](http://redis.io/commands/eval) & [Pub/Sub](http://redis.io/topics/pubsub) (with the support of binary messages).\n0. High performance.\n0. Delightful API. It works with Node callbacks and Native promises.\n0. Transformation of command arguments and replies.\n0. Transparent key prefixing.\n0. Abstraction for Lua scripting, allowing you to define custom commands.\n0. Support for binary data.\n0. Support for TLS.\n0. Support for offline queue and ready checking.\n0. Support for ES6 types, such as `Map` and `Set`.\n0. Support for GEO commands (Redis 3.2 Unstable).\n0. Sophisticated error handling strategy.\n\n# Links\n* [API Documentation](API.md)\n* [Changelog](Changelog.md)\n* [Migrating from node_redis](https://github.com/luin/ioredis/wiki/Migrating-from-node_redis)\n* [Error Handling](#error-handling)\n\n## Become a Sponsor to Support ioredis's Development\nOpen source is hard and time-consuming. If you want to invest in ioredis's future you can become a sponsor and make us spend more time on this library's improvements and new features.\n\n<a href=\"https://opencollective.com/ioredis\"><img src=\"https://opencollective.com/ioredis/tiers/sponsor.svg?avatarHeight=36\"></a>\n\nThank you for using ioredis :-)\n\n<hr>\n<a href=\"https://itunes.apple.com/app/medis-gui-for-redis/id1063631769\"><img align=\"right\" src=\"medis.png\" alt=\"Download on the App Store\"></a>\n\n\n### Advertisement\n\nLooking for a Redis GUI manager for OS X, Windows and Linux? Here's [Medis](https://itunes.apple.com/us/app/medis-gui-for-redis/id1063631769)!\n\nMedis is an open-sourced, beautiful, easy-to-use Redis GUI management application.\n\nMedis starts with all the basic features you need:\n\n* Keys viewing/editing\n* SSH Tunnel for connecting with remote servers\n* Terminal for executing custom commands\n* JSON/MessagePack format viewing/editing and built-in highlighting/validator\n* And other awesome features...\n\n[Medis is open sourced on GitHub](https://github.com/luin/medis)\n\n<hr>\n\n# Quick Start\n\n## Install\n```shell\n$ npm install ioredis\n```\n\n## Basic Usage\n\n```javascript\nvar Redis = require('ioredis');\nvar redis = new Redis();\n\nredis.set('foo', 'bar');\nredis.get('foo', function (err, result) {\n  console.log(result);\n});\n\n// Or using a promise if the last argument isn't a function\nredis.get('foo').then(function (result) {\n  console.log(result);\n});\n\n// Arguments to commands are flattened, so the following are the same:\nredis.sadd('set', 1, 3, 5, 7);\nredis.sadd('set', [1, 3, 5, 7]);\n\n// All arguments are passed directly to the redis server:\nredis.set('key', 100, 'EX', 10);\n```\n\nSee the `examples/` folder for more examples.\n\n## Connect to Redis\nWhen a new `Redis` instance is created,\na connection to Redis will be created at the same time.\nYou can specify which Redis to connect to by:\n\n```javascript\nnew Redis()       // Connect to 127.0.0.1:6379\nnew Redis(6380)   // 127.0.0.1:6380\nnew Redis(6379, '192.168.1.1')        // 192.168.1.1:6379\nnew Redis('/tmp/redis.sock')\nnew Redis({\n  port: 6379,          // Redis port\n  host: '127.0.0.1',   // Redis host\n  family: 4,           // 4 (IPv4) or 6 (IPv6)\n  password: 'auth',\n  db: 0\n})\n```\n\nYou can also specify connection options as a [`redis://` URL](http://www.iana.org/assignments/uri-schemes/prov/redis):\n\n```javascript\n// Connect to 127.0.0.1:6380, db 4, using password \"authpassword\":\nnew Redis('redis://:authpassword@127.0.0.1:6380/4')\n```\n\nSee [API Documentation](API.md#new_Redis) for all available options.\n\n## Pub/Sub\n\nHere is a simple example of the API for publish/subscribe.\nThe following program opens two client connections.\nIt subscribes to a channel with one connection\nand publishes to that channel with the other:\n\n```javascript\nvar Redis = require('ioredis');\nvar redis = new Redis();\nvar pub = new Redis();\nredis.subscribe('news', 'music', function (err, count) {\n  // Now we are subscribed to both the 'news' and 'music' channels.\n  // `count` represents the number of channels we are currently subscribed to.\n\n  pub.publish('news', 'Hello world!');\n  pub.publish('music', 'Hello again!');\n});\n\nredis.on('message', function (channel, message) {\n  // Receive message Hello world! from channel news\n  // Receive message Hello again! from channel music\n  console.log('Receive message %s from channel %s', message, channel);\n});\n\n// There's also an event called 'messageBuffer', which is the same as 'message' except\n// it returns buffers instead of strings.\nredis.on('messageBuffer', function (channel, message) {\n  // Both `channel` and `message` are buffers.\n});\n```\n\n`PSUBSCRIBE` is also supported in a similar way:\n\n```javascript\nredis.psubscribe('pat?ern', function (err, count) {});\nredis.on('pmessage', function (pattern, channel, message) {});\nredis.on('pmessageBuffer', function (pattern, channel, message) {});\n```\n\nWhen a client issues a SUBSCRIBE or PSUBSCRIBE, that connection is put into a \"subscriber\" mode.\nAt that point, only commands that modify the subscription set are valid.\nWhen the subscription set is empty, the connection is put back into regular mode.\n\nIf you need to send regular commands to Redis while in subscriber mode, just open another connection.\n\n## Handle Binary Data\nArguments can be buffers:\n```javascript\nredis.set('foo', new Buffer('bar'));\n```\n\nAnd every command has a method that returns a Buffer (by adding a suffix of \"Buffer\" to the command name).\nTo get a buffer instead of a utf8 string:\n\n```javascript\nredis.getBuffer('foo', function (err, result) {\n  // result is a buffer.\n});\n```\n\n## Pipelining\nIf you want to send a batch of commands (e.g. > 5), you can use pipelining to queue\nthe commands in memory and then send them to Redis all at once. This way the performance improves by 50%~300% (See [benchmark section](#benchmark)).\n\n`redis.pipeline()` creates a `Pipeline` instance. You can call any Redis\ncommands on it just like the `Redis` instance. The commands are queued in memory\nand flushed to Redis by calling the `exec` method:\n\n```javascript\nvar pipeline = redis.pipeline();\npipeline.set('foo', 'bar');\npipeline.del('cc');\npipeline.exec(function (err, results) {\n  // `err` is always null, and `results` is an array of responses\n  // corresponding to the sequence of queued commands.\n  // Each response follows the format `[err, result]`.\n});\n\n// You can even chain the commands:\nredis.pipeline().set('foo', 'bar').del('cc').exec(function (err, results) {\n});\n\n// `exec` also returns a Promise:\nvar promise = redis.pipeline().set('foo', 'bar').get('foo').exec();\npromise.then(function (result) {\n  // result === [[null, 'OK'], [null, 'bar']]\n});\n```\n\nEach chained command can also have a callback, which will be invoked when the command\ngets a reply:\n\n```javascript\nredis.pipeline().set('foo', 'bar').get('foo', function (err, result) {\n  // result === 'bar'\n}).exec(function (err, result) {\n  // result[1][1] === 'bar'\n});\n```\n\nIn addition to adding commands to the `pipeline` queue individually, you can also pass an array of commands and arguments to the constructor:\n\n```javascript\nredis.pipeline([\n  ['set', 'foo', 'bar'],\n  ['get', 'foo']\n]).exec(function () { /* ... */ });\n```\n\n`#length` property shows how many commands in the pipeline:\n\n```javascript\nconst length = redis.pipeline().set('foo', 'bar').get('foo').length;\n// length === 2\n```\n\n\n## Transaction\nMost of the time, the transaction commands `multi` & `exec` are used together with pipeline.\nTherefore, when `multi` is called, a `Pipeline` instance is created automatically by default,\nso you can use `multi` just like `pipeline`:\n\n```javascript\nredis.multi().set('foo', 'bar').get('foo').exec(function (err, results) {\n  // results === [[null, 'OK'], [null, 'bar']]\n});\n```\nIf there's a syntax error in the transaction's command chain (e.g. wrong number of arguments, wrong command name, etc),\nthen none of the commands would be executed, and an error is returned:\n\n```javascript\nredis.multi().set('foo').set('foo', 'new value').exec(function (err, results) {\n  // err:\n  //  { [ReplyError: EXECABORT Transaction discarded because of previous errors.]\n  //    name: 'ReplyError',\n  //    message: 'EXECABORT Transaction discarded because of previous errors.',\n  //    command: { name: 'exec', args: [] },\n  //    previousErrors:\n  //     [ { [ReplyError: ERR wrong number of arguments for 'set' command]\n  //         name: 'ReplyError',\n  //         message: 'ERR wrong number of arguments for \\'set\\' command',\n  //         command: [Object] } ] }\n});\n```\n\nIn terms of the interface, `multi` differs from `pipeline` in that when specifying a callback\nto each chained command, the queueing state is passed to the callback instead of the result of the command:\n\n```javascript\nredis.multi().set('foo', 'bar', function (err, result) {\n  // result === 'QUEUED'\n}).exec(/* ... */);\n```\n\nIf you want to use transaction without pipeline, pass `{ pipeline: false }` to `multi`,\nand every command will be sent to Redis immediately without waiting for an `exec` invocation:\n\n```javascript\nredis.multi({ pipeline: false });\nredis.set('foo', 'bar');\nredis.get('foo');\nredis.exec(function (err, result) {\n  // result === [[null, 'OK'], [null, 'bar']]\n});\n```\n\nThe constructor of `multi` also accepts a batch of commands:\n\n```javascript\nredis.multi([\n  ['set', 'foo', 'bar'],\n  ['get', 'foo']\n]).exec(function () { /* ... */ });\n```\n\nInline transactions are supported by pipeline, which means you can group a subset of commands\nin the pipeline into a transaction:\n\n```javascript\nredis.pipeline().get('foo').multi().set('foo', 'bar').get('foo').exec().get('foo').exec();\n```\n\n## Lua Scripting\nioredis supports all of the scripting commands such as `EVAL`, `EVALSHA` and `SCRIPT`.\nHowever, it's tedious to use in real world scenarios since developers have to take\ncare of script caching and to detect when to use `EVAL` and when to use `EVALSHA`.\nioredis expose a `defineCommand` method to make scripting much easier to use:\n\n```javascript\nvar redis = new Redis();\n\n// This will define a command echo:\nredis.defineCommand('echo', {\n  numberOfKeys: 2,\n  lua: 'return {KEYS[1],KEYS[2],ARGV[1],ARGV[2]}'\n});\n\n// Now `echo` can be used just like any other ordinary command,\n// and ioredis will try to use `EVALSHA` internally when possible for better performance.\nredis.echo('k1', 'k2', 'a1', 'a2', function (err, result) {\n  // result === ['k1', 'k2', 'a1', 'a2']\n});\n\n// `echoBuffer` is also defined automatically to return buffers instead of strings:\nredis.echoBuffer('k1', 'k2', 'a1', 'a2', function (err, result) {\n  // result[0] === new Buffer('k1');\n});\n\n// And of course it works with pipeline:\nredis.pipeline().set('foo', 'bar').echo('k1', 'k2', 'a1', 'a2').exec();\n```\n\nIf the number of keys can't be determined when defining a command, you can\nomit the `numberOfKeys` property and pass the number of keys as the first argument\nwhen you call the command:\n\n```javascript\nredis.defineCommand('echoDynamicKeyNumber', {\n  lua: 'return {KEYS[1],KEYS[2],ARGV[1],ARGV[2]}'\n});\n\n// Now you have to pass the number of keys as the first argument every time\n// you invoke the `echoDynamicKeyNumber` command:\nredis.echoDynamicKeyNumber(2, 'k1', 'k2', 'a1', 'a2', function (err, result) {\n  // result === ['k1', 'k2', 'a1', 'a2']\n});\n```\n\n## Transparent Key Prefixing\nThis feature allows you to specify a string that will automatically be prepended\nto all the keys in a command, which makes it easier to manage your key\nnamespaces.\n\n**Warning** This feature won't apply to commands like [KEYS](http://redis.io/commands/KEYS) and [SCAN](http://redis.io/commands/scan) that take patterns rather than actual keys([#239](https://github.com/luin/ioredis/issues/239)),\nand this feature also won't apply to the replies of commands even they are key names ([#325](https://github.com/luin/ioredis/issues/325)).\n\n```javascript\nvar fooRedis = new Redis({ keyPrefix: 'foo:' });\nfooRedis.set('bar', 'baz');  // Actually sends SET foo:bar baz\n\nfooRedis.defineCommand('echo', {\n  numberOfKeys: 2,\n  lua: 'return {KEYS[1],KEYS[2],ARGV[1],ARGV[2]}'\n});\n\n// Works well with pipelining/transaction\nfooRedis.pipeline()\n  // Sends SORT foo:list BY foo:weight_*->fieldname\n  .sort('list', 'BY', 'weight_*->fieldname')\n  // Supports custom commands\n  // Sends EVALSHA xxx foo:k1 foo:k2 a1 a2\n  .echo('k1', 'k2', 'a1', 'a2')\n  .exec()\n```\n\n## Transforming Arguments & Replies\nMost Redis commands take one or more Strings as arguments,\nand replies are sent back as a single String or an Array of Strings. However, sometimes\nyou may want something different. For instance, it would be more convenient if the `HGETALL`\ncommand returns a hash (e.g. `{ key: val1, key2: v2 }`) rather than an array of key values (e.g. `[key1, val1, key2, val2]`).\n\nioredis has a flexible system for transforming arguments and replies. There are two types\nof transformers, argument transformer and reply transformer:\n\n```javascript\nvar Redis = require('ioredis');\n\n// Here's the built-in argument transformer converting\n// hmset('key', { k1: 'v1', k2: 'v2' })\n// or\n// hmset('key', new Map([['k1', 'v1'], ['k2', 'v2']]))\n// into\n// hmset('key', 'k1', 'v1', 'k2', 'v2')\nRedis.Command.setArgumentTransformer('hmset', function (args) {\n  if (args.length === 2) {\n    if (typeof Map !== 'undefined' && args[1] instanceof Map) {\n      // utils is a internal module of ioredis\n      return [args[0]].concat(utils.convertMapToArray(args[1]));\n    }\n    if ( typeof args[1] === 'object' && args[1] !== null) {\n      return [args[0]].concat(utils.convertObjectToArray(args[1]));\n    }\n  }\n  return args;\n});\n\n// Here's the built-in reply transformer converting the HGETALL reply\n// ['k1', 'v1', 'k2', 'v2']\n// into\n// { k1: 'v1', 'k2': 'v2' }\nRedis.Command.setReplyTransformer('hgetall', function (result) {\n  if (Array.isArray(result)) {\n    var obj = {};\n    for (var i = 0; i < result.length; i += 2) {\n      obj[result[i]] = result[i + 1];\n    }\n    return obj;\n  }\n  return result;\n});\n```\n\nThere are three built-in transformers, two argument transformers for `hmset` & `mset` and\na reply transformer for `hgetall`. Transformers for `hmset` and `hgetall` were mentioned\nabove, and the transformer for `mset` is similar to the one for `hmset`:\n\n```javascript\nredis.mset({ k1: 'v1', k2: 'v2' });\nredis.get('k1', function (err, result) {\n  // result === 'v1';\n});\n\nredis.mset(new Map([['k3', 'v3'], ['k4', 'v4']]));\nredis.get('k3', function (err, result) {\n  // result === 'v3';\n});\n```\n\nAnother useful example of a reply transformer is one that changes `hgetall` to return array of arrays instead of objects which avoids a unwanted conversation of hash keys to strings when dealing with binary hash keys:\n\n```javascript\nRedis.Command.setReplyTransformer('hgetall', function (result) {\n  var arr = [];\n  for (var i = 0; i < result.length; i += 2) {\n    arr.push([result[i], result[i + 1]]);\n  }\n  return arr;\n});\nredis.hset('h1', Buffer.from([0x01]), Buffer.from([0x02]));\nredis.hset('h1', Buffer.from([0x03]), Buffer.from([0x04]));\nredis.hgetallBuffer('h1', function (err, result) {\n  // result === [ [ <Buffer 01>, <Buffer 02> ], [ <Buffer 03>, <Buffer 04> ] ];\n});\n```\n\n## Monitor\nRedis supports the MONITOR command,\nwhich lets you see all commands received by the Redis server across all client connections,\nincluding from other client libraries and other computers.\n\nThe `monitor` method returns a monitor instance.\nAfter you send the MONITOR command, no other commands are valid on that connection. ioredis will emit a monitor event for every new monitor message that comes across.\nThe callback for the monitor event takes a timestamp from the Redis server and an array of command arguments.\n\nHere is a simple example:\n\n```javascript\nredis.monitor(function (err, monitor) {\n  monitor.on('monitor', function (time, args, source, database) {\n  });\n});\n```\n\n## Streamify Scanning\nRedis 2.8 added the `SCAN` command to incrementally iterate through the keys in the database. It's different from `KEYS` in that\n`SCAN` only returns a small number of elements each call, so it can be used in production without the downside\nof blocking the server for a long time. However, it requires recording the cursor on the client side each time\nthe `SCAN` command is called in order to iterate through all the keys correctly. Since it's a relatively common use case, ioredis\nprovides a streaming interface for the `SCAN` command to make things much easier. A readable stream can be created by calling `scanStream`:\n\n```javascript\nvar redis = new Redis();\n// Create a readable stream (object mode)\nvar stream = redis.scanStream();\nvar keys = [];\nstream.on('data', function (resultKeys) {\n  // `resultKeys` is an array of strings representing key names.\n  // Note that resultKeys may contain 0 keys.\n  for (var i = 0; i < resultKeys.length; i++) {\n    keys.push(resultKeys[i]);\n  }\n});\nstream.on('end', function () {\n  console.log('done with the keys: ', keys);\n});\n```\n\n`scanStream` accepts an option, with which you can specify the `MATCH` pattern and the `COUNT` argument:\n\n```javascript\nvar stream = redis.scanStream({\n  // only returns keys following the pattern of `user:*`\n  match: 'user:*',\n  // returns approximately 100 elements per call\n  count: 100\n});\n```\n\nJust like other commands, `scanStream` has a binary version `scanBufferStream`, which returns an array of buffers. It's useful when\nthe key names are not utf8 strings.\n\nThere are also `hscanStream`, `zscanStream` and `sscanStream` to iterate through elements in a hash, zset and set. The interface of each is\nsimilar to `scanStream` except the first argument is the key name:\n\n```javascript\nvar stream = redis.hscanStream('myhash', {\n  match: 'age:??'\n});\n```\n\nYou can learn more from the [Redis documentation](http://redis.io/commands/scan).\n\n**Useful Tips**\nIt's pretty common that doing an async task in the `data` handler. We'd like the scanning process to be paused until the async task to be finished. `Stream#pause()` and `Stream.resume()` do the trick. For example if we want to migrate data in Redis to MySQL:\n\n```javascript\nvar stream = redis.scanStream();\nstream.on('data', function (resultKeys) {\n  // Pause the stream from scanning more keys until we've migrated the current keys.\n  stream.pause();\n\n  Promise.all(resultKeys.map(migrateKeyToMySQL)).then(() => {\n    // Resume the stream here.\n    stream.resume();\n  });\n});\n\nstream.on('end', function () {\n  console.log('done migration');\n});\n```\n\n## Auto-reconnect\nBy default, ioredis will try to reconnect when the connection to Redis is lost\nexcept when the connection is closed manually by `redis.disconnect()` or `redis.quit()`.\n\nIt's very flexible to control how long to wait to reconnect after disconnection\nusing the `retryStrategy` option:\n\n```javascript\nvar redis = new Redis({\n  // This is the default value of `retryStrategy`\n  retryStrategy: function (times) {\n    var delay = Math.min(times * 50, 2000);\n    return delay;\n  }\n});\n```\n\n`retryStrategy` is a function that will be called when the connection is lost.\nThe argument `times` means this is the nth reconnection being made and\nthe return value represents how long (in ms) to wait to reconnect. When the\nreturn value isn't a number, ioredis will stop trying to reconnect, and the connection\nwill be lost forever if the user doesn't call `redis.connect()` manually.\n\nWhen reconnected, the client will auto subscribe to channels that the previous connection subscribed to.\nThis behavior can be disabled by setting the `autoResubscribe` option to `false`.\n\nAnd if the previous connection has some unfulfilled commands (most likely blocking commands such as `brpop` and `blpop`),\nthe client will resend them when reconnected. This behavior can be disabled by setting the `autoResendUnfulfilledCommands` option to `false`.\n\nBy default, all pending commands will be flushed with an error every 20 retry attempts. That makes sure commands won't wait forever when the connection is down. You can change this behavior by setting `maxRetriesPerRequest`:\n\n```javascript\nvar redis = new Redis({\n  maxRetriesPerRequest: 1\n});\n```\n\nSet maxRetriesPerRequest to `null` to disable this behavior, and every command will wait forever until the connection is alive again (which is the default behavior before ioredis v4).\n\n### Reconnect on error\n\nBesides auto-reconnect when the connection is closed, ioredis supports reconnecting on the specified errors by the `reconnectOnError` option. Here's an example that will reconnect when receiving `READONLY` error:\n\n```javascript\nvar redis = new Redis({\n  reconnectOnError: function (err) {\n    var targetError = 'READONLY';\n    if (err.message.slice(0, targetError.length) === targetError) {\n      // Only reconnect when the error starts with \"READONLY\"\n      return true; // or `return 1;`\n    }\n  }\n});\n```\n\nThis feature is useful when using Amazon ElastiCache. Once failover happens, Amazon ElastiCache will switch the master we currently connected with to a slave, leading to the following writes fails with the error `READONLY`. Using `reconnectOnError`, we can force the connection to reconnect on this error in order to connect to the new master.\n\nFurthermore, if the `reconnectOnError` returns `2`, ioredis will resend the failed command after reconnecting.\n\n## Connection Events\nThe Redis instance will emit some events about the state of the connection to the Redis server.\n\nEvent    | Description\n:------------- | :-------------\nconnect  | emits when a connection is established to the Redis server.\nready    | If `enableReadyCheck` is `true`, client will emit `ready` when the server reports that it is ready to receive commands (e.g. finish loading data from disk).<br>Otherwise, `ready` will be emitted immediately right after the `connect` event.\nerror    | emits when an error occurs while connecting.<br>However, ioredis emits all `error` events silently (only emits when there's at least one listener) so that your application won't crash if you're not listening to the `error` event.\nclose    | emits when an established Redis server connection has closed.\nreconnecting | emits after `close` when a reconnection will be made. The argument of the event is the time (in ms) before reconnecting.\nend     | emits after `close` when no more reconnections will be made, or the connection is failed to establish.\n\nYou can also check out the `Redis#status` property to get the current connection status.\n\nBesides the above connection events, there are several other custom events:\n\nEvent    | Description\n:------------- | :-------------\nselect   | emits when the database changed. The argument is the new db number.\n\n## Offline Queue\nWhen a command can't be processed by Redis (being sent before the `ready` event), by default, it's added to the offline queue and will be\nexecuted when it can be processed. You can disable this feature by setting the `enableOfflineQueue`\noption to `false`:\n\n```javascript\nvar redis = new Redis({ enableOfflineQueue: false });\n```\n\n## TLS Options\nRedis doesn't support TLS natively, however if the redis server you want to connect to is hosted behind a TLS proxy (e.g. [stunnel](https://www.stunnel.org/)) or is offered by a PaaS service that supports TLS connection (e.g. [Redis Labs](https://redislabs.com/)), you can set the `tls` option:\n\n```javascript\nvar redis = new Redis({\n  host: 'localhost',\n  tls: {\n    // Refer to `tls.connect()` section in\n    // https://nodejs.org/api/tls.html\n    // for all supported options\n    ca: fs.readFileSync('cert.pem')\n  }\n});\n```\n\n<hr>\n\n## Sentinel\nioredis supports Sentinel out of the box. It works transparently as all features that work when\nyou connect to a single node also work when you connect to a sentinel group. Make sure to run Redis >= 2.8.12 if you want to use this feature. Sentinels have a default port of 26379.\n\nTo connect using Sentinel, use:\n\n```javascript\nvar redis = new Redis({\n  sentinels: [{ host: 'localhost', port: 26379 }, { host: 'localhost', port: 26380 }],\n  name: 'mymaster'\n});\n\nredis.set('foo', 'bar');\n```\n\nThe arguments passed to the constructor are different from the ones you use to connect to a single node, where:\n\n* `name` identifies a group of Redis instances composed of a master and one or more slaves (`mymaster` in the example);\n* `sentinels` are a list of sentinels to connect to. The list does not need to enumerate all your sentinel instances, but a few so that if one is down the client will try the next one.\n* `role` (optional) with a value of `slave` will return a random slave from the Sentinel group.\n* `preferredSlaves` (optional) can be used to prefer a particular slave or set of slaves based on priority. It accepts a function or array.\n\nioredis **guarantees** that the node you connected to is always a master even after a failover. When a failover happens, instead of trying to reconnect to the failed node (which will be demoted to slave when it's available again), ioredis will ask sentinels for the new master node and connect to it. All commands sent during the failover are queued and will be executed when the new connection is established so that none of the commands will be lost.\n\nIt's possible to connect to a slave instead of a master by specifying the option `role` with the value of `slave` and ioredis will try to connect to a random slave of the specified master, with the guarantee that the connected node is always a slave. If the current node is promoted to master due to a failover, ioredis will disconnect from it and ask the sentinels for another slave node to connect to.\n\nIf you specify the option `preferredSlaves` along with `role: 'slave'` ioredis will attempt to use this value when selecting the slave from the pool of available slaves. The value of `preferredSlaves` should either be a function that accepts an array of avaiable slaves and returns a single result, or an array of slave values priorities by the lowest `prio` value first with a default value of `1`.\n\n```javascript\n// available slaves format\nvar availableSlaves = [{ ip: '127.0.0.1', port: '31231', flags: 'slave' }];\n\n// preferredSlaves array format\nvar preferredSlaves = [\n  { ip: '127.0.0.1', port: '31231', prio: 1 },\n  { ip: '127.0.0.1', port: '31232', prio: 2 }\n];\n\n// preferredSlaves function format\npreferredSlaves = function(availableSlaves) {\n  for (var i = 0; i < availableSlaves.length; i++) {\n    var slave = availableSlaves[i];\n    if (slave.ip === '127.0.0.1') {\n      if (slave.port === '31234') {\n        return slave;\n      }\n    }\n  }\n  // if no preferred slaves are available a random one is used\n  return false;\n};\n\nvar redis = new Redis({\n  sentinels: [{ host: '127.0.0.1', port: 26379 }, { host: '127.0.0.1', port: 26380 }],\n  name: 'mymaster',\n  role: 'slave',\n  preferredSlaves: preferredSlaves\n});\n```\n\nBesides the `retryStrategy` option, there's also a `sentinelRetryStrategy` in Sentinel mode which will be invoked when all the sentinel nodes are unreachable during connecting. If `sentinelRetryStrategy` returns a valid delay time, ioredis will try to reconnect from scratch. The default value of `sentinelRetryStrategy` is:\n\n```javascript\nfunction (times) {\n  var delay = Math.min(times * 10, 1000);\n  return delay;\n}\n```\n\n## Cluster\nRedis Cluster provides a way to run a Redis installation where data is automatically sharded across multiple Redis nodes.\nYou can connect to a Redis Cluster like this:\n\n```javascript\nvar Redis = require('ioredis');\n\nvar cluster = new Redis.Cluster([{\n  port: 6380,\n  host: '127.0.0.1'\n}, {\n  port: 6381,\n  host: '127.0.0.1'\n}]);\n\ncluster.set('foo', 'bar');\ncluster.get('foo', function (err, res) {\n  // res === 'bar'\n});\n```\n\n`Cluster` constructor accepts two arguments, where:\n\n0. The first argument is a list of nodes of the cluster you want to connect to.\nJust like Sentinel, the list does not need to enumerate all your cluster nodes,\nbut a few so that if one is unreachable the client will try the next one, and the client will discover other nodes automatically when at least one node is connected.\n0. The second argument is the options, where:\n\n    * `clusterRetryStrategy`: When none of the startup nodes are reachable, `clusterRetryStrategy` will be invoked. When a number is returned,\n    ioredis will try to reconnect to the startup nodes from scratch after the specified delay (in ms). Otherwise, an error of \"None of startup nodes is available\" will be returned.\n    The default value of this option is:\n\n        ```javascript\n        function (times) {\n          var delay = Math.min(100 + times * 2, 2000);\n          return delay;\n        }\n        ```\n\n        It's possible to modify the `startupNodes` property in order to switch to another set of nodes here:\n\n        ```javascript\n        function (times) {\n          this.startupNodes = [{ port: 6790, host: '127.0.0.1' }];\n          return Math.min(100 + times * 2, 2000);\n        }\n        ```\n\n    * `enableOfflineQueue`: Similar to the `enableOfflineQueue` option of `Redis` class.\n    * `enableReadyCheck`: When enabled, \"ready\" event will only be emitted when `CLUSTER INFO` command\n    reporting the cluster is ready for handling commands. Otherwise, it will be emitted immediately after \"connect\" is emitted.\n    * `scaleReads`: Config where to send the read queries. See below for more details.\n    * `maxRedirections`: When a cluster related error (e.g. `MOVED`, `ASK` and `CLUSTERDOWN` etc.) is received, the client will redirect the\n    command to another node. This option limits the max redirections allowed when sending a command. The default value is `16`.\n    * `retryDelayOnFailover`: If the target node is disconnected when sending a command,\n    ioredis will retry after the specified delay. The default value is `100`. You should make sure `retryDelayOnFailover * maxRedirections > cluster-node-timeout`\n    to insure that no command will fail during a failover.\n    * `retryDelayOnClusterDown`: When a cluster is down, all commands will be rejected with the error of `CLUSTERDOWN`. If this option is a number (by default, it is `100`), the client\n    will resend the commands after the specified time (in ms).\n    * `retryDelayOnTryAgain`: If this option is a number (by default, it is `100`), the client\n    will resend the commands rejected with `TRYAGAIN` error after the specified time (in ms).\n    * `redisOptions`: Default options passed to the constructor of `Redis` when connecting to a node.\n    * `slotsRefreshTimeout`: Milliseconds before a timeout occurs while refreshing slots from the cluster (default `1000`)\n    * `slotsRefreshInterval`: Milliseconds between every automatic slots refresh (default `5000`)\n\n### Read-write splitting\n\nA typical redis cluster contains three or more masters and several slaves for each master. It's possible to scale out redis cluster by sending read queries to slaves and write queries to masters by setting the `scaleReads` option.\n\n`scaleReads` is \"master\" by default, which means ioredis will never send any queries to slaves. There are other three available options:\n\n1. \"all\": Send write queries to masters and read queries to masters or slaves randomly.\n2. \"slave\": Send write queries to masters and read queries to slaves.\n3. a custom `function(nodes, command): node`: Will choose the custom function to select to which node to send read queries (write queries keep being sent to master). The first node in `nodes` is always the master serving the relevant slots. If the function returns an array of nodes, a random node of that list will be selected.\n\nFor example:\n\n```javascript\nvar cluster = new Redis.Cluster([/* nodes */], {\n  scaleReads: 'slave'\n});\ncluster.set('foo', 'bar'); // This query will be sent to one of the masters.\ncluster.get('foo', function (err, res) {\n  // This query will be sent to one of the slaves.\n});\n```\n\n**NB** In the code snippet above, the `res` may not be equal to \"bar\" because of the lag of replication between the master and slaves.\n\n### Running commands to multiple nodes\n\nEvery command will be sent to exactly one node. For commands containing keys, (e.g. `GET`, `SET` and `HGETALL`), ioredis sends them to the node that serving the keys, and for other commands not containing keys, (e.g. `INFO`, `KEYS` and `FLUSHDB`), ioredis sends them to a random node.\n\nSometimes you may want to send a command to multiple nodes (masters or slaves) of the cluster, you can get the nodes via `Cluster#nodes()` method.\n\n`Cluster#nodes()` accepts a parameter role, which can be \"master\", \"slave\" and \"all\" (default), and returns an array of `Redis` instance. For example:\n\n```javascript\n// Send `FLUSHDB` command to all slaves:\nvar slaves = cluster.nodes('slave');\nPromise.all(slaves.map(function (node) {\n  return node.flushdb();\n}));\n\n// Get keys of all the masters:\nvar masters = cluster.nodes('master');\nPromise.all(masters.map(function (node) {\n  return node.keys();\n})).then(function (keys) {\n  // keys: [['key1', 'key2'], ['key3', 'key4']]\n});\n```\n\n### Transaction and pipeline in Cluster mode\nAlmost all features that are supported by `Redis` are also supported by `Redis.Cluster`, e.g. custom commands, transaction and pipeline.\nHowever there are some differences when using transaction and pipeline in Cluster mode:\n\n0. All keys in a pipeline should belong to the same slot since ioredis sends all commands in a pipeline to the same node.\n0. You can't use `multi` without pipeline (aka `cluster.multi({ pipeline: false })`). This is because when you call `cluster.multi({ pipeline: false })`, ioredis doesn't know which node the `multi` command should be sent to.\n0. Chaining custom commands in the pipeline is not supported in Cluster mode.\n\nWhen any commands in a pipeline receives a `MOVED` or `ASK` error, ioredis will resend the whole pipeline to the specified node automatically if all of the following conditions are satisfied:\n\n0. All errors received in the pipeline are the same. For example, we won't resend the pipeline if we got two `MOVED` errors pointing to different nodes.\n0. All commands executed successfully are readonly commands. This makes sure that resending the pipeline won't have side effects.\n\n### Pub/Sub\nPub/Sub in cluster mode works exactly as the same as in standalone mode. Internally, when a node of the cluster receives a message, it will broadcast the message to the other nodes. ioredis makes sure that each message will only be received once by strictly subscribing one node at the same time.\n\n```javascript\nvar nodes = [/* nodes */];\nvar pub = new Redis.Cluster(nodes);\nvar sub = new Redis.Cluster(nodes);\nsub.on('message', function (channel, message) {\n  console.log(channel, message);\n});\n\nsub.subscribe('news', function () {\n  pub.publish('news', 'highlights');\n});\n```\n\n### Events\n\nEvent    | Description\n:------------- | :-------------\nconnect  | emits when a connection is established to the Redis server.\nready    | emits when `CLUSTER INFO` reporting the cluster is able to receive commands (if `enableReadyCheck` is `true`) or immediately after `connect` event (if `enableReadyCheck` is false).\nerror    | emits when an error occurs while connecting with a property of `lastNodeError` representing the last node error received. This event is emitted silently (only emitting if there's at least one listener).\nclose    | emits when an established Redis server connection has closed.\nreconnecting | emits after `close` when a reconnection will be made. The argument of the event is the time (in ms) before reconnecting.\nend     | emits after `close` when no more reconnections will be made.\n+node   | emits when a new node is connected.\n-node   | emits when a node is disconnected.\nnode error | emits when an error occurs when connecting to a node\n\n### Password\nSetting the `password` option to access password-proctected clusters:\n\n```javascript\nvar Redis = require('ioredis');\nvar cluster = new Redis.Cluster(nodes, {\n  redisOptions: {\n    password: 'your-cluster-password'\n  }\n});\n```\n\nIf some of nodes in the cluster using a different password, you should specify them in the first parameter:\n\n```javascript\nvar Redis = require('ioredis');\nvar cluster = new Redis.Cluster([\n  // Use password \"password-for-30001\" for 30001\n  { port: 30001, password: 'password-for-30001'},\n  // Don't use password when accessing 30002\n  { port: 30002, password: null }\n  // Other nodes will use \"fallback-password\"\n], {\n  redisOptions: {\n    password: 'fallback-password'\n  }\n});\n```\n\n<hr>\n\n# Error Handling\nAll the errors returned by the Redis server are instances of `ReplyError`, which can be accessed via `Redis`:\n\n```javascript\nvar Redis = require('ioredis');\nvar redis = new Redis();\n// This command causes a reply error since the SET command requires two arguments.\nredis.set('foo', function (err) {\n  err instanceof Redis.ReplyError\n});\n```\n\nThis is the error stack of the `ReplyError`:\n\n```\nUnhandled rejection ReplyError: ERR wrong number of arguments for 'set' command\n    at ReplyParser._parseResult (/app/node_modules/ioredis/lib/parsers/javascript.js:60:14)\n    at ReplyParser.execute (/app/node_modules/ioredis/lib/parsers/javascript.js:178:20)\n    at Socket.<anonymous> (/app/node_modules/ioredis/lib/redis/event_handler.js:99:22)\n    at Socket.emit (events.js:97:17)\n    at readableAddChunk (_stream_readable.js:143:16)\n    at Socket.Readable.push (_stream_readable.js:106:10)\n    at TCP.onread (net.js:509:20)\n```\n\nBy default, the error stack doesn't make any sense because the whole stack happens in the ioredis\nmodule itself, not in your code. So it's not easy to find out where the error happens in your code.\nioredis provides an option `showFriendlyErrorStack` to solve the problem. When you enable\n`showFriendlyErrorStack`, ioredis will optimize the error stack for you:\n\n```javascript\nvar Redis = require('ioredis');\nvar redis = new Redis({ showFriendlyErrorStack: true });\nredis.set('foo');\n```\n\nAnd the output will be:\n\n```\nReplyError: ERR wrong number of arguments for 'set' command\n    at Object.<anonymous> (/app/index.js:3:7)\n    at Module._compile (module.js:446:26)\n    at Object.Module._extensions..js (module.js:464:10)\n    at Module.load (module.js:341:32)\n    at Function.Module._load (module.js:296:12)\n    at Function.Module.runMain (module.js:487:10)\n    at startup (node.js:111:16)\n    at node.js:799:3\n```\n\nThis time the stack tells you that the error happens on the third line in your code. Pretty sweet!\nHowever, it would decrease the performance significantly to optimize the error stack. So by\ndefault, this option is disabled and can only be used for debugging purposes. You **shouldn't** use this feature in a production environment.\n\n# Plugging in your own Promises Library\nIf you're an advanced user, you may want to plug in your own promise library like [bluebird](https://www.npmjs.com/package/bluebird). Just set Redis.Promise to your favorite ES6-style promise constructor and ioredis will use it.\n\n```javascript\nconst Redis = require('ioredis')\nRedis.Promise = require('bluebird')\n\nconst redis = new Redis()\n\n// Use bluebird\nassert.equal(redis.get().constructor, require('bluebird'))\n\n// You can change the Promise implementation at any time:\nRedis.Promise = global.Promise\nassert.equal(redis.get().constructor, global.Promise)\n```\n\n\n# Running tests\n\nStart a Redis server on 127.0.0.1:6379, and then:\n\n```shell\n$ npm test\n```\n\n`FLUSH ALL` will be invoked after each test, so make sure there's no valuable data in it before running tests.\n\nIf your testing environment does not let you spin up a Redis server [ioredis-mock](https://github.com/stipsan/ioredis-mock) is a drop-in replacement you can use in your tests. It aims to behave identically to ioredis connected to a Redis server so that your integration tests is easier to write and of better quality.\n\n# Debug\n\nYou can set the `DEBUG` env to `ioredis:*` to print debug info:\n\n```shell\n$ DEBUG=ioredis:* node app.js\n```\n\n# Consolidation: It's time for celebration\n\nRight now there are two great redis clients around and both have some advantages above each other. We speak about [node_redis](https://github.com/NodeRedis/node_redis) and ioredis. So after talking to each other about how we could improve in working together we (that is [@BridgeAR](https://github.com/BridgeAR) and [@luin](https://github.com/luin)) decided to work towards a single library on the long run. But step by step.\n\nFirst of all, we want to split small parts of our libraries into others so that we're both able to use the same code. Those libraries are going to be maintained under the NodeRedis organization. This is going to reduce the maintance overhead, allows others to use the very same code, if they need it and it's way easier for others to contribute to both libraries.\n\nWe're very happy about this step towards working together as we both want to give you the best redis experience possible.\n\nIf you want to join our cause by help maintaining something, please don't hesitate to contact either one of us.\n\n# Join in!\n\nI'm happy to receive bug reports, fixes, documentation enhancements, and any other improvements.\n\nAnd since I'm not a native English speaker, if you find any grammar mistakes in the documentation, please also let me know. :)\n\n# Contributors\n\nThis project exists thanks to all the people who contribute:\n\n<table><tr><td width=\"20%\"><a href=\"https://github.com/luin\"><img src=\"https://avatars2.githubusercontent.com/u/635902?v=4\" /></a><p align=\"center\">luin</p></td><td width=\"20%\"><a href=\"https://github.com/shaharmor\"><img src=\"https://avatars3.githubusercontent.com/u/10861920?v=4\" /></a><p align=\"center\">shaharmor</p></td><td width=\"20%\"><a href=\"https://github.com/iamjochem\"><img src=\"https://avatars0.githubusercontent.com/u/792188?v=4\" /></a><p align=\"center\">iamjochem</p></td><td width=\"20%\"><a href=\"https://github.com/doublesharp\"><img src=\"https://avatars3.githubusercontent.com/u/571472?v=4\" /></a><p align=\"center\">doublesharp</p></td><td width=\"20%\"><a href=\"https://github.com/nakulgan\"><img src=\"https://avatars3.githubusercontent.com/u/189836?v=4\" /></a><p align=\"center\">nakulgan</p></td></tr><tr><td width=\"20%\"><a href=\"https://github.com/AVVS\"><img src=\"https://avatars1.githubusercontent.com/u/1713617?v=4\" /></a><p align=\"center\">AVVS</p></td><td width=\"20%\"><a href=\"https://github.com/ramonsnir\"><img src=\"https://avatars1.githubusercontent.com/u/1024028?v=4\" /></a><p align=\"center\">ramonsnir</p></td><td width=\"20%\"><a href=\"https://github.com/hayeah\"><img src=\"https://avatars2.githubusercontent.com/u/50120?v=4\" /></a><p align=\"center\">hayeah</p></td><td width=\"20%\"><a href=\"https://github.com/albin3\"><img src=\"https://avatars3.githubusercontent.com/u/6190670?v=4\" /></a><p align=\"center\">albin3</p></td><td width=\"20%\"><a href=\"https://github.com/phlip9\"><img src=\"https://avatars0.githubusercontent.com/u/918989?v=4\" /></a><p align=\"center\">phlip9</p></td></tr><tr><td width=\"20%\"><a href=\"https://github.com/chris-olszewski\"><img src=\"https://avatars1.githubusercontent.com/u/4131117?v=4\" /></a><p align=\"center\">chris-olszewski</p></td><td width=\"20%\"><a href=\"https://github.com/fracmak\"><img src=\"https://avatars1.githubusercontent.com/u/378178?v=4\" /></a><p align=\"center\">fracmak</p></td><td width=\"20%\"><a href=\"https://github.com/ddunkin\"><img src=\"https://avatars2.githubusercontent.com/u/264744?v=4\" /></a><p align=\"center\">ddunkin</p></td><td width=\"20%\"><a href=\"https://github.com/ruimarinho\"><img src=\"https://avatars0.githubusercontent.com/u/288709?v=4\" /></a><p align=\"center\">ruimarinho</p></td><td width=\"20%\"><a href=\"https://github.com/suprememoocow\"><img src=\"https://avatars0.githubusercontent.com/u/594566?v=4\" /></a><p align=\"center\">suprememoocow</p></td></tr><tr><td width=\"20%\"><a href=\"https://github.com/jpallen\"><img src=\"https://avatars0.githubusercontent.com/u/31305?v=4\" /></a><p align=\"center\">jpallen</p></td><td width=\"20%\"><a href=\"https://github.com/reconbot\"><img src=\"https://avatars2.githubusercontent.com/u/25966?v=4\" /></a><p align=\"center\">reconbot</p></td><td width=\"20%\"><a href=\"https://github.com/lpinca\"><img src=\"https://avatars0.githubusercontent.com/u/1443911?v=4\" /></a><p align=\"center\">lpinca</p></td><td width=\"20%\"><a href=\"https://github.com/frankvm04\"><img src=\"https://avatars1.githubusercontent.com/u/796475?v=4\" /></a><p align=\"center\">frankvm04</p></td><td width=\"20%\"><a href=\"https://github.com/jeffjen\"><img src=\"https://avatars3.githubusercontent.com/u/5814507?v=4\" /></a><p align=\"center\">jeffjen</p></td></tr><tr><td width=\"20%\"><a href=\"https://github.com/SamBergeron\"><img src=\"https://avatars1.githubusercontent.com/u/3879294?v=4\" /></a><p align=\"center\">SamBergeron</p></td><td width=\"20%\"><a href=\"https://github.com/seoker\"><img src=\"https://avatars1.githubusercontent.com/u/7975797?v=4\" /></a><p align=\"center\">seoker</p></td><td width=\"20%\"><a href=\"https://github.com/southpolesteve\"><img src=\"https://avatars1.githubusercontent.com/u/471400?v=4\" /></a><p align=\"center\">southpolesteve</p></td><td width=\"20%\"><a href=\"https://github.com/devaos\"><img src=\"https://avatars0.githubusercontent.com/u/5412167?v=4\" /></a><p align=\"center\">devaos</p></td><td width=\"20%\"><a href=\"https://github.com/headquarters\"><img src=\"https://avatars0.githubusercontent.com/u/347079?v=4\" /></a><p align=\"center\">headquarters</p></td></tr><tr><td width=\"20%\"><a href=\"https://github.com/9point6\"><img src=\"https://avatars1.githubusercontent.com/u/627697?v=4\" /></a><p align=\"center\">9point6</p></td><td width=\"20%\"><a href=\"https://github.com/horx\"><img src=\"https://avatars2.githubusercontent.com/u/1332618?v=4\" /></a><p align=\"center\">horx</p></td><td width=\"20%\"><a href=\"https://github.com/darrachequesne\"><img src=\"https://avatars3.githubusercontent.com/u/13031701?v=4\" /></a><p align=\"center\">darrachequesne</p></td><td width=\"20%\"><a href=\"https://github.com/damianhodgkiss\"><img src=\"https://avatars2.githubusercontent.com/u/4359427?v=4\" /></a><p align=\"center\">damianhodgkiss</p></td><td width=\"20%\"><a href=\"https://github.com/ColmHally\"><img src=\"https://avatars3.githubusercontent.com/u/20333?v=4\" /></a><p align=\"center\">ColmHally</p></td></tr><tr><td width=\"20%\"><a href=\"https://github.com/klinquist\"><img src=\"https://avatars2.githubusercontent.com/u/1343376?v=4\" /></a><p align=\"center\">klinquist</p></td><td width=\"20%\"><a href=\"https://github.com/alsotang\"><img src=\"https://avatars1.githubusercontent.com/u/1147375?v=4\" /></a><p align=\"center\">alsotang</p></td><td width=\"20%\"><a href=\"https://github.com/zhuangya\"><img src=\"https://avatars2.githubusercontent.com/u/499038?v=4\" /></a><p align=\"center\">zhuangya</p></td><td width=\"20%\"><a href=\"https://github.com/taichunmin\"><img src=\"https://avatars3.githubusercontent.com/u/2192626?v=4\" /></a><p align=\"center\">taichunmin</p></td><td width=\"20%\"><a href=\"https://github.com/Gerhut\"><img src=\"https://avatars1.githubusercontent.com/u/2500247?v=4\" /></a><p align=\"center\">Gerhut</p></td></tr><tr><td width=\"20%\"><a href=\"https://github.com/barwin\"><img src=\"https://avatars3.githubusercontent.com/u/3289?v=4\" /></a><p align=\"center\">barwin</p></td><td width=\"20%\"><a href=\"https://github.com/jcperez\"><img src=\"https://avatars0.githubusercontent.com/u/4073359?v=4\" /></a><p align=\"center\">jcperez</p></td><td width=\"20%\"><a href=\"https://github.com/pensierinmusica\"><img src=\"https://avatars1.githubusercontent.com/u/3594037?v=4\" /></a><p align=\"center\">pensierinmusica</p></td><td width=\"20%\"><a href=\"https://github.com/TeeAaTeeUu\"><img src=\"https://avatars1.githubusercontent.com/u/997511?v=4\" /></a><p align=\"center\">TeeAaTeeUu</p></td><td width=\"20%\"><a href=\"https://github.com/henstock\"><img src=\"https://avatars3.githubusercontent.com/u/13809467?v=4\" /></a><p align=\"center\">henstock</p></td></tr><tr><td width=\"20%\"><a href=\"https://github.com/i5ting\"><img src=\"https://avatars3.githubusercontent.com/u/3118295?v=4\" /></a><p align=\"center\">i5ting</p></td><td width=\"20%\"><a href=\"https://github.com/devoto13\"><img src=\"https://avatars1.githubusercontent.com/u/823594?v=4\" /></a><p align=\"center\">devoto13</p></td><td width=\"20%\"><a href=\"https://github.com/tkalfigo\"><img src=\"https://avatars2.githubusercontent.com/u/3481553?v=4\" /></a><p align=\"center\">tkalfigo</p></td><td width=\"20%\"><a href=\"https://github.com/ArtskydJ\"><img src=\"https://avatars2.githubusercontent.com/u/1833684?v=4\" /></a><p align=\"center\">ArtskydJ</p></td><td width=\"20%\"><a href=\"https://github.com/nswbmw\"><img src=\"https://avatars0.githubusercontent.com/u/4279697?v=4\" /></a><p align=\"center\">nswbmw</p></td></tr><tr><td width=\"20%\"><a href=\"https://github.com/igrcic\"><img src=\"https://avatars1.githubusercontent.com/u/394398?v=4\" /></a><p align=\"center\">igrcic</p></td><td width=\"20%\"><a href=\"https://github.com/VikramTiwari\"><img src=\"https://avatars3.githubusercontent.com/u/1330677?v=4\" /></a><p align=\"center\">VikramTiwari</p></td><td width=\"20%\"><a href=\"https://github.com/mtlima\"><img src=\"https://avatars0.githubusercontent.com/u/9111440?v=4\" /></a><p align=\"center\">mtlima</p></td><td width=\"20%\"><a href=\"https://github.com/pra85\"><img src=\"https://avatars2.githubusercontent.com/u/829526?v=4\" /></a><p align=\"center\">pra85</p></td><td width=\"20%\"><a href=\"https://github.com/joeledwards\"><img src=\"https://avatars3.githubusercontent.com/u/412853?v=4\" /></a><p align=\"center\">joeledwards</p></td></tr><tr><td width=\"20%\"><a href=\"https://github.com/dguo\"><img src=\"https://avatars0.githubusercontent.com/u/2763135?v=4\" /></a><p align=\"center\">dguo</p></td><td width=\"20%\"><a href=\"https://github.com/stipsan\"><img src=\"https://avatars2.githubusercontent.com/u/81981?v=4\" /></a><p align=\"center\">stipsan</p></td><td width=\"20%\"><a href=\"https://github.com/bradvogel\"><img src=\"https://avatars1.githubusercontent.com/u/821706?v=4\" /></a><p align=\"center\">bradvogel</p></td><td width=\"20%\"><a href=\"https://github.com/pyros2097\"><img src=\"https://avatars0.githubusercontent.com/u/1687946?v=4\" /></a><p align=\"center\">pyros2097</p></td><td width=\"20%\"><a href=\"https://github.com/tempname11\"><img src=\"https://avatars0.githubusercontent.com/u/8409150?v=4\" /></a><p align=\"center\">tempname11</p></td></tr></table>\n\n# License\n\nMIT\n","readmeFilename":"README.md","gitHead":"1fb9c3a6901e26751bf5811c1550866d52135ec7","bugs":{"url":"https://github.com/luin/ioredis/issues"},"homepage":"https://github.com/luin/ioredis#readme","_id":"ioredis@4.0.0-1","_npmVersion":"5.10.0","_nodeVersion":"8.9.1","_npmUser":{"name":"luin","email":"i@zihua.li"},"dist":{"integrity":"sha512-uVMtlKnVnUhhJWZXy5iXFaqvUpPfB0oLCScXokL88/FZOYtLOe17BKftiX6zdbw8MdpGgOeW/HjH1u4cJ+fIwQ==","shasum":"9f9afb06051f1b3258824b38a77feef56d0225b9","tarball":"https://registry.npmjs.org/ioredis/-/ioredis-4.0.0-1.tgz","fileCount":27,"unpackedSize":188134,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJbOZ2eCRA9TVsSAnZWagAAakgP+gMpwYQlVcnfTu/DrSf+\nUvZAie7VoRNeBvlcsyaKZDx1YlV6p8SsZVuDLuZUqbIJpimspqRv3RdJoihC\niKyvcw4K99ICvGTxWvJsm5brSxWwEbu7FL2tHb8ey9GDfBt/IV09/Cqp4Ibp\ndkvpVZiywdot/cpxkLOKn0jYDmtweMwHqS5QF5KT6ObaAhadg2W1EsYxkeGx\n4Jg6XspAFOiZKVFJwl1Ki08PTzkHHaQLiZY64IE6KJsQ4G0hJsQhhOH5Urzp\nEEh9Z+DccB9VCkaogLlkqGSVIXifXK+4Och3NsiWbtwHa+OU68BLeRJXR4Yg\na57+OXEM2WpJRElpdBb4hI3Frz0hbxClPxCAid11ROwB5jCYdOJ+IXqTMeh7\n0voS4VN/1z8S6YAsUwFrVnIHzddcPiMz0HM7yVphawehfOEmo46755ZY2OjK\ncRyuJLaROBozY/gjieywz9br/GKWk1qnQSbmUjG06qjWyCh64APBHjakIs1P\nqHbB6sP9C+CYQTUhibyPjl5loNI+TeuOeVguubsK+Gt5hIuhNrc+dk2D1KpL\nflvlY1z42TwZnVhOimKIUVegUB4inadXCjqZ3zrdLcO4tlIMYYUu065Lepst\nnH3NxXkmgR4QCADv+6BAtIAMKJuJNaSxe6T1Q1ziUxIbgHi7LLasa/9pBC48\ndCy9\r\n=YZe8\r\n-----END PGP SIGNATURE-----\r\n"},"maintainers":[{"name":"luin","email":"i@zihua.li"}],"directories":{},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/ioredis_4.0.0-1_1530502557941_0.2990758998457832"},"_hasShrinkwrap":false},"4.0.0-2":{"name":"ioredis","version":"4.0.0-2","description":"A delightful, performance-focused Redis client for Node and io.js","main":"index.js","files":["index.js","lib/"],"scripts":{"test":"NODE_ENV=test mocha --timeout 8000 --exit","test:cov":"NODE_ENV=test node ./node_modules/istanbul/lib/cli.js cover --preserve-comments ./node_modules/mocha/bin/_mocha -- -R spec --exit","generate-docs":"jsdoc2md lib/redis.js lib/cluster/index.js lib/commander.js > API.md","bench":"matcha benchmarks/*.js"},"repository":{"type":"git","url":"git://github.com/luin/ioredis.git"},"keywords":["redis","cluster","sentinel","pipelining"],"author":{"name":"luin","email":"i@zihua.li","url":"http://zihua.li"},"license":"MIT","dependencies":{"cluster-key-slot":"^1.0.6","debug":"^3.1.0","denque":"^1.1.0","flexbuffer":"0.0.6","lodash.bind":"^4.2.1","lodash.clone":"^4.5.0","lodash.clonedeep":"^4.5.0","lodash.defaults":"^4.2.0","lodash.difference":"^4.5.0","lodash.flatten":"^4.4.0","lodash.foreach":"^4.5.0","lodash.isempty":"^4.4.0","lodash.partial":"^4.2.1","lodash.pick":"^4.4.0","lodash.sample":"^4.2.1","lodash.shuffle":"^4.2.0","lodash.values":"^4.3.0","redis-commands":"^1.2.0","redis-errors":"^1.2.0","redis-parser":"^3.0.0","standard-as-callback":"^1.0.0"},"devDependencies":{"bluebird":"^3.5.1","chai":"^3.5.0","cz-conventional-changelog":"^2.0.0","istanbul":"^0.4.2","jsdoc":"^3.4.0","jsdoc-to-markdown":"^4.0.1","mocha":"^5.2.0","server-destroy":"^1.0.1","sinon":"^1.17.3"},"engines":{"node":">=4"},"config":{"commitizen":{"path":"./node_modules/cz-conventional-changelog"}},"readme":"[![ioredis](https://cdn.rawgit.com/luin/ioredis/57b5b89e3e9111ff25d8c62c0bc58ed42e5b8d1e/logo.svg)](https://github.com/luin/ioredis)\n\n[![Build Status](https://travis-ci.org/luin/ioredis.svg?branch=master)](https://travis-ci.org/luin/ioredis)\n[![Test Coverage](https://codeclimate.com/github/luin/ioredis/badges/coverage.svg)](https://codeclimate.com/github/luin/ioredis)\n[![Code Climate](https://codeclimate.com/github/luin/ioredis/badges/gpa.svg)](https://codeclimate.com/github/luin/ioredis)\n[![Commitizen friendly](https://img.shields.io/badge/commitizen-friendly-brightgreen.svg)](http://commitizen.github.io/cz-cli/)\n[![Join the chat at https://gitter.im/luin/ioredis](https://badges.gitter.im/Join%20Chat.svg)](https://gitter.im/luin/ioredis?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge)\n\nA robust, performance-focused and full-featured [Redis](http://redis.io) client for [Node](https://nodejs.org) and [io.js](https://iojs.org).\n\nSupports Redis >= 2.6.12 and (Node.js >= 6).\n\n# Features\nioredis is a robust, full-featured Redis client that is\nused in the world's biggest online commerce company [Alibaba](http://www.alibaba.com/) and many other awesome companies.\n\n0. Full-featured. It supports [Cluster](http://redis.io/topics/cluster-tutorial), [Sentinel](http://redis.io/topics/sentinel), [Pipelining](http://redis.io/topics/pipelining) and of course [Lua scripting](http://redis.io/commands/eval) & [Pub/Sub](http://redis.io/topics/pubsub) (with the support of binary messages).\n0. High performance.\n0. Delightful API. It works with Node callbacks and Native promises.\n0. Transformation of command arguments and replies.\n0. Transparent key prefixing.\n0. Abstraction for Lua scripting, allowing you to define custom commands.\n0. Support for binary data.\n0. Support for TLS.\n0. Support for offline queue and ready checking.\n0. Support for ES6 types, such as `Map` and `Set`.\n0. Support for GEO commands (Redis 3.2 Unstable).\n0. Sophisticated error handling strategy.\n\n# Links\n* [API Documentation](API.md)\n* [Changelog](Changelog.md)\n* [Migrating from node_redis](https://github.com/luin/ioredis/wiki/Migrating-from-node_redis)\n* [Error Handling](#error-handling)\n\n## Become a Sponsor to Support ioredis's Development\nOpen source is hard and time-consuming. If you want to invest in ioredis's future you can become a sponsor and make us spend more time on this library's improvements and new features.\n\n<a href=\"https://opencollective.com/ioredis\"><img src=\"https://opencollective.com/ioredis/tiers/sponsor.svg?avatarHeight=36\"></a>\n\nThank you for using ioredis :-)\n\n<hr>\n<a href=\"https://itunes.apple.com/app/medis-gui-for-redis/id1063631769\"><img align=\"right\" src=\"medis.png\" alt=\"Download on the App Store\"></a>\n\n\n### Advertisement\n\nLooking for a Redis GUI manager for OS X, Windows and Linux? Here's [Medis](https://itunes.apple.com/us/app/medis-gui-for-redis/id1063631769)!\n\nMedis is an open-sourced, beautiful, easy-to-use Redis GUI management application.\n\nMedis starts with all the basic features you need:\n\n* Keys viewing/editing\n* SSH Tunnel for connecting with remote servers\n* Terminal for executing custom commands\n* JSON/MessagePack format viewing/editing and built-in highlighting/validator\n* And other awesome features...\n\n[Medis is open sourced on GitHub](https://github.com/luin/medis)\n\n<hr>\n\n# Quick Start\n\n## Install\n```shell\n$ npm install ioredis\n```\n\n## Basic Usage\n\n```javascript\nvar Redis = require('ioredis');\nvar redis = new Redis();\n\nredis.set('foo', 'bar');\nredis.get('foo', function (err, result) {\n  console.log(result);\n});\n\n// Or using a promise if the last argument isn't a function\nredis.get('foo').then(function (result) {\n  console.log(result);\n});\n\n// Arguments to commands are flattened, so the following are the same:\nredis.sadd('set', 1, 3, 5, 7);\nredis.sadd('set', [1, 3, 5, 7]);\n\n// All arguments are passed directly to the redis server:\nredis.set('key', 100, 'EX', 10);\n```\n\nSee the `examples/` folder for more examples.\n\n## Connect to Redis\nWhen a new `Redis` instance is created,\na connection to Redis will be created at the same time.\nYou can specify which Redis to connect to by:\n\n```javascript\nnew Redis()       // Connect to 127.0.0.1:6379\nnew Redis(6380)   // 127.0.0.1:6380\nnew Redis(6379, '192.168.1.1')        // 192.168.1.1:6379\nnew Redis('/tmp/redis.sock')\nnew Redis({\n  port: 6379,          // Redis port\n  host: '127.0.0.1',   // Redis host\n  family: 4,           // 4 (IPv4) or 6 (IPv6)\n  password: 'auth',\n  db: 0\n})\n```\n\nYou can also specify connection options as a [`redis://` URL](http://www.iana.org/assignments/uri-schemes/prov/redis):\n\n```javascript\n// Connect to 127.0.0.1:6380, db 4, using password \"authpassword\":\nnew Redis('redis://:authpassword@127.0.0.1:6380/4')\n```\n\nSee [API Documentation](API.md#new_Redis) for all available options.\n\n## Pub/Sub\n\nHere is a simple example of the API for publish/subscribe.\nThe following program opens two client connections.\nIt subscribes to a channel with one connection\nand publishes to that channel with the other:\n\n```javascript\nvar Redis = require('ioredis');\nvar redis = new Redis();\nvar pub = new Redis();\nredis.subscribe('news', 'music', function (err, count) {\n  // Now we are subscribed to both the 'news' and 'music' channels.\n  // `count` represents the number of channels we are currently subscribed to.\n\n  pub.publish('news', 'Hello world!');\n  pub.publish('music', 'Hello again!');\n});\n\nredis.on('message', function (channel, message) {\n  // Receive message Hello world! from channel news\n  // Receive message Hello again! from channel music\n  console.log('Receive message %s from channel %s', message, channel);\n});\n\n// There's also an event called 'messageBuffer', which is the same as 'message' except\n// it returns buffers instead of strings.\nredis.on('messageBuffer', function (channel, message) {\n  // Both `channel` and `message` are buffers.\n});\n```\n\n`PSUBSCRIBE` is also supported in a similar way:\n\n```javascript\nredis.psubscribe('pat?ern', function (err, count) {});\nredis.on('pmessage', function (pattern, channel, message) {});\nredis.on('pmessageBuffer', function (pattern, channel, message) {});\n```\n\nWhen a client issues a SUBSCRIBE or PSUBSCRIBE, that connection is put into a \"subscriber\" mode.\nAt that point, only commands that modify the subscription set are valid.\nWhen the subscription set is empty, the connection is put back into regular mode.\n\nIf you need to send regular commands to Redis while in subscriber mode, just open another connection.\n\n## Handle Binary Data\nArguments can be buffers:\n```javascript\nredis.set('foo', new Buffer('bar'));\n```\n\nAnd every command has a method that returns a Buffer (by adding a suffix of \"Buffer\" to the command name).\nTo get a buffer instead of a utf8 string:\n\n```javascript\nredis.getBuffer('foo', function (err, result) {\n  // result is a buffer.\n});\n```\n\n## Pipelining\nIf you want to send a batch of commands (e.g. > 5), you can use pipelining to queue\nthe commands in memory and then send them to Redis all at once. This way the performance improves by 50%~300% (See [benchmark section](#benchmark)).\n\n`redis.pipeline()` creates a `Pipeline` instance. You can call any Redis\ncommands on it just like the `Redis` instance. The commands are queued in memory\nand flushed to Redis by calling the `exec` method:\n\n```javascript\nvar pipeline = redis.pipeline();\npipeline.set('foo', 'bar');\npipeline.del('cc');\npipeline.exec(function (err, results) {\n  // `err` is always null, and `results` is an array of responses\n  // corresponding to the sequence of queued commands.\n  // Each response follows the format `[err, result]`.\n});\n\n// You can even chain the commands:\nredis.pipeline().set('foo', 'bar').del('cc').exec(function (err, results) {\n});\n\n// `exec` also returns a Promise:\nvar promise = redis.pipeline().set('foo', 'bar').get('foo').exec();\npromise.then(function (result) {\n  // result === [[null, 'OK'], [null, 'bar']]\n});\n```\n\nEach chained command can also have a callback, which will be invoked when the command\ngets a reply:\n\n```javascript\nredis.pipeline().set('foo', 'bar').get('foo', function (err, result) {\n  // result === 'bar'\n}).exec(function (err, result) {\n  // result[1][1] === 'bar'\n});\n```\n\nIn addition to adding commands to the `pipeline` queue individually, you can also pass an array of commands and arguments to the constructor:\n\n```javascript\nredis.pipeline([\n  ['set', 'foo', 'bar'],\n  ['get', 'foo']\n]).exec(function () { /* ... */ });\n```\n\n`#length` property shows how many commands in the pipeline:\n\n```javascript\nconst length = redis.pipeline().set('foo', 'bar').get('foo').length;\n// length === 2\n```\n\n\n## Transaction\nMost of the time, the transaction commands `multi` & `exec` are used together with pipeline.\nTherefore, when `multi` is called, a `Pipeline` instance is created automatically by default,\nso you can use `multi` just like `pipeline`:\n\n```javascript\nredis.multi().set('foo', 'bar').get('foo').exec(function (err, results) {\n  // results === [[null, 'OK'], [null, 'bar']]\n});\n```\nIf there's a syntax error in the transaction's command chain (e.g. wrong number of arguments, wrong command name, etc),\nthen none of the commands would be executed, and an error is returned:\n\n```javascript\nredis.multi().set('foo').set('foo', 'new value').exec(function (err, results) {\n  // err:\n  //  { [ReplyError: EXECABORT Transaction discarded because of previous errors.]\n  //    name: 'ReplyError',\n  //    message: 'EXECABORT Transaction discarded because of previous errors.',\n  //    command: { name: 'exec', args: [] },\n  //    previousErrors:\n  //     [ { [ReplyError: ERR wrong number of arguments for 'set' command]\n  //         name: 'ReplyError',\n  //         message: 'ERR wrong number of arguments for \\'set\\' command',\n  //         command: [Object] } ] }\n});\n```\n\nIn terms of the interface, `multi` differs from `pipeline` in that when specifying a callback\nto each chained command, the queueing state is passed to the callback instead of the result of the command:\n\n```javascript\nredis.multi().set('foo', 'bar', function (err, result) {\n  // result === 'QUEUED'\n}).exec(/* ... */);\n```\n\nIf you want to use transaction without pipeline, pass `{ pipeline: false }` to `multi`,\nand every command will be sent to Redis immediately without waiting for an `exec` invocation:\n\n```javascript\nredis.multi({ pipeline: false });\nredis.set('foo', 'bar');\nredis.get('foo');\nredis.exec(function (err, result) {\n  // result === [[null, 'OK'], [null, 'bar']]\n});\n```\n\nThe constructor of `multi` also accepts a batch of commands:\n\n```javascript\nredis.multi([\n  ['set', 'foo', 'bar'],\n  ['get', 'foo']\n]).exec(function () { /* ... */ });\n```\n\nInline transactions are supported by pipeline, which means you can group a subset of commands\nin the pipeline into a transaction:\n\n```javascript\nredis.pipeline().get('foo').multi().set('foo', 'bar').get('foo').exec().get('foo').exec();\n```\n\n## Lua Scripting\nioredis supports all of the scripting commands such as `EVAL`, `EVALSHA` and `SCRIPT`.\nHowever, it's tedious to use in real world scenarios since developers have to take\ncare of script caching and to detect when to use `EVAL` and when to use `EVALSHA`.\nioredis expose a `defineCommand` method to make scripting much easier to use:\n\n```javascript\nvar redis = new Redis();\n\n// This will define a command echo:\nredis.defineCommand('echo', {\n  numberOfKeys: 2,\n  lua: 'return {KEYS[1],KEYS[2],ARGV[1],ARGV[2]}'\n});\n\n// Now `echo` can be used just like any other ordinary command,\n// and ioredis will try to use `EVALSHA` internally when possible for better performance.\nredis.echo('k1', 'k2', 'a1', 'a2', function (err, result) {\n  // result === ['k1', 'k2', 'a1', 'a2']\n});\n\n// `echoBuffer` is also defined automatically to return buffers instead of strings:\nredis.echoBuffer('k1', 'k2', 'a1', 'a2', function (err, result) {\n  // result[0] === new Buffer('k1');\n});\n\n// And of course it works with pipeline:\nredis.pipeline().set('foo', 'bar').echo('k1', 'k2', 'a1', 'a2').exec();\n```\n\nIf the number of keys can't be determined when defining a command, you can\nomit the `numberOfKeys` property and pass the number of keys as the first argument\nwhen you call the command:\n\n```javascript\nredis.defineCommand('echoDynamicKeyNumber', {\n  lua: 'return {KEYS[1],KEYS[2],ARGV[1],ARGV[2]}'\n});\n\n// Now you have to pass the number of keys as the first argument every time\n// you invoke the `echoDynamicKeyNumber` command:\nredis.echoDynamicKeyNumber(2, 'k1', 'k2', 'a1', 'a2', function (err, result) {\n  // result === ['k1', 'k2', 'a1', 'a2']\n});\n```\n\n## Transparent Key Prefixing\nThis feature allows you to specify a string that will automatically be prepended\nto all the keys in a command, which makes it easier to manage your key\nnamespaces.\n\n**Warning** This feature won't apply to commands like [KEYS](http://redis.io/commands/KEYS) and [SCAN](http://redis.io/commands/scan) that take patterns rather than actual keys([#239](https://github.com/luin/ioredis/issues/239)),\nand this feature also won't apply to the replies of commands even they are key names ([#325](https://github.com/luin/ioredis/issues/325)).\n\n```javascript\nvar fooRedis = new Redis({ keyPrefix: 'foo:' });\nfooRedis.set('bar', 'baz');  // Actually sends SET foo:bar baz\n\nfooRedis.defineCommand('echo', {\n  numberOfKeys: 2,\n  lua: 'return {KEYS[1],KEYS[2],ARGV[1],ARGV[2]}'\n});\n\n// Works well with pipelining/transaction\nfooRedis.pipeline()\n  // Sends SORT foo:list BY foo:weight_*->fieldname\n  .sort('list', 'BY', 'weight_*->fieldname')\n  // Supports custom commands\n  // Sends EVALSHA xxx foo:k1 foo:k2 a1 a2\n  .echo('k1', 'k2', 'a1', 'a2')\n  .exec()\n```\n\n## Transforming Arguments & Replies\nMost Redis commands take one or more Strings as arguments,\nand replies are sent back as a single String or an Array of Strings. However, sometimes\nyou may want something different. For instance, it would be more convenient if the `HGETALL`\ncommand returns a hash (e.g. `{ key: val1, key2: v2 }`) rather than an array of key values (e.g. `[key1, val1, key2, val2]`).\n\nioredis has a flexible system for transforming arguments and replies. There are two types\nof transformers, argument transformer and reply transformer:\n\n```javascript\nvar Redis = require('ioredis');\n\n// Here's the built-in argument transformer converting\n// hmset('key', { k1: 'v1', k2: 'v2' })\n// or\n// hmset('key', new Map([['k1', 'v1'], ['k2', 'v2']]))\n// into\n// hmset('key', 'k1', 'v1', 'k2', 'v2')\nRedis.Command.setArgumentTransformer('hmset', function (args) {\n  if (args.length === 2) {\n    if (typeof Map !== 'undefined' && args[1] instanceof Map) {\n      // utils is a internal module of ioredis\n      return [args[0]].concat(utils.convertMapToArray(args[1]));\n    }\n    if ( typeof args[1] === 'object' && args[1] !== null) {\n      return [args[0]].concat(utils.convertObjectToArray(args[1]));\n    }\n  }\n  return args;\n});\n\n// Here's the built-in reply transformer converting the HGETALL reply\n// ['k1', 'v1', 'k2', 'v2']\n// into\n// { k1: 'v1', 'k2': 'v2' }\nRedis.Command.setReplyTransformer('hgetall', function (result) {\n  if (Array.isArray(result)) {\n    var obj = {};\n    for (var i = 0; i < result.length; i += 2) {\n      obj[result[i]] = result[i + 1];\n    }\n    return obj;\n  }\n  return result;\n});\n```\n\nThere are three built-in transformers, two argument transformers for `hmset` & `mset` and\na reply transformer for `hgetall`. Transformers for `hmset` and `hgetall` were mentioned\nabove, and the transformer for `mset` is similar to the one for `hmset`:\n\n```javascript\nredis.mset({ k1: 'v1', k2: 'v2' });\nredis.get('k1', function (err, result) {\n  // result === 'v1';\n});\n\nredis.mset(new Map([['k3', 'v3'], ['k4', 'v4']]));\nredis.get('k3', function (err, result) {\n  // result === 'v3';\n});\n```\n\nAnother useful example of a reply transformer is one that changes `hgetall` to return array of arrays instead of objects which avoids a unwanted conversation of hash keys to strings when dealing with binary hash keys:\n\n```javascript\nRedis.Command.setReplyTransformer('hgetall', function (result) {\n  var arr = [];\n  for (var i = 0; i < result.length; i += 2) {\n    arr.push([result[i], result[i + 1]]);\n  }\n  return arr;\n});\nredis.hset('h1', Buffer.from([0x01]), Buffer.from([0x02]));\nredis.hset('h1', Buffer.from([0x03]), Buffer.from([0x04]));\nredis.hgetallBuffer('h1', function (err, result) {\n  // result === [ [ <Buffer 01>, <Buffer 02> ], [ <Buffer 03>, <Buffer 04> ] ];\n});\n```\n\n## Monitor\nRedis supports the MONITOR command,\nwhich lets you see all commands received by the Redis server across all client connections,\nincluding from other client libraries and other computers.\n\nThe `monitor` method returns a monitor instance.\nAfter you send the MONITOR command, no other commands are valid on that connection. ioredis will emit a monitor event for every new monitor message that comes across.\nThe callback for the monitor event takes a timestamp from the Redis server and an array of command arguments.\n\nHere is a simple example:\n\n```javascript\nredis.monitor(function (err, monitor) {\n  monitor.on('monitor', function (time, args, source, database) {\n  });\n});\n```\n\n## Streamify Scanning\nRedis 2.8 added the `SCAN` command to incrementally iterate through the keys in the database. It's different from `KEYS` in that\n`SCAN` only returns a small number of elements each call, so it can be used in production without the downside\nof blocking the server for a long time. However, it requires recording the cursor on the client side each time\nthe `SCAN` command is called in order to iterate through all the keys correctly. Since it's a relatively common use case, ioredis\nprovides a streaming interface for the `SCAN` command to make things much easier. A readable stream can be created by calling `scanStream`:\n\n```javascript\nvar redis = new Redis();\n// Create a readable stream (object mode)\nvar stream = redis.scanStream();\nvar keys = [];\nstream.on('data', function (resultKeys) {\n  // `resultKeys` is an array of strings representing key names.\n  // Note that resultKeys may contain 0 keys.\n  for (var i = 0; i < resultKeys.length; i++) {\n    keys.push(resultKeys[i]);\n  }\n});\nstream.on('end', function () {\n  console.log('done with the keys: ', keys);\n});\n```\n\n`scanStream` accepts an option, with which you can specify the `MATCH` pattern and the `COUNT` argument:\n\n```javascript\nvar stream = redis.scanStream({\n  // only returns keys following the pattern of `user:*`\n  match: 'user:*',\n  // returns approximately 100 elements per call\n  count: 100\n});\n```\n\nJust like other commands, `scanStream` has a binary version `scanBufferStream`, which returns an array of buffers. It's useful when\nthe key names are not utf8 strings.\n\nThere are also `hscanStream`, `zscanStream` and `sscanStream` to iterate through elements in a hash, zset and set. The interface of each is\nsimilar to `scanStream` except the first argument is the key name:\n\n```javascript\nvar stream = redis.hscanStream('myhash', {\n  match: 'age:??'\n});\n```\n\nYou can learn more from the [Redis documentation](http://redis.io/commands/scan).\n\n**Useful Tips**\nIt's pretty common that doing an async task in the `data` handler. We'd like the scanning process to be paused until the async task to be finished. `Stream#pause()` and `Stream.resume()` do the trick. For example if we want to migrate data in Redis to MySQL:\n\n```javascript\nvar stream = redis.scanStream();\nstream.on('data', function (resultKeys) {\n  // Pause the stream from scanning more keys until we've migrated the current keys.\n  stream.pause();\n\n  Promise.all(resultKeys.map(migrateKeyToMySQL)).then(() => {\n    // Resume the stream here.\n    stream.resume();\n  });\n});\n\nstream.on('end', function () {\n  console.log('done migration');\n});\n```\n\n## Auto-reconnect\nBy default, ioredis will try to reconnect when the connection to Redis is lost\nexcept when the connection is closed manually by `redis.disconnect()` or `redis.quit()`.\n\nIt's very flexible to control how long to wait to reconnect after disconnection\nusing the `retryStrategy` option:\n\n```javascript\nvar redis = new Redis({\n  // This is the default value of `retryStrategy`\n  retryStrategy: function (times) {\n    var delay = Math.min(times * 50, 2000);\n    return delay;\n  }\n});\n```\n\n`retryStrategy` is a function that will be called when the connection is lost.\nThe argument `times` means this is the nth reconnection being made and\nthe return value represents how long (in ms) to wait to reconnect. When the\nreturn value isn't a number, ioredis will stop trying to reconnect, and the connection\nwill be lost forever if the user doesn't call `redis.connect()` manually.\n\nWhen reconnected, the client will auto subscribe to channels that the previous connection subscribed to.\nThis behavior can be disabled by setting the `autoResubscribe` option to `false`.\n\nAnd if the previous connection has some unfulfilled commands (most likely blocking commands such as `brpop` and `blpop`),\nthe client will resend them when reconnected. This behavior can be disabled by setting the `autoResendUnfulfilledCommands` option to `false`.\n\nBy default, all pending commands will be flushed with an error every 20 retry attempts. That makes sure commands won't wait forever when the connection is down. You can change this behavior by setting `maxRetriesPerRequest`:\n\n```javascript\nvar redis = new Redis({\n  maxRetriesPerRequest: 1\n});\n```\n\nSet maxRetriesPerRequest to `null` to disable this behavior, and every command will wait forever until the connection is alive again (which is the default behavior before ioredis v4).\n\n### Reconnect on error\n\nBesides auto-reconnect when the connection is closed, ioredis supports reconnecting on the specified errors by the `reconnectOnError` option. Here's an example that will reconnect when receiving `READONLY` error:\n\n```javascript\nvar redis = new Redis({\n  reconnectOnError: function (err) {\n    var targetError = 'READONLY';\n    if (err.message.slice(0, targetError.length) === targetError) {\n      // Only reconnect when the error starts with \"READONLY\"\n      return true; // or `return 1;`\n    }\n  }\n});\n```\n\nThis feature is useful when using Amazon ElastiCache. Once failover happens, Amazon ElastiCache will switch the master we currently connected with to a slave, leading to the following writes fails with the error `READONLY`. Using `reconnectOnError`, we can force the connection to reconnect on this error in order to connect to the new master.\n\nFurthermore, if the `reconnectOnError` returns `2`, ioredis will resend the failed command after reconnecting.\n\n## Connection Events\nThe Redis instance will emit some events about the state of the connection to the Redis server.\n\nEvent    | Description\n:------------- | :-------------\nconnect  | emits when a connection is established to the Redis server.\nready    | If `enableReadyCheck` is `true`, client will emit `ready` when the server reports that it is ready to receive commands (e.g. finish loading data from disk).<br>Otherwise, `ready` will be emitted immediately right after the `connect` event.\nerror    | emits when an error occurs while connecting.<br>However, ioredis emits all `error` events silently (only emits when there's at least one listener) so that your application won't crash if you're not listening to the `error` event.\nclose    | emits when an established Redis server connection has closed.\nreconnecting | emits after `close` when a reconnection will be made. The argument of the event is the time (in ms) before reconnecting.\nend     | emits after `close` when no more reconnections will be made, or the connection is failed to establish.\n\nYou can also check out the `Redis#status` property to get the current connection status.\n\nBesides the above connection events, there are several other custom events:\n\nEvent    | Description\n:------------- | :-------------\nselect   | emits when the database changed. The argument is the new db number.\n\n## Offline Queue\nWhen a command can't be processed by Redis (being sent before the `ready` event), by default, it's added to the offline queue and will be\nexecuted when it can be processed. You can disable this feature by setting the `enableOfflineQueue`\noption to `false`:\n\n```javascript\nvar redis = new Redis({ enableOfflineQueue: false });\n```\n\n## TLS Options\nRedis doesn't support TLS natively, however if the redis server you want to connect to is hosted behind a TLS proxy (e.g. [stunnel](https://www.stunnel.org/)) or is offered by a PaaS service that supports TLS connection (e.g. [Redis Labs](https://redislabs.com/)), you can set the `tls` option:\n\n```javascript\nvar redis = new Redis({\n  host: 'localhost',\n  tls: {\n    // Refer to `tls.connect()` section in\n    // https://nodejs.org/api/tls.html\n    // for all supported options\n    ca: fs.readFileSync('cert.pem')\n  }\n});\n```\n\n<hr>\n\n## Sentinel\nioredis supports Sentinel out of the box. It works transparently as all features that work when\nyou connect to a single node also work when you connect to a sentinel group. Make sure to run Redis >= 2.8.12 if you want to use this feature. Sentinels have a default port of 26379.\n\nTo connect using Sentinel, use:\n\n```javascript\nvar redis = new Redis({\n  sentinels: [{ host: 'localhost', port: 26379 }, { host: 'localhost', port: 26380 }],\n  name: 'mymaster'\n});\n\nredis.set('foo', 'bar');\n```\n\nThe arguments passed to the constructor are different from the ones you use to connect to a single node, where:\n\n* `name` identifies a group of Redis instances composed of a master and one or more slaves (`mymaster` in the example);\n* `sentinels` are a list of sentinels to connect to. The list does not need to enumerate all your sentinel instances, but a few so that if one is down the client will try the next one.\n* `role` (optional) with a value of `slave` will return a random slave from the Sentinel group.\n* `preferredSlaves` (optional) can be used to prefer a particular slave or set of slaves based on priority. It accepts a function or array.\n\nioredis **guarantees** that the node you connected to is always a master even after a failover. When a failover happens, instead of trying to reconnect to the failed node (which will be demoted to slave when it's available again), ioredis will ask sentinels for the new master node and connect to it. All commands sent during the failover are queued and will be executed when the new connection is established so that none of the commands will be lost.\n\nIt's possible to connect to a slave instead of a master by specifying the option `role` with the value of `slave` and ioredis will try to connect to a random slave of the specified master, with the guarantee that the connected node is always a slave. If the current node is promoted to master due to a failover, ioredis will disconnect from it and ask the sentinels for another slave node to connect to.\n\nIf you specify the option `preferredSlaves` along with `role: 'slave'` ioredis will attempt to use this value when selecting the slave from the pool of available slaves. The value of `preferredSlaves` should either be a function that accepts an array of avaiable slaves and returns a single result, or an array of slave values priorities by the lowest `prio` value first with a default value of `1`.\n\n```javascript\n// available slaves format\nvar availableSlaves = [{ ip: '127.0.0.1', port: '31231', flags: 'slave' }];\n\n// preferredSlaves array format\nvar preferredSlaves = [\n  { ip: '127.0.0.1', port: '31231', prio: 1 },\n  { ip: '127.0.0.1', port: '31232', prio: 2 }\n];\n\n// preferredSlaves function format\npreferredSlaves = function(availableSlaves) {\n  for (var i = 0; i < availableSlaves.length; i++) {\n    var slave = availableSlaves[i];\n    if (slave.ip === '127.0.0.1') {\n      if (slave.port === '31234') {\n        return slave;\n      }\n    }\n  }\n  // if no preferred slaves are available a random one is used\n  return false;\n};\n\nvar redis = new Redis({\n  sentinels: [{ host: '127.0.0.1', port: 26379 }, { host: '127.0.0.1', port: 26380 }],\n  name: 'mymaster',\n  role: 'slave',\n  preferredSlaves: preferredSlaves\n});\n```\n\nBesides the `retryStrategy` option, there's also a `sentinelRetryStrategy` in Sentinel mode which will be invoked when all the sentinel nodes are unreachable during connecting. If `sentinelRetryStrategy` returns a valid delay time, ioredis will try to reconnect from scratch. The default value of `sentinelRetryStrategy` is:\n\n```javascript\nfunction (times) {\n  var delay = Math.min(times * 10, 1000);\n  return delay;\n}\n```\n\n## Cluster\nRedis Cluster provides a way to run a Redis installation where data is automatically sharded across multiple Redis nodes.\nYou can connect to a Redis Cluster like this:\n\n```javascript\nvar Redis = require('ioredis');\n\nvar cluster = new Redis.Cluster([{\n  port: 6380,\n  host: '127.0.0.1'\n}, {\n  port: 6381,\n  host: '127.0.0.1'\n}]);\n\ncluster.set('foo', 'bar');\ncluster.get('foo', function (err, res) {\n  // res === 'bar'\n});\n```\n\n`Cluster` constructor accepts two arguments, where:\n\n0. The first argument is a list of nodes of the cluster you want to connect to.\nJust like Sentinel, the list does not need to enumerate all your cluster nodes,\nbut a few so that if one is unreachable the client will try the next one, and the client will discover other nodes automatically when at least one node is connected.\n0. The second argument is the options, where:\n\n    * `clusterRetryStrategy`: When none of the startup nodes are reachable, `clusterRetryStrategy` will be invoked. When a number is returned,\n    ioredis will try to reconnect to the startup nodes from scratch after the specified delay (in ms). Otherwise, an error of \"None of startup nodes is available\" will be returned.\n    The default value of this option is:\n\n        ```javascript\n        function (times) {\n          var delay = Math.min(100 + times * 2, 2000);\n          return delay;\n        }\n        ```\n\n        It's possible to modify the `startupNodes` property in order to switch to another set of nodes here:\n\n        ```javascript\n        function (times) {\n          this.startupNodes = [{ port: 6790, host: '127.0.0.1' }];\n          return Math.min(100 + times * 2, 2000);\n        }\n        ```\n\n    * `enableOfflineQueue`: Similar to the `enableOfflineQueue` option of `Redis` class.\n    * `enableReadyCheck`: When enabled, \"ready\" event will only be emitted when `CLUSTER INFO` command\n    reporting the cluster is ready for handling commands. Otherwise, it will be emitted immediately after \"connect\" is emitted.\n    * `scaleReads`: Config where to send the read queries. See below for more details.\n    * `maxRedirections`: When a cluster related error (e.g. `MOVED`, `ASK` and `CLUSTERDOWN` etc.) is received, the client will redirect the\n    command to another node. This option limits the max redirections allowed when sending a command. The default value is `16`.\n    * `retryDelayOnFailover`: If the target node is disconnected when sending a command,\n    ioredis will retry after the specified delay. The default value is `100`. You should make sure `retryDelayOnFailover * maxRedirections > cluster-node-timeout`\n    to insure that no command will fail during a failover.\n    * `retryDelayOnClusterDown`: When a cluster is down, all commands will be rejected with the error of `CLUSTERDOWN`. If this option is a number (by default, it is `100`), the client\n    will resend the commands after the specified time (in ms).\n    * `retryDelayOnTryAgain`: If this option is a number (by default, it is `100`), the client\n    will resend the commands rejected with `TRYAGAIN` error after the specified time (in ms).\n    * `redisOptions`: Default options passed to the constructor of `Redis` when connecting to a node.\n    * `slotsRefreshTimeout`: Milliseconds before a timeout occurs while refreshing slots from the cluster (default `1000`)\n    * `slotsRefreshInterval`: Milliseconds between every automatic slots refresh (default `5000`)\n\n### Read-write splitting\n\nA typical redis cluster contains three or more masters and several slaves for each master. It's possible to scale out redis cluster by sending read queries to slaves and write queries to masters by setting the `scaleReads` option.\n\n`scaleReads` is \"master\" by default, which means ioredis will never send any queries to slaves. There are other three available options:\n\n1. \"all\": Send write queries to masters and read queries to masters or slaves randomly.\n2. \"slave\": Send write queries to masters and read queries to slaves.\n3. a custom `function(nodes, command): node`: Will choose the custom function to select to which node to send read queries (write queries keep being sent to master). The first node in `nodes` is always the master serving the relevant slots. If the function returns an array of nodes, a random node of that list will be selected.\n\nFor example:\n\n```javascript\nvar cluster = new Redis.Cluster([/* nodes */], {\n  scaleReads: 'slave'\n});\ncluster.set('foo', 'bar'); // This query will be sent to one of the masters.\ncluster.get('foo', function (err, res) {\n  // This query will be sent to one of the slaves.\n});\n```\n\n**NB** In the code snippet above, the `res` may not be equal to \"bar\" because of the lag of replication between the master and slaves.\n\n### Running commands to multiple nodes\n\nEvery command will be sent to exactly one node. For commands containing keys, (e.g. `GET`, `SET` and `HGETALL`), ioredis sends them to the node that serving the keys, and for other commands not containing keys, (e.g. `INFO`, `KEYS` and `FLUSHDB`), ioredis sends them to a random node.\n\nSometimes you may want to send a command to multiple nodes (masters or slaves) of the cluster, you can get the nodes via `Cluster#nodes()` method.\n\n`Cluster#nodes()` accepts a parameter role, which can be \"master\", \"slave\" and \"all\" (default), and returns an array of `Redis` instance. For example:\n\n```javascript\n// Send `FLUSHDB` command to all slaves:\nvar slaves = cluster.nodes('slave');\nPromise.all(slaves.map(function (node) {\n  return node.flushdb();\n}));\n\n// Get keys of all the masters:\nvar masters = cluster.nodes('master');\nPromise.all(masters.map(function (node) {\n  return node.keys();\n})).then(function (keys) {\n  // keys: [['key1', 'key2'], ['key3', 'key4']]\n});\n```\n\n### Transaction and pipeline in Cluster mode\nAlmost all features that are supported by `Redis` are also supported by `Redis.Cluster`, e.g. custom commands, transaction and pipeline.\nHowever there are some differences when using transaction and pipeline in Cluster mode:\n\n0. All keys in a pipeline should belong to the same slot since ioredis sends all commands in a pipeline to the same node.\n0. You can't use `multi` without pipeline (aka `cluster.multi({ pipeline: false })`). This is because when you call `cluster.multi({ pipeline: false })`, ioredis doesn't know which node the `multi` command should be sent to.\n0. Chaining custom commands in the pipeline is not supported in Cluster mode.\n\nWhen any commands in a pipeline receives a `MOVED` or `ASK` error, ioredis will resend the whole pipeline to the specified node automatically if all of the following conditions are satisfied:\n\n0. All errors received in the pipeline are the same. For example, we won't resend the pipeline if we got two `MOVED` errors pointing to different nodes.\n0. All commands executed successfully are readonly commands. This makes sure that resending the pipeline won't have side effects.\n\n### Pub/Sub\nPub/Sub in cluster mode works exactly as the same as in standalone mode. Internally, when a node of the cluster receives a message, it will broadcast the message to the other nodes. ioredis makes sure that each message will only be received once by strictly subscribing one node at the same time.\n\n```javascript\nvar nodes = [/* nodes */];\nvar pub = new Redis.Cluster(nodes);\nvar sub = new Redis.Cluster(nodes);\nsub.on('message', function (channel, message) {\n  console.log(channel, message);\n});\n\nsub.subscribe('news', function () {\n  pub.publish('news', 'highlights');\n});\n```\n\n### Events\n\nEvent    | Description\n:------------- | :-------------\nconnect  | emits when a connection is established to the Redis server.\nready    | emits when `CLUSTER INFO` reporting the cluster is able to receive commands (if `enableReadyCheck` is `true`) or immediately after `connect` event (if `enableReadyCheck` is false).\nerror    | emits when an error occurs while connecting with a property of `lastNodeError` representing the last node error received. This event is emitted silently (only emitting if there's at least one listener).\nclose    | emits when an established Redis server connection has closed.\nreconnecting | emits after `close` when a reconnection will be made. The argument of the event is the time (in ms) before reconnecting.\nend     | emits after `close` when no more reconnections will be made.\n+node   | emits when a new node is connected.\n-node   | emits when a node is disconnected.\nnode error | emits when an error occurs when connecting to a node\n\n### Password\nSetting the `password` option to access password-proctected clusters:\n\n```javascript\nvar Redis = require('ioredis');\nvar cluster = new Redis.Cluster(nodes, {\n  redisOptions: {\n    password: 'your-cluster-password'\n  }\n});\n```\n\nIf some of nodes in the cluster using a different password, you should specify them in the first parameter:\n\n```javascript\nvar Redis = require('ioredis');\nvar cluster = new Redis.Cluster([\n  // Use password \"password-for-30001\" for 30001\n  { port: 30001, password: 'password-for-30001'},\n  // Don't use password when accessing 30002\n  { port: 30002, password: null }\n  // Other nodes will use \"fallback-password\"\n], {\n  redisOptions: {\n    password: 'fallback-password'\n  }\n});\n```\n\n<hr>\n\n# Error Handling\nAll the errors returned by the Redis server are instances of `ReplyError`, which can be accessed via `Redis`:\n\n```javascript\nvar Redis = require('ioredis');\nvar redis = new Redis();\n// This command causes a reply error since the SET command requires two arguments.\nredis.set('foo', function (err) {\n  err instanceof Redis.ReplyError\n});\n```\n\nThis is the error stack of the `ReplyError`:\n\n```\nReplyError: ERR wrong number of arguments for 'set' command\n    at ReplyParser._parseResult (/app/node_modules/ioredis/lib/parsers/javascript.js:60:14)\n    at ReplyParser.execute (/app/node_modules/ioredis/lib/parsers/javascript.js:178:20)\n    at Socket.<anonymous> (/app/node_modules/ioredis/lib/redis/event_handler.js:99:22)\n    at Socket.emit (events.js:97:17)\n    at readableAddChunk (_stream_readable.js:143:16)\n    at Socket.Readable.push (_stream_readable.js:106:10)\n    at TCP.onread (net.js:509:20)\n```\n\nBy default, the error stack doesn't make any sense because the whole stack happens in the ioredis\nmodule itself, not in your code. So it's not easy to find out where the error happens in your code.\nioredis provides an option `showFriendlyErrorStack` to solve the problem. When you enable\n`showFriendlyErrorStack`, ioredis will optimize the error stack for you:\n\n```javascript\nvar Redis = require('ioredis');\nvar redis = new Redis({ showFriendlyErrorStack: true });\nredis.set('foo');\n```\n\nAnd the output will be:\n\n```\nReplyError: ERR wrong number of arguments for 'set' command\n    at Object.<anonymous> (/app/index.js:3:7)\n    at Module._compile (module.js:446:26)\n    at Object.Module._extensions..js (module.js:464:10)\n    at Module.load (module.js:341:32)\n    at Function.Module._load (module.js:296:12)\n    at Function.Module.runMain (module.js:487:10)\n    at startup (node.js:111:16)\n    at node.js:799:3\n```\n\nThis time the stack tells you that the error happens on the third line in your code. Pretty sweet!\nHowever, it would decrease the performance significantly to optimize the error stack. So by\ndefault, this option is disabled and can only be used for debugging purposes. You **shouldn't** use this feature in a production environment.\n\n# Plugging in your own Promises Library\nIf you're an advanced user, you may want to plug in your own promise library like [bluebird](https://www.npmjs.com/package/bluebird). Just set Redis.Promise to your favorite ES6-style promise constructor and ioredis will use it.\n\n```javascript\nconst Redis = require('ioredis')\nRedis.Promise = require('bluebird')\n\nconst redis = new Redis()\n\n// Use bluebird\nassert.equal(redis.get().constructor, require('bluebird'))\n\n// You can change the Promise implementation at any time:\nRedis.Promise = global.Promise\nassert.equal(redis.get().constructor, global.Promise)\n```\n\n\n# Running tests\n\nStart a Redis server on 127.0.0.1:6379, and then:\n\n```shell\n$ npm test\n```\n\n`FLUSH ALL` will be invoked after each test, so make sure there's no valuable data in it before running tests.\n\nIf your testing environment does not let you spin up a Redis server [ioredis-mock](https://github.com/stipsan/ioredis-mock) is a drop-in replacement you can use in your tests. It aims to behave identically to ioredis connected to a Redis server so that your integration tests is easier to write and of better quality.\n\n# Debug\n\nYou can set the `DEBUG` env to `ioredis:*` to print debug info:\n\n```shell\n$ DEBUG=ioredis:* node app.js\n```\n\n# Consolidation: It's time for celebration\n\nRight now there are two great redis clients around and both have some advantages above each other. We speak about [node_redis](https://github.com/NodeRedis/node_redis) and ioredis. So after talking to each other about how we could improve in working together we (that is [@BridgeAR](https://github.com/BridgeAR) and [@luin](https://github.com/luin)) decided to work towards a single library on the long run. But step by step.\n\nFirst of all, we want to split small parts of our libraries into others so that we're both able to use the same code. Those libraries are going to be maintained under the NodeRedis organization. This is going to reduce the maintance overhead, allows others to use the very same code, if they need it and it's way easier for others to contribute to both libraries.\n\nWe're very happy about this step towards working together as we both want to give you the best redis experience possible.\n\nIf you want to join our cause by help maintaining something, please don't hesitate to contact either one of us.\n\n# Join in!\n\nI'm happy to receive bug reports, fixes, documentation enhancements, and any other improvements.\n\nAnd since I'm not a native English speaker, if you find any grammar mistakes in the documentation, please also let me know. :)\n\n# Contributors\n\nThis project exists thanks to all the people who contribute:\n\n<table><tr><td width=\"20%\"><a href=\"https://github.com/luin\"><img src=\"https://avatars2.githubusercontent.com/u/635902?v=4\" /></a><p align=\"center\">luin</p></td><td width=\"20%\"><a href=\"https://github.com/shaharmor\"><img src=\"https://avatars3.githubusercontent.com/u/10861920?v=4\" /></a><p align=\"center\">shaharmor</p></td><td width=\"20%\"><a href=\"https://github.com/iamjochem\"><img src=\"https://avatars0.githubusercontent.com/u/792188?v=4\" /></a><p align=\"center\">iamjochem</p></td><td width=\"20%\"><a href=\"https://github.com/doublesharp\"><img src=\"https://avatars3.githubusercontent.com/u/571472?v=4\" /></a><p align=\"center\">doublesharp</p></td><td width=\"20%\"><a href=\"https://github.com/nakulgan\"><img src=\"https://avatars3.githubusercontent.com/u/189836?v=4\" /></a><p align=\"center\">nakulgan</p></td></tr><tr><td width=\"20%\"><a href=\"https://github.com/AVVS\"><img src=\"https://avatars1.githubusercontent.com/u/1713617?v=4\" /></a><p align=\"center\">AVVS</p></td><td width=\"20%\"><a href=\"https://github.com/ramonsnir\"><img src=\"https://avatars1.githubusercontent.com/u/1024028?v=4\" /></a><p align=\"center\">ramonsnir</p></td><td width=\"20%\"><a href=\"https://github.com/hayeah\"><img src=\"https://avatars2.githubusercontent.com/u/50120?v=4\" /></a><p align=\"center\">hayeah</p></td><td width=\"20%\"><a href=\"https://github.com/albin3\"><img src=\"https://avatars3.githubusercontent.com/u/6190670?v=4\" /></a><p align=\"center\">albin3</p></td><td width=\"20%\"><a href=\"https://github.com/phlip9\"><img src=\"https://avatars0.githubusercontent.com/u/918989?v=4\" /></a><p align=\"center\">phlip9</p></td></tr><tr><td width=\"20%\"><a href=\"https://github.com/chris-olszewski\"><img src=\"https://avatars1.githubusercontent.com/u/4131117?v=4\" /></a><p align=\"center\">chris-olszewski</p></td><td width=\"20%\"><a href=\"https://github.com/fracmak\"><img src=\"https://avatars1.githubusercontent.com/u/378178?v=4\" /></a><p align=\"center\">fracmak</p></td><td width=\"20%\"><a href=\"https://github.com/ddunkin\"><img src=\"https://avatars2.githubusercontent.com/u/264744?v=4\" /></a><p align=\"center\">ddunkin</p></td><td width=\"20%\"><a href=\"https://github.com/ruimarinho\"><img src=\"https://avatars0.githubusercontent.com/u/288709?v=4\" /></a><p align=\"center\">ruimarinho</p></td><td width=\"20%\"><a href=\"https://github.com/suprememoocow\"><img src=\"https://avatars0.githubusercontent.com/u/594566?v=4\" /></a><p align=\"center\">suprememoocow</p></td></tr><tr><td width=\"20%\"><a href=\"https://github.com/jpallen\"><img src=\"https://avatars0.githubusercontent.com/u/31305?v=4\" /></a><p align=\"center\">jpallen</p></td><td width=\"20%\"><a href=\"https://github.com/reconbot\"><img src=\"https://avatars2.githubusercontent.com/u/25966?v=4\" /></a><p align=\"center\">reconbot</p></td><td width=\"20%\"><a href=\"https://github.com/lpinca\"><img src=\"https://avatars0.githubusercontent.com/u/1443911?v=4\" /></a><p align=\"center\">lpinca</p></td><td width=\"20%\"><a href=\"https://github.com/frankvm04\"><img src=\"https://avatars1.githubusercontent.com/u/796475?v=4\" /></a><p align=\"center\">frankvm04</p></td><td width=\"20%\"><a href=\"https://github.com/jeffjen\"><img src=\"https://avatars3.githubusercontent.com/u/5814507?v=4\" /></a><p align=\"center\">jeffjen</p></td></tr><tr><td width=\"20%\"><a href=\"https://github.com/SamBergeron\"><img src=\"https://avatars1.githubusercontent.com/u/3879294?v=4\" /></a><p align=\"center\">SamBergeron</p></td><td width=\"20%\"><a href=\"https://github.com/seoker\"><img src=\"https://avatars1.githubusercontent.com/u/7975797?v=4\" /></a><p align=\"center\">seoker</p></td><td width=\"20%\"><a href=\"https://github.com/southpolesteve\"><img src=\"https://avatars1.githubusercontent.com/u/471400?v=4\" /></a><p align=\"center\">southpolesteve</p></td><td width=\"20%\"><a href=\"https://github.com/devaos\"><img src=\"https://avatars0.githubusercontent.com/u/5412167?v=4\" /></a><p align=\"center\">devaos</p></td><td width=\"20%\"><a href=\"https://github.com/headquarters\"><img src=\"https://avatars0.githubusercontent.com/u/347079?v=4\" /></a><p align=\"center\">headquarters</p></td></tr><tr><td width=\"20%\"><a href=\"https://github.com/9point6\"><img src=\"https://avatars1.githubusercontent.com/u/627697?v=4\" /></a><p align=\"center\">9point6</p></td><td width=\"20%\"><a href=\"https://github.com/horx\"><img src=\"https://avatars2.githubusercontent.com/u/1332618?v=4\" /></a><p align=\"center\">horx</p></td><td width=\"20%\"><a href=\"https://github.com/darrachequesne\"><img src=\"https://avatars3.githubusercontent.com/u/13031701?v=4\" /></a><p align=\"center\">darrachequesne</p></td><td width=\"20%\"><a href=\"https://github.com/damianhodgkiss\"><img src=\"https://avatars2.githubusercontent.com/u/4359427?v=4\" /></a><p align=\"center\">damianhodgkiss</p></td><td width=\"20%\"><a href=\"https://github.com/ColmHally\"><img src=\"https://avatars3.githubusercontent.com/u/20333?v=4\" /></a><p align=\"center\">ColmHally</p></td></tr><tr><td width=\"20%\"><a href=\"https://github.com/klinquist\"><img src=\"https://avatars2.githubusercontent.com/u/1343376?v=4\" /></a><p align=\"center\">klinquist</p></td><td width=\"20%\"><a href=\"https://github.com/alsotang\"><img src=\"https://avatars1.githubusercontent.com/u/1147375?v=4\" /></a><p align=\"center\">alsotang</p></td><td width=\"20%\"><a href=\"https://github.com/zhuangya\"><img src=\"https://avatars2.githubusercontent.com/u/499038?v=4\" /></a><p align=\"center\">zhuangya</p></td><td width=\"20%\"><a href=\"https://github.com/taichunmin\"><img src=\"https://avatars3.githubusercontent.com/u/2192626?v=4\" /></a><p align=\"center\">taichunmin</p></td><td width=\"20%\"><a href=\"https://github.com/Gerhut\"><img src=\"https://avatars1.githubusercontent.com/u/2500247?v=4\" /></a><p align=\"center\">Gerhut</p></td></tr><tr><td width=\"20%\"><a href=\"https://github.com/barwin\"><img src=\"https://avatars3.githubusercontent.com/u/3289?v=4\" /></a><p align=\"center\">barwin</p></td><td width=\"20%\"><a href=\"https://github.com/jcperez\"><img src=\"https://avatars0.githubusercontent.com/u/4073359?v=4\" /></a><p align=\"center\">jcperez</p></td><td width=\"20%\"><a href=\"https://github.com/pensierinmusica\"><img src=\"https://avatars1.githubusercontent.com/u/3594037?v=4\" /></a><p align=\"center\">pensierinmusica</p></td><td width=\"20%\"><a href=\"https://github.com/TeeAaTeeUu\"><img src=\"https://avatars1.githubusercontent.com/u/997511?v=4\" /></a><p align=\"center\">TeeAaTeeUu</p></td><td width=\"20%\"><a href=\"https://github.com/henstock\"><img src=\"https://avatars3.githubusercontent.com/u/13809467?v=4\" /></a><p align=\"center\">henstock</p></td></tr><tr><td width=\"20%\"><a href=\"https://github.com/i5ting\"><img src=\"https://avatars3.githubusercontent.com/u/3118295?v=4\" /></a><p align=\"center\">i5ting</p></td><td width=\"20%\"><a href=\"https://github.com/devoto13\"><img src=\"https://avatars1.githubusercontent.com/u/823594?v=4\" /></a><p align=\"center\">devoto13</p></td><td width=\"20%\"><a href=\"https://github.com/tkalfigo\"><img src=\"https://avatars2.githubusercontent.com/u/3481553?v=4\" /></a><p align=\"center\">tkalfigo</p></td><td width=\"20%\"><a href=\"https://github.com/ArtskydJ\"><img src=\"https://avatars2.githubusercontent.com/u/1833684?v=4\" /></a><p align=\"center\">ArtskydJ</p></td><td width=\"20%\"><a href=\"https://github.com/nswbmw\"><img src=\"https://avatars0.githubusercontent.com/u/4279697?v=4\" /></a><p align=\"center\">nswbmw</p></td></tr><tr><td width=\"20%\"><a href=\"https://github.com/igrcic\"><img src=\"https://avatars1.githubusercontent.com/u/394398?v=4\" /></a><p align=\"center\">igrcic</p></td><td width=\"20%\"><a href=\"https://github.com/VikramTiwari\"><img src=\"https://avatars3.githubusercontent.com/u/1330677?v=4\" /></a><p align=\"center\">VikramTiwari</p></td><td width=\"20%\"><a href=\"https://github.com/mtlima\"><img src=\"https://avatars0.githubusercontent.com/u/9111440?v=4\" /></a><p align=\"center\">mtlima</p></td><td width=\"20%\"><a href=\"https://github.com/pra85\"><img src=\"https://avatars2.githubusercontent.com/u/829526?v=4\" /></a><p align=\"center\">pra85</p></td><td width=\"20%\"><a href=\"https://github.com/joeledwards\"><img src=\"https://avatars3.githubusercontent.com/u/412853?v=4\" /></a><p align=\"center\">joeledwards</p></td></tr><tr><td width=\"20%\"><a href=\"https://github.com/dguo\"><img src=\"https://avatars0.githubusercontent.com/u/2763135?v=4\" /></a><p align=\"center\">dguo</p></td><td width=\"20%\"><a href=\"https://github.com/stipsan\"><img src=\"https://avatars2.githubusercontent.com/u/81981?v=4\" /></a><p align=\"center\">stipsan</p></td><td width=\"20%\"><a href=\"https://github.com/bradvogel\"><img src=\"https://avatars1.githubusercontent.com/u/821706?v=4\" /></a><p align=\"center\">bradvogel</p></td><td width=\"20%\"><a href=\"https://github.com/pyros2097\"><img src=\"https://avatars0.githubusercontent.com/u/1687946?v=4\" /></a><p align=\"center\">pyros2097</p></td><td width=\"20%\"><a href=\"https://github.com/tempname11\"><img src=\"https://avatars0.githubusercontent.com/u/8409150?v=4\" /></a><p align=\"center\">tempname11</p></td></tr></table>\n\n# License\n\nMIT\n","readmeFilename":"README.md","gitHead":"92696d5126fd1ae450e14904efb18a7e184b3e37","bugs":{"url":"https://github.com/luin/ioredis/issues"},"homepage":"https://github.com/luin/ioredis#readme","_id":"ioredis@4.0.0-2","_npmVersion":"5.6.0","_nodeVersion":"8.1.0","_npmUser":{"name":"luin","email":"i@zihua.li"},"dist":{"integrity":"sha512-l+K6UpwwJgf36Ru/rHcZSmppTeGj70fTxGx0s7az0gV3KU5+oiiZhzFLoQzDTEaBdeeoVrM2ykacHHsm+Ryktg==","shasum":"87230630326654c8be1901f91d34cec575da60b0","tarball":"https://registry.npmjs.org/ioredis/-/ioredis-4.0.0-2.tgz","fileCount":26,"unpackedSize":188203,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJbQHyUCRA9TVsSAnZWagAAZzEP/2os8ClzqhlqZf1nM/hX\nxGPJNM+rj0lFZ4FWauJWg9pekoVXNV9MZUcEgGIofIh84Ylz+YhTBp+DCIfc\nbZQdmi2uDrrN6F5eix/tgE1WjxmKEC2XpPlY8/KRTi+dOFOfzP9GLz5ZWP1W\nD18xEpypxkIDmVFLzXF7u0HVgGAL5vX/+Vdp0m/RKuG00plt9O++XHHoEHJr\nFuo2VW8ws3eYTdzbGDalBQK3VE1km+RgflxrTj6aOWFxsGDibgB5HTuRf4UZ\n0HDP7ZckmasJ+qU4pelbFRXd7znfqHyamkPeR8KjVG5a40qE1n8TyTDjOYWe\nEBhiLDIxdqnLXMuX5C08bLzJ7Y17cUbT1m3aS4G930YMgQMyH8cYbpiyXS+j\nVXAePG0zI+1241v+/HiC4Z4ea8NMfpDn6RDwDNT3zxXej010LPnM/X3+EHrm\nuII2tdo+Ab09JiSXr4gLxa0BU8s2TdhYn2fGeghROohYLRLsf4NyKh7C9qsQ\n/w0rcu/mE3WgGjL7GOmMAwD5TIm5W2N6eIxdk6BAOf4lUYxxF7aFGP80shTF\nNEYeC90t9HQ5/JR31RHb3z8hY8zU2n8ZnAuddD4jMF6vSSQIA7VqMc16avPA\nYQkN68mlotFrddm/AoYIBwDCOIgkFaDF4Y8RKNNM/pp0XSy7dPFVeyM9gkwv\nUKIz\r\n=ZavH\r\n-----END PGP SIGNATURE-----\r\n"},"maintainers":[{"name":"luin","email":"i@zihua.li"}],"directories":{},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/ioredis_4.0.0-2_1530952851514_0.23889938822281187"},"_hasShrinkwrap":false},"4.0.0-3":{"name":"ioredis","version":"4.0.0-3","description":"A robust, performance-focused and full-featured Redis client for Node.js.","main":"built/index.js","files":["index.js","built/"],"scripts":{"test":"NODE_ENV=test mocha --timeout 8000 -r ts-node/register --exit","test:cov":"NODE_ENV=test node ./node_modules/istanbul/lib/cli.js cover --preserve-comments ./node_modules/mocha/bin/_mocha -- -r ts-node/register -R spec --exit","build":"rm -rf built && tsc","generate-docs":"jsdoc2md lib/redis.js lib/cluster/index.js lib/commander.js > API.md","prepublish":"npm run build && npm test","bench":"matcha benchmarks/*.js"},"repository":{"type":"git","url":"git://github.com/luin/ioredis.git"},"keywords":["redis","cluster","sentinel","pipelining"],"author":{"name":"luin","email":"i@zihua.li","url":"http://zihua.li"},"license":"MIT","dependencies":{"cluster-key-slot":"^1.0.6","debug":"^3.1.0","denque":"^1.1.0","flexbuffer":"0.0.6","lodash.bind":"^4.2.1","lodash.clone":"^4.5.0","lodash.clonedeep":"^4.5.0","lodash.defaults":"^4.2.0","lodash.difference":"^4.5.0","lodash.flatten":"^4.4.0","lodash.foreach":"^4.5.0","lodash.isempty":"^4.4.0","lodash.partial":"^4.2.1","lodash.pick":"^4.4.0","lodash.sample":"^4.2.1","lodash.shuffle":"^4.2.0","lodash.values":"^4.3.0","redis-commands":"^1.2.0","redis-errors":"^1.2.0","redis-parser":"^3.0.0","standard-as-callback":"^1.0.0"},"devDependencies":{"@types/node":"^10.5.2","bluebird":"^3.5.1","chai":"^3.5.0","cz-conventional-changelog":"^2.0.0","istanbul":"^0.4.2","jsdoc":"^3.4.0","jsdoc-to-markdown":"^4.0.1","mocha":"^5.2.0","server-destroy":"^1.0.1","sinon":"^1.17.3","ts-node":"^7.0.0","typescript":"^2.9.2"},"engines":{"node":">=4"},"config":{"commitizen":{"path":"./node_modules/cz-conventional-changelog"}},"readme":"[![ioredis](https://cdn.rawgit.com/luin/ioredis/57b5b89e3e9111ff25d8c62c0bc58ed42e5b8d1e/logo.svg)](https://github.com/luin/ioredis)\n\n[![Build Status](https://travis-ci.org/luin/ioredis.svg?branch=master)](https://travis-ci.org/luin/ioredis)\n[![Test Coverage](https://codeclimate.com/github/luin/ioredis/badges/coverage.svg)](https://codeclimate.com/github/luin/ioredis)\n[![Code Climate](https://codeclimate.com/github/luin/ioredis/badges/gpa.svg)](https://codeclimate.com/github/luin/ioredis)\n[![Commitizen friendly](https://img.shields.io/badge/commitizen-friendly-brightgreen.svg)](http://commitizen.github.io/cz-cli/)\n[![Join the chat at https://gitter.im/luin/ioredis](https://badges.gitter.im/Join%20Chat.svg)](https://gitter.im/luin/ioredis?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge)\n\nA robust, performance-focused and full-featured [Redis](http://redis.io) client for [Node.js](https://nodejs.org).\n\nSupports Redis >= 2.6.12 and (Node.js >= 6).\n\n# Features\nioredis is a robust, full-featured Redis client that is\nused in the world's biggest online commerce company [Alibaba](http://www.alibaba.com/) and many other awesome companies.\n\n0. Full-featured. It supports [Cluster](http://redis.io/topics/cluster-tutorial), [Sentinel](http://redis.io/topics/sentinel), [Pipelining](http://redis.io/topics/pipelining) and of course [Lua scripting](http://redis.io/commands/eval) & [Pub/Sub](http://redis.io/topics/pubsub) (with the support of binary messages).\n0. High performance.\n0. Delightful API. It works with Node callbacks and Native promises.\n0. Transformation of command arguments and replies.\n0. Transparent key prefixing.\n0. Abstraction for Lua scripting, allowing you to define custom commands.\n0. Support for binary data.\n0. Support for TLS.\n0. Support for offline queue and ready checking.\n0. Support for ES6 types, such as `Map` and `Set`.\n0. Support for GEO commands (Redis 3.2 Unstable).\n0. Sophisticated error handling strategy.\n\n# Links\n* [API Documentation](API.md)\n* [Changelog](Changelog.md)\n* [Migrating from node_redis](https://github.com/luin/ioredis/wiki/Migrating-from-node_redis)\n* [Error Handling](#error-handling)\n\n## Become a Sponsor to Support ioredis's Development\nOpen source is hard and time-consuming. If you want to invest in ioredis's future you can become a sponsor and make us spend more time on this library's improvements and new features.\n\n<a href=\"https://opencollective.com/ioredis\"><img src=\"https://opencollective.com/ioredis/tiers/sponsor.svg?avatarHeight=36\"></a>\n\nThank you for using ioredis :-)\n\n<hr>\n<a href=\"https://itunes.apple.com/app/medis-gui-for-redis/id1063631769\"><img align=\"right\" src=\"medis.png\" alt=\"Download on the App Store\"></a>\n\n\n### Advertisement\n\nLooking for a Redis GUI manager for OS X, Windows and Linux? Here's [Medis](https://itunes.apple.com/us/app/medis-gui-for-redis/id1063631769)!\n\nMedis is an open-sourced, beautiful, easy-to-use Redis GUI management application.\n\nMedis starts with all the basic features you need:\n\n* Keys viewing/editing\n* SSH Tunnel for connecting with remote servers\n* Terminal for executing custom commands\n* JSON/MessagePack format viewing/editing and built-in highlighting/validator\n* And other awesome features...\n\n[Medis is open sourced on GitHub](https://github.com/luin/medis)\n\n<hr>\n\n# Quick Start\n\n## Install\n```shell\n$ npm install ioredis\n```\n\n## Basic Usage\n\n```javascript\nvar Redis = require('ioredis');\nvar redis = new Redis();\n\nredis.set('foo', 'bar');\nredis.get('foo', function (err, result) {\n  console.log(result);\n});\n\n// Or using a promise if the last argument isn't a function\nredis.get('foo').then(function (result) {\n  console.log(result);\n});\n\n// Arguments to commands are flattened, so the following are the same:\nredis.sadd('set', 1, 3, 5, 7);\nredis.sadd('set', [1, 3, 5, 7]);\n\n// All arguments are passed directly to the redis server:\nredis.set('key', 100, 'EX', 10);\n```\n\nSee the `examples/` folder for more examples.\n\n## Connect to Redis\nWhen a new `Redis` instance is created,\na connection to Redis will be created at the same time.\nYou can specify which Redis to connect to by:\n\n```javascript\nnew Redis()       // Connect to 127.0.0.1:6379\nnew Redis(6380)   // 127.0.0.1:6380\nnew Redis(6379, '192.168.1.1')        // 192.168.1.1:6379\nnew Redis('/tmp/redis.sock')\nnew Redis({\n  port: 6379,          // Redis port\n  host: '127.0.0.1',   // Redis host\n  family: 4,           // 4 (IPv4) or 6 (IPv6)\n  password: 'auth',\n  db: 0\n})\n```\n\nYou can also specify connection options as a [`redis://` URL](http://www.iana.org/assignments/uri-schemes/prov/redis):\n\n```javascript\n// Connect to 127.0.0.1:6380, db 4, using password \"authpassword\":\nnew Redis('redis://:authpassword@127.0.0.1:6380/4')\n```\n\nSee [API Documentation](API.md#new_Redis) for all available options.\n\n## Pub/Sub\n\nHere is a simple example of the API for publish/subscribe.\nThe following program opens two client connections.\nIt subscribes to a channel with one connection\nand publishes to that channel with the other:\n\n```javascript\nvar Redis = require('ioredis');\nvar redis = new Redis();\nvar pub = new Redis();\nredis.subscribe('news', 'music', function (err, count) {\n  // Now we are subscribed to both the 'news' and 'music' channels.\n  // `count` represents the number of channels we are currently subscribed to.\n\n  pub.publish('news', 'Hello world!');\n  pub.publish('music', 'Hello again!');\n});\n\nredis.on('message', function (channel, message) {\n  // Receive message Hello world! from channel news\n  // Receive message Hello again! from channel music\n  console.log('Receive message %s from channel %s', message, channel);\n});\n\n// There's also an event called 'messageBuffer', which is the same as 'message' except\n// it returns buffers instead of strings.\nredis.on('messageBuffer', function (channel, message) {\n  // Both `channel` and `message` are buffers.\n});\n```\n\n`PSUBSCRIBE` is also supported in a similar way:\n\n```javascript\nredis.psubscribe('pat?ern', function (err, count) {});\nredis.on('pmessage', function (pattern, channel, message) {});\nredis.on('pmessageBuffer', function (pattern, channel, message) {});\n```\n\nWhen a client issues a SUBSCRIBE or PSUBSCRIBE, that connection is put into a \"subscriber\" mode.\nAt that point, only commands that modify the subscription set are valid.\nWhen the subscription set is empty, the connection is put back into regular mode.\n\nIf you need to send regular commands to Redis while in subscriber mode, just open another connection.\n\n## Handle Binary Data\nArguments can be buffers:\n```javascript\nredis.set('foo', new Buffer('bar'));\n```\n\nAnd every command has a method that returns a Buffer (by adding a suffix of \"Buffer\" to the command name).\nTo get a buffer instead of a utf8 string:\n\n```javascript\nredis.getBuffer('foo', function (err, result) {\n  // result is a buffer.\n});\n```\n\n## Pipelining\nIf you want to send a batch of commands (e.g. > 5), you can use pipelining to queue\nthe commands in memory and then send them to Redis all at once. This way the performance improves by 50%~300% (See [benchmark section](#benchmark)).\n\n`redis.pipeline()` creates a `Pipeline` instance. You can call any Redis\ncommands on it just like the `Redis` instance. The commands are queued in memory\nand flushed to Redis by calling the `exec` method:\n\n```javascript\nvar pipeline = redis.pipeline();\npipeline.set('foo', 'bar');\npipeline.del('cc');\npipeline.exec(function (err, results) {\n  // `err` is always null, and `results` is an array of responses\n  // corresponding to the sequence of queued commands.\n  // Each response follows the format `[err, result]`.\n});\n\n// You can even chain the commands:\nredis.pipeline().set('foo', 'bar').del('cc').exec(function (err, results) {\n});\n\n// `exec` also returns a Promise:\nvar promise = redis.pipeline().set('foo', 'bar').get('foo').exec();\npromise.then(function (result) {\n  // result === [[null, 'OK'], [null, 'bar']]\n});\n```\n\nEach chained command can also have a callback, which will be invoked when the command\ngets a reply:\n\n```javascript\nredis.pipeline().set('foo', 'bar').get('foo', function (err, result) {\n  // result === 'bar'\n}).exec(function (err, result) {\n  // result[1][1] === 'bar'\n});\n```\n\nIn addition to adding commands to the `pipeline` queue individually, you can also pass an array of commands and arguments to the constructor:\n\n```javascript\nredis.pipeline([\n  ['set', 'foo', 'bar'],\n  ['get', 'foo']\n]).exec(function () { /* ... */ });\n```\n\n`#length` property shows how many commands in the pipeline:\n\n```javascript\nconst length = redis.pipeline().set('foo', 'bar').get('foo').length;\n// length === 2\n```\n\n\n## Transaction\nMost of the time, the transaction commands `multi` & `exec` are used together with pipeline.\nTherefore, when `multi` is called, a `Pipeline` instance is created automatically by default,\nso you can use `multi` just like `pipeline`:\n\n```javascript\nredis.multi().set('foo', 'bar').get('foo').exec(function (err, results) {\n  // results === [[null, 'OK'], [null, 'bar']]\n});\n```\nIf there's a syntax error in the transaction's command chain (e.g. wrong number of arguments, wrong command name, etc),\nthen none of the commands would be executed, and an error is returned:\n\n```javascript\nredis.multi().set('foo').set('foo', 'new value').exec(function (err, results) {\n  // err:\n  //  { [ReplyError: EXECABORT Transaction discarded because of previous errors.]\n  //    name: 'ReplyError',\n  //    message: 'EXECABORT Transaction discarded because of previous errors.',\n  //    command: { name: 'exec', args: [] },\n  //    previousErrors:\n  //     [ { [ReplyError: ERR wrong number of arguments for 'set' command]\n  //         name: 'ReplyError',\n  //         message: 'ERR wrong number of arguments for \\'set\\' command',\n  //         command: [Object] } ] }\n});\n```\n\nIn terms of the interface, `multi` differs from `pipeline` in that when specifying a callback\nto each chained command, the queueing state is passed to the callback instead of the result of the command:\n\n```javascript\nredis.multi().set('foo', 'bar', function (err, result) {\n  // result === 'QUEUED'\n}).exec(/* ... */);\n```\n\nIf you want to use transaction without pipeline, pass `{ pipeline: false }` to `multi`,\nand every command will be sent to Redis immediately without waiting for an `exec` invocation:\n\n```javascript\nredis.multi({ pipeline: false });\nredis.set('foo', 'bar');\nredis.get('foo');\nredis.exec(function (err, result) {\n  // result === [[null, 'OK'], [null, 'bar']]\n});\n```\n\nThe constructor of `multi` also accepts a batch of commands:\n\n```javascript\nredis.multi([\n  ['set', 'foo', 'bar'],\n  ['get', 'foo']\n]).exec(function () { /* ... */ });\n```\n\nInline transactions are supported by pipeline, which means you can group a subset of commands\nin the pipeline into a transaction:\n\n```javascript\nredis.pipeline().get('foo').multi().set('foo', 'bar').get('foo').exec().get('foo').exec();\n```\n\n## Lua Scripting\nioredis supports all of the scripting commands such as `EVAL`, `EVALSHA` and `SCRIPT`.\nHowever, it's tedious to use in real world scenarios since developers have to take\ncare of script caching and to detect when to use `EVAL` and when to use `EVALSHA`.\nioredis expose a `defineCommand` method to make scripting much easier to use:\n\n```javascript\nvar redis = new Redis();\n\n// This will define a command echo:\nredis.defineCommand('echo', {\n  numberOfKeys: 2,\n  lua: 'return {KEYS[1],KEYS[2],ARGV[1],ARGV[2]}'\n});\n\n// Now `echo` can be used just like any other ordinary command,\n// and ioredis will try to use `EVALSHA` internally when possible for better performance.\nredis.echo('k1', 'k2', 'a1', 'a2', function (err, result) {\n  // result === ['k1', 'k2', 'a1', 'a2']\n});\n\n// `echoBuffer` is also defined automatically to return buffers instead of strings:\nredis.echoBuffer('k1', 'k2', 'a1', 'a2', function (err, result) {\n  // result[0] === new Buffer('k1');\n});\n\n// And of course it works with pipeline:\nredis.pipeline().set('foo', 'bar').echo('k1', 'k2', 'a1', 'a2').exec();\n```\n\nIf the number of keys can't be determined when defining a command, you can\nomit the `numberOfKeys` property and pass the number of keys as the first argument\nwhen you call the command:\n\n```javascript\nredis.defineCommand('echoDynamicKeyNumber', {\n  lua: 'return {KEYS[1],KEYS[2],ARGV[1],ARGV[2]}'\n});\n\n// Now you have to pass the number of keys as the first argument every time\n// you invoke the `echoDynamicKeyNumber` command:\nredis.echoDynamicKeyNumber(2, 'k1', 'k2', 'a1', 'a2', function (err, result) {\n  // result === ['k1', 'k2', 'a1', 'a2']\n});\n```\n\n## Transparent Key Prefixing\nThis feature allows you to specify a string that will automatically be prepended\nto all the keys in a command, which makes it easier to manage your key\nnamespaces.\n\n**Warning** This feature won't apply to commands like [KEYS](http://redis.io/commands/KEYS) and [SCAN](http://redis.io/commands/scan) that take patterns rather than actual keys([#239](https://github.com/luin/ioredis/issues/239)),\nand this feature also won't apply to the replies of commands even they are key names ([#325](https://github.com/luin/ioredis/issues/325)).\n\n```javascript\nvar fooRedis = new Redis({ keyPrefix: 'foo:' });\nfooRedis.set('bar', 'baz');  // Actually sends SET foo:bar baz\n\nfooRedis.defineCommand('echo', {\n  numberOfKeys: 2,\n  lua: 'return {KEYS[1],KEYS[2],ARGV[1],ARGV[2]}'\n});\n\n// Works well with pipelining/transaction\nfooRedis.pipeline()\n  // Sends SORT foo:list BY foo:weight_*->fieldname\n  .sort('list', 'BY', 'weight_*->fieldname')\n  // Supports custom commands\n  // Sends EVALSHA xxx foo:k1 foo:k2 a1 a2\n  .echo('k1', 'k2', 'a1', 'a2')\n  .exec()\n```\n\n## Transforming Arguments & Replies\nMost Redis commands take one or more Strings as arguments,\nand replies are sent back as a single String or an Array of Strings. However, sometimes\nyou may want something different. For instance, it would be more convenient if the `HGETALL`\ncommand returns a hash (e.g. `{ key: val1, key2: v2 }`) rather than an array of key values (e.g. `[key1, val1, key2, val2]`).\n\nioredis has a flexible system for transforming arguments and replies. There are two types\nof transformers, argument transformer and reply transformer:\n\n```javascript\nvar Redis = require('ioredis');\n\n// Here's the built-in argument transformer converting\n// hmset('key', { k1: 'v1', k2: 'v2' })\n// or\n// hmset('key', new Map([['k1', 'v1'], ['k2', 'v2']]))\n// into\n// hmset('key', 'k1', 'v1', 'k2', 'v2')\nRedis.Command.setArgumentTransformer('hmset', function (args) {\n  if (args.length === 2) {\n    if (typeof Map !== 'undefined' && args[1] instanceof Map) {\n      // utils is a internal module of ioredis\n      return [args[0]].concat(utils.convertMapToArray(args[1]));\n    }\n    if ( typeof args[1] === 'object' && args[1] !== null) {\n      return [args[0]].concat(utils.convertObjectToArray(args[1]));\n    }\n  }\n  return args;\n});\n\n// Here's the built-in reply transformer converting the HGETALL reply\n// ['k1', 'v1', 'k2', 'v2']\n// into\n// { k1: 'v1', 'k2': 'v2' }\nRedis.Command.setReplyTransformer('hgetall', function (result) {\n  if (Array.isArray(result)) {\n    var obj = {};\n    for (var i = 0; i < result.length; i += 2) {\n      obj[result[i]] = result[i + 1];\n    }\n    return obj;\n  }\n  return result;\n});\n```\n\nThere are three built-in transformers, two argument transformers for `hmset` & `mset` and\na reply transformer for `hgetall`. Transformers for `hmset` and `hgetall` were mentioned\nabove, and the transformer for `mset` is similar to the one for `hmset`:\n\n```javascript\nredis.mset({ k1: 'v1', k2: 'v2' });\nredis.get('k1', function (err, result) {\n  // result === 'v1';\n});\n\nredis.mset(new Map([['k3', 'v3'], ['k4', 'v4']]));\nredis.get('k3', function (err, result) {\n  // result === 'v3';\n});\n```\n\nAnother useful example of a reply transformer is one that changes `hgetall` to return array of arrays instead of objects which avoids a unwanted conversation of hash keys to strings when dealing with binary hash keys:\n\n```javascript\nRedis.Command.setReplyTransformer('hgetall', function (result) {\n  var arr = [];\n  for (var i = 0; i < result.length; i += 2) {\n    arr.push([result[i], result[i + 1]]);\n  }\n  return arr;\n});\nredis.hset('h1', Buffer.from([0x01]), Buffer.from([0x02]));\nredis.hset('h1', Buffer.from([0x03]), Buffer.from([0x04]));\nredis.hgetallBuffer('h1', function (err, result) {\n  // result === [ [ <Buffer 01>, <Buffer 02> ], [ <Buffer 03>, <Buffer 04> ] ];\n});\n```\n\n## Monitor\nRedis supports the MONITOR command,\nwhich lets you see all commands received by the Redis server across all client connections,\nincluding from other client libraries and other computers.\n\nThe `monitor` method returns a monitor instance.\nAfter you send the MONITOR command, no other commands are valid on that connection. ioredis will emit a monitor event for every new monitor message that comes across.\nThe callback for the monitor event takes a timestamp from the Redis server and an array of command arguments.\n\nHere is a simple example:\n\n```javascript\nredis.monitor(function (err, monitor) {\n  monitor.on('monitor', function (time, args, source, database) {\n  });\n});\n```\n\n## Streamify Scanning\nRedis 2.8 added the `SCAN` command to incrementally iterate through the keys in the database. It's different from `KEYS` in that\n`SCAN` only returns a small number of elements each call, so it can be used in production without the downside\nof blocking the server for a long time. However, it requires recording the cursor on the client side each time\nthe `SCAN` command is called in order to iterate through all the keys correctly. Since it's a relatively common use case, ioredis\nprovides a streaming interface for the `SCAN` command to make things much easier. A readable stream can be created by calling `scanStream`:\n\n```javascript\nvar redis = new Redis();\n// Create a readable stream (object mode)\nvar stream = redis.scanStream();\nvar keys = [];\nstream.on('data', function (resultKeys) {\n  // `resultKeys` is an array of strings representing key names.\n  // Note that resultKeys may contain 0 keys.\n  for (var i = 0; i < resultKeys.length; i++) {\n    keys.push(resultKeys[i]);\n  }\n});\nstream.on('end', function () {\n  console.log('done with the keys: ', keys);\n});\n```\n\n`scanStream` accepts an option, with which you can specify the `MATCH` pattern and the `COUNT` argument:\n\n```javascript\nvar stream = redis.scanStream({\n  // only returns keys following the pattern of `user:*`\n  match: 'user:*',\n  // returns approximately 100 elements per call\n  count: 100\n});\n```\n\nJust like other commands, `scanStream` has a binary version `scanBufferStream`, which returns an array of buffers. It's useful when\nthe key names are not utf8 strings.\n\nThere are also `hscanStream`, `zscanStream` and `sscanStream` to iterate through elements in a hash, zset and set. The interface of each is\nsimilar to `scanStream` except the first argument is the key name:\n\n```javascript\nvar stream = redis.hscanStream('myhash', {\n  match: 'age:??'\n});\n```\n\nYou can learn more from the [Redis documentation](http://redis.io/commands/scan).\n\n**Useful Tips**\nIt's pretty common that doing an async task in the `data` handler. We'd like the scanning process to be paused until the async task to be finished. `Stream#pause()` and `Stream.resume()` do the trick. For example if we want to migrate data in Redis to MySQL:\n\n```javascript\nvar stream = redis.scanStream();\nstream.on('data', function (resultKeys) {\n  // Pause the stream from scanning more keys until we've migrated the current keys.\n  stream.pause();\n\n  Promise.all(resultKeys.map(migrateKeyToMySQL)).then(() => {\n    // Resume the stream here.\n    stream.resume();\n  });\n});\n\nstream.on('end', function () {\n  console.log('done migration');\n});\n```\n\n## Auto-reconnect\nBy default, ioredis will try to reconnect when the connection to Redis is lost\nexcept when the connection is closed manually by `redis.disconnect()` or `redis.quit()`.\n\nIt's very flexible to control how long to wait to reconnect after disconnection\nusing the `retryStrategy` option:\n\n```javascript\nvar redis = new Redis({\n  // This is the default value of `retryStrategy`\n  retryStrategy: function (times) {\n    var delay = Math.min(times * 50, 2000);\n    return delay;\n  }\n});\n```\n\n`retryStrategy` is a function that will be called when the connection is lost.\nThe argument `times` means this is the nth reconnection being made and\nthe return value represents how long (in ms) to wait to reconnect. When the\nreturn value isn't a number, ioredis will stop trying to reconnect, and the connection\nwill be lost forever if the user doesn't call `redis.connect()` manually.\n\nWhen reconnected, the client will auto subscribe to channels that the previous connection subscribed to.\nThis behavior can be disabled by setting the `autoResubscribe` option to `false`.\n\nAnd if the previous connection has some unfulfilled commands (most likely blocking commands such as `brpop` and `blpop`),\nthe client will resend them when reconnected. This behavior can be disabled by setting the `autoResendUnfulfilledCommands` option to `false`.\n\nBy default, all pending commands will be flushed with an error every 20 retry attempts. That makes sure commands won't wait forever when the connection is down. You can change this behavior by setting `maxRetriesPerRequest`:\n\n```javascript\nvar redis = new Redis({\n  maxRetriesPerRequest: 1\n});\n```\n\nSet maxRetriesPerRequest to `null` to disable this behavior, and every command will wait forever until the connection is alive again (which is the default behavior before ioredis v4).\n\n### Reconnect on error\n\nBesides auto-reconnect when the connection is closed, ioredis supports reconnecting on the specified errors by the `reconnectOnError` option. Here's an example that will reconnect when receiving `READONLY` error:\n\n```javascript\nvar redis = new Redis({\n  reconnectOnError: function (err) {\n    var targetError = 'READONLY';\n    if (err.message.slice(0, targetError.length) === targetError) {\n      // Only reconnect when the error starts with \"READONLY\"\n      return true; // or `return 1;`\n    }\n  }\n});\n```\n\nThis feature is useful when using Amazon ElastiCache. Once failover happens, Amazon ElastiCache will switch the master we currently connected with to a slave, leading to the following writes fails with the error `READONLY`. Using `reconnectOnError`, we can force the connection to reconnect on this error in order to connect to the new master.\n\nFurthermore, if the `reconnectOnError` returns `2`, ioredis will resend the failed command after reconnecting.\n\n## Connection Events\nThe Redis instance will emit some events about the state of the connection to the Redis server.\n\nEvent    | Description\n:------------- | :-------------\nconnect  | emits when a connection is established to the Redis server.\nready    | If `enableReadyCheck` is `true`, client will emit `ready` when the server reports that it is ready to receive commands (e.g. finish loading data from disk).<br>Otherwise, `ready` will be emitted immediately right after the `connect` event.\nerror    | emits when an error occurs while connecting.<br>However, ioredis emits all `error` events silently (only emits when there's at least one listener) so that your application won't crash if you're not listening to the `error` event.\nclose    | emits when an established Redis server connection has closed.\nreconnecting | emits after `close` when a reconnection will be made. The argument of the event is the time (in ms) before reconnecting.\nend     | emits after `close` when no more reconnections will be made, or the connection is failed to establish.\n\nYou can also check out the `Redis#status` property to get the current connection status.\n\nBesides the above connection events, there are several other custom events:\n\nEvent    | Description\n:------------- | :-------------\nselect   | emits when the database changed. The argument is the new db number.\n\n## Offline Queue\nWhen a command can't be processed by Redis (being sent before the `ready` event), by default, it's added to the offline queue and will be\nexecuted when it can be processed. You can disable this feature by setting the `enableOfflineQueue`\noption to `false`:\n\n```javascript\nvar redis = new Redis({ enableOfflineQueue: false });\n```\n\n## TLS Options\nRedis doesn't support TLS natively, however if the redis server you want to connect to is hosted behind a TLS proxy (e.g. [stunnel](https://www.stunnel.org/)) or is offered by a PaaS service that supports TLS connection (e.g. [Redis Labs](https://redislabs.com/)), you can set the `tls` option:\n\n```javascript\nvar redis = new Redis({\n  host: 'localhost',\n  tls: {\n    // Refer to `tls.connect()` section in\n    // https://nodejs.org/api/tls.html\n    // for all supported options\n    ca: fs.readFileSync('cert.pem')\n  }\n});\n```\n\n<hr>\n\n## Sentinel\nioredis supports Sentinel out of the box. It works transparently as all features that work when\nyou connect to a single node also work when you connect to a sentinel group. Make sure to run Redis >= 2.8.12 if you want to use this feature. Sentinels have a default port of 26379.\n\nTo connect using Sentinel, use:\n\n```javascript\nvar redis = new Redis({\n  sentinels: [{ host: 'localhost', port: 26379 }, { host: 'localhost', port: 26380 }],\n  name: 'mymaster'\n});\n\nredis.set('foo', 'bar');\n```\n\nThe arguments passed to the constructor are different from the ones you use to connect to a single node, where:\n\n* `name` identifies a group of Redis instances composed of a master and one or more slaves (`mymaster` in the example);\n* `sentinels` are a list of sentinels to connect to. The list does not need to enumerate all your sentinel instances, but a few so that if one is down the client will try the next one.\n* `role` (optional) with a value of `slave` will return a random slave from the Sentinel group.\n* `preferredSlaves` (optional) can be used to prefer a particular slave or set of slaves based on priority. It accepts a function or array.\n\nioredis **guarantees** that the node you connected to is always a master even after a failover. When a failover happens, instead of trying to reconnect to the failed node (which will be demoted to slave when it's available again), ioredis will ask sentinels for the new master node and connect to it. All commands sent during the failover are queued and will be executed when the new connection is established so that none of the commands will be lost.\n\nIt's possible to connect to a slave instead of a master by specifying the option `role` with the value of `slave` and ioredis will try to connect to a random slave of the specified master, with the guarantee that the connected node is always a slave. If the current node is promoted to master due to a failover, ioredis will disconnect from it and ask the sentinels for another slave node to connect to.\n\nIf you specify the option `preferredSlaves` along with `role: 'slave'` ioredis will attempt to use this value when selecting the slave from the pool of available slaves. The value of `preferredSlaves` should either be a function that accepts an array of avaiable slaves and returns a single result, or an array of slave values priorities by the lowest `prio` value first with a default value of `1`.\n\n```javascript\n// available slaves format\nvar availableSlaves = [{ ip: '127.0.0.1', port: '31231', flags: 'slave' }];\n\n// preferredSlaves array format\nvar preferredSlaves = [\n  { ip: '127.0.0.1', port: '31231', prio: 1 },\n  { ip: '127.0.0.1', port: '31232', prio: 2 }\n];\n\n// preferredSlaves function format\npreferredSlaves = function(availableSlaves) {\n  for (var i = 0; i < availableSlaves.length; i++) {\n    var slave = availableSlaves[i];\n    if (slave.ip === '127.0.0.1') {\n      if (slave.port === '31234') {\n        return slave;\n      }\n    }\n  }\n  // if no preferred slaves are available a random one is used\n  return false;\n};\n\nvar redis = new Redis({\n  sentinels: [{ host: '127.0.0.1', port: 26379 }, { host: '127.0.0.1', port: 26380 }],\n  name: 'mymaster',\n  role: 'slave',\n  preferredSlaves: preferredSlaves\n});\n```\n\nBesides the `retryStrategy` option, there's also a `sentinelRetryStrategy` in Sentinel mode which will be invoked when all the sentinel nodes are unreachable during connecting. If `sentinelRetryStrategy` returns a valid delay time, ioredis will try to reconnect from scratch. The default value of `sentinelRetryStrategy` is:\n\n```javascript\nfunction (times) {\n  var delay = Math.min(times * 10, 1000);\n  return delay;\n}\n```\n\n## Cluster\nRedis Cluster provides a way to run a Redis installation where data is automatically sharded across multiple Redis nodes.\nYou can connect to a Redis Cluster like this:\n\n```javascript\nvar Redis = require('ioredis');\n\nvar cluster = new Redis.Cluster([{\n  port: 6380,\n  host: '127.0.0.1'\n}, {\n  port: 6381,\n  host: '127.0.0.1'\n}]);\n\ncluster.set('foo', 'bar');\ncluster.get('foo', function (err, res) {\n  // res === 'bar'\n});\n```\n\n`Cluster` constructor accepts two arguments, where:\n\n0. The first argument is a list of nodes of the cluster you want to connect to.\nJust like Sentinel, the list does not need to enumerate all your cluster nodes,\nbut a few so that if one is unreachable the client will try the next one, and the client will discover other nodes automatically when at least one node is connected.\n0. The second argument is the options, where:\n\n    * `clusterRetryStrategy`: When none of the startup nodes are reachable, `clusterRetryStrategy` will be invoked. When a number is returned,\n    ioredis will try to reconnect to the startup nodes from scratch after the specified delay (in ms). Otherwise, an error of \"None of startup nodes is available\" will be returned.\n    The default value of this option is:\n\n        ```javascript\n        function (times) {\n          var delay = Math.min(100 + times * 2, 2000);\n          return delay;\n        }\n        ```\n\n        It's possible to modify the `startupNodes` property in order to switch to another set of nodes here:\n\n        ```javascript\n        function (times) {\n          this.startupNodes = [{ port: 6790, host: '127.0.0.1' }];\n          return Math.min(100 + times * 2, 2000);\n        }\n        ```\n\n    * `enableOfflineQueue`: Similar to the `enableOfflineQueue` option of `Redis` class.\n    * `enableReadyCheck`: When enabled, \"ready\" event will only be emitted when `CLUSTER INFO` command\n    reporting the cluster is ready for handling commands. Otherwise, it will be emitted immediately after \"connect\" is emitted.\n    * `scaleReads`: Config where to send the read queries. See below for more details.\n    * `maxRedirections`: When a cluster related error (e.g. `MOVED`, `ASK` and `CLUSTERDOWN` etc.) is received, the client will redirect the\n    command to another node. This option limits the max redirections allowed when sending a command. The default value is `16`.\n    * `retryDelayOnFailover`: If the target node is disconnected when sending a command,\n    ioredis will retry after the specified delay. The default value is `100`. You should make sure `retryDelayOnFailover * maxRedirections > cluster-node-timeout`\n    to insure that no command will fail during a failover.\n    * `retryDelayOnClusterDown`: When a cluster is down, all commands will be rejected with the error of `CLUSTERDOWN`. If this option is a number (by default, it is `100`), the client\n    will resend the commands after the specified time (in ms).\n    * `retryDelayOnTryAgain`: If this option is a number (by default, it is `100`), the client\n    will resend the commands rejected with `TRYAGAIN` error after the specified time (in ms).\n    * `redisOptions`: Default options passed to the constructor of `Redis` when connecting to a node.\n    * `slotsRefreshTimeout`: Milliseconds before a timeout occurs while refreshing slots from the cluster (default `1000`)\n    * `slotsRefreshInterval`: Milliseconds between every automatic slots refresh (default `5000`)\n\n### Read-write splitting\n\nA typical redis cluster contains three or more masters and several slaves for each master. It's possible to scale out redis cluster by sending read queries to slaves and write queries to masters by setting the `scaleReads` option.\n\n`scaleReads` is \"master\" by default, which means ioredis will never send any queries to slaves. There are other three available options:\n\n1. \"all\": Send write queries to masters and read queries to masters or slaves randomly.\n2. \"slave\": Send write queries to masters and read queries to slaves.\n3. a custom `function(nodes, command): node`: Will choose the custom function to select to which node to send read queries (write queries keep being sent to master). The first node in `nodes` is always the master serving the relevant slots. If the function returns an array of nodes, a random node of that list will be selected.\n\nFor example:\n\n```javascript\nvar cluster = new Redis.Cluster([/* nodes */], {\n  scaleReads: 'slave'\n});\ncluster.set('foo', 'bar'); // This query will be sent to one of the masters.\ncluster.get('foo', function (err, res) {\n  // This query will be sent to one of the slaves.\n});\n```\n\n**NB** In the code snippet above, the `res` may not be equal to \"bar\" because of the lag of replication between the master and slaves.\n\n### Running commands to multiple nodes\n\nEvery command will be sent to exactly one node. For commands containing keys, (e.g. `GET`, `SET` and `HGETALL`), ioredis sends them to the node that serving the keys, and for other commands not containing keys, (e.g. `INFO`, `KEYS` and `FLUSHDB`), ioredis sends them to a random node.\n\nSometimes you may want to send a command to multiple nodes (masters or slaves) of the cluster, you can get the nodes via `Cluster#nodes()` method.\n\n`Cluster#nodes()` accepts a parameter role, which can be \"master\", \"slave\" and \"all\" (default), and returns an array of `Redis` instance. For example:\n\n```javascript\n// Send `FLUSHDB` command to all slaves:\nvar slaves = cluster.nodes('slave');\nPromise.all(slaves.map(function (node) {\n  return node.flushdb();\n}));\n\n// Get keys of all the masters:\nvar masters = cluster.nodes('master');\nPromise.all(masters.map(function (node) {\n  return node.keys();\n})).then(function (keys) {\n  // keys: [['key1', 'key2'], ['key3', 'key4']]\n});\n```\n\n### Transaction and pipeline in Cluster mode\nAlmost all features that are supported by `Redis` are also supported by `Redis.Cluster`, e.g. custom commands, transaction and pipeline.\nHowever there are some differences when using transaction and pipeline in Cluster mode:\n\n0. All keys in a pipeline should belong to the same slot since ioredis sends all commands in a pipeline to the same node.\n0. You can't use `multi` without pipeline (aka `cluster.multi({ pipeline: false })`). This is because when you call `cluster.multi({ pipeline: false })`, ioredis doesn't know which node the `multi` command should be sent to.\n0. Chaining custom commands in the pipeline is not supported in Cluster mode.\n\nWhen any commands in a pipeline receives a `MOVED` or `ASK` error, ioredis will resend the whole pipeline to the specified node automatically if all of the following conditions are satisfied:\n\n0. All errors received in the pipeline are the same. For example, we won't resend the pipeline if we got two `MOVED` errors pointing to different nodes.\n0. All commands executed successfully are readonly commands. This makes sure that resending the pipeline won't have side effects.\n\n### Pub/Sub\nPub/Sub in cluster mode works exactly as the same as in standalone mode. Internally, when a node of the cluster receives a message, it will broadcast the message to the other nodes. ioredis makes sure that each message will only be received once by strictly subscribing one node at the same time.\n\n```javascript\nvar nodes = [/* nodes */];\nvar pub = new Redis.Cluster(nodes);\nvar sub = new Redis.Cluster(nodes);\nsub.on('message', function (channel, message) {\n  console.log(channel, message);\n});\n\nsub.subscribe('news', function () {\n  pub.publish('news', 'highlights');\n});\n```\n\n### Events\n\nEvent    | Description\n:------------- | :-------------\nconnect  | emits when a connection is established to the Redis server.\nready    | emits when `CLUSTER INFO` reporting the cluster is able to receive commands (if `enableReadyCheck` is `true`) or immediately after `connect` event (if `enableReadyCheck` is false).\nerror    | emits when an error occurs while connecting with a property of `lastNodeError` representing the last node error received. This event is emitted silently (only emitting if there's at least one listener).\nclose    | emits when an established Redis server connection has closed.\nreconnecting | emits after `close` when a reconnection will be made. The argument of the event is the time (in ms) before reconnecting.\nend     | emits after `close` when no more reconnections will be made.\n+node   | emits when a new node is connected.\n-node   | emits when a node is disconnected.\nnode error | emits when an error occurs when connecting to a node\n\n### Password\nSetting the `password` option to access password-proctected clusters:\n\n```javascript\nvar Redis = require('ioredis');\nvar cluster = new Redis.Cluster(nodes, {\n  redisOptions: {\n    password: 'your-cluster-password'\n  }\n});\n```\n\nIf some of nodes in the cluster using a different password, you should specify them in the first parameter:\n\n```javascript\nvar Redis = require('ioredis');\nvar cluster = new Redis.Cluster([\n  // Use password \"password-for-30001\" for 30001\n  { port: 30001, password: 'password-for-30001'},\n  // Don't use password when accessing 30002\n  { port: 30002, password: null }\n  // Other nodes will use \"fallback-password\"\n], {\n  redisOptions: {\n    password: 'fallback-password'\n  }\n});\n```\n\n<hr>\n\n# Error Handling\nAll the errors returned by the Redis server are instances of `ReplyError`, which can be accessed via `Redis`:\n\n```javascript\nvar Redis = require('ioredis');\nvar redis = new Redis();\n// This command causes a reply error since the SET command requires two arguments.\nredis.set('foo', function (err) {\n  err instanceof Redis.ReplyError\n});\n```\n\nThis is the error stack of the `ReplyError`:\n\n```\nReplyError: ERR wrong number of arguments for 'set' command\n    at ReplyParser._parseResult (/app/node_modules/ioredis/lib/parsers/javascript.js:60:14)\n    at ReplyParser.execute (/app/node_modules/ioredis/lib/parsers/javascript.js:178:20)\n    at Socket.<anonymous> (/app/node_modules/ioredis/lib/redis/event_handler.js:99:22)\n    at Socket.emit (events.js:97:17)\n    at readableAddChunk (_stream_readable.js:143:16)\n    at Socket.Readable.push (_stream_readable.js:106:10)\n    at TCP.onread (net.js:509:20)\n```\n\nBy default, the error stack doesn't make any sense because the whole stack happens in the ioredis\nmodule itself, not in your code. So it's not easy to find out where the error happens in your code.\nioredis provides an option `showFriendlyErrorStack` to solve the problem. When you enable\n`showFriendlyErrorStack`, ioredis will optimize the error stack for you:\n\n```javascript\nvar Redis = require('ioredis');\nvar redis = new Redis({ showFriendlyErrorStack: true });\nredis.set('foo');\n```\n\nAnd the output will be:\n\n```\nReplyError: ERR wrong number of arguments for 'set' command\n    at Object.<anonymous> (/app/index.js:3:7)\n    at Module._compile (module.js:446:26)\n    at Object.Module._extensions..js (module.js:464:10)\n    at Module.load (module.js:341:32)\n    at Function.Module._load (module.js:296:12)\n    at Function.Module.runMain (module.js:487:10)\n    at startup (node.js:111:16)\n    at node.js:799:3\n```\n\nThis time the stack tells you that the error happens on the third line in your code. Pretty sweet!\nHowever, it would decrease the performance significantly to optimize the error stack. So by\ndefault, this option is disabled and can only be used for debugging purposes. You **shouldn't** use this feature in a production environment.\n\n# Plugging in your own Promises Library\nIf you're an advanced user, you may want to plug in your own promise library like [bluebird](https://www.npmjs.com/package/bluebird). Just set Redis.Promise to your favorite ES6-style promise constructor and ioredis will use it.\n\n```javascript\nconst Redis = require('ioredis')\nRedis.Promise = require('bluebird')\n\nconst redis = new Redis()\n\n// Use bluebird\nassert.equal(redis.get().constructor, require('bluebird'))\n\n// You can change the Promise implementation at any time:\nRedis.Promise = global.Promise\nassert.equal(redis.get().constructor, global.Promise)\n```\n\n\n# Running tests\n\nStart a Redis server on 127.0.0.1:6379, and then:\n\n```shell\n$ npm test\n```\n\n`FLUSH ALL` will be invoked after each test, so make sure there's no valuable data in it before running tests.\n\nIf your testing environment does not let you spin up a Redis server [ioredis-mock](https://github.com/stipsan/ioredis-mock) is a drop-in replacement you can use in your tests. It aims to behave identically to ioredis connected to a Redis server so that your integration tests is easier to write and of better quality.\n\n# Debug\n\nYou can set the `DEBUG` env to `ioredis:*` to print debug info:\n\n```shell\n$ DEBUG=ioredis:* node app.js\n```\n\n# Consolidation: It's time for celebration\n\nRight now there are two great redis clients around and both have some advantages above each other. We speak about [node_redis](https://github.com/NodeRedis/node_redis) and ioredis. So after talking to each other about how we could improve in working together we (that is [@BridgeAR](https://github.com/BridgeAR) and [@luin](https://github.com/luin)) decided to work towards a single library on the long run. But step by step.\n\nFirst of all, we want to split small parts of our libraries into others so that we're both able to use the same code. Those libraries are going to be maintained under the NodeRedis organization. This is going to reduce the maintance overhead, allows others to use the very same code, if they need it and it's way easier for others to contribute to both libraries.\n\nWe're very happy about this step towards working together as we both want to give you the best redis experience possible.\n\nIf you want to join our cause by help maintaining something, please don't hesitate to contact either one of us.\n\n# Join in!\n\nI'm happy to receive bug reports, fixes, documentation enhancements, and any other improvements.\n\nAnd since I'm not a native English speaker, if you find any grammar mistakes in the documentation, please also let me know. :)\n\n# Contributors\n\nThis project exists thanks to all the people who contribute:\n\n<a href=\"https://github.com/luin/ioredis/graphs/contributors\"><img src=\"https://opencollective.com/ioredis/contributors.svg?width=890&showBtn=false\" /></a>\n\n# License\n\nMIT\n","readmeFilename":"README.md","gitHead":"a57c2a8705906ab99014dbf8c5d5592486804f55","bugs":{"url":"https://github.com/luin/ioredis/issues"},"homepage":"https://github.com/luin/ioredis#readme","_id":"ioredis@4.0.0-3","_npmVersion":"5.5.1","_nodeVersion":"8.9.1","_npmUser":{"name":"luin","email":"i@zihua.li"},"dist":{"integrity":"sha512-Z2v0CRPc8zAq3TrQZu0U/ucHGhcPCJ9WMRnSrNu5HE6hEgsWRl5hV5NKczLQKsQ3nfdavnvrhUhdyFSKEGUP+Q==","shasum":"c5892aa76d652dc2b2f8064c34809769fb3dd5a9","tarball":"https://registry.npmjs.org/ioredis/-/ioredis-4.0.0-3.tgz","fileCount":30,"unpackedSize":195157,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJbVJ1LCRA9TVsSAnZWagAA/tYP/1SaV8+8oUzsZi9629IZ\nHg7BFPl7OZar/rbuIdMQq8ZtkEdagx//gDHMxuTzEbpC5lyvr3/cdZOMz27K\n/lpDDpx4ug+Yw8bmLASAgl/QTbZvNusID69QDanmYBM0x4ZGA9BIHyaNeyYD\nNxZBHeqPXkeZwJWuG1TYnzybjmHzh5TZveFsud6DBeoyTK32R0ATc6abVqms\ndms4LUFJ+DWJgGACosPTAofo4Qng+aKFEl4CgkIO/rM6UAYOU0CbGjEj/1BR\njiu057TNI1nHxA7HdyJD4uThXvKfZRbOsamAkPeQJRncqtmzWB6/2R9HODuT\neBGr72jmGZ2CPNcHgyySAL0cMjEVoMLr1dZz1wOH8wUhx4SHlsrCX0HrtSWE\nq0MN9HkUv561hWNhlSKsco14/wd/YpOSu21/PyhFiYeo0EqDAOUFRBjdomgA\nfm907XzS+jUaEkvMRE8eX5UWr8W+1UjCiUmmNJwROj62reptrbafIXCwZXlU\nA7atagTTqhrMC5UqHB6o/LFR3Izxs9I6ONsPO4Y+6J6oxCZsOtnMP8ievIMq\nNfz2imlYxSTXX3nNaWUL2PfxD+0nDdYEghS55NYgrH0qpCxZ3HP/mRhnzh/P\ny3+itL6RwPwAZkFK56VZEWLKC/ylVZRdrxrdpfa4z9JCNYN9Z0h4aTF8BrgK\n8PTA\r\n=7gNg\r\n-----END PGP SIGNATURE-----\r\n"},"maintainers":[{"name":"luin","email":"i@zihua.li"}],"directories":{},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/ioredis_4.0.0-3_1532271947291_0.14065194585640128"},"_hasShrinkwrap":false},"4.0.0":{"name":"ioredis","version":"4.0.0","description":"A robust, performance-focused and full-featured Redis client for Node.js.","main":"built/index.js","files":["index.js","built/"],"scripts":{"test":"NODE_ENV=test mocha --timeout 8000 -r ts-node/register --exit","test:cov":"NODE_ENV=test node ./node_modules/istanbul/lib/cli.js cover --preserve-comments ./node_modules/mocha/bin/_mocha -- -r ts-node/register -R spec --exit","build":"rm -rf built && tsc","generate-docs":"jsdoc2md lib/redis.js lib/cluster/index.js lib/commander.js > API.md","prepublish":"npm run build && npm test","bench":"matcha benchmarks/*.js"},"repository":{"type":"git","url":"git://github.com/luin/ioredis.git"},"keywords":["redis","cluster","sentinel","pipelining"],"author":{"name":"luin","email":"i@zihua.li","url":"http://zihua.li"},"license":"MIT","dependencies":{"cluster-key-slot":"^1.0.6","debug":"^3.1.0","denque":"^1.1.0","flexbuffer":"0.0.6","lodash.bind":"^4.2.1","lodash.clone":"^4.5.0","lodash.clonedeep":"^4.5.0","lodash.defaults":"^4.2.0","lodash.difference":"^4.5.0","lodash.flatten":"^4.4.0","lodash.foreach":"^4.5.0","lodash.isempty":"^4.4.0","lodash.partial":"^4.2.1","lodash.pick":"^4.4.0","lodash.sample":"^4.2.1","lodash.shuffle":"^4.2.0","lodash.values":"^4.3.0","redis-commands":"^1.2.0","redis-errors":"^1.2.0","redis-parser":"^3.0.0","standard-as-callback":"^1.0.0"},"devDependencies":{"@types/node":"^10.5.2","bluebird":"^3.5.1","chai":"^3.5.0","cz-conventional-changelog":"^2.0.0","istanbul":"^0.4.2","jsdoc":"^3.4.0","jsdoc-to-markdown":"^4.0.1","mocha":"^5.2.0","server-destroy":"^1.0.1","sinon":"^1.17.3","ts-node":"^7.0.0","typescript":"^2.9.2"},"engines":{"node":">=4"},"config":{"commitizen":{"path":"./node_modules/cz-conventional-changelog"}},"gitHead":"206b0ed01215dc5ca6091ab4e017dbed21056008","bugs":{"url":"https://github.com/luin/ioredis/issues"},"homepage":"https://github.com/luin/ioredis#readme","_id":"ioredis@4.0.0","_npmVersion":"5.5.1","_nodeVersion":"8.9.1","_npmUser":{"name":"luin","email":"i@zihua.li"},"dist":{"integrity":"sha512-KDio3eKM4zZWRPWlcM26E4Dcbj1bH6pPLNuCHJwKucklsEVMXT0axh5ctPaETbkPIBLRk910qKOEQoXSFkn+dw==","shasum":"fabf1cf8724f14fd0885233cf2f4fbc6e1e59da2","tarball":"https://registry.npmjs.org/ioredis/-/ioredis-4.0.0.tgz","fileCount":30,"unpackedSize":196124,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJbcvjKCRA9TVsSAnZWagAAt9MP/iYCA5Rdf4v+wb26OHFR\nYbxu87/fT3rPSxYAglcO8601muaKoVorNTewOYEgCtXr45sAUfbtCbMuL/w+\nHgGiY+oIccKFr3LEEZiRKSppDpzfgC07BmPcDcIBIMscbSXTEBlN3qSx9nb9\nI8bWChKKi4tH7VvfJKRD7PXSgcnTMBortOSyMIOfHk6Ie2tmq/DliSFMbPIV\nEn9gln6zEvnriOVMQLEWaYZeMs+6fbYxpfvdr8ycaZ5Y+19Unajbo8qKFjuk\nJXTFkz5jOUl4PC9o1vBbd95BZ5r/Ej3mETDQoI3npRjlKfjDW/1r/JH70gV8\nxMoSAuelN+uHs1iyJlhH+1Ai8hxEK21EtUoBMPFIWsouAX6mvMGfxZhFUjVp\njkEwTS7OLoq85vAT3V/xQ3N0KeqO6vVR/yE1xPUWjnm1PbUzoRwLwFS01bCl\n+Uy2Y9W4JxNZgwWpiYI89Jpl4b8rCb2Tck6QFK0ZD86eNjwPLQs4DgvlMnNp\nvEJNkp2QIZC4bRYO1dbHLfFXK4i4i+Ck005FyVyoLbvP8yFIMl9HG3zde+sj\nZnsZG9CgEHmGxPA9cb3XhRLyttGhiSlqncTtXC6WdkfKxUhP8xaKUIbuPazk\nrwx2R15BKPOjpgtQFlRfcgnTvilKxBb/gYgzWhYdeEU6KwXx5shZZFAEe0Df\nrcDD\r\n=j0fC\r\n-----END PGP SIGNATURE-----\r\n"},"maintainers":[{"name":"luin","email":"i@zihua.li"}],"directories":{},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/ioredis_4.0.0_1534261449310_0.03651706612897909"},"_hasShrinkwrap":false},"4.0.1":{"name":"ioredis","version":"4.0.1","description":"A robust, performance-focused and full-featured Redis client for Node.js.","main":"built/index.js","scripts":{"test":"NODE_ENV=test mocha --timeout 8000 -r ts-node/register --exit","test:cov":"NODE_ENV=test node ./node_modules/istanbul/lib/cli.js cover --preserve-comments ./node_modules/mocha/bin/_mocha -- -r ts-node/register -R spec --exit","build":"rm -rf built && tsc","generate-docs":"jsdoc2md lib/redis.js lib/cluster/index.js lib/commander.js > API.md","prepublish":"npm run build && npm test","bench":"matcha benchmarks/*.js"},"repository":{"type":"git","url":"git://github.com/luin/ioredis.git"},"keywords":["redis","cluster","sentinel","pipelining"],"author":{"name":"luin","email":"i@zihua.li","url":"http://zihua.li"},"license":"MIT","dependencies":{"cluster-key-slot":"^1.0.6","debug":"^3.1.0","denque":"^1.1.0","flexbuffer":"0.0.6","lodash.bind":"^4.2.1","lodash.clone":"^4.5.0","lodash.clonedeep":"^4.5.0","lodash.defaults":"^4.2.0","lodash.difference":"^4.5.0","lodash.flatten":"^4.4.0","lodash.foreach":"^4.5.0","lodash.isempty":"^4.4.0","lodash.partial":"^4.2.1","lodash.pick":"^4.4.0","lodash.sample":"^4.2.1","lodash.shuffle":"^4.2.0","lodash.values":"^4.3.0","redis-commands":"^1.3.5","redis-errors":"^1.2.0","redis-parser":"^3.0.0","standard-as-callback":"^1.0.0"},"devDependencies":{"@types/node":"^10.5.2","bluebird":"^3.5.1","chai":"^3.5.0","cz-conventional-changelog":"^2.0.0","istanbul":"^0.4.2","jsdoc":"^3.4.0","jsdoc-to-markdown":"^4.0.1","mocha":"^5.2.0","server-destroy":"^1.0.1","sinon":"^1.17.3","ts-node":"^7.0.0","typescript":"^3.1.1"},"engines":{"node":">=6"},"config":{"commitizen":{"path":"./node_modules/cz-conventional-changelog"}},"gitHead":"47ab05c28dd499a4af87a93a547d05c74aa4f5cf","bugs":{"url":"https://github.com/luin/ioredis/issues"},"homepage":"https://github.com/luin/ioredis#readme","_id":"ioredis@4.0.1","_npmVersion":"5.5.1","_nodeVersion":"8.9.1","_npmUser":{"name":"luin","email":"i@zihua.li"},"dist":{"integrity":"sha512-X0X0EiM/4kc8pkBmPFIHYs0DljVkJLl31dI0jzZXLWeh8xSafpnpLC/ZJRSnz/X/Fw2tNijuh/sNM8Tt0Z+orA==","shasum":"266f18534fb7d8a28ca752cd5ade8150684e46e7","tarball":"https://registry.npmjs.org/ioredis/-/ioredis-4.0.1.tgz","fileCount":32,"unpackedSize":203873,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJbuudPCRA9TVsSAnZWagAAN+oP/j12uMOMa9IYvhQzHm+R\n8FG6/9ylKyy8jW6pJZJfa0KliJV+tO1+9oRIPMh10h7mfkGNAJx9YwsxJu26\nmkQjnF4S4exzrnq8wsn/0G4r5YW8gg4YDfJdW5nLF63AWyUFiU+dYYnRYG2s\nIZITcOvlW7GFN3hMdTULLMzCVmx+Y2ecFvR6u2RPHcmXt5/0bCjFbIxOxMIV\nJ3YqejzmVT97vAWnCFdmpFQWRXvxCjQGjiS+FuF/03qGY51zT7XoErcV1Lnp\nZjh6HUrWKCainD5Tr3w+Amkyins0CR4p8oSxoWgq7toY6kEuSrIIbBDJEvJ2\nO7EqimmITmC1JZZoTtmAEsoqwt0Zq49fAOVUA4Zs/l8LpjuU1hn4577zvMuQ\n7tGxNcAPi+A7fNn2Z++SSpe5Q6gjvDqCXfixPQPHjieNlmEoiqk27cwIOqnp\nMV1/ZF2Kii1Nd8m4/lFEN2LjQKstoSw+2glNNlptXBJKOIYZM1RBJeeReGxl\nMOXYEOm1GdTJXxD+0Xf6NGkQG2upiYF1T/TCtCx5PuibYTetCUbNjgzTjROK\nENPi9wdcZFrJs/xukbo+xmQMqmlRjxC6qK50vxF2dh+CJHBqCUTvqgH2HzG9\nP9gc0HgZWYEBUyCL8ULCoHBAil/LuxKm85lOL1sHUQunsLD7LDIbMPDpUaGf\n+yhB\r\n=gQWX\r\n-----END PGP SIGNATURE-----\r\n"},"maintainers":[{"name":"luin","email":"i@zihua.li"}],"directories":{},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/ioredis_4.0.1_1538975566775_0.4934248877925156"},"_hasShrinkwrap":false},"4.0.2":{"name":"ioredis","version":"4.0.2","description":"A robust, performance-focused and full-featured Redis client for Node.js.","main":"built/index.js","scripts":{"test":"NODE_ENV=test mocha --timeout 8000 -r ts-node/register --exit","test:cov":"NODE_ENV=test node ./node_modules/istanbul/lib/cli.js cover --preserve-comments ./node_modules/mocha/bin/_mocha -- -r ts-node/register -R spec --exit","build":"rm -rf built && tsc","generate-docs":"jsdoc2md lib/redis.js lib/cluster/index.js lib/commander.js > API.md","prepublishOnly":"npm run build && npm test","bench":"matcha benchmarks/*.js"},"repository":{"type":"git","url":"git://github.com/luin/ioredis.git"},"keywords":["redis","cluster","sentinel","pipelining"],"author":{"name":"luin","email":"i@zihua.li","url":"http://zihua.li"},"license":"MIT","dependencies":{"cluster-key-slot":"^1.0.6","debug":"^3.1.0","denque":"^1.1.0","flexbuffer":"0.0.6","lodash.defaults":"^4.2.0","lodash.difference":"^4.5.0","lodash.flatten":"^4.4.0","lodash.foreach":"^4.5.0","lodash.isempty":"^4.4.0","lodash.partial":"^4.2.1","lodash.pick":"^4.4.0","lodash.sample":"^4.2.1","lodash.shuffle":"^4.2.0","lodash.values":"^4.3.0","redis-commands":"^1.3.5","redis-errors":"^1.2.0","redis-parser":"^3.0.0","standard-as-callback":"^1.0.0"},"devDependencies":{"@types/node":"^10.5.2","bluebird":"^3.5.1","chai":"^3.5.0","cz-conventional-changelog":"^2.0.0","istanbul":"^0.4.2","jsdoc":"^3.4.0","jsdoc-to-markdown":"^4.0.1","mocha":"^5.2.0","server-destroy":"^1.0.1","sinon":"^1.17.3","ts-node":"^7.0.0","typescript":"^3.1.1"},"engines":{"node":">=6"},"config":{"commitizen":{"path":"./node_modules/cz-conventional-changelog"}},"gitHead":"cbbdc85bacc2c055fa6e2b8170936af76996f436","bugs":{"url":"https://github.com/luin/ioredis/issues"},"homepage":"https://github.com/luin/ioredis#readme","_id":"ioredis@4.0.2","_npmVersion":"6.1.0","_nodeVersion":"10.5.0","_npmUser":{"name":"luin","email":"i@zihua.li"},"dist":{"integrity":"sha512-vI+3jj28EOwlYsNvXZAfsnBMZjsURS9s57vjwEJPf0wIvX7cJBqduRywB3lM4Pqs2Q8Z9g+lLBQoOLsJ13NKDw==","shasum":"4de98677615f182d38071414f8b2bbad2740f583","tarball":"https://registry.npmjs.org/ioredis/-/ioredis-4.0.2.tgz","fileCount":32,"unpackedSize":204102,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJbvFtACRA9TVsSAnZWagAAFecP/imKMnidK1o5w1yIOIL7\neJIQDnHyImh1BEcAIoOaEsgcOKM0i2I5OTSjeMGvXH9xf6uKv9oAY39+xtle\n3eySYLCYXdnzNEpqL6TP399WjTxMhJbwoeBUKitPdCQ3rlhzqGgX1pcU704g\nJEF9TDvVkn1LGTllA+rN5kbrJrP55QsmdFE1t7BN3rg5fs9OnkrEPby+3j0m\nYLhl6bl2tMklikcP/J8DEzIqU14Fy2song0Y4rmTn4+yfbhVNHAVbkI2TWP6\nsFbyEh0GqYpHOMIYwdNzz4v0Tqfrj/inNrSW2/N9/Y4Wwl9qEjx/YjpfdWCD\nYTPVL5mQiVc6OmOiCrPAUAD6q+i1dwXM0myd65iMZaUDvPTp6rOSmtLJ+wad\nQDUi0BsWbKokSYCya7fFI8Qi49wqP8i96fmBlqxBqGsswQXt7XTqnuZTkak8\n0AiuvCrsOBIiCEZ9So4TQq964fClJTw5pZGyzG84P//RM/zu6or8qunACNxp\ngKOZvJQy8B2KdbRQkMOco0zSsvn+ZN4RxAYH1ffnCTcbP3JJfuFp8nOssEtu\nAtsECJo7TcRHbyRLNBHRRYDgp4gFqXCR5F1t0Du5dUTUbr/jYl8OmZO1L1vZ\nC18HAvbARqHe+CMHBEPkSg1qIdQPN7d2Er0qhWp/TG4D621DGC2AydJbyaQp\nERUd\r\n=Ml/q\r\n-----END PGP SIGNATURE-----\r\n"},"maintainers":[{"name":"luin","email":"i@zihua.li"}],"directories":{},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/ioredis_4.0.2_1539070773828_0.8032530782214811"},"_hasShrinkwrap":false},"4.1.0":{"name":"ioredis","version":"4.1.0","description":"A robust, performance-focused and full-featured Redis client for Node.js.","main":"built/index.js","scripts":{"test":"NODE_ENV=test mocha --timeout 8000 -r ts-node/register --exit","test:cov":"NODE_ENV=test node ./node_modules/istanbul/lib/cli.js cover --preserve-comments ./node_modules/mocha/bin/_mocha -- -r ts-node/register -R spec --exit","build":"rm -rf built && tsc","generate-docs":"jsdoc2md lib/redis.js lib/cluster/index.js lib/commander.js > API.md","prepublishOnly":"npm run build && npm test","bench":"matcha benchmarks/*.js"},"repository":{"type":"git","url":"git://github.com/luin/ioredis.git"},"keywords":["redis","cluster","sentinel","pipelining"],"author":{"name":"luin","email":"i@zihua.li","url":"http://zihua.li"},"license":"MIT","dependencies":{"cluster-key-slot":"^1.0.6","debug":"^3.1.0","denque":"^1.1.0","flexbuffer":"0.0.6","lodash.defaults":"^4.2.0","lodash.flatten":"^4.4.0","redis-commands":"1.4.0","redis-errors":"^1.2.0","redis-parser":"^3.0.0","standard-as-callback":"^1.0.0"},"devDependencies":{"@types/node":"^10.11.5","@types/redis-errors":"1.2.0","bluebird":"^3.5.1","chai":"^3.5.0","cz-conventional-changelog":"^2.0.0","istanbul":"^0.4.2","jsdoc":"^3.4.0","jsdoc-to-markdown":"^4.0.1","mocha":"^5.2.0","server-destroy":"^1.0.1","sinon":"^1.17.3","ts-node":"^7.0.0","typescript":"^3.1.1"},"engines":{"node":">=6"},"config":{"commitizen":{"path":"./node_modules/cz-conventional-changelog"}},"gitHead":"aeded57a6ab3fa880e3544df739570fa681de54d","bugs":{"url":"https://github.com/luin/ioredis/issues"},"homepage":"https://github.com/luin/ioredis#readme","_id":"ioredis@4.1.0","_npmVersion":"6.4.1","_nodeVersion":"8.9.1","_npmUser":{"name":"luin","email":"i@zihua.li"},"dist":{"integrity":"sha512-TcYrEJjWdz8s0ce06hAIo/Ehm8xcBbhgWj2p5ZED/dc2gXG6NYEGmDRq/SU5lmrCPK9330Nf9RtY53pYwOiyVA==","shasum":"77374eeeb6c019e136b3cd84193d264f48ecfc59","tarball":"https://registry.npmjs.org/ioredis/-/ioredis-4.1.0.tgz","fileCount":35,"unpackedSize":208245,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJbxNCKCRA9TVsSAnZWagAAA0gQAJhEHfTBhZqtjfX9ILl7\nkHrWEtmE0jEXNUdjq96q+BJNKTGzwmEuahi4G5mWjj+jrB7pi/4g8VGhxJ0L\nYg0SeybZGRmKdoeMM3By/fyGXrP4/ZpUHk6bnxOIAEdujztfLIzk6EyukntK\nIZ/P3JKgwJiUTcUCvK1HWCgHPN6g/MJMDRPbQ0bA2Cf15rVungMSTFUZfuQF\nqVW2LZRvy19f8izkA0DnYnuqOffcJDUVbIsSGL3i5wVBI776K/1zZPbMZzT5\nbAIJFdw1/q32uhu+F1bHTw49HxDIkyFYIn3c0RcgX2tYI45zclAjO5h2QWwi\nOdwyJ3IDcWmcWZK7txh0rO8rj5bRcaKOCXumxYnuzN0ADytrpNmpPErqRo7E\n83lDBGQtXpBRh+OqK0SNAzUhkfwHDyFv8OXg7pyj2a1cygeEWhbO1RoDoOht\ndW5y0ZSMN2K7YIiIHnzyR8GMNMfpe9JvX4yf6GuCSiA7HApNRL4P7qRICPSv\n7VgRwaTHd1wUVoyy45wvdA6u+w/6fzr9MihhrwLqdzCriNBavgjfefPxt9wI\nVhKyHOPjQI9aNCSzQdxzYJo2cJJZkfjgYetHabSquvIVqHvHmawlpUnOXujJ\nHqV5K2XVW4iYQJmd3wPGG0nlKgGLzCtgqo/ITPhRlP6ZEeWe9kYWhFnAKK0c\nZcFW\r\n=dACw\r\n-----END PGP SIGNATURE-----\r\n"},"maintainers":[{"name":"luin","email":"i@zihua.li"}],"directories":{},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/ioredis_4.1.0_1539625095657_0.5705649769714045"},"_hasShrinkwrap":false},"4.2.0":{"name":"ioredis","version":"4.2.0","description":"A robust, performance-focused and full-featured Redis client for Node.js.","main":"built/index.js","scripts":{"test":"NODE_ENV=test mocha --timeout 8000 -r ts-node/register --exit","test:cov":"NODE_ENV=test node ./node_modules/istanbul/lib/cli.js cover --preserve-comments ./node_modules/mocha/bin/_mocha -- -r ts-node/register -R spec --exit","build":"rm -rf built && tsc","generate-docs":"jsdoc2md lib/redis.js lib/cluster/index.js lib/commander.js > API.md","prepublishOnly":"npm run build && npm test","bench":"matcha benchmarks/*.js","semantic-release":"semantic-release"},"repository":{"type":"git","url":"git://github.com/luin/ioredis.git"},"keywords":["redis","cluster","sentinel","pipelining"],"author":{"name":"luin","email":"i@zihua.li","url":"http://zihua.li"},"license":"MIT","dependencies":{"cluster-key-slot":"^1.0.6","debug":"^3.1.0","denque":"^1.1.0","flexbuffer":"0.0.6","lodash.defaults":"^4.2.0","lodash.flatten":"^4.4.0","redis-commands":"1.4.0","redis-errors":"^1.2.0","redis-parser":"^3.0.0","standard-as-callback":"^1.0.0"},"devDependencies":{"@semantic-release/changelog":"^3.0.0","@semantic-release/git":"^7.0.4","@types/node":"^10.11.5","@types/redis-errors":"1.2.0","bluebird":"^3.5.1","chai":"^3.5.0","cz-conventional-changelog":"^2.0.0","istanbul":"^0.4.2","jsdoc":"^3.4.0","jsdoc-to-markdown":"^4.0.1","mocha":"^5.2.0","server-destroy":"^1.0.1","sinon":"^1.17.3","ts-node":"^7.0.0","typescript":"^3.1.1"},"engines":{"node":">=6"},"config":{"commitizen":{"path":"./node_modules/cz-conventional-changelog"}},"gitHead":"b46016aaeec31df7ab29faa6c3f2e8d2383d84ea","bugs":{"url":"https://github.com/luin/ioredis/issues"},"homepage":"https://github.com/luin/ioredis#readme","_id":"ioredis@4.2.0","_npmVersion":"6.4.1","_nodeVersion":"10.12.0","_npmUser":{"name":"ioredis-robot","email":"ioredis-robot@zihua.li"},"dist":{"integrity":"sha512-PdxZGNJBfPiR2RI6DkqmiacL1+ML3gaqEiaC5QXWQt9eSTlGj+BwDCct0s8irn1ed8GyzAHTzcjvU9fmnl6D7A==","shasum":"f0f76fa5067a51c365ef1411f6572478a825971d","tarball":"https://registry.npmjs.org/ioredis/-/ioredis-4.2.0.tgz","fileCount":35,"unpackedSize":211770,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJbxyQjCRA9TVsSAnZWagAAo2EP/RSkN54fxdCtHNoaNM4s\nYyuwS5oamPKpceeftSFR86MO+9fPzpSN06EOx7om2KJyzwn+rRKZZ3qRbrvV\nq8yVFC09WE2BtFRsfJFZSGzKwYjPLA9sUQYLDatC0vmJa8JlOMurNxetSQmm\nx/WkxmaUCg3LRJNaq1CcwAtNH7IUNwl8HlosgjCY21d0p2r/chhWpRbCEoch\nM/cxKKHQDawg3MhtyrMTwEkEnoAta4KLigN40tMhSLj50wDT7Dmn2z/45B8H\noUGKt0NTn14K2KXCjs8dXlOW4JjzDtd5HheeZ6gD/XqA/DX9rsU4c5MwVpDH\n1ME+GVfyfMSRRloCIat6xfNf3c+P1j/9dWPR3xK0OA8YZkHXzlpd5EDXSQtT\nD05Q79mifYDx8iOqpXD1AUW6LdqBveJ6pnuF/s0wPq0k7N9L5ndNQHNcOMQD\n85E1qespy1nP8bVW6O32pRooXcnqwO0qm41kAZoT5kiTC7xlbuq8Kegp6yhi\ngCBRL1/PjPGcBkiQGxiJkMh5TcynnnU7fMpkmt9Qb3/mGCYlJOpdqHc+MSoe\n4Q6H/unhPqIHxsQDQl7n6wDvoFHbLWJV+bAUp5F0aOZQBgC+GVcA9seZlA61\nF2AfYTKAutvBppm4mPqs+XrfeR7ZhmNijTIMOjZrULO6o+8/t/I8KIcUEGP8\nTzFp\r\n=xf6L\r\n-----END PGP SIGNATURE-----\r\n"},"maintainers":[{"email":"ioredis-robot@zihua.li","name":"ioredis-robot"},{"email":"i@zihua.li","name":"luin"}],"directories":{},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/ioredis_4.2.0_1539777570178_0.9779589586341004"},"_hasShrinkwrap":false},"4.2.1":{"name":"ioredis","version":"4.2.1","description":"A robust, performance-focused and full-featured Redis client for Node.js.","main":"built/index.js","scripts":{"test":"NODE_ENV=test mocha --timeout 8000 -r ts-node/register --exit","test:cov":"NODE_ENV=test node ./node_modules/istanbul/lib/cli.js cover --preserve-comments ./node_modules/mocha/bin/_mocha -- -r ts-node/register -R spec --exit","build":"rm -rf built && tsc","generate-docs":"jsdoc2md lib/redis.js lib/cluster/index.js lib/commander.js > API.md","prepublishOnly":"npm run build && npm test","bench":"matcha benchmarks/*.js","semantic-release":"semantic-release"},"repository":{"type":"git","url":"git://github.com/luin/ioredis.git"},"keywords":["redis","cluster","sentinel","pipelining"],"author":{"name":"luin","email":"i@zihua.li","url":"http://zihua.li"},"license":"MIT","dependencies":{"cluster-key-slot":"^1.0.6","debug":"^3.1.0","denque":"^1.1.0","flexbuffer":"0.0.6","lodash.defaults":"^4.2.0","lodash.flatten":"^4.4.0","redis-commands":"1.4.0","redis-errors":"^1.2.0","redis-parser":"^3.0.0","standard-as-callback":"^1.0.0"},"devDependencies":{"@semantic-release/changelog":"^3.0.0","@semantic-release/git":"^7.0.4","@types/node":"^10.11.5","@types/redis-errors":"1.2.0","bluebird":"^3.5.1","chai":"^3.5.0","cz-conventional-changelog":"^2.0.0","istanbul":"^0.4.2","jsdoc":"^3.4.0","jsdoc-to-markdown":"^4.0.1","mocha":"^5.2.0","server-destroy":"^1.0.1","sinon":"^1.17.3","ts-node":"^7.0.0","typescript":"^3.1.1"},"engines":{"node":">=6"},"config":{"commitizen":{"path":"./node_modules/cz-conventional-changelog"}},"gitHead":"48e56daec4eb1011a5f9994bb8ff9512e9659c75","readme":"[![ioredis](https://cdn.rawgit.com/luin/ioredis/57b5b89e3e9111ff25d8c62c0bc58ed42e5b8d1e/logo.svg)](https://github.com/luin/ioredis)\n\n[![Build Status](https://travis-ci.org/luin/ioredis.svg?branch=master)](https://travis-ci.org/luin/ioredis)\n[![Test Coverage](https://codeclimate.com/github/luin/ioredis/badges/coverage.svg)](https://codeclimate.com/github/luin/ioredis)\n[![Code Climate](https://codeclimate.com/github/luin/ioredis/badges/gpa.svg)](https://codeclimate.com/github/luin/ioredis)\n[![Commitizen friendly](https://img.shields.io/badge/commitizen-friendly-brightgreen.svg)](http://commitizen.github.io/cz-cli/)\n[![Join the chat at https://gitter.im/luin/ioredis](https://badges.gitter.im/Join%20Chat.svg)](https://gitter.im/luin/ioredis?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge)\n\nA robust, performance-focused and full-featured [Redis](http://redis.io) client for [Node.js](https://nodejs.org).\n\nSupports Redis >= 2.6.12 and (Node.js >= 6).\n\n# Features\nioredis is a robust, full-featured Redis client that is\nused in the world's biggest online commerce company [Alibaba](http://www.alibaba.com/) and many other awesome companies.\n\n0. Full-featured. It supports [Cluster](http://redis.io/topics/cluster-tutorial), [Sentinel](http://redis.io/topics/sentinel), [Pipelining](http://redis.io/topics/pipelining) and of course [Lua scripting](http://redis.io/commands/eval) & [Pub/Sub](http://redis.io/topics/pubsub) (with the support of binary messages).\n0. High performance.\n0. Delightful API. It works with Node callbacks and Native promises.\n0. Transformation of command arguments and replies.\n0. Transparent key prefixing.\n0. Abstraction for Lua scripting, allowing you to define custom commands.\n0. Support for binary data.\n0. Support for TLS.\n0. Support for offline queue and ready checking.\n0. Support for ES6 types, such as `Map` and `Set`.\n0. Support for GEO commands (Redis 3.2 Unstable).\n0. Sophisticated error handling strategy.\n\n# Links\n* [API Documentation](API.md)\n* [Changelog](Changelog.md)\n* [Migrating from node_redis](https://github.com/luin/ioredis/wiki/Migrating-from-node_redis)\n* [Error Handling](#error-handling)\n\n## Become a Sponsor to Support ioredis's Development\nOpen source is hard and time-consuming. If you want to invest in ioredis's future you can become a sponsor and make us spend more time on this library's improvements and new features.\n\n<a href=\"https://opencollective.com/ioredis\"><img src=\"https://opencollective.com/ioredis/tiers/sponsor.svg?avatarHeight=36\"></a>\n\nThank you for using ioredis :-)\n\n<hr>\n<a href=\"https://itunes.apple.com/app/medis-gui-for-redis/id1063631769\"><img align=\"right\" src=\"medis.png\" alt=\"Download on the App Store\"></a>\n\n\n### Advertisement\n\nLooking for a Redis GUI manager for OS X, Windows and Linux? Here's [Medis](https://itunes.apple.com/us/app/medis-gui-for-redis/id1063631769)!\n\nMedis is an open-sourced, beautiful, easy-to-use Redis GUI management application.\n\nMedis starts with all the basic features you need:\n\n* Keys viewing/editing\n* SSH Tunnel for connecting with remote servers\n* Terminal for executing custom commands\n* JSON/MessagePack format viewing/editing and built-in highlighting/validator\n* And other awesome features...\n\n[Medis is open sourced on GitHub](https://github.com/luin/medis)\n\n<hr>\n\n# Quick Start\n\n## Install\n```shell\n$ npm install ioredis\n```\n\n## Basic Usage\n\n```javascript\nvar Redis = require('ioredis');\nvar redis = new Redis();\n\nredis.set('foo', 'bar');\nredis.get('foo', function (err, result) {\n  console.log(result);\n});\n\n// Or using a promise if the last argument isn't a function\nredis.get('foo').then(function (result) {\n  console.log(result);\n});\n\n// Arguments to commands are flattened, so the following are the same:\nredis.sadd('set', 1, 3, 5, 7);\nredis.sadd('set', [1, 3, 5, 7]);\n\n// All arguments are passed directly to the redis server:\nredis.set('key', 100, 'EX', 10);\n```\n\nSee the `examples/` folder for more examples.\n\n## Connect to Redis\nWhen a new `Redis` instance is created,\na connection to Redis will be created at the same time.\nYou can specify which Redis to connect to by:\n\n```javascript\nnew Redis()       // Connect to 127.0.0.1:6379\nnew Redis(6380)   // 127.0.0.1:6380\nnew Redis(6379, '192.168.1.1')        // 192.168.1.1:6379\nnew Redis('/tmp/redis.sock')\nnew Redis({\n  port: 6379,          // Redis port\n  host: '127.0.0.1',   // Redis host\n  family: 4,           // 4 (IPv4) or 6 (IPv6)\n  password: 'auth',\n  db: 0\n})\n```\n\nYou can also specify connection options as a [`redis://` URL](http://www.iana.org/assignments/uri-schemes/prov/redis):\n\n```javascript\n// Connect to 127.0.0.1:6380, db 4, using password \"authpassword\":\nnew Redis('redis://:authpassword@127.0.0.1:6380/4')\n```\n\nSee [API Documentation](API.md#new_Redis) for all available options.\n\n## Pub/Sub\n\nHere is a simple example of the API for publish/subscribe.\nThe following program opens two client connections.\nIt subscribes to a channel with one connection\nand publishes to that channel with the other:\n\n```javascript\nvar Redis = require('ioredis');\nvar redis = new Redis();\nvar pub = new Redis();\nredis.subscribe('news', 'music', function (err, count) {\n  // Now we are subscribed to both the 'news' and 'music' channels.\n  // `count` represents the number of channels we are currently subscribed to.\n\n  pub.publish('news', 'Hello world!');\n  pub.publish('music', 'Hello again!');\n});\n\nredis.on('message', function (channel, message) {\n  // Receive message Hello world! from channel news\n  // Receive message Hello again! from channel music\n  console.log('Receive message %s from channel %s', message, channel);\n});\n\n// There's also an event called 'messageBuffer', which is the same as 'message' except\n// it returns buffers instead of strings.\nredis.on('messageBuffer', function (channel, message) {\n  // Both `channel` and `message` are buffers.\n});\n```\n\n`PSUBSCRIBE` is also supported in a similar way:\n\n```javascript\nredis.psubscribe('pat?ern', function (err, count) {});\nredis.on('pmessage', function (pattern, channel, message) {});\nredis.on('pmessageBuffer', function (pattern, channel, message) {});\n```\n\nWhen a client issues a SUBSCRIBE or PSUBSCRIBE, that connection is put into a \"subscriber\" mode.\nAt that point, only commands that modify the subscription set are valid.\nWhen the subscription set is empty, the connection is put back into regular mode.\n\nIf you need to send regular commands to Redis while in subscriber mode, just open another connection.\n\n## Handle Binary Data\nArguments can be buffers:\n```javascript\nredis.set('foo', Buffer.from('bar'));\n```\n\nAnd every command has a method that returns a Buffer (by adding a suffix of \"Buffer\" to the command name).\nTo get a buffer instead of a utf8 string:\n\n```javascript\nredis.getBuffer('foo', function (err, result) {\n  // result is a buffer.\n});\n```\n\n## Pipelining\nIf you want to send a batch of commands (e.g. > 5), you can use pipelining to queue\nthe commands in memory and then send them to Redis all at once. This way the performance improves by 50%~300% (See [benchmark section](#benchmark)).\n\n`redis.pipeline()` creates a `Pipeline` instance. You can call any Redis\ncommands on it just like the `Redis` instance. The commands are queued in memory\nand flushed to Redis by calling the `exec` method:\n\n```javascript\nvar pipeline = redis.pipeline();\npipeline.set('foo', 'bar');\npipeline.del('cc');\npipeline.exec(function (err, results) {\n  // `err` is always null, and `results` is an array of responses\n  // corresponding to the sequence of queued commands.\n  // Each response follows the format `[err, result]`.\n});\n\n// You can even chain the commands:\nredis.pipeline().set('foo', 'bar').del('cc').exec(function (err, results) {\n});\n\n// `exec` also returns a Promise:\nvar promise = redis.pipeline().set('foo', 'bar').get('foo').exec();\npromise.then(function (result) {\n  // result === [[null, 'OK'], [null, 'bar']]\n});\n```\n\nEach chained command can also have a callback, which will be invoked when the command\ngets a reply:\n\n```javascript\nredis.pipeline().set('foo', 'bar').get('foo', function (err, result) {\n  // result === 'bar'\n}).exec(function (err, result) {\n  // result[1][1] === 'bar'\n});\n```\n\nIn addition to adding commands to the `pipeline` queue individually, you can also pass an array of commands and arguments to the constructor:\n\n```javascript\nredis.pipeline([\n  ['set', 'foo', 'bar'],\n  ['get', 'foo']\n]).exec(function () { /* ... */ });\n```\n\n`#length` property shows how many commands in the pipeline:\n\n```javascript\nconst length = redis.pipeline().set('foo', 'bar').get('foo').length;\n// length === 2\n```\n\n\n## Transaction\nMost of the time, the transaction commands `multi` & `exec` are used together with pipeline.\nTherefore, when `multi` is called, a `Pipeline` instance is created automatically by default,\nso you can use `multi` just like `pipeline`:\n\n```javascript\nredis.multi().set('foo', 'bar').get('foo').exec(function (err, results) {\n  // results === [[null, 'OK'], [null, 'bar']]\n});\n```\nIf there's a syntax error in the transaction's command chain (e.g. wrong number of arguments, wrong command name, etc),\nthen none of the commands would be executed, and an error is returned:\n\n```javascript\nredis.multi().set('foo').set('foo', 'new value').exec(function (err, results) {\n  // err:\n  //  { [ReplyError: EXECABORT Transaction discarded because of previous errors.]\n  //    name: 'ReplyError',\n  //    message: 'EXECABORT Transaction discarded because of previous errors.',\n  //    command: { name: 'exec', args: [] },\n  //    previousErrors:\n  //     [ { [ReplyError: ERR wrong number of arguments for 'set' command]\n  //         name: 'ReplyError',\n  //         message: 'ERR wrong number of arguments for \\'set\\' command',\n  //         command: [Object] } ] }\n});\n```\n\nIn terms of the interface, `multi` differs from `pipeline` in that when specifying a callback\nto each chained command, the queueing state is passed to the callback instead of the result of the command:\n\n```javascript\nredis.multi().set('foo', 'bar', function (err, result) {\n  // result === 'QUEUED'\n}).exec(/* ... */);\n```\n\nIf you want to use transaction without pipeline, pass `{ pipeline: false }` to `multi`,\nand every command will be sent to Redis immediately without waiting for an `exec` invocation:\n\n```javascript\nredis.multi({ pipeline: false });\nredis.set('foo', 'bar');\nredis.get('foo');\nredis.exec(function (err, result) {\n  // result === [[null, 'OK'], [null, 'bar']]\n});\n```\n\nThe constructor of `multi` also accepts a batch of commands:\n\n```javascript\nredis.multi([\n  ['set', 'foo', 'bar'],\n  ['get', 'foo']\n]).exec(function () { /* ... */ });\n```\n\nInline transactions are supported by pipeline, which means you can group a subset of commands\nin the pipeline into a transaction:\n\n```javascript\nredis.pipeline().get('foo').multi().set('foo', 'bar').get('foo').exec().get('foo').exec();\n```\n\n## Lua Scripting\nioredis supports all of the scripting commands such as `EVAL`, `EVALSHA` and `SCRIPT`.\nHowever, it's tedious to use in real world scenarios since developers have to take\ncare of script caching and to detect when to use `EVAL` and when to use `EVALSHA`.\nioredis expose a `defineCommand` method to make scripting much easier to use:\n\n```javascript\nvar redis = new Redis();\n\n// This will define a command echo:\nredis.defineCommand('echo', {\n  numberOfKeys: 2,\n  lua: 'return {KEYS[1],KEYS[2],ARGV[1],ARGV[2]}'\n});\n\n// Now `echo` can be used just like any other ordinary command,\n// and ioredis will try to use `EVALSHA` internally when possible for better performance.\nredis.echo('k1', 'k2', 'a1', 'a2', function (err, result) {\n  // result === ['k1', 'k2', 'a1', 'a2']\n});\n\n// `echoBuffer` is also defined automatically to return buffers instead of strings:\nredis.echoBuffer('k1', 'k2', 'a1', 'a2', function (err, result) {\n  // result[0] equals to Buffer.from('k1');\n});\n\n// And of course it works with pipeline:\nredis.pipeline().set('foo', 'bar').echo('k1', 'k2', 'a1', 'a2').exec();\n```\n\nIf the number of keys can't be determined when defining a command, you can\nomit the `numberOfKeys` property and pass the number of keys as the first argument\nwhen you call the command:\n\n```javascript\nredis.defineCommand('echoDynamicKeyNumber', {\n  lua: 'return {KEYS[1],KEYS[2],ARGV[1],ARGV[2]}'\n});\n\n// Now you have to pass the number of keys as the first argument every time\n// you invoke the `echoDynamicKeyNumber` command:\nredis.echoDynamicKeyNumber(2, 'k1', 'k2', 'a1', 'a2', function (err, result) {\n  // result === ['k1', 'k2', 'a1', 'a2']\n});\n```\n\n## Transparent Key Prefixing\nThis feature allows you to specify a string that will automatically be prepended\nto all the keys in a command, which makes it easier to manage your key\nnamespaces.\n\n**Warning** This feature won't apply to commands like [KEYS](http://redis.io/commands/KEYS) and [SCAN](http://redis.io/commands/scan) that take patterns rather than actual keys([#239](https://github.com/luin/ioredis/issues/239)),\nand this feature also won't apply to the replies of commands even they are key names ([#325](https://github.com/luin/ioredis/issues/325)).\n\n```javascript\nvar fooRedis = new Redis({ keyPrefix: 'foo:' });\nfooRedis.set('bar', 'baz');  // Actually sends SET foo:bar baz\n\nfooRedis.defineCommand('echo', {\n  numberOfKeys: 2,\n  lua: 'return {KEYS[1],KEYS[2],ARGV[1],ARGV[2]}'\n});\n\n// Works well with pipelining/transaction\nfooRedis.pipeline()\n  // Sends SORT foo:list BY foo:weight_*->fieldname\n  .sort('list', 'BY', 'weight_*->fieldname')\n  // Supports custom commands\n  // Sends EVALSHA xxx foo:k1 foo:k2 a1 a2\n  .echo('k1', 'k2', 'a1', 'a2')\n  .exec()\n```\n\n## Transforming Arguments & Replies\nMost Redis commands take one or more Strings as arguments,\nand replies are sent back as a single String or an Array of Strings. However, sometimes\nyou may want something different. For instance, it would be more convenient if the `HGETALL`\ncommand returns a hash (e.g. `{ key: val1, key2: v2 }`) rather than an array of key values (e.g. `[key1, val1, key2, val2]`).\n\nioredis has a flexible system for transforming arguments and replies. There are two types\nof transformers, argument transformer and reply transformer:\n\n```javascript\nvar Redis = require('ioredis');\n\n// Here's the built-in argument transformer converting\n// hmset('key', { k1: 'v1', k2: 'v2' })\n// or\n// hmset('key', new Map([['k1', 'v1'], ['k2', 'v2']]))\n// into\n// hmset('key', 'k1', 'v1', 'k2', 'v2')\nRedis.Command.setArgumentTransformer('hmset', function (args) {\n  if (args.length === 2) {\n    if (typeof Map !== 'undefined' && args[1] instanceof Map) {\n      // utils is a internal module of ioredis\n      return [args[0]].concat(utils.convertMapToArray(args[1]));\n    }\n    if ( typeof args[1] === 'object' && args[1] !== null) {\n      return [args[0]].concat(utils.convertObjectToArray(args[1]));\n    }\n  }\n  return args;\n});\n\n// Here's the built-in reply transformer converting the HGETALL reply\n// ['k1', 'v1', 'k2', 'v2']\n// into\n// { k1: 'v1', 'k2': 'v2' }\nRedis.Command.setReplyTransformer('hgetall', function (result) {\n  if (Array.isArray(result)) {\n    var obj = {};\n    for (var i = 0; i < result.length; i += 2) {\n      obj[result[i]] = result[i + 1];\n    }\n    return obj;\n  }\n  return result;\n});\n```\n\nThere are three built-in transformers, two argument transformers for `hmset` & `mset` and\na reply transformer for `hgetall`. Transformers for `hmset` and `hgetall` were mentioned\nabove, and the transformer for `mset` is similar to the one for `hmset`:\n\n```javascript\nredis.mset({ k1: 'v1', k2: 'v2' });\nredis.get('k1', function (err, result) {\n  // result === 'v1';\n});\n\nredis.mset(new Map([['k3', 'v3'], ['k4', 'v4']]));\nredis.get('k3', function (err, result) {\n  // result === 'v3';\n});\n```\n\nAnother useful example of a reply transformer is one that changes `hgetall` to return array of arrays instead of objects which avoids a unwanted conversation of hash keys to strings when dealing with binary hash keys:\n\n```javascript\nRedis.Command.setReplyTransformer('hgetall', function (result) {\n  var arr = [];\n  for (var i = 0; i < result.length; i += 2) {\n    arr.push([result[i], result[i + 1]]);\n  }\n  return arr;\n});\nredis.hset('h1', Buffer.from([0x01]), Buffer.from([0x02]));\nredis.hset('h1', Buffer.from([0x03]), Buffer.from([0x04]));\nredis.hgetallBuffer('h1', function (err, result) {\n  // result === [ [ <Buffer 01>, <Buffer 02> ], [ <Buffer 03>, <Buffer 04> ] ];\n});\n```\n\n## Monitor\nRedis supports the MONITOR command,\nwhich lets you see all commands received by the Redis server across all client connections,\nincluding from other client libraries and other computers.\n\nThe `monitor` method returns a monitor instance.\nAfter you send the MONITOR command, no other commands are valid on that connection. ioredis will emit a monitor event for every new monitor message that comes across.\nThe callback for the monitor event takes a timestamp from the Redis server and an array of command arguments.\n\nHere is a simple example:\n\n```javascript\nredis.monitor(function (err, monitor) {\n  monitor.on('monitor', function (time, args, source, database) {\n  });\n});\n```\n\n## Streamify Scanning\nRedis 2.8 added the `SCAN` command to incrementally iterate through the keys in the database. It's different from `KEYS` in that\n`SCAN` only returns a small number of elements each call, so it can be used in production without the downside\nof blocking the server for a long time. However, it requires recording the cursor on the client side each time\nthe `SCAN` command is called in order to iterate through all the keys correctly. Since it's a relatively common use case, ioredis\nprovides a streaming interface for the `SCAN` command to make things much easier. A readable stream can be created by calling `scanStream`:\n\n```javascript\nvar redis = new Redis();\n// Create a readable stream (object mode)\nvar stream = redis.scanStream();\nstream.on('data', function (resultKeys) {\n  // `resultKeys` is an array of strings representing key names.\n  // Note that resultKeys may contain 0 keys, and that it will sometimes\n  // contain duplicates due to SCAN's implementation in Redis.\n  for (var i = 0; i < resultKeys.length; i++) {\n    console.log(resultKeys[i]);\n  }\n});\nstream.on('end', function () {\n  console.log('all keys have been visited');\n});\n```\n\n`scanStream` accepts an option, with which you can specify the `MATCH` pattern and the `COUNT` argument:\n\n```javascript\nvar stream = redis.scanStream({\n  // only returns keys following the pattern of `user:*`\n  match: 'user:*',\n  // returns approximately 100 elements per call\n  count: 100\n});\n```\n\nJust like other commands, `scanStream` has a binary version `scanBufferStream`, which returns an array of buffers. It's useful when\nthe key names are not utf8 strings.\n\nThere are also `hscanStream`, `zscanStream` and `sscanStream` to iterate through elements in a hash, zset and set. The interface of each is\nsimilar to `scanStream` except the first argument is the key name:\n\n```javascript\nvar stream = redis.hscanStream('myhash', {\n  match: 'age:??'\n});\n```\n\nYou can learn more from the [Redis documentation](http://redis.io/commands/scan).\n\n**Useful Tips**\nIt's pretty common that doing an async task in the `data` handler. We'd like the scanning process to be paused until the async task to be finished. `Stream#pause()` and `Stream.resume()` do the trick. For example if we want to migrate data in Redis to MySQL:\n\n```javascript\nvar stream = redis.scanStream();\nstream.on('data', function (resultKeys) {\n  // Pause the stream from scanning more keys until we've migrated the current keys.\n  stream.pause();\n\n  Promise.all(resultKeys.map(migrateKeyToMySQL)).then(() => {\n    // Resume the stream here.\n    stream.resume();\n  });\n});\n\nstream.on('end', function () {\n  console.log('done migration');\n});\n```\n\n## Auto-reconnect\nBy default, ioredis will try to reconnect when the connection to Redis is lost\nexcept when the connection is closed manually by `redis.disconnect()` or `redis.quit()`.\n\nIt's very flexible to control how long to wait to reconnect after disconnection\nusing the `retryStrategy` option:\n\n```javascript\nvar redis = new Redis({\n  // This is the default value of `retryStrategy`\n  retryStrategy: function (times) {\n    var delay = Math.min(times * 50, 2000);\n    return delay;\n  }\n});\n```\n\n`retryStrategy` is a function that will be called when the connection is lost.\nThe argument `times` means this is the nth reconnection being made and\nthe return value represents how long (in ms) to wait to reconnect. When the\nreturn value isn't a number, ioredis will stop trying to reconnect, and the connection\nwill be lost forever if the user doesn't call `redis.connect()` manually.\n\nWhen reconnected, the client will auto subscribe to channels that the previous connection subscribed to.\nThis behavior can be disabled by setting the `autoResubscribe` option to `false`.\n\nAnd if the previous connection has some unfulfilled commands (most likely blocking commands such as `brpop` and `blpop`),\nthe client will resend them when reconnected. This behavior can be disabled by setting the `autoResendUnfulfilledCommands` option to `false`.\n\nBy default, all pending commands will be flushed with an error every 20 retry attempts. That makes sure commands won't wait forever when the connection is down. You can change this behavior by setting `maxRetriesPerRequest`:\n\n```javascript\nvar redis = new Redis({\n  maxRetriesPerRequest: 1\n});\n```\n\nSet maxRetriesPerRequest to `null` to disable this behavior, and every command will wait forever until the connection is alive again (which is the default behavior before ioredis v4).\n\n### Reconnect on error\n\nBesides auto-reconnect when the connection is closed, ioredis supports reconnecting on the specified errors by the `reconnectOnError` option. Here's an example that will reconnect when receiving `READONLY` error:\n\n```javascript\nvar redis = new Redis({\n  reconnectOnError: function (err) {\n    var targetError = 'READONLY';\n    if (err.message.slice(0, targetError.length) === targetError) {\n      // Only reconnect when the error starts with \"READONLY\"\n      return true; // or `return 1;`\n    }\n  }\n});\n```\n\nThis feature is useful when using Amazon ElastiCache. Once failover happens, Amazon ElastiCache will switch the master we currently connected with to a slave, leading to the following writes fails with the error `READONLY`. Using `reconnectOnError`, we can force the connection to reconnect on this error in order to connect to the new master.\n\nFurthermore, if the `reconnectOnError` returns `2`, ioredis will resend the failed command after reconnecting.\n\n## Connection Events\nThe Redis instance will emit some events about the state of the connection to the Redis server.\n\nEvent    | Description\n:------------- | :-------------\nconnect  | emits when a connection is established to the Redis server.\nready    | If `enableReadyCheck` is `true`, client will emit `ready` when the server reports that it is ready to receive commands (e.g. finish loading data from disk).<br>Otherwise, `ready` will be emitted immediately right after the `connect` event.\nerror    | emits when an error occurs while connecting.<br>However, ioredis emits all `error` events silently (only emits when there's at least one listener) so that your application won't crash if you're not listening to the `error` event.\nclose    | emits when an established Redis server connection has closed.\nreconnecting | emits after `close` when a reconnection will be made. The argument of the event is the time (in ms) before reconnecting.\nend     | emits after `close` when no more reconnections will be made, or the connection is failed to establish.\n\nYou can also check out the `Redis#status` property to get the current connection status.\n\nBesides the above connection events, there are several other custom events:\n\nEvent    | Description\n:------------- | :-------------\nselect   | emits when the database changed. The argument is the new db number.\n\n## Offline Queue\nWhen a command can't be processed by Redis (being sent before the `ready` event), by default, it's added to the offline queue and will be\nexecuted when it can be processed. You can disable this feature by setting the `enableOfflineQueue`\noption to `false`:\n\n```javascript\nvar redis = new Redis({ enableOfflineQueue: false });\n```\n\n## TLS Options\nRedis doesn't support TLS natively, however if the redis server you want to connect to is hosted behind a TLS proxy (e.g. [stunnel](https://www.stunnel.org/)) or is offered by a PaaS service that supports TLS connection (e.g. [Redis Labs](https://redislabs.com/)), you can set the `tls` option:\n\n```javascript\nvar redis = new Redis({\n  host: 'localhost',\n  tls: {\n    // Refer to `tls.connect()` section in\n    // https://nodejs.org/api/tls.html\n    // for all supported options\n    ca: fs.readFileSync('cert.pem')\n  }\n});\n```\n\n<hr>\n\n## Sentinel\nioredis supports Sentinel out of the box. It works transparently as all features that work when\nyou connect to a single node also work when you connect to a sentinel group. Make sure to run Redis >= 2.8.12 if you want to use this feature. Sentinels have a default port of 26379.\n\nTo connect using Sentinel, use:\n\n```javascript\nvar redis = new Redis({\n  sentinels: [{ host: 'localhost', port: 26379 }, { host: 'localhost', port: 26380 }],\n  name: 'mymaster'\n});\n\nredis.set('foo', 'bar');\n```\n\nThe arguments passed to the constructor are different from the ones you use to connect to a single node, where:\n\n* `name` identifies a group of Redis instances composed of a master and one or more slaves (`mymaster` in the example);\n* `sentinels` are a list of sentinels to connect to. The list does not need to enumerate all your sentinel instances, but a few so that if one is down the client will try the next one.\n* `role` (optional) with a value of `slave` will return a random slave from the Sentinel group.\n* `preferredSlaves` (optional) can be used to prefer a particular slave or set of slaves based on priority. It accepts a function or array.\n\nioredis **guarantees** that the node you connected to is always a master even after a failover. When a failover happens, instead of trying to reconnect to the failed node (which will be demoted to slave when it's available again), ioredis will ask sentinels for the new master node and connect to it. All commands sent during the failover are queued and will be executed when the new connection is established so that none of the commands will be lost.\n\nIt's possible to connect to a slave instead of a master by specifying the option `role` with the value of `slave` and ioredis will try to connect to a random slave of the specified master, with the guarantee that the connected node is always a slave. If the current node is promoted to master due to a failover, ioredis will disconnect from it and ask the sentinels for another slave node to connect to.\n\nIf you specify the option `preferredSlaves` along with `role: 'slave'` ioredis will attempt to use this value when selecting the slave from the pool of available slaves. The value of `preferredSlaves` should either be a function that accepts an array of avaiable slaves and returns a single result, or an array of slave values priorities by the lowest `prio` value first with a default value of `1`.\n\n```javascript\n// available slaves format\nvar availableSlaves = [{ ip: '127.0.0.1', port: '31231', flags: 'slave' }];\n\n// preferredSlaves array format\nvar preferredSlaves = [\n  { ip: '127.0.0.1', port: '31231', prio: 1 },\n  { ip: '127.0.0.1', port: '31232', prio: 2 }\n];\n\n// preferredSlaves function format\npreferredSlaves = function(availableSlaves) {\n  for (var i = 0; i < availableSlaves.length; i++) {\n    var slave = availableSlaves[i];\n    if (slave.ip === '127.0.0.1') {\n      if (slave.port === '31234') {\n        return slave;\n      }\n    }\n  }\n  // if no preferred slaves are available a random one is used\n  return false;\n};\n\nvar redis = new Redis({\n  sentinels: [{ host: '127.0.0.1', port: 26379 }, { host: '127.0.0.1', port: 26380 }],\n  name: 'mymaster',\n  role: 'slave',\n  preferredSlaves: preferredSlaves\n});\n```\n\nBesides the `retryStrategy` option, there's also a `sentinelRetryStrategy` in Sentinel mode which will be invoked when all the sentinel nodes are unreachable during connecting. If `sentinelRetryStrategy` returns a valid delay time, ioredis will try to reconnect from scratch. The default value of `sentinelRetryStrategy` is:\n\n```javascript\nfunction (times) {\n  var delay = Math.min(times * 10, 1000);\n  return delay;\n}\n```\n\n## Cluster\nRedis Cluster provides a way to run a Redis installation where data is automatically sharded across multiple Redis nodes.\nYou can connect to a Redis Cluster like this:\n\n```javascript\nvar Redis = require('ioredis');\n\nvar cluster = new Redis.Cluster([{\n  port: 6380,\n  host: '127.0.0.1'\n}, {\n  port: 6381,\n  host: '127.0.0.1'\n}]);\n\ncluster.set('foo', 'bar');\ncluster.get('foo', function (err, res) {\n  // res === 'bar'\n});\n```\n\n`Cluster` constructor accepts two arguments, where:\n\n0. The first argument is a list of nodes of the cluster you want to connect to.\nJust like Sentinel, the list does not need to enumerate all your cluster nodes,\nbut a few so that if one is unreachable the client will try the next one, and the client will discover other nodes automatically when at least one node is connected.\n0. The second argument is the options, where:\n\n    * `clusterRetryStrategy`: When none of the startup nodes are reachable, `clusterRetryStrategy` will be invoked. When a number is returned,\n    ioredis will try to reconnect to the startup nodes from scratch after the specified delay (in ms). Otherwise, an error of \"None of startup nodes is available\" will be returned.\n    The default value of this option is:\n\n        ```javascript\n        function (times) {\n          var delay = Math.min(100 + times * 2, 2000);\n          return delay;\n        }\n        ```\n\n        It's possible to modify the `startupNodes` property in order to switch to another set of nodes here:\n\n        ```javascript\n        function (times) {\n          this.startupNodes = [{ port: 6790, host: '127.0.0.1' }];\n          return Math.min(100 + times * 2, 2000);\n        }\n        ```\n\n    * `enableOfflineQueue`: Similar to the `enableOfflineQueue` option of `Redis` class.\n    * `enableReadyCheck`: When enabled, \"ready\" event will only be emitted when `CLUSTER INFO` command\n    reporting the cluster is ready for handling commands. Otherwise, it will be emitted immediately after \"connect\" is emitted.\n    * `scaleReads`: Config where to send the read queries. See below for more details.\n    * `maxRedirections`: When a cluster related error (e.g. `MOVED`, `ASK` and `CLUSTERDOWN` etc.) is received, the client will redirect the\n    command to another node. This option limits the max redirections allowed when sending a command. The default value is `16`.\n    * `retryDelayOnFailover`: If the target node is disconnected when sending a command,\n    ioredis will retry after the specified delay. The default value is `100`. You should make sure `retryDelayOnFailover * maxRedirections > cluster-node-timeout`\n    to insure that no command will fail during a failover.\n    * `retryDelayOnClusterDown`: When a cluster is down, all commands will be rejected with the error of `CLUSTERDOWN`. If this option is a number (by default, it is `100`), the client\n    will resend the commands after the specified time (in ms).\n    * `retryDelayOnTryAgain`: If this option is a number (by default, it is `100`), the client\n    will resend the commands rejected with `TRYAGAIN` error after the specified time (in ms).\n    * `redisOptions`: Default options passed to the constructor of `Redis` when connecting to a node.\n    * `slotsRefreshTimeout`: Milliseconds before a timeout occurs while refreshing slots from the cluster (default `1000`)\n    * `slotsRefreshInterval`: Milliseconds between every automatic slots refresh (default `5000`)\n\n### Read-write splitting\n\nA typical redis cluster contains three or more masters and several slaves for each master. It's possible to scale out redis cluster by sending read queries to slaves and write queries to masters by setting the `scaleReads` option.\n\n`scaleReads` is \"master\" by default, which means ioredis will never send any queries to slaves. There are other three available options:\n\n1. \"all\": Send write queries to masters and read queries to masters or slaves randomly.\n2. \"slave\": Send write queries to masters and read queries to slaves.\n3. a custom `function(nodes, command): node`: Will choose the custom function to select to which node to send read queries (write queries keep being sent to master). The first node in `nodes` is always the master serving the relevant slots. If the function returns an array of nodes, a random node of that list will be selected.\n\nFor example:\n\n```javascript\nvar cluster = new Redis.Cluster([/* nodes */], {\n  scaleReads: 'slave'\n});\ncluster.set('foo', 'bar'); // This query will be sent to one of the masters.\ncluster.get('foo', function (err, res) {\n  // This query will be sent to one of the slaves.\n});\n```\n\n**NB** In the code snippet above, the `res` may not be equal to \"bar\" because of the lag of replication between the master and slaves.\n\n### Running commands to multiple nodes\n\nEvery command will be sent to exactly one node. For commands containing keys, (e.g. `GET`, `SET` and `HGETALL`), ioredis sends them to the node that serving the keys, and for other commands not containing keys, (e.g. `INFO`, `KEYS` and `FLUSHDB`), ioredis sends them to a random node.\n\nSometimes you may want to send a command to multiple nodes (masters or slaves) of the cluster, you can get the nodes via `Cluster#nodes()` method.\n\n`Cluster#nodes()` accepts a parameter role, which can be \"master\", \"slave\" and \"all\" (default), and returns an array of `Redis` instance. For example:\n\n```javascript\n// Send `FLUSHDB` command to all slaves:\nvar slaves = cluster.nodes('slave');\nPromise.all(slaves.map(function (node) {\n  return node.flushdb();\n}));\n\n// Get keys of all the masters:\nvar masters = cluster.nodes('master');\nPromise.all(masters.map(function (node) {\n  return node.keys();\n})).then(function (keys) {\n  // keys: [['key1', 'key2'], ['key3', 'key4']]\n});\n```\n\n### Transaction and pipeline in Cluster mode\nAlmost all features that are supported by `Redis` are also supported by `Redis.Cluster`, e.g. custom commands, transaction and pipeline.\nHowever there are some differences when using transaction and pipeline in Cluster mode:\n\n0. All keys in a pipeline should belong to the same slot since ioredis sends all commands in a pipeline to the same node.\n0. You can't use `multi` without pipeline (aka `cluster.multi({ pipeline: false })`). This is because when you call `cluster.multi({ pipeline: false })`, ioredis doesn't know which node the `multi` command should be sent to.\n0. Chaining custom commands in the pipeline is not supported in Cluster mode.\n\nWhen any commands in a pipeline receives a `MOVED` or `ASK` error, ioredis will resend the whole pipeline to the specified node automatically if all of the following conditions are satisfied:\n\n0. All errors received in the pipeline are the same. For example, we won't resend the pipeline if we got two `MOVED` errors pointing to different nodes.\n0. All commands executed successfully are readonly commands. This makes sure that resending the pipeline won't have side effects.\n\n### Pub/Sub\nPub/Sub in cluster mode works exactly as the same as in standalone mode. Internally, when a node of the cluster receives a message, it will broadcast the message to the other nodes. ioredis makes sure that each message will only be received once by strictly subscribing one node at the same time.\n\n```javascript\nvar nodes = [/* nodes */];\nvar pub = new Redis.Cluster(nodes);\nvar sub = new Redis.Cluster(nodes);\nsub.on('message', function (channel, message) {\n  console.log(channel, message);\n});\n\nsub.subscribe('news', function () {\n  pub.publish('news', 'highlights');\n});\n```\n\n### Events\n\nEvent    | Description\n:------------- | :-------------\nconnect  | emits when a connection is established to the Redis server.\nready    | emits when `CLUSTER INFO` reporting the cluster is able to receive commands (if `enableReadyCheck` is `true`) or immediately after `connect` event (if `enableReadyCheck` is false).\nerror    | emits when an error occurs while connecting with a property of `lastNodeError` representing the last node error received. This event is emitted silently (only emitting if there's at least one listener).\nclose    | emits when an established Redis server connection has closed.\nreconnecting | emits after `close` when a reconnection will be made. The argument of the event is the time (in ms) before reconnecting.\nend     | emits after `close` when no more reconnections will be made.\n+node   | emits when a new node is connected.\n-node   | emits when a node is disconnected.\nnode error | emits when an error occurs when connecting to a node\n\n### Password\nSetting the `password` option to access password-proctected clusters:\n\n```javascript\nvar Redis = require('ioredis');\nvar cluster = new Redis.Cluster(nodes, {\n  redisOptions: {\n    password: 'your-cluster-password'\n  }\n});\n```\n\nIf some of nodes in the cluster using a different password, you should specify them in the first parameter:\n\n```javascript\nvar Redis = require('ioredis');\nvar cluster = new Redis.Cluster([\n  // Use password \"password-for-30001\" for 30001\n  { port: 30001, password: 'password-for-30001'},\n  // Don't use password when accessing 30002\n  { port: 30002, password: null }\n  // Other nodes will use \"fallback-password\"\n], {\n  redisOptions: {\n    password: 'fallback-password'\n  }\n});\n```\n\n<hr>\n\n# Error Handling\nAll the errors returned by the Redis server are instances of `ReplyError`, which can be accessed via `Redis`:\n\n```javascript\nvar Redis = require('ioredis');\nvar redis = new Redis();\n// This command causes a reply error since the SET command requires two arguments.\nredis.set('foo', function (err) {\n  err instanceof Redis.ReplyError\n});\n```\n\nThis is the error stack of the `ReplyError`:\n\n```\nReplyError: ERR wrong number of arguments for 'set' command\n    at ReplyParser._parseResult (/app/node_modules/ioredis/lib/parsers/javascript.js:60:14)\n    at ReplyParser.execute (/app/node_modules/ioredis/lib/parsers/javascript.js:178:20)\n    at Socket.<anonymous> (/app/node_modules/ioredis/lib/redis/event_handler.js:99:22)\n    at Socket.emit (events.js:97:17)\n    at readableAddChunk (_stream_readable.js:143:16)\n    at Socket.Readable.push (_stream_readable.js:106:10)\n    at TCP.onread (net.js:509:20)\n```\n\nBy default, the error stack doesn't make any sense because the whole stack happens in the ioredis\nmodule itself, not in your code. So it's not easy to find out where the error happens in your code.\nioredis provides an option `showFriendlyErrorStack` to solve the problem. When you enable\n`showFriendlyErrorStack`, ioredis will optimize the error stack for you:\n\n```javascript\nvar Redis = require('ioredis');\nvar redis = new Redis({ showFriendlyErrorStack: true });\nredis.set('foo');\n```\n\nAnd the output will be:\n\n```\nReplyError: ERR wrong number of arguments for 'set' command\n    at Object.<anonymous> (/app/index.js:3:7)\n    at Module._compile (module.js:446:26)\n    at Object.Module._extensions..js (module.js:464:10)\n    at Module.load (module.js:341:32)\n    at Function.Module._load (module.js:296:12)\n    at Function.Module.runMain (module.js:487:10)\n    at startup (node.js:111:16)\n    at node.js:799:3\n```\n\nThis time the stack tells you that the error happens on the third line in your code. Pretty sweet!\nHowever, it would decrease the performance significantly to optimize the error stack. So by\ndefault, this option is disabled and can only be used for debugging purposes. You **shouldn't** use this feature in a production environment.\n\n# Plugging in your own Promises Library\nIf you're an advanced user, you may want to plug in your own promise library like [bluebird](https://www.npmjs.com/package/bluebird). Just set Redis.Promise to your favorite ES6-style promise constructor and ioredis will use it.\n\n```javascript\nconst Redis = require('ioredis')\nRedis.Promise = require('bluebird')\n\nconst redis = new Redis()\n\n// Use bluebird\nassert.equal(redis.get().constructor, require('bluebird'))\n\n// You can change the Promise implementation at any time:\nRedis.Promise = global.Promise\nassert.equal(redis.get().constructor, global.Promise)\n```\n\n\n# Running tests\n\nStart a Redis server on 127.0.0.1:6379, and then:\n\n```shell\n$ npm test\n```\n\n`FLUSH ALL` will be invoked after each test, so make sure there's no valuable data in it before running tests.\n\nIf your testing environment does not let you spin up a Redis server [ioredis-mock](https://github.com/stipsan/ioredis-mock) is a drop-in replacement you can use in your tests. It aims to behave identically to ioredis connected to a Redis server so that your integration tests is easier to write and of better quality.\n\n# Debug\n\nYou can set the `DEBUG` env to `ioredis:*` to print debug info:\n\n```shell\n$ DEBUG=ioredis:* node app.js\n```\n\n# Consolidation: It's time for celebration\n\nRight now there are two great redis clients around and both have some advantages above each other. We speak about [node_redis](https://github.com/NodeRedis/node_redis) and ioredis. So after talking to each other about how we could improve in working together we (that is [@BridgeAR](https://github.com/BridgeAR) and [@luin](https://github.com/luin)) decided to work towards a single library on the long run. But step by step.\n\nFirst of all, we want to split small parts of our libraries into others so that we're both able to use the same code. Those libraries are going to be maintained under the NodeRedis organization. This is going to reduce the maintance overhead, allows others to use the very same code, if they need it and it's way easier for others to contribute to both libraries.\n\nWe're very happy about this step towards working together as we both want to give you the best redis experience possible.\n\nIf you want to join our cause by help maintaining something, please don't hesitate to contact either one of us.\n\n# Join in!\n\nI'm happy to receive bug reports, fixes, documentation enhancements, and any other improvements.\n\nAnd since I'm not a native English speaker, if you find any grammar mistakes in the documentation, please also let me know. :)\n\n# Contributors\n\nThis project exists thanks to all the people who contribute:\n\n<a href=\"https://github.com/luin/ioredis/graphs/contributors\"><img src=\"https://opencollective.com/ioredis/contributors.svg?width=890&showBtn=false\" /></a>\n\n# License\n\nMIT\n","readmeFilename":"README.md","bugs":{"url":"https://github.com/luin/ioredis/issues"},"homepage":"https://github.com/luin/ioredis#readme","_id":"ioredis@4.2.1","_npmVersion":"6.4.1","_nodeVersion":"10.12.0","_npmUser":{"name":"ioredis-robot","email":"ioredis-robot@zihua.li"},"dist":{"integrity":"sha512-K847UPZGHnwaJjapunuMlv66873ohkDBA5f/sSRNhWh3krSjkkkMrQQgMtLELPMTmGjxZrukKQbkl94LiXH5ug==","shasum":"0f9e395b476298909f931bd8c459fdf3916114f1","tarball":"https://registry.npmjs.org/ioredis/-/ioredis-4.2.1.tgz","fileCount":35,"unpackedSize":212315,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJbyfP7CRA9TVsSAnZWagAA+4YQAKGZSNDGtP8pykUH4Mr5\noVIWszOBuKpXvTBC/Te/jkYBK8o/M+t7kx5wcxL2hSCvfAGvrzX0dEFO25pY\n8IcAeyCM8bUFwX1rVB6NtwdqpKzedbPhThy2s70kEquTmf/UZ90pFhmEFWwp\n+o7udYETAFyEg6sTvYvc05XzQgReBjg4ZTBOrkdAvWBOoI0/NiJBLJxkanlI\nKjvYZEaNNXACV99v0fxZ5fz+flbXpgcgfMbckgajKgJpfs1TGP41sadacv/N\nBXRA0gYRqZ/RZ7o/VPMgyvjfQyJqn2zCfAtTD0ZCcvF0ADtZaahnbCnaA4va\nQv04PQFg+OsNm3xB4xYlV5svTDZAngLs6mDpr8L2Ie3VBU133INA8Vn57jjS\nplTSfusM47qd+bvZjnic32yEmIiRaOlP96pWjoadmV7SBqqmNBXRISPkeqDx\niyjC21c3bM+onbXqEO4WxC/CWq1/pMxIYRSObWNI9Ehx/xL7JgzagK06qP8e\nLsNTfN74ljf77bEKiL7omWhlKYAvFIFRAFbs32Sctw2egdnzI7KPXeH9a9Jk\n1DvrJalOvzKz8hxMWq4sgvtXQGcRbkyisQBjVrSjqQ7w7ffvWGM2VnU+VLND\nuKhmIZYr8tllYJQLdhMf1wqWbJ9plfvpiKPkavnJq6Uy/QmJOZurhgJtZ06b\nhEnk\r\n=aqgH\r\n-----END PGP SIGNATURE-----\r\n"},"maintainers":[{"email":"ioredis-robot@zihua.li","name":"ioredis-robot"},{"email":"i@zihua.li","name":"luin"}],"directories":{},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/ioredis_4.2.1_1539961850272_0.0862210038753426"},"_hasShrinkwrap":false},"4.2.2":{"name":"ioredis","version":"4.2.2","description":"A robust, performance-focused and full-featured Redis client for Node.js.","main":"built/index.js","scripts":{"test":"NODE_ENV=test mocha --timeout 8000 -r ts-node/register --exit","test:cov":"NODE_ENV=test node ./node_modules/istanbul/lib/cli.js cover --preserve-comments ./node_modules/mocha/bin/_mocha -- -r ts-node/register -R spec --exit","build":"rm -rf built && tsc","generate-docs":"jsdoc2md lib/redis.js lib/cluster/index.js lib/commander.js > API.md","prepublishOnly":"npm run build && npm test","bench":"matcha benchmarks/*.js","semantic-release":"semantic-release"},"repository":{"type":"git","url":"git://github.com/luin/ioredis.git"},"keywords":["redis","cluster","sentinel","pipelining"],"author":{"name":"luin","email":"i@zihua.li","url":"http://zihua.li"},"license":"MIT","dependencies":{"cluster-key-slot":"^1.0.6","debug":"^3.1.0","denque":"^1.1.0","flexbuffer":"0.0.6","lodash.defaults":"^4.2.0","lodash.flatten":"^4.4.0","redis-commands":"1.4.0","redis-errors":"^1.2.0","redis-parser":"^3.0.0","standard-as-callback":"^1.0.0"},"devDependencies":{"@semantic-release/changelog":"^3.0.0","@semantic-release/git":"^7.0.4","@types/node":"^10.11.5","@types/redis-errors":"1.2.0","bluebird":"^3.5.1","chai":"^3.5.0","cz-conventional-changelog":"^2.0.0","istanbul":"^0.4.2","jsdoc":"^3.4.0","jsdoc-to-markdown":"^4.0.1","mocha":"^5.2.0","server-destroy":"^1.0.1","sinon":"^1.17.3","ts-node":"^7.0.0","typescript":"^3.1.1"},"engines":{"node":">=6"},"config":{"commitizen":{"path":"./node_modules/cz-conventional-changelog"}},"gitHead":"d4461462fe9af93ff535fbaec48660e8d52ce565","readme":"[![ioredis](https://cdn.rawgit.com/luin/ioredis/57b5b89e3e9111ff25d8c62c0bc58ed42e5b8d1e/logo.svg)](https://github.com/luin/ioredis)\n\n[![Build Status](https://travis-ci.org/luin/ioredis.svg?branch=master)](https://travis-ci.org/luin/ioredis)\n[![Test Coverage](https://codeclimate.com/github/luin/ioredis/badges/coverage.svg)](https://codeclimate.com/github/luin/ioredis)\n[![Join the chat at https://gitter.im/luin/ioredis](https://badges.gitter.im/Join%20Chat.svg)](https://gitter.im/luin/ioredis?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge)\n[![Commitizen friendly](https://img.shields.io/badge/commitizen-friendly-brightgreen.svg)](http://commitizen.github.io/cz-cli/)\n[![semantic-release](https://img.shields.io/badge/%20%20%F0%9F%93%A6%F0%9F%9A%80-semantic--release-e10079.svg)](https://github.com/semantic-release/semantic-release)\n[![npm latest version](https://img.shields.io/npm/v/ioredis/latest.svg)](https://www.npmjs.com/package/ioredis)\n[![npm next version](https://img.shields.io/npm/v/ioredis/next.svg)](https://www.npmjs.com/package/ioredis)\n<img alt=\"\" src=\"\">\n\nA robust, performance-focused and full-featured [Redis](http://redis.io) client for [Node.js](https://nodejs.org).\n\nSupports Redis >= 2.6.12 and (Node.js >= 6).\n\n# Features\nioredis is a robust, full-featured Redis client that is\nused in the world's biggest online commerce company [Alibaba](http://www.alibaba.com/) and many other awesome companies.\n\n0. Full-featured. It supports [Cluster](http://redis.io/topics/cluster-tutorial), [Sentinel](http://redis.io/topics/sentinel), [Pipelining](http://redis.io/topics/pipelining) and of course [Lua scripting](http://redis.io/commands/eval) & [Pub/Sub](http://redis.io/topics/pubsub) (with the support of binary messages).\n0. High performance.\n0. Delightful API. It works with Node callbacks and Native promises.\n0. Transformation of command arguments and replies.\n0. Transparent key prefixing.\n0. Abstraction for Lua scripting, allowing you to define custom commands.\n0. Support for binary data.\n0. Support for TLS.\n0. Support for offline queue and ready checking.\n0. Support for ES6 types, such as `Map` and `Set`.\n0. Support for GEO commands (Redis 3.2 Unstable).\n0. Sophisticated error handling strategy.\n\n# Links\n* [API Documentation](API.md)\n* [Changelog](Changelog.md)\n* [Migrating from node_redis](https://github.com/luin/ioredis/wiki/Migrating-from-node_redis)\n* [Error Handling](#error-handling)\n\n## Become a Sponsor to Support ioredis's Development\nOpen source is hard and time-consuming. If you want to invest in ioredis's future you can become a sponsor and make us spend more time on this library's improvements and new features.\n\n<a href=\"https://opencollective.com/ioredis\"><img src=\"https://opencollective.com/ioredis/tiers/sponsor.svg?avatarHeight=36\"></a>\n\nThank you for using ioredis :-)\n\n<hr>\n<a href=\"https://itunes.apple.com/app/medis-gui-for-redis/id1063631769\"><img align=\"right\" src=\"medis.png\" alt=\"Download on the App Store\"></a>\n\n\n### Advertisement\n\nLooking for a Redis GUI manager for OS X, Windows and Linux? Here's [Medis](https://itunes.apple.com/us/app/medis-gui-for-redis/id1063631769)!\n\nMedis is an open-sourced, beautiful, easy-to-use Redis GUI management application.\n\nMedis starts with all the basic features you need:\n\n* Keys viewing/editing\n* SSH Tunnel for connecting with remote servers\n* Terminal for executing custom commands\n* JSON/MessagePack format viewing/editing and built-in highlighting/validator\n* And other awesome features...\n\n[Medis is open sourced on GitHub](https://github.com/luin/medis)\n\n<hr>\n\n# Quick Start\n\n## Install\n```shell\n$ npm install ioredis\n```\n\n## Basic Usage\n\n```javascript\nvar Redis = require('ioredis');\nvar redis = new Redis();\n\nredis.set('foo', 'bar');\nredis.get('foo', function (err, result) {\n  console.log(result);\n});\n\n// Or using a promise if the last argument isn't a function\nredis.get('foo').then(function (result) {\n  console.log(result);\n});\n\n// Arguments to commands are flattened, so the following are the same:\nredis.sadd('set', 1, 3, 5, 7);\nredis.sadd('set', [1, 3, 5, 7]);\n\n// All arguments are passed directly to the redis server:\nredis.set('key', 100, 'EX', 10);\n```\n\nSee the `examples/` folder for more examples.\n\n## Connect to Redis\nWhen a new `Redis` instance is created,\na connection to Redis will be created at the same time.\nYou can specify which Redis to connect to by:\n\n```javascript\nnew Redis()       // Connect to 127.0.0.1:6379\nnew Redis(6380)   // 127.0.0.1:6380\nnew Redis(6379, '192.168.1.1')        // 192.168.1.1:6379\nnew Redis('/tmp/redis.sock')\nnew Redis({\n  port: 6379,          // Redis port\n  host: '127.0.0.1',   // Redis host\n  family: 4,           // 4 (IPv4) or 6 (IPv6)\n  password: 'auth',\n  db: 0\n})\n```\n\nYou can also specify connection options as a [`redis://` URL](http://www.iana.org/assignments/uri-schemes/prov/redis):\n\n```javascript\n// Connect to 127.0.0.1:6380, db 4, using password \"authpassword\":\nnew Redis('redis://:authpassword@127.0.0.1:6380/4')\n```\n\nSee [API Documentation](API.md#new_Redis) for all available options.\n\n## Pub/Sub\n\nHere is a simple example of the API for publish/subscribe.\nThe following program opens two client connections.\nIt subscribes to a channel with one connection\nand publishes to that channel with the other:\n\n```javascript\nvar Redis = require('ioredis');\nvar redis = new Redis();\nvar pub = new Redis();\nredis.subscribe('news', 'music', function (err, count) {\n  // Now we are subscribed to both the 'news' and 'music' channels.\n  // `count` represents the number of channels we are currently subscribed to.\n\n  pub.publish('news', 'Hello world!');\n  pub.publish('music', 'Hello again!');\n});\n\nredis.on('message', function (channel, message) {\n  // Receive message Hello world! from channel news\n  // Receive message Hello again! from channel music\n  console.log('Receive message %s from channel %s', message, channel);\n});\n\n// There's also an event called 'messageBuffer', which is the same as 'message' except\n// it returns buffers instead of strings.\nredis.on('messageBuffer', function (channel, message) {\n  // Both `channel` and `message` are buffers.\n});\n```\n\n`PSUBSCRIBE` is also supported in a similar way:\n\n```javascript\nredis.psubscribe('pat?ern', function (err, count) {});\nredis.on('pmessage', function (pattern, channel, message) {});\nredis.on('pmessageBuffer', function (pattern, channel, message) {});\n```\n\nWhen a client issues a SUBSCRIBE or PSUBSCRIBE, that connection is put into a \"subscriber\" mode.\nAt that point, only commands that modify the subscription set are valid.\nWhen the subscription set is empty, the connection is put back into regular mode.\n\nIf you need to send regular commands to Redis while in subscriber mode, just open another connection.\n\n## Handle Binary Data\nArguments can be buffers:\n```javascript\nredis.set('foo', Buffer.from('bar'));\n```\n\nAnd every command has a method that returns a Buffer (by adding a suffix of \"Buffer\" to the command name).\nTo get a buffer instead of a utf8 string:\n\n```javascript\nredis.getBuffer('foo', function (err, result) {\n  // result is a buffer.\n});\n```\n\n## Pipelining\nIf you want to send a batch of commands (e.g. > 5), you can use pipelining to queue\nthe commands in memory and then send them to Redis all at once. This way the performance improves by 50%~300% (See [benchmark section](#benchmark)).\n\n`redis.pipeline()` creates a `Pipeline` instance. You can call any Redis\ncommands on it just like the `Redis` instance. The commands are queued in memory\nand flushed to Redis by calling the `exec` method:\n\n```javascript\nvar pipeline = redis.pipeline();\npipeline.set('foo', 'bar');\npipeline.del('cc');\npipeline.exec(function (err, results) {\n  // `err` is always null, and `results` is an array of responses\n  // corresponding to the sequence of queued commands.\n  // Each response follows the format `[err, result]`.\n});\n\n// You can even chain the commands:\nredis.pipeline().set('foo', 'bar').del('cc').exec(function (err, results) {\n});\n\n// `exec` also returns a Promise:\nvar promise = redis.pipeline().set('foo', 'bar').get('foo').exec();\npromise.then(function (result) {\n  // result === [[null, 'OK'], [null, 'bar']]\n});\n```\n\nEach chained command can also have a callback, which will be invoked when the command\ngets a reply:\n\n```javascript\nredis.pipeline().set('foo', 'bar').get('foo', function (err, result) {\n  // result === 'bar'\n}).exec(function (err, result) {\n  // result[1][1] === 'bar'\n});\n```\n\nIn addition to adding commands to the `pipeline` queue individually, you can also pass an array of commands and arguments to the constructor:\n\n```javascript\nredis.pipeline([\n  ['set', 'foo', 'bar'],\n  ['get', 'foo']\n]).exec(function () { /* ... */ });\n```\n\n`#length` property shows how many commands in the pipeline:\n\n```javascript\nconst length = redis.pipeline().set('foo', 'bar').get('foo').length;\n// length === 2\n```\n\n\n## Transaction\nMost of the time, the transaction commands `multi` & `exec` are used together with pipeline.\nTherefore, when `multi` is called, a `Pipeline` instance is created automatically by default,\nso you can use `multi` just like `pipeline`:\n\n```javascript\nredis.multi().set('foo', 'bar').get('foo').exec(function (err, results) {\n  // results === [[null, 'OK'], [null, 'bar']]\n});\n```\nIf there's a syntax error in the transaction's command chain (e.g. wrong number of arguments, wrong command name, etc),\nthen none of the commands would be executed, and an error is returned:\n\n```javascript\nredis.multi().set('foo').set('foo', 'new value').exec(function (err, results) {\n  // err:\n  //  { [ReplyError: EXECABORT Transaction discarded because of previous errors.]\n  //    name: 'ReplyError',\n  //    message: 'EXECABORT Transaction discarded because of previous errors.',\n  //    command: { name: 'exec', args: [] },\n  //    previousErrors:\n  //     [ { [ReplyError: ERR wrong number of arguments for 'set' command]\n  //         name: 'ReplyError',\n  //         message: 'ERR wrong number of arguments for \\'set\\' command',\n  //         command: [Object] } ] }\n});\n```\n\nIn terms of the interface, `multi` differs from `pipeline` in that when specifying a callback\nto each chained command, the queueing state is passed to the callback instead of the result of the command:\n\n```javascript\nredis.multi().set('foo', 'bar', function (err, result) {\n  // result === 'QUEUED'\n}).exec(/* ... */);\n```\n\nIf you want to use transaction without pipeline, pass `{ pipeline: false }` to `multi`,\nand every command will be sent to Redis immediately without waiting for an `exec` invocation:\n\n```javascript\nredis.multi({ pipeline: false });\nredis.set('foo', 'bar');\nredis.get('foo');\nredis.exec(function (err, result) {\n  // result === [[null, 'OK'], [null, 'bar']]\n});\n```\n\nThe constructor of `multi` also accepts a batch of commands:\n\n```javascript\nredis.multi([\n  ['set', 'foo', 'bar'],\n  ['get', 'foo']\n]).exec(function () { /* ... */ });\n```\n\nInline transactions are supported by pipeline, which means you can group a subset of commands\nin the pipeline into a transaction:\n\n```javascript\nredis.pipeline().get('foo').multi().set('foo', 'bar').get('foo').exec().get('foo').exec();\n```\n\n## Lua Scripting\nioredis supports all of the scripting commands such as `EVAL`, `EVALSHA` and `SCRIPT`.\nHowever, it's tedious to use in real world scenarios since developers have to take\ncare of script caching and to detect when to use `EVAL` and when to use `EVALSHA`.\nioredis expose a `defineCommand` method to make scripting much easier to use:\n\n```javascript\nvar redis = new Redis();\n\n// This will define a command echo:\nredis.defineCommand('echo', {\n  numberOfKeys: 2,\n  lua: 'return {KEYS[1],KEYS[2],ARGV[1],ARGV[2]}'\n});\n\n// Now `echo` can be used just like any other ordinary command,\n// and ioredis will try to use `EVALSHA` internally when possible for better performance.\nredis.echo('k1', 'k2', 'a1', 'a2', function (err, result) {\n  // result === ['k1', 'k2', 'a1', 'a2']\n});\n\n// `echoBuffer` is also defined automatically to return buffers instead of strings:\nredis.echoBuffer('k1', 'k2', 'a1', 'a2', function (err, result) {\n  // result[0] equals to Buffer.from('k1');\n});\n\n// And of course it works with pipeline:\nredis.pipeline().set('foo', 'bar').echo('k1', 'k2', 'a1', 'a2').exec();\n```\n\nIf the number of keys can't be determined when defining a command, you can\nomit the `numberOfKeys` property and pass the number of keys as the first argument\nwhen you call the command:\n\n```javascript\nredis.defineCommand('echoDynamicKeyNumber', {\n  lua: 'return {KEYS[1],KEYS[2],ARGV[1],ARGV[2]}'\n});\n\n// Now you have to pass the number of keys as the first argument every time\n// you invoke the `echoDynamicKeyNumber` command:\nredis.echoDynamicKeyNumber(2, 'k1', 'k2', 'a1', 'a2', function (err, result) {\n  // result === ['k1', 'k2', 'a1', 'a2']\n});\n```\n\n## Transparent Key Prefixing\nThis feature allows you to specify a string that will automatically be prepended\nto all the keys in a command, which makes it easier to manage your key\nnamespaces.\n\n**Warning** This feature won't apply to commands like [KEYS](http://redis.io/commands/KEYS) and [SCAN](http://redis.io/commands/scan) that take patterns rather than actual keys([#239](https://github.com/luin/ioredis/issues/239)),\nand this feature also won't apply to the replies of commands even they are key names ([#325](https://github.com/luin/ioredis/issues/325)).\n\n```javascript\nvar fooRedis = new Redis({ keyPrefix: 'foo:' });\nfooRedis.set('bar', 'baz');  // Actually sends SET foo:bar baz\n\nfooRedis.defineCommand('echo', {\n  numberOfKeys: 2,\n  lua: 'return {KEYS[1],KEYS[2],ARGV[1],ARGV[2]}'\n});\n\n// Works well with pipelining/transaction\nfooRedis.pipeline()\n  // Sends SORT foo:list BY foo:weight_*->fieldname\n  .sort('list', 'BY', 'weight_*->fieldname')\n  // Supports custom commands\n  // Sends EVALSHA xxx foo:k1 foo:k2 a1 a2\n  .echo('k1', 'k2', 'a1', 'a2')\n  .exec()\n```\n\n## Transforming Arguments & Replies\nMost Redis commands take one or more Strings as arguments,\nand replies are sent back as a single String or an Array of Strings. However, sometimes\nyou may want something different. For instance, it would be more convenient if the `HGETALL`\ncommand returns a hash (e.g. `{ key: val1, key2: v2 }`) rather than an array of key values (e.g. `[key1, val1, key2, val2]`).\n\nioredis has a flexible system for transforming arguments and replies. There are two types\nof transformers, argument transformer and reply transformer:\n\n```javascript\nvar Redis = require('ioredis');\n\n// Here's the built-in argument transformer converting\n// hmset('key', { k1: 'v1', k2: 'v2' })\n// or\n// hmset('key', new Map([['k1', 'v1'], ['k2', 'v2']]))\n// into\n// hmset('key', 'k1', 'v1', 'k2', 'v2')\nRedis.Command.setArgumentTransformer('hmset', function (args) {\n  if (args.length === 2) {\n    if (typeof Map !== 'undefined' && args[1] instanceof Map) {\n      // utils is a internal module of ioredis\n      return [args[0]].concat(utils.convertMapToArray(args[1]));\n    }\n    if ( typeof args[1] === 'object' && args[1] !== null) {\n      return [args[0]].concat(utils.convertObjectToArray(args[1]));\n    }\n  }\n  return args;\n});\n\n// Here's the built-in reply transformer converting the HGETALL reply\n// ['k1', 'v1', 'k2', 'v2']\n// into\n// { k1: 'v1', 'k2': 'v2' }\nRedis.Command.setReplyTransformer('hgetall', function (result) {\n  if (Array.isArray(result)) {\n    var obj = {};\n    for (var i = 0; i < result.length; i += 2) {\n      obj[result[i]] = result[i + 1];\n    }\n    return obj;\n  }\n  return result;\n});\n```\n\nThere are three built-in transformers, two argument transformers for `hmset` & `mset` and\na reply transformer for `hgetall`. Transformers for `hmset` and `hgetall` were mentioned\nabove, and the transformer for `mset` is similar to the one for `hmset`:\n\n```javascript\nredis.mset({ k1: 'v1', k2: 'v2' });\nredis.get('k1', function (err, result) {\n  // result === 'v1';\n});\n\nredis.mset(new Map([['k3', 'v3'], ['k4', 'v4']]));\nredis.get('k3', function (err, result) {\n  // result === 'v3';\n});\n```\n\nAnother useful example of a reply transformer is one that changes `hgetall` to return array of arrays instead of objects which avoids a unwanted conversation of hash keys to strings when dealing with binary hash keys:\n\n```javascript\nRedis.Command.setReplyTransformer('hgetall', function (result) {\n  var arr = [];\n  for (var i = 0; i < result.length; i += 2) {\n    arr.push([result[i], result[i + 1]]);\n  }\n  return arr;\n});\nredis.hset('h1', Buffer.from([0x01]), Buffer.from([0x02]));\nredis.hset('h1', Buffer.from([0x03]), Buffer.from([0x04]));\nredis.hgetallBuffer('h1', function (err, result) {\n  // result === [ [ <Buffer 01>, <Buffer 02> ], [ <Buffer 03>, <Buffer 04> ] ];\n});\n```\n\n## Monitor\nRedis supports the MONITOR command,\nwhich lets you see all commands received by the Redis server across all client connections,\nincluding from other client libraries and other computers.\n\nThe `monitor` method returns a monitor instance.\nAfter you send the MONITOR command, no other commands are valid on that connection. ioredis will emit a monitor event for every new monitor message that comes across.\nThe callback for the monitor event takes a timestamp from the Redis server and an array of command arguments.\n\nHere is a simple example:\n\n```javascript\nredis.monitor(function (err, monitor) {\n  monitor.on('monitor', function (time, args, source, database) {\n  });\n});\n```\n\n## Streamify Scanning\nRedis 2.8 added the `SCAN` command to incrementally iterate through the keys in the database. It's different from `KEYS` in that\n`SCAN` only returns a small number of elements each call, so it can be used in production without the downside\nof blocking the server for a long time. However, it requires recording the cursor on the client side each time\nthe `SCAN` command is called in order to iterate through all the keys correctly. Since it's a relatively common use case, ioredis\nprovides a streaming interface for the `SCAN` command to make things much easier. A readable stream can be created by calling `scanStream`:\n\n```javascript\nvar redis = new Redis();\n// Create a readable stream (object mode)\nvar stream = redis.scanStream();\nstream.on('data', function (resultKeys) {\n  // `resultKeys` is an array of strings representing key names.\n  // Note that resultKeys may contain 0 keys, and that it will sometimes\n  // contain duplicates due to SCAN's implementation in Redis.\n  for (var i = 0; i < resultKeys.length; i++) {\n    console.log(resultKeys[i]);\n  }\n});\nstream.on('end', function () {\n  console.log('all keys have been visited');\n});\n```\n\n`scanStream` accepts an option, with which you can specify the `MATCH` pattern and the `COUNT` argument:\n\n```javascript\nvar stream = redis.scanStream({\n  // only returns keys following the pattern of `user:*`\n  match: 'user:*',\n  // returns approximately 100 elements per call\n  count: 100\n});\n```\n\nJust like other commands, `scanStream` has a binary version `scanBufferStream`, which returns an array of buffers. It's useful when\nthe key names are not utf8 strings.\n\nThere are also `hscanStream`, `zscanStream` and `sscanStream` to iterate through elements in a hash, zset and set. The interface of each is\nsimilar to `scanStream` except the first argument is the key name:\n\n```javascript\nvar stream = redis.hscanStream('myhash', {\n  match: 'age:??'\n});\n```\n\nYou can learn more from the [Redis documentation](http://redis.io/commands/scan).\n\n**Useful Tips**\nIt's pretty common that doing an async task in the `data` handler. We'd like the scanning process to be paused until the async task to be finished. `Stream#pause()` and `Stream.resume()` do the trick. For example if we want to migrate data in Redis to MySQL:\n\n```javascript\nvar stream = redis.scanStream();\nstream.on('data', function (resultKeys) {\n  // Pause the stream from scanning more keys until we've migrated the current keys.\n  stream.pause();\n\n  Promise.all(resultKeys.map(migrateKeyToMySQL)).then(() => {\n    // Resume the stream here.\n    stream.resume();\n  });\n});\n\nstream.on('end', function () {\n  console.log('done migration');\n});\n```\n\n## Auto-reconnect\nBy default, ioredis will try to reconnect when the connection to Redis is lost\nexcept when the connection is closed manually by `redis.disconnect()` or `redis.quit()`.\n\nIt's very flexible to control how long to wait to reconnect after disconnection\nusing the `retryStrategy` option:\n\n```javascript\nvar redis = new Redis({\n  // This is the default value of `retryStrategy`\n  retryStrategy: function (times) {\n    var delay = Math.min(times * 50, 2000);\n    return delay;\n  }\n});\n```\n\n`retryStrategy` is a function that will be called when the connection is lost.\nThe argument `times` means this is the nth reconnection being made and\nthe return value represents how long (in ms) to wait to reconnect. When the\nreturn value isn't a number, ioredis will stop trying to reconnect, and the connection\nwill be lost forever if the user doesn't call `redis.connect()` manually.\n\nWhen reconnected, the client will auto subscribe to channels that the previous connection subscribed to.\nThis behavior can be disabled by setting the `autoResubscribe` option to `false`.\n\nAnd if the previous connection has some unfulfilled commands (most likely blocking commands such as `brpop` and `blpop`),\nthe client will resend them when reconnected. This behavior can be disabled by setting the `autoResendUnfulfilledCommands` option to `false`.\n\nBy default, all pending commands will be flushed with an error every 20 retry attempts. That makes sure commands won't wait forever when the connection is down. You can change this behavior by setting `maxRetriesPerRequest`:\n\n```javascript\nvar redis = new Redis({\n  maxRetriesPerRequest: 1\n});\n```\n\nSet maxRetriesPerRequest to `null` to disable this behavior, and every command will wait forever until the connection is alive again (which is the default behavior before ioredis v4).\n\n### Reconnect on error\n\nBesides auto-reconnect when the connection is closed, ioredis supports reconnecting on the specified errors by the `reconnectOnError` option. Here's an example that will reconnect when receiving `READONLY` error:\n\n```javascript\nvar redis = new Redis({\n  reconnectOnError: function (err) {\n    var targetError = 'READONLY';\n    if (err.message.slice(0, targetError.length) === targetError) {\n      // Only reconnect when the error starts with \"READONLY\"\n      return true; // or `return 1;`\n    }\n  }\n});\n```\n\nThis feature is useful when using Amazon ElastiCache. Once failover happens, Amazon ElastiCache will switch the master we currently connected with to a slave, leading to the following writes fails with the error `READONLY`. Using `reconnectOnError`, we can force the connection to reconnect on this error in order to connect to the new master.\n\nFurthermore, if the `reconnectOnError` returns `2`, ioredis will resend the failed command after reconnecting.\n\n## Connection Events\nThe Redis instance will emit some events about the state of the connection to the Redis server.\n\nEvent    | Description\n:------------- | :-------------\nconnect  | emits when a connection is established to the Redis server.\nready    | If `enableReadyCheck` is `true`, client will emit `ready` when the server reports that it is ready to receive commands (e.g. finish loading data from disk).<br>Otherwise, `ready` will be emitted immediately right after the `connect` event.\nerror    | emits when an error occurs while connecting.<br>However, ioredis emits all `error` events silently (only emits when there's at least one listener) so that your application won't crash if you're not listening to the `error` event.\nclose    | emits when an established Redis server connection has closed.\nreconnecting | emits after `close` when a reconnection will be made. The argument of the event is the time (in ms) before reconnecting.\nend     | emits after `close` when no more reconnections will be made, or the connection is failed to establish.\n\nYou can also check out the `Redis#status` property to get the current connection status.\n\nBesides the above connection events, there are several other custom events:\n\nEvent    | Description\n:------------- | :-------------\nselect   | emits when the database changed. The argument is the new db number.\n\n## Offline Queue\nWhen a command can't be processed by Redis (being sent before the `ready` event), by default, it's added to the offline queue and will be\nexecuted when it can be processed. You can disable this feature by setting the `enableOfflineQueue`\noption to `false`:\n\n```javascript\nvar redis = new Redis({ enableOfflineQueue: false });\n```\n\n## TLS Options\nRedis doesn't support TLS natively, however if the redis server you want to connect to is hosted behind a TLS proxy (e.g. [stunnel](https://www.stunnel.org/)) or is offered by a PaaS service that supports TLS connection (e.g. [Redis Labs](https://redislabs.com/)), you can set the `tls` option:\n\n```javascript\nvar redis = new Redis({\n  host: 'localhost',\n  tls: {\n    // Refer to `tls.connect()` section in\n    // https://nodejs.org/api/tls.html\n    // for all supported options\n    ca: fs.readFileSync('cert.pem')\n  }\n});\n```\n\n<hr>\n\n## Sentinel\nioredis supports Sentinel out of the box. It works transparently as all features that work when\nyou connect to a single node also work when you connect to a sentinel group. Make sure to run Redis >= 2.8.12 if you want to use this feature. Sentinels have a default port of 26379.\n\nTo connect using Sentinel, use:\n\n```javascript\nvar redis = new Redis({\n  sentinels: [{ host: 'localhost', port: 26379 }, { host: 'localhost', port: 26380 }],\n  name: 'mymaster'\n});\n\nredis.set('foo', 'bar');\n```\n\nThe arguments passed to the constructor are different from the ones you use to connect to a single node, where:\n\n* `name` identifies a group of Redis instances composed of a master and one or more slaves (`mymaster` in the example);\n* `sentinels` are a list of sentinels to connect to. The list does not need to enumerate all your sentinel instances, but a few so that if one is down the client will try the next one.\n* `role` (optional) with a value of `slave` will return a random slave from the Sentinel group.\n* `preferredSlaves` (optional) can be used to prefer a particular slave or set of slaves based on priority. It accepts a function or array.\n\nioredis **guarantees** that the node you connected to is always a master even after a failover. When a failover happens, instead of trying to reconnect to the failed node (which will be demoted to slave when it's available again), ioredis will ask sentinels for the new master node and connect to it. All commands sent during the failover are queued and will be executed when the new connection is established so that none of the commands will be lost.\n\nIt's possible to connect to a slave instead of a master by specifying the option `role` with the value of `slave` and ioredis will try to connect to a random slave of the specified master, with the guarantee that the connected node is always a slave. If the current node is promoted to master due to a failover, ioredis will disconnect from it and ask the sentinels for another slave node to connect to.\n\nIf you specify the option `preferredSlaves` along with `role: 'slave'` ioredis will attempt to use this value when selecting the slave from the pool of available slaves. The value of `preferredSlaves` should either be a function that accepts an array of avaiable slaves and returns a single result, or an array of slave values priorities by the lowest `prio` value first with a default value of `1`.\n\n```javascript\n// available slaves format\nvar availableSlaves = [{ ip: '127.0.0.1', port: '31231', flags: 'slave' }];\n\n// preferredSlaves array format\nvar preferredSlaves = [\n  { ip: '127.0.0.1', port: '31231', prio: 1 },\n  { ip: '127.0.0.1', port: '31232', prio: 2 }\n];\n\n// preferredSlaves function format\npreferredSlaves = function(availableSlaves) {\n  for (var i = 0; i < availableSlaves.length; i++) {\n    var slave = availableSlaves[i];\n    if (slave.ip === '127.0.0.1') {\n      if (slave.port === '31234') {\n        return slave;\n      }\n    }\n  }\n  // if no preferred slaves are available a random one is used\n  return false;\n};\n\nvar redis = new Redis({\n  sentinels: [{ host: '127.0.0.1', port: 26379 }, { host: '127.0.0.1', port: 26380 }],\n  name: 'mymaster',\n  role: 'slave',\n  preferredSlaves: preferredSlaves\n});\n```\n\nBesides the `retryStrategy` option, there's also a `sentinelRetryStrategy` in Sentinel mode which will be invoked when all the sentinel nodes are unreachable during connecting. If `sentinelRetryStrategy` returns a valid delay time, ioredis will try to reconnect from scratch. The default value of `sentinelRetryStrategy` is:\n\n```javascript\nfunction (times) {\n  var delay = Math.min(times * 10, 1000);\n  return delay;\n}\n```\n\n## Cluster\nRedis Cluster provides a way to run a Redis installation where data is automatically sharded across multiple Redis nodes.\nYou can connect to a Redis Cluster like this:\n\n```javascript\nvar Redis = require('ioredis');\n\nvar cluster = new Redis.Cluster([{\n  port: 6380,\n  host: '127.0.0.1'\n}, {\n  port: 6381,\n  host: '127.0.0.1'\n}]);\n\ncluster.set('foo', 'bar');\ncluster.get('foo', function (err, res) {\n  // res === 'bar'\n});\n```\n\n`Cluster` constructor accepts two arguments, where:\n\n0. The first argument is a list of nodes of the cluster you want to connect to.\nJust like Sentinel, the list does not need to enumerate all your cluster nodes,\nbut a few so that if one is unreachable the client will try the next one, and the client will discover other nodes automatically when at least one node is connected.\n0. The second argument is the options, where:\n\n    * `clusterRetryStrategy`: When none of the startup nodes are reachable, `clusterRetryStrategy` will be invoked. When a number is returned,\n    ioredis will try to reconnect to the startup nodes from scratch after the specified delay (in ms). Otherwise, an error of \"None of startup nodes is available\" will be returned.\n    The default value of this option is:\n\n        ```javascript\n        function (times) {\n          var delay = Math.min(100 + times * 2, 2000);\n          return delay;\n        }\n        ```\n\n        It's possible to modify the `startupNodes` property in order to switch to another set of nodes here:\n\n        ```javascript\n        function (times) {\n          this.startupNodes = [{ port: 6790, host: '127.0.0.1' }];\n          return Math.min(100 + times * 2, 2000);\n        }\n        ```\n\n    * `enableOfflineQueue`: Similar to the `enableOfflineQueue` option of `Redis` class.\n    * `enableReadyCheck`: When enabled, \"ready\" event will only be emitted when `CLUSTER INFO` command\n    reporting the cluster is ready for handling commands. Otherwise, it will be emitted immediately after \"connect\" is emitted.\n    * `scaleReads`: Config where to send the read queries. See below for more details.\n    * `maxRedirections`: When a cluster related error (e.g. `MOVED`, `ASK` and `CLUSTERDOWN` etc.) is received, the client will redirect the\n    command to another node. This option limits the max redirections allowed when sending a command. The default value is `16`.\n    * `retryDelayOnFailover`: If the target node is disconnected when sending a command,\n    ioredis will retry after the specified delay. The default value is `100`. You should make sure `retryDelayOnFailover * maxRedirections > cluster-node-timeout`\n    to insure that no command will fail during a failover.\n    * `retryDelayOnClusterDown`: When a cluster is down, all commands will be rejected with the error of `CLUSTERDOWN`. If this option is a number (by default, it is `100`), the client\n    will resend the commands after the specified time (in ms).\n    * `retryDelayOnTryAgain`: If this option is a number (by default, it is `100`), the client\n    will resend the commands rejected with `TRYAGAIN` error after the specified time (in ms).\n    * `redisOptions`: Default options passed to the constructor of `Redis` when connecting to a node.\n    * `slotsRefreshTimeout`: Milliseconds before a timeout occurs while refreshing slots from the cluster (default `1000`)\n    * `slotsRefreshInterval`: Milliseconds between every automatic slots refresh (default `5000`)\n\n### Read-write splitting\n\nA typical redis cluster contains three or more masters and several slaves for each master. It's possible to scale out redis cluster by sending read queries to slaves and write queries to masters by setting the `scaleReads` option.\n\n`scaleReads` is \"master\" by default, which means ioredis will never send any queries to slaves. There are other three available options:\n\n1. \"all\": Send write queries to masters and read queries to masters or slaves randomly.\n2. \"slave\": Send write queries to masters and read queries to slaves.\n3. a custom `function(nodes, command): node`: Will choose the custom function to select to which node to send read queries (write queries keep being sent to master). The first node in `nodes` is always the master serving the relevant slots. If the function returns an array of nodes, a random node of that list will be selected.\n\nFor example:\n\n```javascript\nvar cluster = new Redis.Cluster([/* nodes */], {\n  scaleReads: 'slave'\n});\ncluster.set('foo', 'bar'); // This query will be sent to one of the masters.\ncluster.get('foo', function (err, res) {\n  // This query will be sent to one of the slaves.\n});\n```\n\n**NB** In the code snippet above, the `res` may not be equal to \"bar\" because of the lag of replication between the master and slaves.\n\n### Running commands to multiple nodes\n\nEvery command will be sent to exactly one node. For commands containing keys, (e.g. `GET`, `SET` and `HGETALL`), ioredis sends them to the node that serving the keys, and for other commands not containing keys, (e.g. `INFO`, `KEYS` and `FLUSHDB`), ioredis sends them to a random node.\n\nSometimes you may want to send a command to multiple nodes (masters or slaves) of the cluster, you can get the nodes via `Cluster#nodes()` method.\n\n`Cluster#nodes()` accepts a parameter role, which can be \"master\", \"slave\" and \"all\" (default), and returns an array of `Redis` instance. For example:\n\n```javascript\n// Send `FLUSHDB` command to all slaves:\nvar slaves = cluster.nodes('slave');\nPromise.all(slaves.map(function (node) {\n  return node.flushdb();\n}));\n\n// Get keys of all the masters:\nvar masters = cluster.nodes('master');\nPromise.all(masters.map(function (node) {\n  return node.keys();\n})).then(function (keys) {\n  // keys: [['key1', 'key2'], ['key3', 'key4']]\n});\n```\n\n### Transaction and pipeline in Cluster mode\nAlmost all features that are supported by `Redis` are also supported by `Redis.Cluster`, e.g. custom commands, transaction and pipeline.\nHowever there are some differences when using transaction and pipeline in Cluster mode:\n\n0. All keys in a pipeline should belong to the same slot since ioredis sends all commands in a pipeline to the same node.\n0. You can't use `multi` without pipeline (aka `cluster.multi({ pipeline: false })`). This is because when you call `cluster.multi({ pipeline: false })`, ioredis doesn't know which node the `multi` command should be sent to.\n0. Chaining custom commands in the pipeline is not supported in Cluster mode.\n\nWhen any commands in a pipeline receives a `MOVED` or `ASK` error, ioredis will resend the whole pipeline to the specified node automatically if all of the following conditions are satisfied:\n\n0. All errors received in the pipeline are the same. For example, we won't resend the pipeline if we got two `MOVED` errors pointing to different nodes.\n0. All commands executed successfully are readonly commands. This makes sure that resending the pipeline won't have side effects.\n\n### Pub/Sub\nPub/Sub in cluster mode works exactly as the same as in standalone mode. Internally, when a node of the cluster receives a message, it will broadcast the message to the other nodes. ioredis makes sure that each message will only be received once by strictly subscribing one node at the same time.\n\n```javascript\nvar nodes = [/* nodes */];\nvar pub = new Redis.Cluster(nodes);\nvar sub = new Redis.Cluster(nodes);\nsub.on('message', function (channel, message) {\n  console.log(channel, message);\n});\n\nsub.subscribe('news', function () {\n  pub.publish('news', 'highlights');\n});\n```\n\n### Events\n\nEvent    | Description\n:------------- | :-------------\nconnect  | emits when a connection is established to the Redis server.\nready    | emits when `CLUSTER INFO` reporting the cluster is able to receive commands (if `enableReadyCheck` is `true`) or immediately after `connect` event (if `enableReadyCheck` is false).\nerror    | emits when an error occurs while connecting with a property of `lastNodeError` representing the last node error received. This event is emitted silently (only emitting if there's at least one listener).\nclose    | emits when an established Redis server connection has closed.\nreconnecting | emits after `close` when a reconnection will be made. The argument of the event is the time (in ms) before reconnecting.\nend     | emits after `close` when no more reconnections will be made.\n+node   | emits when a new node is connected.\n-node   | emits when a node is disconnected.\nnode error | emits when an error occurs when connecting to a node\n\n### Password\nSetting the `password` option to access password-proctected clusters:\n\n```javascript\nvar Redis = require('ioredis');\nvar cluster = new Redis.Cluster(nodes, {\n  redisOptions: {\n    password: 'your-cluster-password'\n  }\n});\n```\n\nIf some of nodes in the cluster using a different password, you should specify them in the first parameter:\n\n```javascript\nvar Redis = require('ioredis');\nvar cluster = new Redis.Cluster([\n  // Use password \"password-for-30001\" for 30001\n  { port: 30001, password: 'password-for-30001'},\n  // Don't use password when accessing 30002\n  { port: 30002, password: null }\n  // Other nodes will use \"fallback-password\"\n], {\n  redisOptions: {\n    password: 'fallback-password'\n  }\n});\n```\n\n<hr>\n\n# Error Handling\nAll the errors returned by the Redis server are instances of `ReplyError`, which can be accessed via `Redis`:\n\n```javascript\nvar Redis = require('ioredis');\nvar redis = new Redis();\n// This command causes a reply error since the SET command requires two arguments.\nredis.set('foo', function (err) {\n  err instanceof Redis.ReplyError\n});\n```\n\nThis is the error stack of the `ReplyError`:\n\n```\nReplyError: ERR wrong number of arguments for 'set' command\n    at ReplyParser._parseResult (/app/node_modules/ioredis/lib/parsers/javascript.js:60:14)\n    at ReplyParser.execute (/app/node_modules/ioredis/lib/parsers/javascript.js:178:20)\n    at Socket.<anonymous> (/app/node_modules/ioredis/lib/redis/event_handler.js:99:22)\n    at Socket.emit (events.js:97:17)\n    at readableAddChunk (_stream_readable.js:143:16)\n    at Socket.Readable.push (_stream_readable.js:106:10)\n    at TCP.onread (net.js:509:20)\n```\n\nBy default, the error stack doesn't make any sense because the whole stack happens in the ioredis\nmodule itself, not in your code. So it's not easy to find out where the error happens in your code.\nioredis provides an option `showFriendlyErrorStack` to solve the problem. When you enable\n`showFriendlyErrorStack`, ioredis will optimize the error stack for you:\n\n```javascript\nvar Redis = require('ioredis');\nvar redis = new Redis({ showFriendlyErrorStack: true });\nredis.set('foo');\n```\n\nAnd the output will be:\n\n```\nReplyError: ERR wrong number of arguments for 'set' command\n    at Object.<anonymous> (/app/index.js:3:7)\n    at Module._compile (module.js:446:26)\n    at Object.Module._extensions..js (module.js:464:10)\n    at Module.load (module.js:341:32)\n    at Function.Module._load (module.js:296:12)\n    at Function.Module.runMain (module.js:487:10)\n    at startup (node.js:111:16)\n    at node.js:799:3\n```\n\nThis time the stack tells you that the error happens on the third line in your code. Pretty sweet!\nHowever, it would decrease the performance significantly to optimize the error stack. So by\ndefault, this option is disabled and can only be used for debugging purposes. You **shouldn't** use this feature in a production environment.\n\n# Plugging in your own Promises Library\nIf you're an advanced user, you may want to plug in your own promise library like [bluebird](https://www.npmjs.com/package/bluebird). Just set Redis.Promise to your favorite ES6-style promise constructor and ioredis will use it.\n\n```javascript\nconst Redis = require('ioredis')\nRedis.Promise = require('bluebird')\n\nconst redis = new Redis()\n\n// Use bluebird\nassert.equal(redis.get().constructor, require('bluebird'))\n\n// You can change the Promise implementation at any time:\nRedis.Promise = global.Promise\nassert.equal(redis.get().constructor, global.Promise)\n```\n\n\n# Running tests\n\nStart a Redis server on 127.0.0.1:6379, and then:\n\n```shell\n$ npm test\n```\n\n`FLUSH ALL` will be invoked after each test, so make sure there's no valuable data in it before running tests.\n\nIf your testing environment does not let you spin up a Redis server [ioredis-mock](https://github.com/stipsan/ioredis-mock) is a drop-in replacement you can use in your tests. It aims to behave identically to ioredis connected to a Redis server so that your integration tests is easier to write and of better quality.\n\n# Debug\n\nYou can set the `DEBUG` env to `ioredis:*` to print debug info:\n\n```shell\n$ DEBUG=ioredis:* node app.js\n```\n\n# Consolidation: It's time for celebration\n\nRight now there are two great redis clients around and both have some advantages above each other. We speak about [node_redis](https://github.com/NodeRedis/node_redis) and ioredis. So after talking to each other about how we could improve in working together we (that is [@BridgeAR](https://github.com/BridgeAR) and [@luin](https://github.com/luin)) decided to work towards a single library on the long run. But step by step.\n\nFirst of all, we want to split small parts of our libraries into others so that we're both able to use the same code. Those libraries are going to be maintained under the NodeRedis organization. This is going to reduce the maintance overhead, allows others to use the very same code, if they need it and it's way easier for others to contribute to both libraries.\n\nWe're very happy about this step towards working together as we both want to give you the best redis experience possible.\n\nIf you want to join our cause by help maintaining something, please don't hesitate to contact either one of us.\n\n# Join in!\n\nI'm happy to receive bug reports, fixes, documentation enhancements, and any other improvements.\n\nAnd since I'm not a native English speaker, if you find any grammar mistakes in the documentation, please also let me know. :)\n\n# Contributors\n\nThis project exists thanks to all the people who contribute:\n\n<a href=\"https://github.com/luin/ioredis/graphs/contributors\"><img src=\"https://opencollective.com/ioredis/contributors.svg?width=890&showBtn=false\" /></a>\n\n# License\n\nMIT\n","readmeFilename":"README.md","bugs":{"url":"https://github.com/luin/ioredis/issues"},"homepage":"https://github.com/luin/ioredis#readme","_id":"ioredis@4.2.2","_npmVersion":"6.4.1","_nodeVersion":"10.12.0","_npmUser":{"name":"ioredis-robot","email":"ioredis-robot@zihua.li"},"dist":{"integrity":"sha512-Aa5hEZBKBe8/HvtOOLAfRFWg3TeVFtOB4WAAn630BPrNkxCljVaCuTzYd5xgYDO+PFpZkHZIJOlkXDKPd7eg0g==","shasum":"0c464bf460cd0d9f0ede3624e1de2b56cac10363","tarball":"https://registry.npmjs.org/ioredis/-/ioredis-4.2.2.tgz","fileCount":35,"unpackedSize":212680,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJbyraACRA9TVsSAnZWagAA3f0P/AyXP4xGv3kwyEUiYLuY\nIFIOe+dmwcqrMckgaGuwQ9DJgv+INeOTtmzPq2pFwAbpDHmx9Yb3v84BVUBA\nTZQu0PDAox7y4nio6KYMayrw1wSdi8lx8wXIvzf7FFPv+BiW1/ud2kzlcqmm\nS6U8h5k1umE0FfGJkGEtAO3Vkc4CwnFd+oB+hGDvONBWUR9XOTqZDuEi1VXw\nfrKwy96P3CMRxu7PUYOHFyYXjn2UqEisk0c81ZLpZmw+w9xBXBKTW5mjQa3o\nIzLsWV/XzczEnEOC8I5FFsFocR7jtobRtuiG+53VLKSfx19RKTVmTlc6TNoi\n0LHDjkv7XrZ6Qw0ZPj1c7ju2LNHLg4MoThWKr2bkaAHIT8mjzLEC2VZaDDoH\njud6aBuvQ928QYbwgepjE5DkUcFzFBJzA+TfeZwuwLa0f5I8rK12emxpmh+w\n1cjOqO94+gbNDXkmXpiOzZSYv6SfYdS7JiPF8nWhSyVMTVqeIkNKPYfaFAqx\nNTpR0K0trW0BNyNOWecycHNzON9W1Sl2qG1vcdffKQsjgjYOZ/80hS0qdthG\niXktSz4vmJgmkVnZ30ne2lQY63CuAUesmqweKISaWQrHErgRr9Y87I/cjK7W\nUHlgbmLCRLjRx4XUGGjfQFyH0NiOJXc9Aoc+xo47aspDpCP8IMu12vd2AZoV\nsEfY\r\n=0o6s\r\n-----END PGP SIGNATURE-----\r\n"},"maintainers":[{"email":"ioredis-robot@zihua.li","name":"ioredis-robot"},{"email":"i@zihua.li","name":"luin"}],"directories":{},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/ioredis_4.2.2_1540011647189_0.41884090385162787"},"_hasShrinkwrap":false},"4.2.3":{"name":"ioredis","version":"4.2.3","description":"A robust, performance-focused and full-featured Redis client for Node.js.","main":"built/index.js","scripts":{"test":"NODE_ENV=test mocha --timeout 8000 -r ts-node/register --exit","test:cov":"NODE_ENV=test node ./node_modules/istanbul/lib/cli.js cover --preserve-comments ./node_modules/mocha/bin/_mocha -- -r ts-node/register -R spec --exit","build":"rm -rf built && tsc","generate-docs":"jsdoc2md lib/redis.js lib/cluster/index.js lib/commander.js > API.md","prepublishOnly":"npm run build && npm test","bench":"matcha benchmarks/*.js","semantic-release":"semantic-release"},"repository":{"type":"git","url":"git://github.com/luin/ioredis.git"},"keywords":["redis","cluster","sentinel","pipelining"],"author":{"name":"luin","email":"i@zihua.li","url":"http://zihua.li"},"license":"MIT","dependencies":{"cluster-key-slot":"^1.0.6","debug":"^3.1.0","denque":"^1.1.0","flexbuffer":"0.0.6","lodash.defaults":"^4.2.0","lodash.flatten":"^4.4.0","redis-commands":"1.4.0","redis-errors":"^1.2.0","redis-parser":"^3.0.0","standard-as-callback":"^1.0.0"},"devDependencies":{"@semantic-release/changelog":"^3.0.0","@semantic-release/git":"^7.0.4","@types/node":"^10.11.5","@types/redis-errors":"1.2.0","bluebird":"^3.5.1","chai":"^3.5.0","cz-conventional-changelog":"^2.0.0","istanbul":"^0.4.2","jsdoc":"^3.4.0","jsdoc-to-markdown":"^4.0.1","mocha":"^5.2.0","server-destroy":"^1.0.1","sinon":"^1.17.3","ts-node":"^7.0.0","typescript":"^3.1.1"},"engines":{"node":">=6"},"config":{"commitizen":{"path":"./node_modules/cz-conventional-changelog"}},"gitHead":"ab63994670209cc40533a26ec69813fcedd3f8d0","readme":"[![ioredis](https://cdn.rawgit.com/luin/ioredis/57b5b89e3e9111ff25d8c62c0bc58ed42e5b8d1e/logo.svg)](https://github.com/luin/ioredis)\n\n[![Build Status](https://travis-ci.org/luin/ioredis.svg?branch=master)](https://travis-ci.org/luin/ioredis)\n[![Test Coverage](https://codeclimate.com/github/luin/ioredis/badges/coverage.svg)](https://codeclimate.com/github/luin/ioredis)\n[![Join the chat at https://gitter.im/luin/ioredis](https://badges.gitter.im/Join%20Chat.svg)](https://gitter.im/luin/ioredis?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge)\n[![Commitizen friendly](https://img.shields.io/badge/commitizen-friendly-brightgreen.svg)](http://commitizen.github.io/cz-cli/)\n[![semantic-release](https://img.shields.io/badge/%20%20%F0%9F%93%A6%F0%9F%9A%80-semantic--release-e10079.svg)](https://github.com/semantic-release/semantic-release)\n[![npm latest version](https://img.shields.io/npm/v/ioredis/latest.svg)](https://www.npmjs.com/package/ioredis)\n[![npm next version](https://img.shields.io/npm/v/ioredis/next.svg)](https://www.npmjs.com/package/ioredis)\n<img alt=\"\" src=\"\">\n\nA robust, performance-focused and full-featured [Redis](http://redis.io) client for [Node.js](https://nodejs.org).\n\nSupports Redis >= 2.6.12 and (Node.js >= 6).\n\n# Features\nioredis is a robust, full-featured Redis client that is\nused in the world's biggest online commerce company [Alibaba](http://www.alibaba.com/) and many other awesome companies.\n\n0. Full-featured. It supports [Cluster](http://redis.io/topics/cluster-tutorial), [Sentinel](http://redis.io/topics/sentinel), [Pipelining](http://redis.io/topics/pipelining) and of course [Lua scripting](http://redis.io/commands/eval) & [Pub/Sub](http://redis.io/topics/pubsub) (with the support of binary messages).\n0. High performance.\n0. Delightful API. It works with Node callbacks and Native promises.\n0. Transformation of command arguments and replies.\n0. Transparent key prefixing.\n0. Abstraction for Lua scripting, allowing you to define custom commands.\n0. Support for binary data.\n0. Support for TLS.\n0. Support for offline queue and ready checking.\n0. Support for ES6 types, such as `Map` and `Set`.\n0. Support for GEO commands (Redis 3.2 Unstable).\n0. Sophisticated error handling strategy.\n\n# Links\n* [API Documentation](API.md)\n* [Changelog](Changelog.md)\n* [Migrating from node_redis](https://github.com/luin/ioredis/wiki/Migrating-from-node_redis)\n* [Error Handling](#error-handling)\n\n## Become a Sponsor to Support ioredis's Development\nOpen source is hard and time-consuming. If you want to invest in ioredis's future you can become a sponsor and make us spend more time on this library's improvements and new features.\n\n<a href=\"https://opencollective.com/ioredis\"><img src=\"https://opencollective.com/ioredis/tiers/sponsor.svg?avatarHeight=36\"></a>\n\nThank you for using ioredis :-)\n\n<hr>\n<a href=\"https://itunes.apple.com/app/medis-gui-for-redis/id1063631769\"><img align=\"right\" src=\"medis.png\" alt=\"Download on the App Store\"></a>\n\n\n### Advertisement\n\nLooking for a Redis GUI manager for OS X, Windows and Linux? Here's [Medis](https://itunes.apple.com/us/app/medis-gui-for-redis/id1063631769)!\n\nMedis is an open-sourced, beautiful, easy-to-use Redis GUI management application.\n\nMedis starts with all the basic features you need:\n\n* Keys viewing/editing\n* SSH Tunnel for connecting with remote servers\n* Terminal for executing custom commands\n* JSON/MessagePack format viewing/editing and built-in highlighting/validator\n* And other awesome features...\n\n[Medis is open sourced on GitHub](https://github.com/luin/medis)\n\n<hr>\n\n# Quick Start\n\n## Install\n```shell\n$ npm install ioredis\n```\n\n## Basic Usage\n\n```javascript\nvar Redis = require('ioredis');\nvar redis = new Redis();\n\nredis.set('foo', 'bar');\nredis.get('foo', function (err, result) {\n  console.log(result);\n});\n\n// Or using a promise if the last argument isn't a function\nredis.get('foo').then(function (result) {\n  console.log(result);\n});\n\n// Arguments to commands are flattened, so the following are the same:\nredis.sadd('set', 1, 3, 5, 7);\nredis.sadd('set', [1, 3, 5, 7]);\n\n// All arguments are passed directly to the redis server:\nredis.set('key', 100, 'EX', 10);\n```\n\nSee the `examples/` folder for more examples.\n\n## Connect to Redis\nWhen a new `Redis` instance is created,\na connection to Redis will be created at the same time.\nYou can specify which Redis to connect to by:\n\n```javascript\nnew Redis()       // Connect to 127.0.0.1:6379\nnew Redis(6380)   // 127.0.0.1:6380\nnew Redis(6379, '192.168.1.1')        // 192.168.1.1:6379\nnew Redis('/tmp/redis.sock')\nnew Redis({\n  port: 6379,          // Redis port\n  host: '127.0.0.1',   // Redis host\n  family: 4,           // 4 (IPv4) or 6 (IPv6)\n  password: 'auth',\n  db: 0\n})\n```\n\nYou can also specify connection options as a [`redis://` URL](http://www.iana.org/assignments/uri-schemes/prov/redis):\n\n```javascript\n// Connect to 127.0.0.1:6380, db 4, using password \"authpassword\":\nnew Redis('redis://:authpassword@127.0.0.1:6380/4')\n```\n\nSee [API Documentation](API.md#new_Redis) for all available options.\n\n## Pub/Sub\n\nHere is a simple example of the API for publish/subscribe.\nThe following program opens two client connections.\nIt subscribes to a channel with one connection\nand publishes to that channel with the other:\n\n```javascript\nvar Redis = require('ioredis');\nvar redis = new Redis();\nvar pub = new Redis();\nredis.subscribe('news', 'music', function (err, count) {\n  // Now we are subscribed to both the 'news' and 'music' channels.\n  // `count` represents the number of channels we are currently subscribed to.\n\n  pub.publish('news', 'Hello world!');\n  pub.publish('music', 'Hello again!');\n});\n\nredis.on('message', function (channel, message) {\n  // Receive message Hello world! from channel news\n  // Receive message Hello again! from channel music\n  console.log('Receive message %s from channel %s', message, channel);\n});\n\n// There's also an event called 'messageBuffer', which is the same as 'message' except\n// it returns buffers instead of strings.\nredis.on('messageBuffer', function (channel, message) {\n  // Both `channel` and `message` are buffers.\n});\n```\n\n`PSUBSCRIBE` is also supported in a similar way:\n\n```javascript\nredis.psubscribe('pat?ern', function (err, count) {});\nredis.on('pmessage', function (pattern, channel, message) {});\nredis.on('pmessageBuffer', function (pattern, channel, message) {});\n```\n\nWhen a client issues a SUBSCRIBE or PSUBSCRIBE, that connection is put into a \"subscriber\" mode.\nAt that point, only commands that modify the subscription set are valid.\nWhen the subscription set is empty, the connection is put back into regular mode.\n\nIf you need to send regular commands to Redis while in subscriber mode, just open another connection.\n\n## Handle Binary Data\nArguments can be buffers:\n```javascript\nredis.set('foo', Buffer.from('bar'));\n```\n\nAnd every command has a method that returns a Buffer (by adding a suffix of \"Buffer\" to the command name).\nTo get a buffer instead of a utf8 string:\n\n```javascript\nredis.getBuffer('foo', function (err, result) {\n  // result is a buffer.\n});\n```\n\n## Pipelining\nIf you want to send a batch of commands (e.g. > 5), you can use pipelining to queue\nthe commands in memory and then send them to Redis all at once. This way the performance improves by 50%~300% (See [benchmark section](#benchmark)).\n\n`redis.pipeline()` creates a `Pipeline` instance. You can call any Redis\ncommands on it just like the `Redis` instance. The commands are queued in memory\nand flushed to Redis by calling the `exec` method:\n\n```javascript\nvar pipeline = redis.pipeline();\npipeline.set('foo', 'bar');\npipeline.del('cc');\npipeline.exec(function (err, results) {\n  // `err` is always null, and `results` is an array of responses\n  // corresponding to the sequence of queued commands.\n  // Each response follows the format `[err, result]`.\n});\n\n// You can even chain the commands:\nredis.pipeline().set('foo', 'bar').del('cc').exec(function (err, results) {\n});\n\n// `exec` also returns a Promise:\nvar promise = redis.pipeline().set('foo', 'bar').get('foo').exec();\npromise.then(function (result) {\n  // result === [[null, 'OK'], [null, 'bar']]\n});\n```\n\nEach chained command can also have a callback, which will be invoked when the command\ngets a reply:\n\n```javascript\nredis.pipeline().set('foo', 'bar').get('foo', function (err, result) {\n  // result === 'bar'\n}).exec(function (err, result) {\n  // result[1][1] === 'bar'\n});\n```\n\nIn addition to adding commands to the `pipeline` queue individually, you can also pass an array of commands and arguments to the constructor:\n\n```javascript\nredis.pipeline([\n  ['set', 'foo', 'bar'],\n  ['get', 'foo']\n]).exec(function () { /* ... */ });\n```\n\n`#length` property shows how many commands in the pipeline:\n\n```javascript\nconst length = redis.pipeline().set('foo', 'bar').get('foo').length;\n// length === 2\n```\n\n\n## Transaction\nMost of the time, the transaction commands `multi` & `exec` are used together with pipeline.\nTherefore, when `multi` is called, a `Pipeline` instance is created automatically by default,\nso you can use `multi` just like `pipeline`:\n\n```javascript\nredis.multi().set('foo', 'bar').get('foo').exec(function (err, results) {\n  // results === [[null, 'OK'], [null, 'bar']]\n});\n```\nIf there's a syntax error in the transaction's command chain (e.g. wrong number of arguments, wrong command name, etc),\nthen none of the commands would be executed, and an error is returned:\n\n```javascript\nredis.multi().set('foo').set('foo', 'new value').exec(function (err, results) {\n  // err:\n  //  { [ReplyError: EXECABORT Transaction discarded because of previous errors.]\n  //    name: 'ReplyError',\n  //    message: 'EXECABORT Transaction discarded because of previous errors.',\n  //    command: { name: 'exec', args: [] },\n  //    previousErrors:\n  //     [ { [ReplyError: ERR wrong number of arguments for 'set' command]\n  //         name: 'ReplyError',\n  //         message: 'ERR wrong number of arguments for \\'set\\' command',\n  //         command: [Object] } ] }\n});\n```\n\nIn terms of the interface, `multi` differs from `pipeline` in that when specifying a callback\nto each chained command, the queueing state is passed to the callback instead of the result of the command:\n\n```javascript\nredis.multi().set('foo', 'bar', function (err, result) {\n  // result === 'QUEUED'\n}).exec(/* ... */);\n```\n\nIf you want to use transaction without pipeline, pass `{ pipeline: false }` to `multi`,\nand every command will be sent to Redis immediately without waiting for an `exec` invocation:\n\n```javascript\nredis.multi({ pipeline: false });\nredis.set('foo', 'bar');\nredis.get('foo');\nredis.exec(function (err, result) {\n  // result === [[null, 'OK'], [null, 'bar']]\n});\n```\n\nThe constructor of `multi` also accepts a batch of commands:\n\n```javascript\nredis.multi([\n  ['set', 'foo', 'bar'],\n  ['get', 'foo']\n]).exec(function () { /* ... */ });\n```\n\nInline transactions are supported by pipeline, which means you can group a subset of commands\nin the pipeline into a transaction:\n\n```javascript\nredis.pipeline().get('foo').multi().set('foo', 'bar').get('foo').exec().get('foo').exec();\n```\n\n## Lua Scripting\nioredis supports all of the scripting commands such as `EVAL`, `EVALSHA` and `SCRIPT`.\nHowever, it's tedious to use in real world scenarios since developers have to take\ncare of script caching and to detect when to use `EVAL` and when to use `EVALSHA`.\nioredis expose a `defineCommand` method to make scripting much easier to use:\n\n```javascript\nvar redis = new Redis();\n\n// This will define a command echo:\nredis.defineCommand('echo', {\n  numberOfKeys: 2,\n  lua: 'return {KEYS[1],KEYS[2],ARGV[1],ARGV[2]}'\n});\n\n// Now `echo` can be used just like any other ordinary command,\n// and ioredis will try to use `EVALSHA` internally when possible for better performance.\nredis.echo('k1', 'k2', 'a1', 'a2', function (err, result) {\n  // result === ['k1', 'k2', 'a1', 'a2']\n});\n\n// `echoBuffer` is also defined automatically to return buffers instead of strings:\nredis.echoBuffer('k1', 'k2', 'a1', 'a2', function (err, result) {\n  // result[0] equals to Buffer.from('k1');\n});\n\n// And of course it works with pipeline:\nredis.pipeline().set('foo', 'bar').echo('k1', 'k2', 'a1', 'a2').exec();\n```\n\nIf the number of keys can't be determined when defining a command, you can\nomit the `numberOfKeys` property and pass the number of keys as the first argument\nwhen you call the command:\n\n```javascript\nredis.defineCommand('echoDynamicKeyNumber', {\n  lua: 'return {KEYS[1],KEYS[2],ARGV[1],ARGV[2]}'\n});\n\n// Now you have to pass the number of keys as the first argument every time\n// you invoke the `echoDynamicKeyNumber` command:\nredis.echoDynamicKeyNumber(2, 'k1', 'k2', 'a1', 'a2', function (err, result) {\n  // result === ['k1', 'k2', 'a1', 'a2']\n});\n```\n\n## Transparent Key Prefixing\nThis feature allows you to specify a string that will automatically be prepended\nto all the keys in a command, which makes it easier to manage your key\nnamespaces.\n\n**Warning** This feature won't apply to commands like [KEYS](http://redis.io/commands/KEYS) and [SCAN](http://redis.io/commands/scan) that take patterns rather than actual keys([#239](https://github.com/luin/ioredis/issues/239)),\nand this feature also won't apply to the replies of commands even they are key names ([#325](https://github.com/luin/ioredis/issues/325)).\n\n```javascript\nvar fooRedis = new Redis({ keyPrefix: 'foo:' });\nfooRedis.set('bar', 'baz');  // Actually sends SET foo:bar baz\n\nfooRedis.defineCommand('echo', {\n  numberOfKeys: 2,\n  lua: 'return {KEYS[1],KEYS[2],ARGV[1],ARGV[2]}'\n});\n\n// Works well with pipelining/transaction\nfooRedis.pipeline()\n  // Sends SORT foo:list BY foo:weight_*->fieldname\n  .sort('list', 'BY', 'weight_*->fieldname')\n  // Supports custom commands\n  // Sends EVALSHA xxx foo:k1 foo:k2 a1 a2\n  .echo('k1', 'k2', 'a1', 'a2')\n  .exec()\n```\n\n## Transforming Arguments & Replies\nMost Redis commands take one or more Strings as arguments,\nand replies are sent back as a single String or an Array of Strings. However, sometimes\nyou may want something different. For instance, it would be more convenient if the `HGETALL`\ncommand returns a hash (e.g. `{ key: val1, key2: v2 }`) rather than an array of key values (e.g. `[key1, val1, key2, val2]`).\n\nioredis has a flexible system for transforming arguments and replies. There are two types\nof transformers, argument transformer and reply transformer:\n\n```javascript\nvar Redis = require('ioredis');\n\n// Here's the built-in argument transformer converting\n// hmset('key', { k1: 'v1', k2: 'v2' })\n// or\n// hmset('key', new Map([['k1', 'v1'], ['k2', 'v2']]))\n// into\n// hmset('key', 'k1', 'v1', 'k2', 'v2')\nRedis.Command.setArgumentTransformer('hmset', function (args) {\n  if (args.length === 2) {\n    if (typeof Map !== 'undefined' && args[1] instanceof Map) {\n      // utils is a internal module of ioredis\n      return [args[0]].concat(utils.convertMapToArray(args[1]));\n    }\n    if ( typeof args[1] === 'object' && args[1] !== null) {\n      return [args[0]].concat(utils.convertObjectToArray(args[1]));\n    }\n  }\n  return args;\n});\n\n// Here's the built-in reply transformer converting the HGETALL reply\n// ['k1', 'v1', 'k2', 'v2']\n// into\n// { k1: 'v1', 'k2': 'v2' }\nRedis.Command.setReplyTransformer('hgetall', function (result) {\n  if (Array.isArray(result)) {\n    var obj = {};\n    for (var i = 0; i < result.length; i += 2) {\n      obj[result[i]] = result[i + 1];\n    }\n    return obj;\n  }\n  return result;\n});\n```\n\nThere are three built-in transformers, two argument transformers for `hmset` & `mset` and\na reply transformer for `hgetall`. Transformers for `hmset` and `hgetall` were mentioned\nabove, and the transformer for `mset` is similar to the one for `hmset`:\n\n```javascript\nredis.mset({ k1: 'v1', k2: 'v2' });\nredis.get('k1', function (err, result) {\n  // result === 'v1';\n});\n\nredis.mset(new Map([['k3', 'v3'], ['k4', 'v4']]));\nredis.get('k3', function (err, result) {\n  // result === 'v3';\n});\n```\n\nAnother useful example of a reply transformer is one that changes `hgetall` to return array of arrays instead of objects which avoids a unwanted conversation of hash keys to strings when dealing with binary hash keys:\n\n```javascript\nRedis.Command.setReplyTransformer('hgetall', function (result) {\n  var arr = [];\n  for (var i = 0; i < result.length; i += 2) {\n    arr.push([result[i], result[i + 1]]);\n  }\n  return arr;\n});\nredis.hset('h1', Buffer.from([0x01]), Buffer.from([0x02]));\nredis.hset('h1', Buffer.from([0x03]), Buffer.from([0x04]));\nredis.hgetallBuffer('h1', function (err, result) {\n  // result === [ [ <Buffer 01>, <Buffer 02> ], [ <Buffer 03>, <Buffer 04> ] ];\n});\n```\n\n## Monitor\nRedis supports the MONITOR command,\nwhich lets you see all commands received by the Redis server across all client connections,\nincluding from other client libraries and other computers.\n\nThe `monitor` method returns a monitor instance.\nAfter you send the MONITOR command, no other commands are valid on that connection. ioredis will emit a monitor event for every new monitor message that comes across.\nThe callback for the monitor event takes a timestamp from the Redis server and an array of command arguments.\n\nHere is a simple example:\n\n```javascript\nredis.monitor(function (err, monitor) {\n  monitor.on('monitor', function (time, args, source, database) {\n  });\n});\n```\n\n## Streamify Scanning\nRedis 2.8 added the `SCAN` command to incrementally iterate through the keys in the database. It's different from `KEYS` in that\n`SCAN` only returns a small number of elements each call, so it can be used in production without the downside\nof blocking the server for a long time. However, it requires recording the cursor on the client side each time\nthe `SCAN` command is called in order to iterate through all the keys correctly. Since it's a relatively common use case, ioredis\nprovides a streaming interface for the `SCAN` command to make things much easier. A readable stream can be created by calling `scanStream`:\n\n```javascript\nvar redis = new Redis();\n// Create a readable stream (object mode)\nvar stream = redis.scanStream();\nstream.on('data', function (resultKeys) {\n  // `resultKeys` is an array of strings representing key names.\n  // Note that resultKeys may contain 0 keys, and that it will sometimes\n  // contain duplicates due to SCAN's implementation in Redis.\n  for (var i = 0; i < resultKeys.length; i++) {\n    console.log(resultKeys[i]);\n  }\n});\nstream.on('end', function () {\n  console.log('all keys have been visited');\n});\n```\n\n`scanStream` accepts an option, with which you can specify the `MATCH` pattern and the `COUNT` argument:\n\n```javascript\nvar stream = redis.scanStream({\n  // only returns keys following the pattern of `user:*`\n  match: 'user:*',\n  // returns approximately 100 elements per call\n  count: 100\n});\n```\n\nJust like other commands, `scanStream` has a binary version `scanBufferStream`, which returns an array of buffers. It's useful when\nthe key names are not utf8 strings.\n\nThere are also `hscanStream`, `zscanStream` and `sscanStream` to iterate through elements in a hash, zset and set. The interface of each is\nsimilar to `scanStream` except the first argument is the key name:\n\n```javascript\nvar stream = redis.hscanStream('myhash', {\n  match: 'age:??'\n});\n```\n\nYou can learn more from the [Redis documentation](http://redis.io/commands/scan).\n\n**Useful Tips**\nIt's pretty common that doing an async task in the `data` handler. We'd like the scanning process to be paused until the async task to be finished. `Stream#pause()` and `Stream.resume()` do the trick. For example if we want to migrate data in Redis to MySQL:\n\n```javascript\nvar stream = redis.scanStream();\nstream.on('data', function (resultKeys) {\n  // Pause the stream from scanning more keys until we've migrated the current keys.\n  stream.pause();\n\n  Promise.all(resultKeys.map(migrateKeyToMySQL)).then(() => {\n    // Resume the stream here.\n    stream.resume();\n  });\n});\n\nstream.on('end', function () {\n  console.log('done migration');\n});\n```\n\n## Auto-reconnect\nBy default, ioredis will try to reconnect when the connection to Redis is lost\nexcept when the connection is closed manually by `redis.disconnect()` or `redis.quit()`.\n\nIt's very flexible to control how long to wait to reconnect after disconnection\nusing the `retryStrategy` option:\n\n```javascript\nvar redis = new Redis({\n  // This is the default value of `retryStrategy`\n  retryStrategy: function (times) {\n    var delay = Math.min(times * 50, 2000);\n    return delay;\n  }\n});\n```\n\n`retryStrategy` is a function that will be called when the connection is lost.\nThe argument `times` means this is the nth reconnection being made and\nthe return value represents how long (in ms) to wait to reconnect. When the\nreturn value isn't a number, ioredis will stop trying to reconnect, and the connection\nwill be lost forever if the user doesn't call `redis.connect()` manually.\n\nWhen reconnected, the client will auto subscribe to channels that the previous connection subscribed to.\nThis behavior can be disabled by setting the `autoResubscribe` option to `false`.\n\nAnd if the previous connection has some unfulfilled commands (most likely blocking commands such as `brpop` and `blpop`),\nthe client will resend them when reconnected. This behavior can be disabled by setting the `autoResendUnfulfilledCommands` option to `false`.\n\nBy default, all pending commands will be flushed with an error every 20 retry attempts. That makes sure commands won't wait forever when the connection is down. You can change this behavior by setting `maxRetriesPerRequest`:\n\n```javascript\nvar redis = new Redis({\n  maxRetriesPerRequest: 1\n});\n```\n\nSet maxRetriesPerRequest to `null` to disable this behavior, and every command will wait forever until the connection is alive again (which is the default behavior before ioredis v4).\n\n### Reconnect on error\n\nBesides auto-reconnect when the connection is closed, ioredis supports reconnecting on the specified errors by the `reconnectOnError` option. Here's an example that will reconnect when receiving `READONLY` error:\n\n```javascript\nvar redis = new Redis({\n  reconnectOnError: function (err) {\n    var targetError = 'READONLY';\n    if (err.message.slice(0, targetError.length) === targetError) {\n      // Only reconnect when the error starts with \"READONLY\"\n      return true; // or `return 1;`\n    }\n  }\n});\n```\n\nThis feature is useful when using Amazon ElastiCache. Once failover happens, Amazon ElastiCache will switch the master we currently connected with to a slave, leading to the following writes fails with the error `READONLY`. Using `reconnectOnError`, we can force the connection to reconnect on this error in order to connect to the new master.\n\nFurthermore, if the `reconnectOnError` returns `2`, ioredis will resend the failed command after reconnecting.\n\n## Connection Events\nThe Redis instance will emit some events about the state of the connection to the Redis server.\n\nEvent    | Description\n:------------- | :-------------\nconnect  | emits when a connection is established to the Redis server.\nready    | If `enableReadyCheck` is `true`, client will emit `ready` when the server reports that it is ready to receive commands (e.g. finish loading data from disk).<br>Otherwise, `ready` will be emitted immediately right after the `connect` event.\nerror    | emits when an error occurs while connecting.<br>However, ioredis emits all `error` events silently (only emits when there's at least one listener) so that your application won't crash if you're not listening to the `error` event.\nclose    | emits when an established Redis server connection has closed.\nreconnecting | emits after `close` when a reconnection will be made. The argument of the event is the time (in ms) before reconnecting.\nend     | emits after `close` when no more reconnections will be made, or the connection is failed to establish.\n\nYou can also check out the `Redis#status` property to get the current connection status.\n\nBesides the above connection events, there are several other custom events:\n\nEvent    | Description\n:------------- | :-------------\nselect   | emits when the database changed. The argument is the new db number.\n\n## Offline Queue\nWhen a command can't be processed by Redis (being sent before the `ready` event), by default, it's added to the offline queue and will be\nexecuted when it can be processed. You can disable this feature by setting the `enableOfflineQueue`\noption to `false`:\n\n```javascript\nvar redis = new Redis({ enableOfflineQueue: false });\n```\n\n## TLS Options\nRedis doesn't support TLS natively, however if the redis server you want to connect to is hosted behind a TLS proxy (e.g. [stunnel](https://www.stunnel.org/)) or is offered by a PaaS service that supports TLS connection (e.g. [Redis Labs](https://redislabs.com/)), you can set the `tls` option:\n\n```javascript\nvar redis = new Redis({\n  host: 'localhost',\n  tls: {\n    // Refer to `tls.connect()` section in\n    // https://nodejs.org/api/tls.html\n    // for all supported options\n    ca: fs.readFileSync('cert.pem')\n  }\n});\n```\n\n<hr>\n\n## Sentinel\nioredis supports Sentinel out of the box. It works transparently as all features that work when\nyou connect to a single node also work when you connect to a sentinel group. Make sure to run Redis >= 2.8.12 if you want to use this feature. Sentinels have a default port of 26379.\n\nTo connect using Sentinel, use:\n\n```javascript\nvar redis = new Redis({\n  sentinels: [{ host: 'localhost', port: 26379 }, { host: 'localhost', port: 26380 }],\n  name: 'mymaster'\n});\n\nredis.set('foo', 'bar');\n```\n\nThe arguments passed to the constructor are different from the ones you use to connect to a single node, where:\n\n* `name` identifies a group of Redis instances composed of a master and one or more slaves (`mymaster` in the example);\n* `sentinels` are a list of sentinels to connect to. The list does not need to enumerate all your sentinel instances, but a few so that if one is down the client will try the next one.\n* `role` (optional) with a value of `slave` will return a random slave from the Sentinel group.\n* `preferredSlaves` (optional) can be used to prefer a particular slave or set of slaves based on priority. It accepts a function or array.\n\nioredis **guarantees** that the node you connected to is always a master even after a failover. When a failover happens, instead of trying to reconnect to the failed node (which will be demoted to slave when it's available again), ioredis will ask sentinels for the new master node and connect to it. All commands sent during the failover are queued and will be executed when the new connection is established so that none of the commands will be lost.\n\nIt's possible to connect to a slave instead of a master by specifying the option `role` with the value of `slave` and ioredis will try to connect to a random slave of the specified master, with the guarantee that the connected node is always a slave. If the current node is promoted to master due to a failover, ioredis will disconnect from it and ask the sentinels for another slave node to connect to.\n\nIf you specify the option `preferredSlaves` along with `role: 'slave'` ioredis will attempt to use this value when selecting the slave from the pool of available slaves. The value of `preferredSlaves` should either be a function that accepts an array of avaiable slaves and returns a single result, or an array of slave values priorities by the lowest `prio` value first with a default value of `1`.\n\n```javascript\n// available slaves format\nvar availableSlaves = [{ ip: '127.0.0.1', port: '31231', flags: 'slave' }];\n\n// preferredSlaves array format\nvar preferredSlaves = [\n  { ip: '127.0.0.1', port: '31231', prio: 1 },\n  { ip: '127.0.0.1', port: '31232', prio: 2 }\n];\n\n// preferredSlaves function format\npreferredSlaves = function(availableSlaves) {\n  for (var i = 0; i < availableSlaves.length; i++) {\n    var slave = availableSlaves[i];\n    if (slave.ip === '127.0.0.1') {\n      if (slave.port === '31234') {\n        return slave;\n      }\n    }\n  }\n  // if no preferred slaves are available a random one is used\n  return false;\n};\n\nvar redis = new Redis({\n  sentinels: [{ host: '127.0.0.1', port: 26379 }, { host: '127.0.0.1', port: 26380 }],\n  name: 'mymaster',\n  role: 'slave',\n  preferredSlaves: preferredSlaves\n});\n```\n\nBesides the `retryStrategy` option, there's also a `sentinelRetryStrategy` in Sentinel mode which will be invoked when all the sentinel nodes are unreachable during connecting. If `sentinelRetryStrategy` returns a valid delay time, ioredis will try to reconnect from scratch. The default value of `sentinelRetryStrategy` is:\n\n```javascript\nfunction (times) {\n  var delay = Math.min(times * 10, 1000);\n  return delay;\n}\n```\n\n## Cluster\nRedis Cluster provides a way to run a Redis installation where data is automatically sharded across multiple Redis nodes.\nYou can connect to a Redis Cluster like this:\n\n```javascript\nvar Redis = require('ioredis');\n\nvar cluster = new Redis.Cluster([{\n  port: 6380,\n  host: '127.0.0.1'\n}, {\n  port: 6381,\n  host: '127.0.0.1'\n}]);\n\ncluster.set('foo', 'bar');\ncluster.get('foo', function (err, res) {\n  // res === 'bar'\n});\n```\n\n`Cluster` constructor accepts two arguments, where:\n\n0. The first argument is a list of nodes of the cluster you want to connect to.\nJust like Sentinel, the list does not need to enumerate all your cluster nodes,\nbut a few so that if one is unreachable the client will try the next one, and the client will discover other nodes automatically when at least one node is connected.\n0. The second argument is the options, where:\n\n    * `clusterRetryStrategy`: When none of the startup nodes are reachable, `clusterRetryStrategy` will be invoked. When a number is returned,\n    ioredis will try to reconnect to the startup nodes from scratch after the specified delay (in ms). Otherwise, an error of \"None of startup nodes is available\" will be returned.\n    The default value of this option is:\n\n        ```javascript\n        function (times) {\n          var delay = Math.min(100 + times * 2, 2000);\n          return delay;\n        }\n        ```\n\n        It's possible to modify the `startupNodes` property in order to switch to another set of nodes here:\n\n        ```javascript\n        function (times) {\n          this.startupNodes = [{ port: 6790, host: '127.0.0.1' }];\n          return Math.min(100 + times * 2, 2000);\n        }\n        ```\n\n    * `enableOfflineQueue`: Similar to the `enableOfflineQueue` option of `Redis` class.\n    * `enableReadyCheck`: When enabled, \"ready\" event will only be emitted when `CLUSTER INFO` command\n    reporting the cluster is ready for handling commands. Otherwise, it will be emitted immediately after \"connect\" is emitted.\n    * `scaleReads`: Config where to send the read queries. See below for more details.\n    * `maxRedirections`: When a cluster related error (e.g. `MOVED`, `ASK` and `CLUSTERDOWN` etc.) is received, the client will redirect the\n    command to another node. This option limits the max redirections allowed when sending a command. The default value is `16`.\n    * `retryDelayOnFailover`: If the target node is disconnected when sending a command,\n    ioredis will retry after the specified delay. The default value is `100`. You should make sure `retryDelayOnFailover * maxRedirections > cluster-node-timeout`\n    to insure that no command will fail during a failover.\n    * `retryDelayOnClusterDown`: When a cluster is down, all commands will be rejected with the error of `CLUSTERDOWN`. If this option is a number (by default, it is `100`), the client\n    will resend the commands after the specified time (in ms).\n    * `retryDelayOnTryAgain`: If this option is a number (by default, it is `100`), the client\n    will resend the commands rejected with `TRYAGAIN` error after the specified time (in ms).\n    * `redisOptions`: Default options passed to the constructor of `Redis` when connecting to a node.\n    * `slotsRefreshTimeout`: Milliseconds before a timeout occurs while refreshing slots from the cluster (default `1000`)\n    * `slotsRefreshInterval`: Milliseconds between every automatic slots refresh (default `5000`)\n\n### Read-write splitting\n\nA typical redis cluster contains three or more masters and several slaves for each master. It's possible to scale out redis cluster by sending read queries to slaves and write queries to masters by setting the `scaleReads` option.\n\n`scaleReads` is \"master\" by default, which means ioredis will never send any queries to slaves. There are other three available options:\n\n1. \"all\": Send write queries to masters and read queries to masters or slaves randomly.\n2. \"slave\": Send write queries to masters and read queries to slaves.\n3. a custom `function(nodes, command): node`: Will choose the custom function to select to which node to send read queries (write queries keep being sent to master). The first node in `nodes` is always the master serving the relevant slots. If the function returns an array of nodes, a random node of that list will be selected.\n\nFor example:\n\n```javascript\nvar cluster = new Redis.Cluster([/* nodes */], {\n  scaleReads: 'slave'\n});\ncluster.set('foo', 'bar'); // This query will be sent to one of the masters.\ncluster.get('foo', function (err, res) {\n  // This query will be sent to one of the slaves.\n});\n```\n\n**NB** In the code snippet above, the `res` may not be equal to \"bar\" because of the lag of replication between the master and slaves.\n\n### Running commands to multiple nodes\n\nEvery command will be sent to exactly one node. For commands containing keys, (e.g. `GET`, `SET` and `HGETALL`), ioredis sends them to the node that serving the keys, and for other commands not containing keys, (e.g. `INFO`, `KEYS` and `FLUSHDB`), ioredis sends them to a random node.\n\nSometimes you may want to send a command to multiple nodes (masters or slaves) of the cluster, you can get the nodes via `Cluster#nodes()` method.\n\n`Cluster#nodes()` accepts a parameter role, which can be \"master\", \"slave\" and \"all\" (default), and returns an array of `Redis` instance. For example:\n\n```javascript\n// Send `FLUSHDB` command to all slaves:\nvar slaves = cluster.nodes('slave');\nPromise.all(slaves.map(function (node) {\n  return node.flushdb();\n}));\n\n// Get keys of all the masters:\nvar masters = cluster.nodes('master');\nPromise.all(masters.map(function (node) {\n  return node.keys();\n})).then(function (keys) {\n  // keys: [['key1', 'key2'], ['key3', 'key4']]\n});\n```\n\n### Transaction and pipeline in Cluster mode\nAlmost all features that are supported by `Redis` are also supported by `Redis.Cluster`, e.g. custom commands, transaction and pipeline.\nHowever there are some differences when using transaction and pipeline in Cluster mode:\n\n0. All keys in a pipeline should belong to the same slot since ioredis sends all commands in a pipeline to the same node.\n0. You can't use `multi` without pipeline (aka `cluster.multi({ pipeline: false })`). This is because when you call `cluster.multi({ pipeline: false })`, ioredis doesn't know which node the `multi` command should be sent to.\n0. Chaining custom commands in the pipeline is not supported in Cluster mode.\n\nWhen any commands in a pipeline receives a `MOVED` or `ASK` error, ioredis will resend the whole pipeline to the specified node automatically if all of the following conditions are satisfied:\n\n0. All errors received in the pipeline are the same. For example, we won't resend the pipeline if we got two `MOVED` errors pointing to different nodes.\n0. All commands executed successfully are readonly commands. This makes sure that resending the pipeline won't have side effects.\n\n### Pub/Sub\nPub/Sub in cluster mode works exactly as the same as in standalone mode. Internally, when a node of the cluster receives a message, it will broadcast the message to the other nodes. ioredis makes sure that each message will only be received once by strictly subscribing one node at the same time.\n\n```javascript\nvar nodes = [/* nodes */];\nvar pub = new Redis.Cluster(nodes);\nvar sub = new Redis.Cluster(nodes);\nsub.on('message', function (channel, message) {\n  console.log(channel, message);\n});\n\nsub.subscribe('news', function () {\n  pub.publish('news', 'highlights');\n});\n```\n\n### Events\n\nEvent    | Description\n:------------- | :-------------\nconnect  | emits when a connection is established to the Redis server.\nready    | emits when `CLUSTER INFO` reporting the cluster is able to receive commands (if `enableReadyCheck` is `true`) or immediately after `connect` event (if `enableReadyCheck` is false).\nerror    | emits when an error occurs while connecting with a property of `lastNodeError` representing the last node error received. This event is emitted silently (only emitting if there's at least one listener).\nclose    | emits when an established Redis server connection has closed.\nreconnecting | emits after `close` when a reconnection will be made. The argument of the event is the time (in ms) before reconnecting.\nend     | emits after `close` when no more reconnections will be made.\n+node   | emits when a new node is connected.\n-node   | emits when a node is disconnected.\nnode error | emits when an error occurs when connecting to a node\n\n### Password\nSetting the `password` option to access password-proctected clusters:\n\n```javascript\nvar Redis = require('ioredis');\nvar cluster = new Redis.Cluster(nodes, {\n  redisOptions: {\n    password: 'your-cluster-password'\n  }\n});\n```\n\nIf some of nodes in the cluster using a different password, you should specify them in the first parameter:\n\n```javascript\nvar Redis = require('ioredis');\nvar cluster = new Redis.Cluster([\n  // Use password \"password-for-30001\" for 30001\n  { port: 30001, password: 'password-for-30001'},\n  // Don't use password when accessing 30002\n  { port: 30002, password: null }\n  // Other nodes will use \"fallback-password\"\n], {\n  redisOptions: {\n    password: 'fallback-password'\n  }\n});\n```\n\n<hr>\n\n# Error Handling\nAll the errors returned by the Redis server are instances of `ReplyError`, which can be accessed via `Redis`:\n\n```javascript\nvar Redis = require('ioredis');\nvar redis = new Redis();\n// This command causes a reply error since the SET command requires two arguments.\nredis.set('foo', function (err) {\n  err instanceof Redis.ReplyError\n});\n```\n\nThis is the error stack of the `ReplyError`:\n\n```\nReplyError: ERR wrong number of arguments for 'set' command\n    at ReplyParser._parseResult (/app/node_modules/ioredis/lib/parsers/javascript.js:60:14)\n    at ReplyParser.execute (/app/node_modules/ioredis/lib/parsers/javascript.js:178:20)\n    at Socket.<anonymous> (/app/node_modules/ioredis/lib/redis/event_handler.js:99:22)\n    at Socket.emit (events.js:97:17)\n    at readableAddChunk (_stream_readable.js:143:16)\n    at Socket.Readable.push (_stream_readable.js:106:10)\n    at TCP.onread (net.js:509:20)\n```\n\nBy default, the error stack doesn't make any sense because the whole stack happens in the ioredis\nmodule itself, not in your code. So it's not easy to find out where the error happens in your code.\nioredis provides an option `showFriendlyErrorStack` to solve the problem. When you enable\n`showFriendlyErrorStack`, ioredis will optimize the error stack for you:\n\n```javascript\nvar Redis = require('ioredis');\nvar redis = new Redis({ showFriendlyErrorStack: true });\nredis.set('foo');\n```\n\nAnd the output will be:\n\n```\nReplyError: ERR wrong number of arguments for 'set' command\n    at Object.<anonymous> (/app/index.js:3:7)\n    at Module._compile (module.js:446:26)\n    at Object.Module._extensions..js (module.js:464:10)\n    at Module.load (module.js:341:32)\n    at Function.Module._load (module.js:296:12)\n    at Function.Module.runMain (module.js:487:10)\n    at startup (node.js:111:16)\n    at node.js:799:3\n```\n\nThis time the stack tells you that the error happens on the third line in your code. Pretty sweet!\nHowever, it would decrease the performance significantly to optimize the error stack. So by\ndefault, this option is disabled and can only be used for debugging purposes. You **shouldn't** use this feature in a production environment.\n\n# Plugging in your own Promises Library\nIf you're an advanced user, you may want to plug in your own promise library like [bluebird](https://www.npmjs.com/package/bluebird). Just set Redis.Promise to your favorite ES6-style promise constructor and ioredis will use it.\n\n```javascript\nconst Redis = require('ioredis')\nRedis.Promise = require('bluebird')\n\nconst redis = new Redis()\n\n// Use bluebird\nassert.equal(redis.get().constructor, require('bluebird'))\n\n// You can change the Promise implementation at any time:\nRedis.Promise = global.Promise\nassert.equal(redis.get().constructor, global.Promise)\n```\n\n\n# Running tests\n\nStart a Redis server on 127.0.0.1:6379, and then:\n\n```shell\n$ npm test\n```\n\n`FLUSH ALL` will be invoked after each test, so make sure there's no valuable data in it before running tests.\n\nIf your testing environment does not let you spin up a Redis server [ioredis-mock](https://github.com/stipsan/ioredis-mock) is a drop-in replacement you can use in your tests. It aims to behave identically to ioredis connected to a Redis server so that your integration tests is easier to write and of better quality.\n\n# Debug\n\nYou can set the `DEBUG` env to `ioredis:*` to print debug info:\n\n```shell\n$ DEBUG=ioredis:* node app.js\n```\n\n# Consolidation: It's time for celebration\n\nRight now there are two great redis clients around and both have some advantages above each other. We speak about [node_redis](https://github.com/NodeRedis/node_redis) and ioredis. So after talking to each other about how we could improve in working together we (that is [@BridgeAR](https://github.com/BridgeAR) and [@luin](https://github.com/luin)) decided to work towards a single library on the long run. But step by step.\n\nFirst of all, we want to split small parts of our libraries into others so that we're both able to use the same code. Those libraries are going to be maintained under the NodeRedis organization. This is going to reduce the maintance overhead, allows others to use the very same code, if they need it and it's way easier for others to contribute to both libraries.\n\nWe're very happy about this step towards working together as we both want to give you the best redis experience possible.\n\nIf you want to join our cause by help maintaining something, please don't hesitate to contact either one of us.\n\n# Join in!\n\nI'm happy to receive bug reports, fixes, documentation enhancements, and any other improvements.\n\nAnd since I'm not a native English speaker, if you find any grammar mistakes in the documentation, please also let me know. :)\n\n# Contributors\n\nThis project exists thanks to all the people who contribute:\n\n<a href=\"https://github.com/luin/ioredis/graphs/contributors\"><img src=\"https://opencollective.com/ioredis/contributors.svg?width=890&showBtn=false\" /></a>\n\n# License\n\nMIT\n","readmeFilename":"README.md","bugs":{"url":"https://github.com/luin/ioredis/issues"},"homepage":"https://github.com/luin/ioredis#readme","_id":"ioredis@4.2.3","_npmVersion":"6.4.1","_nodeVersion":"10.13.0","_npmUser":{"name":"ioredis-robot","email":"ioredis-robot@zihua.li"},"dist":{"integrity":"sha512-f1ExpoCS8RMCkNXPOZrFlgxBKeFVZhRjz9+aWiU3A88u1kmm711QfCgE7UFxS9FmI9368BCn9XsIDcVSdy4WrQ==","shasum":"44bea932814edeccac39b214a1e2fb14cffc3faa","tarball":"https://registry.npmjs.org/ioredis/-/ioredis-4.2.3.tgz","fileCount":35,"unpackedSize":212974,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJb+V46CRA9TVsSAnZWagAAPYgP/iohPoRBqzTkOEqNMsh0\nDnWHf3RCLQ9E05H6QOysy/V/p2C+sYBJlry7kS9golshakBPzJEnE+IBd/jt\nT52DNbCQd8tdXuV1fFpMZBeyRYRH8002EzaNsMVDvDhysmtlMW9pbw5+6F4J\nAL/gVLpqAxceLux/kzTb/CQJfSbHUoriTNJeaGpHegQPdc6LURYGg2o+AuJH\npGnK4nWP2fYpubwWNlnGgqnHL3ma2HyFKSscAB0isnsTC81goc2CrKfcGWRg\nBdqrzhSfYftmjwOCRX6ciDW0f8KMka9ruEF76gfNEP3RhDTOUmDqALuNZTaB\n4aOEV9EIbDIm0LQgFDJt3txueKMqYHc25KAQsI8VX4vPLz5dWcTBKtlO1YVd\ngiWVdux7Tv+QtiGFjPBP26i3TgMaUOGuN4dHKl4kVS0AtSbdVrpAlMfKiKDH\nFkRZJesOxkoBwH7Fn1r05bE+TB+NGyAJAEHZAQ0s5eLBFK3OAlYVAbxJnNOF\nmfYiTJtMAu+AVznEdlW94JvoDtsp+VLvzmMmwGlQZ8ZLO11qHn0AZHh6l5lQ\n8/Wo+xQgtFGm6ol8oJ7sPbiK/HhfRCXZeOrSYkg6CAo5rDWpdA2wheWEOZ6e\nov5YHWkN9RndC65ie/1vvKl3Or5K/nLlYN07bg8SATgL9MBoMvvJsktMzxBM\no/Jg\r\n=p3c7\r\n-----END PGP SIGNATURE-----\r\n"},"maintainers":[{"email":"ioredis-robot@zihua.li","name":"ioredis-robot"},{"email":"i@zihua.li","name":"luin"}],"directories":{},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/ioredis_4.2.3_1543069241254_0.0005728968202696194"},"_hasShrinkwrap":false},"4.3.0":{"name":"ioredis","version":"4.3.0","description":"A robust, performance-focused and full-featured Redis client for Node.js.","main":"built/index.js","scripts":{"test":"NODE_ENV=test mocha --timeout 8000 -r ts-node/register --exit","test:cov":"NODE_ENV=test node ./node_modules/istanbul/lib/cli.js cover --preserve-comments ./node_modules/mocha/bin/_mocha -- -r ts-node/register -R spec --exit","build":"rm -rf built && tsc","generate-docs":"jsdoc2md lib/redis.js lib/cluster/index.js lib/commander.js > API.md","prepublishOnly":"npm run build && npm test","bench":"matcha benchmarks/*.js","semantic-release":"semantic-release"},"repository":{"type":"git","url":"git://github.com/luin/ioredis.git"},"keywords":["redis","cluster","sentinel","pipelining"],"author":{"name":"luin","email":"i@zihua.li","url":"http://zihua.li"},"license":"MIT","dependencies":{"cluster-key-slot":"^1.0.6","debug":"^3.1.0","denque":"^1.1.0","flexbuffer":"0.0.6","lodash.defaults":"^4.2.0","lodash.flatten":"^4.4.0","redis-commands":"1.4.0","redis-errors":"^1.2.0","redis-parser":"^3.0.0","standard-as-callback":"^1.0.0"},"devDependencies":{"@semantic-release/changelog":"^3.0.0","@semantic-release/git":"^7.0.4","@types/node":"^10.11.5","@types/redis-errors":"1.2.0","bluebird":"^3.5.1","chai":"^3.5.0","cz-conventional-changelog":"^2.0.0","istanbul":"^0.4.2","jsdoc":"^3.4.0","jsdoc-to-markdown":"^4.0.1","mocha":"^5.2.0","server-destroy":"^1.0.1","sinon":"^1.17.3","ts-node":"^7.0.0","typescript":"^3.1.1"},"engines":{"node":">=6"},"config":{"commitizen":{"path":"./node_modules/cz-conventional-changelog"}},"gitHead":"77231b588393e56f3605ae8305853a8f9059f021","bugs":{"url":"https://github.com/luin/ioredis/issues"},"homepage":"https://github.com/luin/ioredis#readme","_id":"ioredis@4.3.0","_npmVersion":"6.4.1","_nodeVersion":"10.14.1","_npmUser":{"name":"ioredis-robot","email":"ioredis-robot@zihua.li"},"dist":{"integrity":"sha512-TwTp93UDKlKVQeg9ThuavNh4Vs31JTlqn+cI/J6z21OtfghyJm5I349ZlsKobOeEyS4INITMLQ1fhR7xwf9Fxg==","shasum":"a92850dd8794eaee4f38a265c830ca823a09d345","tarball":"https://registry.npmjs.org/ioredis/-/ioredis-4.3.0.tgz","fileCount":35,"unpackedSize":214860,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJcDKEMCRA9TVsSAnZWagAAX20P/RDc/PiON8p8T0Hup3cL\nWZl0ghmfFCnYQP7P4YWxmYMA5gDJ8g0iQonSyGXWnngvEHqIYqihZpCo9AdQ\nCSI7KW2cKwwCTuFTtJ1hXJzit1Js3vQbtKJ4pHcuunvxjbH4OMgKteMlz63t\nV7O+V8Sq5Y9KI9bHijXFDXJdABKeL4c+GjtP6xj5B6m+OS6xKHQDBNc4yVn+\nF+lZRnizIV7cSH558pNlMlwO9sbVpIynrCmgwV8utsPev1owJXHgm1WOT9RI\nzWBnXgoUBArv+ITu0MKrqogQojuS1hxEOJp6XwyByasE9FPVhrAGU9ygcY1i\nDvPEDROrZPeY7l6BvEZ2MYu9qGYPbajcqujZt8AhR/pMCH/QV06Mfo0vWpXS\nVWAxETYcVzazxnOxBWJl87EtIVhPlSZFWHkJLvY4rVW2R2ciC4yPLB176sDU\nEehs3IZsGXDaChhA6sxxAYb4bmoQQOJftRWZkGMdsoqI6ryVZzpPM9TjXd+h\n0lwJP+XjFk2MaX1plQMt0onWNpjg2RzvjfWRcVJ96800ANOpM/ywBDjq5/5u\nvmbfdZcObXsoZdQHY+2rzHh/BIU/afFIbxPaKWCbcg8gLeY3wpfjdY4iQsgc\n03gQqFGDUqG7nmhOXsKdHJHx6ya6g6bbQXIrveBPr+0TN+lVkEcwVRKZwmjL\nK8O3\r\n=N0aO\r\n-----END PGP SIGNATURE-----\r\n"},"maintainers":[{"email":"ioredis-robot@zihua.li","name":"ioredis-robot"},{"email":"i@zihua.li","name":"luin"}],"directories":{},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/ioredis_4.3.0_1544331531533_0.6204909900463673"},"_hasShrinkwrap":false},"4.3.1":{"name":"ioredis","version":"4.3.1","description":"A robust, performance-focused and full-featured Redis client for Node.js.","main":"built/index.js","scripts":{"test":"NODE_ENV=test mocha --timeout 8000 -r ts-node/register --exit","test:cov":"NODE_ENV=test node ./node_modules/istanbul/lib/cli.js cover --preserve-comments ./node_modules/mocha/bin/_mocha -- -r ts-node/register -R spec --exit","build":"rm -rf built && tsc","generate-docs":"jsdoc2md lib/redis.js lib/cluster/index.js lib/commander.js > API.md","prepublishOnly":"npm run build && npm test","bench":"matcha benchmarks/*.js","semantic-release":"semantic-release"},"repository":{"type":"git","url":"git://github.com/luin/ioredis.git"},"keywords":["redis","cluster","sentinel","pipelining"],"author":{"name":"luin","email":"i@zihua.li","url":"http://zihua.li"},"license":"MIT","dependencies":{"cluster-key-slot":"^1.0.6","debug":"^3.1.0","denque":"^1.1.0","flexbuffer":"0.0.6","lodash.defaults":"^4.2.0","lodash.flatten":"^4.4.0","redis-commands":"1.4.0","redis-errors":"^1.2.0","redis-parser":"^3.0.0","standard-as-callback":"^1.0.0"},"devDependencies":{"@semantic-release/changelog":"^3.0.0","@semantic-release/git":"^7.0.4","@types/node":"^10.11.5","@types/redis-errors":"1.2.0","bluebird":"^3.5.1","chai":"^3.5.0","cz-conventional-changelog":"^2.0.0","istanbul":"^0.4.2","jsdoc":"^3.4.0","jsdoc-to-markdown":"^4.0.1","mocha":"^5.2.0","server-destroy":"^1.0.1","sinon":"^1.17.3","ts-node":"^7.0.0","typescript":"^3.1.1"},"engines":{"node":">=6"},"config":{"commitizen":{"path":"./node_modules/cz-conventional-changelog"}},"gitHead":"ec1e85267f79c31825a0340f981be94f8edbed2d","readme":"[![ioredis](https://cdn.rawgit.com/luin/ioredis/57b5b89e3e9111ff25d8c62c0bc58ed42e5b8d1e/logo.svg)](https://github.com/luin/ioredis)\n\n[![Build Status](https://travis-ci.org/luin/ioredis.svg?branch=master)](https://travis-ci.org/luin/ioredis)\n[![Test Coverage](https://codeclimate.com/github/luin/ioredis/badges/coverage.svg)](https://codeclimate.com/github/luin/ioredis)\n[![Join the chat at https://gitter.im/luin/ioredis](https://badges.gitter.im/Join%20Chat.svg)](https://gitter.im/luin/ioredis?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge)\n[![Commitizen friendly](https://img.shields.io/badge/commitizen-friendly-brightgreen.svg)](http://commitizen.github.io/cz-cli/)\n[![semantic-release](https://img.shields.io/badge/%20%20%F0%9F%93%A6%F0%9F%9A%80-semantic--release-e10079.svg)](https://github.com/semantic-release/semantic-release)\n[![npm latest version](https://img.shields.io/npm/v/ioredis/latest.svg)](https://www.npmjs.com/package/ioredis)\n[![npm next version](https://img.shields.io/npm/v/ioredis/next.svg)](https://www.npmjs.com/package/ioredis)\n<img alt=\"\" src=\"\">\n\nA robust, performance-focused and full-featured [Redis](http://redis.io) client for [Node.js](https://nodejs.org).\n\nSupports Redis >= 2.6.12 and (Node.js >= 6).\n\n# Features\nioredis is a robust, full-featured Redis client that is\nused in the world's biggest online commerce company [Alibaba](http://www.alibaba.com/) and many other awesome companies.\n\n0. Full-featured. It supports [Cluster](http://redis.io/topics/cluster-tutorial), [Sentinel](http://redis.io/topics/sentinel), [Pipelining](http://redis.io/topics/pipelining) and of course [Lua scripting](http://redis.io/commands/eval) & [Pub/Sub](http://redis.io/topics/pubsub) (with the support of binary messages).\n0. High performance.\n0. Delightful API. It works with Node callbacks and Native promises.\n0. Transformation of command arguments and replies.\n0. Transparent key prefixing.\n0. Abstraction for Lua scripting, allowing you to define custom commands.\n0. Support for binary data.\n0. Support for TLS.\n0. Support for offline queue and ready checking.\n0. Support for ES6 types, such as `Map` and `Set`.\n0. Support for GEO commands (Redis 3.2 Unstable).\n0. Sophisticated error handling strategy.\n0. Support for NAT mapping.\n\n# Links\n* [API Documentation](API.md)\n* [Changelog](Changelog.md)\n* [Migrating from node_redis](https://github.com/luin/ioredis/wiki/Migrating-from-node_redis)\n* [Error Handling](#error-handling)\n\n## Become a Sponsor to Support ioredis's Development\nOpen source is hard and time-consuming. If you want to invest in ioredis's future you can become a sponsor and make us spend more time on this library's improvements and new features.\n\n<a href=\"https://opencollective.com/ioredis\"><img src=\"https://opencollective.com/ioredis/tiers/sponsor.svg?avatarHeight=36\"></a>\n\nThank you for using ioredis :-)\n\n<hr>\n<a href=\"https://itunes.apple.com/app/medis-gui-for-redis/id1063631769\"><img align=\"right\" src=\"medis.png\" alt=\"Download on the App Store\"></a>\n\n\n### Advertisement\n\nLooking for a Redis GUI manager for OS X, Windows and Linux? Here's [Medis](https://itunes.apple.com/us/app/medis-gui-for-redis/id1063631769)!\n\nMedis is an open-sourced, beautiful, easy-to-use Redis GUI management application.\n\nMedis starts with all the basic features you need:\n\n* Keys viewing/editing\n* SSH Tunnel for connecting with remote servers\n* Terminal for executing custom commands\n* JSON/MessagePack format viewing/editing and built-in highlighting/validator\n* And other awesome features...\n\n[Medis is open sourced on GitHub](https://github.com/luin/medis)\n\n<hr>\n\n# Quick Start\n\n## Install\n```shell\n$ npm install ioredis\n```\n\n## Basic Usage\n\n```javascript\nvar Redis = require('ioredis');\nvar redis = new Redis();\n\nredis.set('foo', 'bar');\nredis.get('foo', function (err, result) {\n  console.log(result);\n});\n\n// Or using a promise if the last argument isn't a function\nredis.get('foo').then(function (result) {\n  console.log(result);\n});\n\n// Arguments to commands are flattened, so the following are the same:\nredis.sadd('set', 1, 3, 5, 7);\nredis.sadd('set', [1, 3, 5, 7]);\n\n// All arguments are passed directly to the redis server:\nredis.set('key', 100, 'EX', 10);\n```\n\nSee the `examples/` folder for more examples.\n\n## Connect to Redis\nWhen a new `Redis` instance is created,\na connection to Redis will be created at the same time.\nYou can specify which Redis to connect to by:\n\n```javascript\nnew Redis()       // Connect to 127.0.0.1:6379\nnew Redis(6380)   // 127.0.0.1:6380\nnew Redis(6379, '192.168.1.1')        // 192.168.1.1:6379\nnew Redis('/tmp/redis.sock')\nnew Redis({\n  port: 6379,          // Redis port\n  host: '127.0.0.1',   // Redis host\n  family: 4,           // 4 (IPv4) or 6 (IPv6)\n  password: 'auth',\n  db: 0\n})\n```\n\nYou can also specify connection options as a [`redis://` URL](http://www.iana.org/assignments/uri-schemes/prov/redis):\n\n```javascript\n// Connect to 127.0.0.1:6380, db 4, using password \"authpassword\":\nnew Redis('redis://:authpassword@127.0.0.1:6380/4')\n```\n\nSee [API Documentation](API.md#new_Redis) for all available options.\n\n## Pub/Sub\n\nHere is a simple example of the API for publish/subscribe.\nThe following program opens two client connections.\nIt subscribes to a channel with one connection\nand publishes to that channel with the other:\n\n```javascript\nvar Redis = require('ioredis');\nvar redis = new Redis();\nvar pub = new Redis();\nredis.subscribe('news', 'music', function (err, count) {\n  // Now we are subscribed to both the 'news' and 'music' channels.\n  // `count` represents the number of channels we are currently subscribed to.\n\n  pub.publish('news', 'Hello world!');\n  pub.publish('music', 'Hello again!');\n});\n\nredis.on('message', function (channel, message) {\n  // Receive message Hello world! from channel news\n  // Receive message Hello again! from channel music\n  console.log('Receive message %s from channel %s', message, channel);\n});\n\n// There's also an event called 'messageBuffer', which is the same as 'message' except\n// it returns buffers instead of strings.\nredis.on('messageBuffer', function (channel, message) {\n  // Both `channel` and `message` are buffers.\n});\n```\n\n`PSUBSCRIBE` is also supported in a similar way:\n\n```javascript\nredis.psubscribe('pat?ern', function (err, count) {});\nredis.on('pmessage', function (pattern, channel, message) {});\nredis.on('pmessageBuffer', function (pattern, channel, message) {});\n```\n\nWhen a client issues a SUBSCRIBE or PSUBSCRIBE, that connection is put into a \"subscriber\" mode.\nAt that point, only commands that modify the subscription set are valid.\nWhen the subscription set is empty, the connection is put back into regular mode.\n\nIf you need to send regular commands to Redis while in subscriber mode, just open another connection.\n\n## Handle Binary Data\nArguments can be buffers:\n```javascript\nredis.set('foo', Buffer.from('bar'));\n```\n\nAnd every command has a method that returns a Buffer (by adding a suffix of \"Buffer\" to the command name).\nTo get a buffer instead of a utf8 string:\n\n```javascript\nredis.getBuffer('foo', function (err, result) {\n  // result is a buffer.\n});\n```\n\n## Pipelining\nIf you want to send a batch of commands (e.g. > 5), you can use pipelining to queue\nthe commands in memory and then send them to Redis all at once. This way the performance improves by 50%~300% (See [benchmark section](#benchmark)).\n\n`redis.pipeline()` creates a `Pipeline` instance. You can call any Redis\ncommands on it just like the `Redis` instance. The commands are queued in memory\nand flushed to Redis by calling the `exec` method:\n\n```javascript\nvar pipeline = redis.pipeline();\npipeline.set('foo', 'bar');\npipeline.del('cc');\npipeline.exec(function (err, results) {\n  // `err` is always null, and `results` is an array of responses\n  // corresponding to the sequence of queued commands.\n  // Each response follows the format `[err, result]`.\n});\n\n// You can even chain the commands:\nredis.pipeline().set('foo', 'bar').del('cc').exec(function (err, results) {\n});\n\n// `exec` also returns a Promise:\nvar promise = redis.pipeline().set('foo', 'bar').get('foo').exec();\npromise.then(function (result) {\n  // result === [[null, 'OK'], [null, 'bar']]\n});\n```\n\nEach chained command can also have a callback, which will be invoked when the command\ngets a reply:\n\n```javascript\nredis.pipeline().set('foo', 'bar').get('foo', function (err, result) {\n  // result === 'bar'\n}).exec(function (err, result) {\n  // result[1][1] === 'bar'\n});\n```\n\nIn addition to adding commands to the `pipeline` queue individually, you can also pass an array of commands and arguments to the constructor:\n\n```javascript\nredis.pipeline([\n  ['set', 'foo', 'bar'],\n  ['get', 'foo']\n]).exec(function () { /* ... */ });\n```\n\n`#length` property shows how many commands in the pipeline:\n\n```javascript\nconst length = redis.pipeline().set('foo', 'bar').get('foo').length;\n// length === 2\n```\n\n\n## Transaction\nMost of the time, the transaction commands `multi` & `exec` are used together with pipeline.\nTherefore, when `multi` is called, a `Pipeline` instance is created automatically by default,\nso you can use `multi` just like `pipeline`:\n\n```javascript\nredis.multi().set('foo', 'bar').get('foo').exec(function (err, results) {\n  // results === [[null, 'OK'], [null, 'bar']]\n});\n```\nIf there's a syntax error in the transaction's command chain (e.g. wrong number of arguments, wrong command name, etc),\nthen none of the commands would be executed, and an error is returned:\n\n```javascript\nredis.multi().set('foo').set('foo', 'new value').exec(function (err, results) {\n  // err:\n  //  { [ReplyError: EXECABORT Transaction discarded because of previous errors.]\n  //    name: 'ReplyError',\n  //    message: 'EXECABORT Transaction discarded because of previous errors.',\n  //    command: { name: 'exec', args: [] },\n  //    previousErrors:\n  //     [ { [ReplyError: ERR wrong number of arguments for 'set' command]\n  //         name: 'ReplyError',\n  //         message: 'ERR wrong number of arguments for \\'set\\' command',\n  //         command: [Object] } ] }\n});\n```\n\nIn terms of the interface, `multi` differs from `pipeline` in that when specifying a callback\nto each chained command, the queueing state is passed to the callback instead of the result of the command:\n\n```javascript\nredis.multi().set('foo', 'bar', function (err, result) {\n  // result === 'QUEUED'\n}).exec(/* ... */);\n```\n\nIf you want to use transaction without pipeline, pass `{ pipeline: false }` to `multi`,\nand every command will be sent to Redis immediately without waiting for an `exec` invocation:\n\n```javascript\nredis.multi({ pipeline: false });\nredis.set('foo', 'bar');\nredis.get('foo');\nredis.exec(function (err, result) {\n  // result === [[null, 'OK'], [null, 'bar']]\n});\n```\n\nThe constructor of `multi` also accepts a batch of commands:\n\n```javascript\nredis.multi([\n  ['set', 'foo', 'bar'],\n  ['get', 'foo']\n]).exec(function () { /* ... */ });\n```\n\nInline transactions are supported by pipeline, which means you can group a subset of commands\nin the pipeline into a transaction:\n\n```javascript\nredis.pipeline().get('foo').multi().set('foo', 'bar').get('foo').exec().get('foo').exec();\n```\n\n## Lua Scripting\nioredis supports all of the scripting commands such as `EVAL`, `EVALSHA` and `SCRIPT`.\nHowever, it's tedious to use in real world scenarios since developers have to take\ncare of script caching and to detect when to use `EVAL` and when to use `EVALSHA`.\nioredis expose a `defineCommand` method to make scripting much easier to use:\n\n```javascript\nvar redis = new Redis();\n\n// This will define a command echo:\nredis.defineCommand('echo', {\n  numberOfKeys: 2,\n  lua: 'return {KEYS[1],KEYS[2],ARGV[1],ARGV[2]}'\n});\n\n// Now `echo` can be used just like any other ordinary command,\n// and ioredis will try to use `EVALSHA` internally when possible for better performance.\nredis.echo('k1', 'k2', 'a1', 'a2', function (err, result) {\n  // result === ['k1', 'k2', 'a1', 'a2']\n});\n\n// `echoBuffer` is also defined automatically to return buffers instead of strings:\nredis.echoBuffer('k1', 'k2', 'a1', 'a2', function (err, result) {\n  // result[0] equals to Buffer.from('k1');\n});\n\n// And of course it works with pipeline:\nredis.pipeline().set('foo', 'bar').echo('k1', 'k2', 'a1', 'a2').exec();\n```\n\nIf the number of keys can't be determined when defining a command, you can\nomit the `numberOfKeys` property and pass the number of keys as the first argument\nwhen you call the command:\n\n```javascript\nredis.defineCommand('echoDynamicKeyNumber', {\n  lua: 'return {KEYS[1],KEYS[2],ARGV[1],ARGV[2]}'\n});\n\n// Now you have to pass the number of keys as the first argument every time\n// you invoke the `echoDynamicKeyNumber` command:\nredis.echoDynamicKeyNumber(2, 'k1', 'k2', 'a1', 'a2', function (err, result) {\n  // result === ['k1', 'k2', 'a1', 'a2']\n});\n```\n\n## Transparent Key Prefixing\nThis feature allows you to specify a string that will automatically be prepended\nto all the keys in a command, which makes it easier to manage your key\nnamespaces.\n\n**Warning** This feature won't apply to commands like [KEYS](http://redis.io/commands/KEYS) and [SCAN](http://redis.io/commands/scan) that take patterns rather than actual keys([#239](https://github.com/luin/ioredis/issues/239)),\nand this feature also won't apply to the replies of commands even they are key names ([#325](https://github.com/luin/ioredis/issues/325)).\n\n```javascript\nvar fooRedis = new Redis({ keyPrefix: 'foo:' });\nfooRedis.set('bar', 'baz');  // Actually sends SET foo:bar baz\n\nfooRedis.defineCommand('echo', {\n  numberOfKeys: 2,\n  lua: 'return {KEYS[1],KEYS[2],ARGV[1],ARGV[2]}'\n});\n\n// Works well with pipelining/transaction\nfooRedis.pipeline()\n  // Sends SORT foo:list BY foo:weight_*->fieldname\n  .sort('list', 'BY', 'weight_*->fieldname')\n  // Supports custom commands\n  // Sends EVALSHA xxx foo:k1 foo:k2 a1 a2\n  .echo('k1', 'k2', 'a1', 'a2')\n  .exec()\n```\n\n## Transforming Arguments & Replies\nMost Redis commands take one or more Strings as arguments,\nand replies are sent back as a single String or an Array of Strings. However, sometimes\nyou may want something different. For instance, it would be more convenient if the `HGETALL`\ncommand returns a hash (e.g. `{ key: val1, key2: v2 }`) rather than an array of key values (e.g. `[key1, val1, key2, val2]`).\n\nioredis has a flexible system for transforming arguments and replies. There are two types\nof transformers, argument transformer and reply transformer:\n\n```javascript\nvar Redis = require('ioredis');\n\n// Here's the built-in argument transformer converting\n// hmset('key', { k1: 'v1', k2: 'v2' })\n// or\n// hmset('key', new Map([['k1', 'v1'], ['k2', 'v2']]))\n// into\n// hmset('key', 'k1', 'v1', 'k2', 'v2')\nRedis.Command.setArgumentTransformer('hmset', function (args) {\n  if (args.length === 2) {\n    if (typeof Map !== 'undefined' && args[1] instanceof Map) {\n      // utils is a internal module of ioredis\n      return [args[0]].concat(utils.convertMapToArray(args[1]));\n    }\n    if ( typeof args[1] === 'object' && args[1] !== null) {\n      return [args[0]].concat(utils.convertObjectToArray(args[1]));\n    }\n  }\n  return args;\n});\n\n// Here's the built-in reply transformer converting the HGETALL reply\n// ['k1', 'v1', 'k2', 'v2']\n// into\n// { k1: 'v1', 'k2': 'v2' }\nRedis.Command.setReplyTransformer('hgetall', function (result) {\n  if (Array.isArray(result)) {\n    var obj = {};\n    for (var i = 0; i < result.length; i += 2) {\n      obj[result[i]] = result[i + 1];\n    }\n    return obj;\n  }\n  return result;\n});\n```\n\nThere are three built-in transformers, two argument transformers for `hmset` & `mset` and\na reply transformer for `hgetall`. Transformers for `hmset` and `hgetall` were mentioned\nabove, and the transformer for `mset` is similar to the one for `hmset`:\n\n```javascript\nredis.mset({ k1: 'v1', k2: 'v2' });\nredis.get('k1', function (err, result) {\n  // result === 'v1';\n});\n\nredis.mset(new Map([['k3', 'v3'], ['k4', 'v4']]));\nredis.get('k3', function (err, result) {\n  // result === 'v3';\n});\n```\n\nAnother useful example of a reply transformer is one that changes `hgetall` to return array of arrays instead of objects which avoids a unwanted conversation of hash keys to strings when dealing with binary hash keys:\n\n```javascript\nRedis.Command.setReplyTransformer('hgetall', function (result) {\n  var arr = [];\n  for (var i = 0; i < result.length; i += 2) {\n    arr.push([result[i], result[i + 1]]);\n  }\n  return arr;\n});\nredis.hset('h1', Buffer.from([0x01]), Buffer.from([0x02]));\nredis.hset('h1', Buffer.from([0x03]), Buffer.from([0x04]));\nredis.hgetallBuffer('h1', function (err, result) {\n  // result === [ [ <Buffer 01>, <Buffer 02> ], [ <Buffer 03>, <Buffer 04> ] ];\n});\n```\n\n## Monitor\nRedis supports the MONITOR command,\nwhich lets you see all commands received by the Redis server across all client connections,\nincluding from other client libraries and other computers.\n\nThe `monitor` method returns a monitor instance.\nAfter you send the MONITOR command, no other commands are valid on that connection. ioredis will emit a monitor event for every new monitor message that comes across.\nThe callback for the monitor event takes a timestamp from the Redis server and an array of command arguments.\n\nHere is a simple example:\n\n```javascript\nredis.monitor(function (err, monitor) {\n  monitor.on('monitor', function (time, args, source, database) {\n  });\n});\n```\n\n## Streamify Scanning\nRedis 2.8 added the `SCAN` command to incrementally iterate through the keys in the database. It's different from `KEYS` in that\n`SCAN` only returns a small number of elements each call, so it can be used in production without the downside\nof blocking the server for a long time. However, it requires recording the cursor on the client side each time\nthe `SCAN` command is called in order to iterate through all the keys correctly. Since it's a relatively common use case, ioredis\nprovides a streaming interface for the `SCAN` command to make things much easier. A readable stream can be created by calling `scanStream`:\n\n```javascript\nvar redis = new Redis();\n// Create a readable stream (object mode)\nvar stream = redis.scanStream();\nstream.on('data', function (resultKeys) {\n  // `resultKeys` is an array of strings representing key names.\n  // Note that resultKeys may contain 0 keys, and that it will sometimes\n  // contain duplicates due to SCAN's implementation in Redis.\n  for (var i = 0; i < resultKeys.length; i++) {\n    console.log(resultKeys[i]);\n  }\n});\nstream.on('end', function () {\n  console.log('all keys have been visited');\n});\n```\n\n`scanStream` accepts an option, with which you can specify the `MATCH` pattern and the `COUNT` argument:\n\n```javascript\nvar stream = redis.scanStream({\n  // only returns keys following the pattern of `user:*`\n  match: 'user:*',\n  // returns approximately 100 elements per call\n  count: 100\n});\n```\n\nJust like other commands, `scanStream` has a binary version `scanBufferStream`, which returns an array of buffers. It's useful when\nthe key names are not utf8 strings.\n\nThere are also `hscanStream`, `zscanStream` and `sscanStream` to iterate through elements in a hash, zset and set. The interface of each is\nsimilar to `scanStream` except the first argument is the key name:\n\n```javascript\nvar stream = redis.hscanStream('myhash', {\n  match: 'age:??'\n});\n```\n\nYou can learn more from the [Redis documentation](http://redis.io/commands/scan).\n\n**Useful Tips**\nIt's pretty common that doing an async task in the `data` handler. We'd like the scanning process to be paused until the async task to be finished. `Stream#pause()` and `Stream.resume()` do the trick. For example if we want to migrate data in Redis to MySQL:\n\n```javascript\nvar stream = redis.scanStream();\nstream.on('data', function (resultKeys) {\n  // Pause the stream from scanning more keys until we've migrated the current keys.\n  stream.pause();\n\n  Promise.all(resultKeys.map(migrateKeyToMySQL)).then(() => {\n    // Resume the stream here.\n    stream.resume();\n  });\n});\n\nstream.on('end', function () {\n  console.log('done migration');\n});\n```\n\n## Auto-reconnect\nBy default, ioredis will try to reconnect when the connection to Redis is lost\nexcept when the connection is closed manually by `redis.disconnect()` or `redis.quit()`.\n\nIt's very flexible to control how long to wait to reconnect after disconnection\nusing the `retryStrategy` option:\n\n```javascript\nvar redis = new Redis({\n  // This is the default value of `retryStrategy`\n  retryStrategy: function (times) {\n    var delay = Math.min(times * 50, 2000);\n    return delay;\n  }\n});\n```\n\n`retryStrategy` is a function that will be called when the connection is lost.\nThe argument `times` means this is the nth reconnection being made and\nthe return value represents how long (in ms) to wait to reconnect. When the\nreturn value isn't a number, ioredis will stop trying to reconnect, and the connection\nwill be lost forever if the user doesn't call `redis.connect()` manually.\n\nWhen reconnected, the client will auto subscribe to channels that the previous connection subscribed to.\nThis behavior can be disabled by setting the `autoResubscribe` option to `false`.\n\nAnd if the previous connection has some unfulfilled commands (most likely blocking commands such as `brpop` and `blpop`),\nthe client will resend them when reconnected. This behavior can be disabled by setting the `autoResendUnfulfilledCommands` option to `false`.\n\nBy default, all pending commands will be flushed with an error every 20 retry attempts. That makes sure commands won't wait forever when the connection is down. You can change this behavior by setting `maxRetriesPerRequest`:\n\n```javascript\nvar redis = new Redis({\n  maxRetriesPerRequest: 1\n});\n```\n\nSet maxRetriesPerRequest to `null` to disable this behavior, and every command will wait forever until the connection is alive again (which is the default behavior before ioredis v4).\n\n### Reconnect on error\n\nBesides auto-reconnect when the connection is closed, ioredis supports reconnecting on the specified errors by the `reconnectOnError` option. Here's an example that will reconnect when receiving `READONLY` error:\n\n```javascript\nvar redis = new Redis({\n  reconnectOnError: function (err) {\n    var targetError = 'READONLY';\n    if (err.message.slice(0, targetError.length) === targetError) {\n      // Only reconnect when the error starts with \"READONLY\"\n      return true; // or `return 1;`\n    }\n  }\n});\n```\n\nThis feature is useful when using Amazon ElastiCache. Once failover happens, Amazon ElastiCache will switch the master we currently connected with to a slave, leading to the following writes fails with the error `READONLY`. Using `reconnectOnError`, we can force the connection to reconnect on this error in order to connect to the new master.\n\nFurthermore, if the `reconnectOnError` returns `2`, ioredis will resend the failed command after reconnecting.\n\n## Connection Events\nThe Redis instance will emit some events about the state of the connection to the Redis server.\n\nEvent    | Description\n:------------- | :-------------\nconnect  | emits when a connection is established to the Redis server.\nready    | If `enableReadyCheck` is `true`, client will emit `ready` when the server reports that it is ready to receive commands (e.g. finish loading data from disk).<br>Otherwise, `ready` will be emitted immediately right after the `connect` event.\nerror    | emits when an error occurs while connecting.<br>However, ioredis emits all `error` events silently (only emits when there's at least one listener) so that your application won't crash if you're not listening to the `error` event.\nclose    | emits when an established Redis server connection has closed.\nreconnecting | emits after `close` when a reconnection will be made. The argument of the event is the time (in ms) before reconnecting.\nend     | emits after `close` when no more reconnections will be made, or the connection is failed to establish.\n\nYou can also check out the `Redis#status` property to get the current connection status.\n\nBesides the above connection events, there are several other custom events:\n\nEvent    | Description\n:------------- | :-------------\nselect   | emits when the database changed. The argument is the new db number.\n\n## Offline Queue\nWhen a command can't be processed by Redis (being sent before the `ready` event), by default, it's added to the offline queue and will be\nexecuted when it can be processed. You can disable this feature by setting the `enableOfflineQueue`\noption to `false`:\n\n```javascript\nvar redis = new Redis({ enableOfflineQueue: false });\n```\n\n## TLS Options\nRedis doesn't support TLS natively, however if the redis server you want to connect to is hosted behind a TLS proxy (e.g. [stunnel](https://www.stunnel.org/)) or is offered by a PaaS service that supports TLS connection (e.g. [Redis Labs](https://redislabs.com/)), you can set the `tls` option:\n\n```javascript\nvar redis = new Redis({\n  host: 'localhost',\n  tls: {\n    // Refer to `tls.connect()` section in\n    // https://nodejs.org/api/tls.html\n    // for all supported options\n    ca: fs.readFileSync('cert.pem')\n  }\n});\n```\n\n<hr>\n\n## Sentinel\nioredis supports Sentinel out of the box. It works transparently as all features that work when\nyou connect to a single node also work when you connect to a sentinel group. Make sure to run Redis >= 2.8.12 if you want to use this feature. Sentinels have a default port of 26379.\n\nTo connect using Sentinel, use:\n\n```javascript\nvar redis = new Redis({\n  sentinels: [{ host: 'localhost', port: 26379 }, { host: 'localhost', port: 26380 }],\n  name: 'mymaster'\n});\n\nredis.set('foo', 'bar');\n```\n\nThe arguments passed to the constructor are different from the ones you use to connect to a single node, where:\n\n* `name` identifies a group of Redis instances composed of a master and one or more slaves (`mymaster` in the example);\n* `sentinels` are a list of sentinels to connect to. The list does not need to enumerate all your sentinel instances, but a few so that if one is down the client will try the next one.\n* `role` (optional) with a value of `slave` will return a random slave from the Sentinel group.\n* `preferredSlaves` (optional) can be used to prefer a particular slave or set of slaves based on priority. It accepts a function or array.\n\nioredis **guarantees** that the node you connected to is always a master even after a failover. When a failover happens, instead of trying to reconnect to the failed node (which will be demoted to slave when it's available again), ioredis will ask sentinels for the new master node and connect to it. All commands sent during the failover are queued and will be executed when the new connection is established so that none of the commands will be lost.\n\nIt's possible to connect to a slave instead of a master by specifying the option `role` with the value of `slave` and ioredis will try to connect to a random slave of the specified master, with the guarantee that the connected node is always a slave. If the current node is promoted to master due to a failover, ioredis will disconnect from it and ask the sentinels for another slave node to connect to.\n\nIf you specify the option `preferredSlaves` along with `role: 'slave'` ioredis will attempt to use this value when selecting the slave from the pool of available slaves. The value of `preferredSlaves` should either be a function that accepts an array of avaiable slaves and returns a single result, or an array of slave values priorities by the lowest `prio` value first with a default value of `1`.\n\n```javascript\n// available slaves format\nvar availableSlaves = [{ ip: '127.0.0.1', port: '31231', flags: 'slave' }];\n\n// preferredSlaves array format\nvar preferredSlaves = [\n  { ip: '127.0.0.1', port: '31231', prio: 1 },\n  { ip: '127.0.0.1', port: '31232', prio: 2 }\n];\n\n// preferredSlaves function format\npreferredSlaves = function(availableSlaves) {\n  for (var i = 0; i < availableSlaves.length; i++) {\n    var slave = availableSlaves[i];\n    if (slave.ip === '127.0.0.1') {\n      if (slave.port === '31234') {\n        return slave;\n      }\n    }\n  }\n  // if no preferred slaves are available a random one is used\n  return false;\n};\n\nvar redis = new Redis({\n  sentinels: [{ host: '127.0.0.1', port: 26379 }, { host: '127.0.0.1', port: 26380 }],\n  name: 'mymaster',\n  role: 'slave',\n  preferredSlaves: preferredSlaves\n});\n```\n\nBesides the `retryStrategy` option, there's also a `sentinelRetryStrategy` in Sentinel mode which will be invoked when all the sentinel nodes are unreachable during connecting. If `sentinelRetryStrategy` returns a valid delay time, ioredis will try to reconnect from scratch. The default value of `sentinelRetryStrategy` is:\n\n```javascript\nfunction (times) {\n  var delay = Math.min(times * 10, 1000);\n  return delay;\n}\n```\n\n## Cluster\nRedis Cluster provides a way to run a Redis installation where data is automatically sharded across multiple Redis nodes.\nYou can connect to a Redis Cluster like this:\n\n```javascript\nvar Redis = require('ioredis');\n\nvar cluster = new Redis.Cluster([{\n  port: 6380,\n  host: '127.0.0.1'\n}, {\n  port: 6381,\n  host: '127.0.0.1'\n}]);\n\ncluster.set('foo', 'bar');\ncluster.get('foo', function (err, res) {\n  // res === 'bar'\n});\n```\n\n`Cluster` constructor accepts two arguments, where:\n\n0. The first argument is a list of nodes of the cluster you want to connect to.\nJust like Sentinel, the list does not need to enumerate all your cluster nodes,\nbut a few so that if one is unreachable the client will try the next one, and the client will discover other nodes automatically when at least one node is connected.\n0. The second argument is the options, where:\n\n    * `clusterRetryStrategy`: When none of the startup nodes are reachable, `clusterRetryStrategy` will be invoked. When a number is returned,\n    ioredis will try to reconnect to the startup nodes from scratch after the specified delay (in ms). Otherwise, an error of \"None of startup nodes is available\" will be returned.\n    The default value of this option is:\n\n        ```javascript\n        function (times) {\n          var delay = Math.min(100 + times * 2, 2000);\n          return delay;\n        }\n        ```\n\n        It's possible to modify the `startupNodes` property in order to switch to another set of nodes here:\n\n        ```javascript\n        function (times) {\n          this.startupNodes = [{ port: 6790, host: '127.0.0.1' }];\n          return Math.min(100 + times * 2, 2000);\n        }\n        ```\n\n    * `enableOfflineQueue`: Similar to the `enableOfflineQueue` option of `Redis` class.\n    * `enableReadyCheck`: When enabled, \"ready\" event will only be emitted when `CLUSTER INFO` command\n    reporting the cluster is ready for handling commands. Otherwise, it will be emitted immediately after \"connect\" is emitted.\n    * `scaleReads`: Config where to send the read queries. See below for more details.\n    * `maxRedirections`: When a cluster related error (e.g. `MOVED`, `ASK` and `CLUSTERDOWN` etc.) is received, the client will redirect the\n    command to another node. This option limits the max redirections allowed when sending a command. The default value is `16`.\n    * `retryDelayOnFailover`: If the target node is disconnected when sending a command,\n    ioredis will retry after the specified delay. The default value is `100`. You should make sure `retryDelayOnFailover * maxRedirections > cluster-node-timeout`\n    to insure that no command will fail during a failover.\n    * `retryDelayOnClusterDown`: When a cluster is down, all commands will be rejected with the error of `CLUSTERDOWN`. If this option is a number (by default, it is `100`), the client\n    will resend the commands after the specified time (in ms).\n    * `retryDelayOnTryAgain`: If this option is a number (by default, it is `100`), the client\n    will resend the commands rejected with `TRYAGAIN` error after the specified time (in ms).\n    * `redisOptions`: Default options passed to the constructor of `Redis` when connecting to a node.\n    * `slotsRefreshTimeout`: Milliseconds before a timeout occurs while refreshing slots from the cluster (default `1000`)\n    * `slotsRefreshInterval`: Milliseconds between every automatic slots refresh (default `5000`)\n\n### Read-write splitting\n\nA typical redis cluster contains three or more masters and several slaves for each master. It's possible to scale out redis cluster by sending read queries to slaves and write queries to masters by setting the `scaleReads` option.\n\n`scaleReads` is \"master\" by default, which means ioredis will never send any queries to slaves. There are other three available options:\n\n1. \"all\": Send write queries to masters and read queries to masters or slaves randomly.\n2. \"slave\": Send write queries to masters and read queries to slaves.\n3. a custom `function(nodes, command): node`: Will choose the custom function to select to which node to send read queries (write queries keep being sent to master). The first node in `nodes` is always the master serving the relevant slots. If the function returns an array of nodes, a random node of that list will be selected.\n\nFor example:\n\n```javascript\nvar cluster = new Redis.Cluster([/* nodes */], {\n  scaleReads: 'slave'\n});\ncluster.set('foo', 'bar'); // This query will be sent to one of the masters.\ncluster.get('foo', function (err, res) {\n  // This query will be sent to one of the slaves.\n});\n```\n\n**NB** In the code snippet above, the `res` may not be equal to \"bar\" because of the lag of replication between the master and slaves.\n\n### Running commands to multiple nodes\n\nEvery command will be sent to exactly one node. For commands containing keys, (e.g. `GET`, `SET` and `HGETALL`), ioredis sends them to the node that serving the keys, and for other commands not containing keys, (e.g. `INFO`, `KEYS` and `FLUSHDB`), ioredis sends them to a random node.\n\nSometimes you may want to send a command to multiple nodes (masters or slaves) of the cluster, you can get the nodes via `Cluster#nodes()` method.\n\n`Cluster#nodes()` accepts a parameter role, which can be \"master\", \"slave\" and \"all\" (default), and returns an array of `Redis` instance. For example:\n\n```javascript\n// Send `FLUSHDB` command to all slaves:\nvar slaves = cluster.nodes('slave');\nPromise.all(slaves.map(function (node) {\n  return node.flushdb();\n}));\n\n// Get keys of all the masters:\nvar masters = cluster.nodes('master');\nPromise.all(masters.map(function (node) {\n  return node.keys();\n})).then(function (keys) {\n  // keys: [['key1', 'key2'], ['key3', 'key4']]\n});\n```\n\n### NAT Mapping\nSometimes the cluster is hosted within a internal network that can only be accessed via a NAT (Network Address Translation) instance. See [Accessing ElastiCache from outside AWS](https://docs.aws.amazon.com/AmazonElastiCache/latest/red-ug/accessing-elasticache.html) as an example.\n\nYou can specify nat mapping rules via `natMap` option:\n\n```javascript\nconst cluster = new Redis.Cluster([{\n  host: '203.0.113.73',\n  port: 30001\n}], {\n  natMap: {\n    '10.0.1.230:30001': {host: '203.0.113.73', port: 30001},\n    '10.0.1.231:30001': {host: '203.0.113.73', port: 30002},\n    '10.0.1.232:30001': {host: '203.0.113.73', port: 30003}\n  }\n})\n```\n\nThis option is also useful when the cluster is running inside a Docker container.\n\n### Transaction and pipeline in Cluster mode\nAlmost all features that are supported by `Redis` are also supported by `Redis.Cluster`, e.g. custom commands, transaction and pipeline.\nHowever there are some differences when using transaction and pipeline in Cluster mode:\n\n0. All keys in a pipeline should belong to the same slot since ioredis sends all commands in a pipeline to the same node.\n0. You can't use `multi` without pipeline (aka `cluster.multi({ pipeline: false })`). This is because when you call `cluster.multi({ pipeline: false })`, ioredis doesn't know which node the `multi` command should be sent to.\n0. Chaining custom commands in the pipeline is not supported in Cluster mode.\n\nWhen any commands in a pipeline receives a `MOVED` or `ASK` error, ioredis will resend the whole pipeline to the specified node automatically if all of the following conditions are satisfied:\n\n0. All errors received in the pipeline are the same. For example, we won't resend the pipeline if we got two `MOVED` errors pointing to different nodes.\n0. All commands executed successfully are readonly commands. This makes sure that resending the pipeline won't have side effects.\n\n### Pub/Sub\nPub/Sub in cluster mode works exactly as the same as in standalone mode. Internally, when a node of the cluster receives a message, it will broadcast the message to the other nodes. ioredis makes sure that each message will only be received once by strictly subscribing one node at the same time.\n\n```javascript\nvar nodes = [/* nodes */];\nvar pub = new Redis.Cluster(nodes);\nvar sub = new Redis.Cluster(nodes);\nsub.on('message', function (channel, message) {\n  console.log(channel, message);\n});\n\nsub.subscribe('news', function () {\n  pub.publish('news', 'highlights');\n});\n```\n\n### Events\n\nEvent    | Description\n:------------- | :-------------\nconnect  | emits when a connection is established to the Redis server.\nready    | emits when `CLUSTER INFO` reporting the cluster is able to receive commands (if `enableReadyCheck` is `true`) or immediately after `connect` event (if `enableReadyCheck` is false).\nerror    | emits when an error occurs while connecting with a property of `lastNodeError` representing the last node error received. This event is emitted silently (only emitting if there's at least one listener).\nclose    | emits when an established Redis server connection has closed.\nreconnecting | emits after `close` when a reconnection will be made. The argument of the event is the time (in ms) before reconnecting.\nend     | emits after `close` when no more reconnections will be made.\n+node   | emits when a new node is connected.\n-node   | emits when a node is disconnected.\nnode error | emits when an error occurs when connecting to a node\n\n### Password\nSetting the `password` option to access password-proctected clusters:\n\n```javascript\nvar Redis = require('ioredis');\nvar cluster = new Redis.Cluster(nodes, {\n  redisOptions: {\n    password: 'your-cluster-password'\n  }\n});\n```\n\nIf some of nodes in the cluster using a different password, you should specify them in the first parameter:\n\n```javascript\nvar Redis = require('ioredis');\nvar cluster = new Redis.Cluster([\n  // Use password \"password-for-30001\" for 30001\n  { port: 30001, password: 'password-for-30001'},\n  // Don't use password when accessing 30002\n  { port: 30002, password: null }\n  // Other nodes will use \"fallback-password\"\n], {\n  redisOptions: {\n    password: 'fallback-password'\n  }\n});\n```\n\n<hr>\n\n# Error Handling\nAll the errors returned by the Redis server are instances of `ReplyError`, which can be accessed via `Redis`:\n\n```javascript\nvar Redis = require('ioredis');\nvar redis = new Redis();\n// This command causes a reply error since the SET command requires two arguments.\nredis.set('foo', function (err) {\n  err instanceof Redis.ReplyError\n});\n```\n\nThis is the error stack of the `ReplyError`:\n\n```\nReplyError: ERR wrong number of arguments for 'set' command\n    at ReplyParser._parseResult (/app/node_modules/ioredis/lib/parsers/javascript.js:60:14)\n    at ReplyParser.execute (/app/node_modules/ioredis/lib/parsers/javascript.js:178:20)\n    at Socket.<anonymous> (/app/node_modules/ioredis/lib/redis/event_handler.js:99:22)\n    at Socket.emit (events.js:97:17)\n    at readableAddChunk (_stream_readable.js:143:16)\n    at Socket.Readable.push (_stream_readable.js:106:10)\n    at TCP.onread (net.js:509:20)\n```\n\nBy default, the error stack doesn't make any sense because the whole stack happens in the ioredis\nmodule itself, not in your code. So it's not easy to find out where the error happens in your code.\nioredis provides an option `showFriendlyErrorStack` to solve the problem. When you enable\n`showFriendlyErrorStack`, ioredis will optimize the error stack for you:\n\n```javascript\nvar Redis = require('ioredis');\nvar redis = new Redis({ showFriendlyErrorStack: true });\nredis.set('foo');\n```\n\nAnd the output will be:\n\n```\nReplyError: ERR wrong number of arguments for 'set' command\n    at Object.<anonymous> (/app/index.js:3:7)\n    at Module._compile (module.js:446:26)\n    at Object.Module._extensions..js (module.js:464:10)\n    at Module.load (module.js:341:32)\n    at Function.Module._load (module.js:296:12)\n    at Function.Module.runMain (module.js:487:10)\n    at startup (node.js:111:16)\n    at node.js:799:3\n```\n\nThis time the stack tells you that the error happens on the third line in your code. Pretty sweet!\nHowever, it would decrease the performance significantly to optimize the error stack. So by\ndefault, this option is disabled and can only be used for debugging purposes. You **shouldn't** use this feature in a production environment.\n\n# Plugging in your own Promises Library\nIf you're an advanced user, you may want to plug in your own promise library like [bluebird](https://www.npmjs.com/package/bluebird). Just set Redis.Promise to your favorite ES6-style promise constructor and ioredis will use it.\n\n```javascript\nconst Redis = require('ioredis')\nRedis.Promise = require('bluebird')\n\nconst redis = new Redis()\n\n// Use bluebird\nassert.equal(redis.get().constructor, require('bluebird'))\n\n// You can change the Promise implementation at any time:\nRedis.Promise = global.Promise\nassert.equal(redis.get().constructor, global.Promise)\n```\n\n\n# Running tests\n\nStart a Redis server on 127.0.0.1:6379, and then:\n\n```shell\n$ npm test\n```\n\n`FLUSH ALL` will be invoked after each test, so make sure there's no valuable data in it before running tests.\n\nIf your testing environment does not let you spin up a Redis server [ioredis-mock](https://github.com/stipsan/ioredis-mock) is a drop-in replacement you can use in your tests. It aims to behave identically to ioredis connected to a Redis server so that your integration tests is easier to write and of better quality.\n\n# Debug\n\nYou can set the `DEBUG` env to `ioredis:*` to print debug info:\n\n```shell\n$ DEBUG=ioredis:* node app.js\n```\n\n# Consolidation: It's time for celebration\n\nRight now there are two great redis clients around and both have some advantages above each other. We speak about [node_redis](https://github.com/NodeRedis/node_redis) and ioredis. So after talking to each other about how we could improve in working together we (that is [@BridgeAR](https://github.com/BridgeAR) and [@luin](https://github.com/luin)) decided to work towards a single library on the long run. But step by step.\n\nFirst of all, we want to split small parts of our libraries into others so that we're both able to use the same code. Those libraries are going to be maintained under the NodeRedis organization. This is going to reduce the maintance overhead, allows others to use the very same code, if they need it and it's way easier for others to contribute to both libraries.\n\nWe're very happy about this step towards working together as we both want to give you the best redis experience possible.\n\nIf you want to join our cause by help maintaining something, please don't hesitate to contact either one of us.\n\n# Join in!\n\nI'm happy to receive bug reports, fixes, documentation enhancements, and any other improvements.\n\nAnd since I'm not a native English speaker, if you find any grammar mistakes in the documentation, please also let me know. :)\n\n# Contributors\n\nThis project exists thanks to all the people who contribute:\n\n<a href=\"https://github.com/luin/ioredis/graphs/contributors\"><img src=\"https://opencollective.com/ioredis/contributors.svg?width=890&showBtn=false\" /></a>\n\n# License\n\nMIT\n","readmeFilename":"README.md","bugs":{"url":"https://github.com/luin/ioredis/issues"},"homepage":"https://github.com/luin/ioredis#readme","_id":"ioredis@4.3.1","_npmVersion":"6.4.1","_nodeVersion":"10.14.2","_npmUser":{"name":"ioredis-robot","email":"ioredis-robot@zihua.li"},"dist":{"integrity":"sha512-gcpvPXDQm9FvLCq978y4C1jNmRnDEqk3p0Y5qfobN2FMzHC/iAnHbbz/ChELuwpQ5/YCWSI1DydmQguUUMLfEQ==","shasum":"5254e240619f54984824e08fce658cc77bd35129","tarball":"https://registry.npmjs.org/ioredis/-/ioredis-4.3.1.tgz","fileCount":35,"unpackedSize":215413,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJcFmIgCRA9TVsSAnZWagAAil4QAIzljVjJStkf3PnPQD9u\nIvduJqCpGqtRmxrm3Lpt0BIIOZFmg2NRveAQWiP7Af+7HoiriG87Dd8CLFD3\nclX38hQq6NpH0hYxEbGDvIniMEAa/BcOz8BnpBij6r4Ler96KLjkeHppIpap\nlZtDvUVeCT4FN39W3Efr2GLffxoBUlyf9T62GdUomFGwdPpWGUPglSlFlOEQ\nZFjWtU9r6UvVL9phgq48GSWMiZd1LWEfJZKPnjN2GgEEXWeHG6n70xMQ2yS0\nJClw1P7YoqcF7TReYI25Z5JyhEDGbPWdVwUXvgQTfDb3XbqEfZMZW+/73tHC\n1+G0o1fAaoG0xf17X+xrpyCynmDBZVon/MMWajqS46pZeCfOPMRf/sI8XcJ5\nZAavTStauG1CJioRhsUJoo1/aUWBGB+BALmQtytbBjIJyr7CMu+zjmqqvmWw\nP++HSvI7AlUL9yXrUH8vQ9BaVDZjRQNLa8hyXr5EkXi0lxHnwsezo5REJImu\nAgbsOUHh9CGleV2xzlh66bduRcL8TtZAOVNvLdGjQzPlwsh5Zjw85TQ6p/hd\ntQRAZHg0YVqc2cJLy2LR7W6eZLJvRwcf9421EG4zWC2USU89SLuta6/4sMwN\nY/Jr6BdeTjk/u7yFbvLqd/OI4sEs7lKLKE1X24fF/yarWZ0dUoLtZ+2iFDBx\nwB0W\r\n=CjUa\r\n-----END PGP SIGNATURE-----\r\n"},"maintainers":[{"email":"ioredis-robot@zihua.li","name":"ioredis-robot"},{"email":"i@zihua.li","name":"luin"}],"directories":{},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/ioredis_4.3.1_1544970782933_0.2508853093376622"},"_hasShrinkwrap":false},"4.4.0":{"name":"ioredis","version":"4.4.0","description":"A robust, performance-focused and full-featured Redis client for Node.js.","main":"built/index.js","scripts":{"test":"NODE_ENV=test mocha --timeout 8000 -r ts-node/register --exit","test:cov":"NODE_ENV=test node ./node_modules/istanbul/lib/cli.js cover --preserve-comments ./node_modules/mocha/bin/_mocha -- -r ts-node/register -R spec --exit","build":"rm -rf built && tsc","generate-docs":"jsdoc2md lib/redis.js lib/cluster/index.js lib/commander.js > API.md","prepublishOnly":"npm run build && npm test","bench":"matcha benchmarks/*.js","semantic-release":"semantic-release"},"repository":{"type":"git","url":"git://github.com/luin/ioredis.git"},"keywords":["redis","cluster","sentinel","pipelining"],"author":{"name":"luin","email":"i@zihua.li","url":"http://zihua.li"},"license":"MIT","dependencies":{"cluster-key-slot":"^1.0.6","debug":"^3.1.0","denque":"^1.1.0","flexbuffer":"0.0.6","lodash.defaults":"^4.2.0","lodash.flatten":"^4.4.0","redis-commands":"1.4.0","redis-errors":"^1.2.0","redis-parser":"^3.0.0","standard-as-callback":"^1.0.0"},"devDependencies":{"@semantic-release/changelog":"^3.0.0","@semantic-release/git":"^7.0.4","@types/node":"^10.11.5","@types/redis-errors":"1.2.0","bluebird":"^3.5.1","chai":"^3.5.0","cz-conventional-changelog":"^2.0.0","istanbul":"^0.4.2","jsdoc":"^3.4.0","jsdoc-to-markdown":"^4.0.1","mocha":"^5.2.0","server-destroy":"^1.0.1","sinon":"^1.17.3","ts-node":"^7.0.0","typescript":"^3.1.1"},"engines":{"node":">=6"},"config":{"commitizen":{"path":"./node_modules/cz-conventional-changelog"}},"gitHead":"16bddc3102d2e2afb9cb3ae7494b30a56d6a241d","readme":"[![ioredis](https://cdn.rawgit.com/luin/ioredis/57b5b89e3e9111ff25d8c62c0bc58ed42e5b8d1e/logo.svg)](https://github.com/luin/ioredis)\n\n[![Build Status](https://travis-ci.org/luin/ioredis.svg?branch=master)](https://travis-ci.org/luin/ioredis)\n[![Test Coverage](https://codeclimate.com/github/luin/ioredis/badges/coverage.svg)](https://codeclimate.com/github/luin/ioredis)\n[![Join the chat at https://gitter.im/luin/ioredis](https://badges.gitter.im/Join%20Chat.svg)](https://gitter.im/luin/ioredis?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge)\n[![Commitizen friendly](https://img.shields.io/badge/commitizen-friendly-brightgreen.svg)](http://commitizen.github.io/cz-cli/)\n[![semantic-release](https://img.shields.io/badge/%20%20%F0%9F%93%A6%F0%9F%9A%80-semantic--release-e10079.svg)](https://github.com/semantic-release/semantic-release)\n[![npm latest version](https://img.shields.io/npm/v/ioredis/latest.svg)](https://www.npmjs.com/package/ioredis)\n[![npm next version](https://img.shields.io/npm/v/ioredis/next.svg)](https://www.npmjs.com/package/ioredis)\n<img alt=\"\" src=\"\">\n\nA robust, performance-focused and full-featured [Redis](http://redis.io) client for [Node.js](https://nodejs.org).\n\nSupports Redis >= 2.6.12 and (Node.js >= 6).\n\n# Features\nioredis is a robust, full-featured Redis client that is\nused in the world's biggest online commerce company [Alibaba](http://www.alibaba.com/) and many other awesome companies.\n\n0. Full-featured. It supports [Cluster](http://redis.io/topics/cluster-tutorial), [Sentinel](http://redis.io/topics/sentinel), [Pipelining](http://redis.io/topics/pipelining) and of course [Lua scripting](http://redis.io/commands/eval) & [Pub/Sub](http://redis.io/topics/pubsub) (with the support of binary messages).\n0. High performance.\n0. Delightful API. It works with Node callbacks and Native promises.\n0. Transformation of command arguments and replies.\n0. Transparent key prefixing.\n0. Abstraction for Lua scripting, allowing you to define custom commands.\n0. Support for binary data.\n0. Support for TLS.\n0. Support for offline queue and ready checking.\n0. Support for ES6 types, such as `Map` and `Set`.\n0. Support for GEO commands (Redis 3.2 Unstable).\n0. Sophisticated error handling strategy.\n0. Support for NAT mapping.\n\n# Links\n* [API Documentation](API.md)\n* [Changelog](Changelog.md)\n* [Migrating from node_redis](https://github.com/luin/ioredis/wiki/Migrating-from-node_redis)\n* [Error Handling](#error-handling)\n\n## Become a Sponsor to Support ioredis's Development\nOpen source is hard and time-consuming. If you want to invest in ioredis's future you can become a sponsor and make us spend more time on this library's improvements and new features.\n\n<a href=\"https://opencollective.com/ioredis\"><img src=\"https://opencollective.com/ioredis/tiers/sponsor.svg?avatarHeight=36\"></a>\n\nThank you for using ioredis :-)\n\n<hr>\n<a href=\"https://itunes.apple.com/app/medis-gui-for-redis/id1063631769\"><img align=\"right\" src=\"medis.png\" alt=\"Download on the App Store\"></a>\n\n\n### Advertisement\n\nLooking for a Redis GUI manager for OS X, Windows and Linux? Here's [Medis](https://itunes.apple.com/us/app/medis-gui-for-redis/id1063631769)!\n\nMedis is an open-sourced, beautiful, easy-to-use Redis GUI management application.\n\nMedis starts with all the basic features you need:\n\n* Keys viewing/editing\n* SSH Tunnel for connecting with remote servers\n* Terminal for executing custom commands\n* JSON/MessagePack format viewing/editing and built-in highlighting/validator\n* And other awesome features...\n\n[Medis is open sourced on GitHub](https://github.com/luin/medis)\n\n<hr>\n\n# Quick Start\n\n## Install\n```shell\n$ npm install ioredis\n```\n\n## Basic Usage\n\n```javascript\nvar Redis = require('ioredis');\nvar redis = new Redis();\n\nredis.set('foo', 'bar');\nredis.get('foo', function (err, result) {\n  console.log(result);\n});\n\n// Or using a promise if the last argument isn't a function\nredis.get('foo').then(function (result) {\n  console.log(result);\n});\n\n// Arguments to commands are flattened, so the following are the same:\nredis.sadd('set', 1, 3, 5, 7);\nredis.sadd('set', [1, 3, 5, 7]);\n\n// All arguments are passed directly to the redis server:\nredis.set('key', 100, 'EX', 10);\n```\n\nSee the `examples/` folder for more examples.\n\n## Connect to Redis\nWhen a new `Redis` instance is created,\na connection to Redis will be created at the same time.\nYou can specify which Redis to connect to by:\n\n```javascript\nnew Redis()       // Connect to 127.0.0.1:6379\nnew Redis(6380)   // 127.0.0.1:6380\nnew Redis(6379, '192.168.1.1')        // 192.168.1.1:6379\nnew Redis('/tmp/redis.sock')\nnew Redis({\n  port: 6379,          // Redis port\n  host: '127.0.0.1',   // Redis host\n  family: 4,           // 4 (IPv4) or 6 (IPv6)\n  password: 'auth',\n  db: 0\n})\n```\n\nYou can also specify connection options as a [`redis://` URL](http://www.iana.org/assignments/uri-schemes/prov/redis):\n\n```javascript\n// Connect to 127.0.0.1:6380, db 4, using password \"authpassword\":\nnew Redis('redis://:authpassword@127.0.0.1:6380/4')\n```\n\nSee [API Documentation](API.md#new_Redis) for all available options.\n\n## Pub/Sub\n\nHere is a simple example of the API for publish/subscribe.\nThe following program opens two client connections.\nIt subscribes to a channel with one connection\nand publishes to that channel with the other:\n\n```javascript\nvar Redis = require('ioredis');\nvar redis = new Redis();\nvar pub = new Redis();\nredis.subscribe('news', 'music', function (err, count) {\n  // Now we are subscribed to both the 'news' and 'music' channels.\n  // `count` represents the number of channels we are currently subscribed to.\n\n  pub.publish('news', 'Hello world!');\n  pub.publish('music', 'Hello again!');\n});\n\nredis.on('message', function (channel, message) {\n  // Receive message Hello world! from channel news\n  // Receive message Hello again! from channel music\n  console.log('Receive message %s from channel %s', message, channel);\n});\n\n// There's also an event called 'messageBuffer', which is the same as 'message' except\n// it returns buffers instead of strings.\nredis.on('messageBuffer', function (channel, message) {\n  // Both `channel` and `message` are buffers.\n});\n```\n\n`PSUBSCRIBE` is also supported in a similar way:\n\n```javascript\nredis.psubscribe('pat?ern', function (err, count) {});\nredis.on('pmessage', function (pattern, channel, message) {});\nredis.on('pmessageBuffer', function (pattern, channel, message) {});\n```\n\nWhen a client issues a SUBSCRIBE or PSUBSCRIBE, that connection is put into a \"subscriber\" mode.\nAt that point, only commands that modify the subscription set are valid.\nWhen the subscription set is empty, the connection is put back into regular mode.\n\nIf you need to send regular commands to Redis while in subscriber mode, just open another connection.\n\n## Handle Binary Data\nArguments can be buffers:\n```javascript\nredis.set('foo', Buffer.from('bar'));\n```\n\nAnd every command has a method that returns a Buffer (by adding a suffix of \"Buffer\" to the command name).\nTo get a buffer instead of a utf8 string:\n\n```javascript\nredis.getBuffer('foo', function (err, result) {\n  // result is a buffer.\n});\n```\n\n## Pipelining\nIf you want to send a batch of commands (e.g. > 5), you can use pipelining to queue\nthe commands in memory and then send them to Redis all at once. This way the performance improves by 50%~300% (See [benchmark section](#benchmark)).\n\n`redis.pipeline()` creates a `Pipeline` instance. You can call any Redis\ncommands on it just like the `Redis` instance. The commands are queued in memory\nand flushed to Redis by calling the `exec` method:\n\n```javascript\nvar pipeline = redis.pipeline();\npipeline.set('foo', 'bar');\npipeline.del('cc');\npipeline.exec(function (err, results) {\n  // `err` is always null, and `results` is an array of responses\n  // corresponding to the sequence of queued commands.\n  // Each response follows the format `[err, result]`.\n});\n\n// You can even chain the commands:\nredis.pipeline().set('foo', 'bar').del('cc').exec(function (err, results) {\n});\n\n// `exec` also returns a Promise:\nvar promise = redis.pipeline().set('foo', 'bar').get('foo').exec();\npromise.then(function (result) {\n  // result === [[null, 'OK'], [null, 'bar']]\n});\n```\n\nEach chained command can also have a callback, which will be invoked when the command\ngets a reply:\n\n```javascript\nredis.pipeline().set('foo', 'bar').get('foo', function (err, result) {\n  // result === 'bar'\n}).exec(function (err, result) {\n  // result[1][1] === 'bar'\n});\n```\n\nIn addition to adding commands to the `pipeline` queue individually, you can also pass an array of commands and arguments to the constructor:\n\n```javascript\nredis.pipeline([\n  ['set', 'foo', 'bar'],\n  ['get', 'foo']\n]).exec(function () { /* ... */ });\n```\n\n`#length` property shows how many commands in the pipeline:\n\n```javascript\nconst length = redis.pipeline().set('foo', 'bar').get('foo').length;\n// length === 2\n```\n\n\n## Transaction\nMost of the time, the transaction commands `multi` & `exec` are used together with pipeline.\nTherefore, when `multi` is called, a `Pipeline` instance is created automatically by default,\nso you can use `multi` just like `pipeline`:\n\n```javascript\nredis.multi().set('foo', 'bar').get('foo').exec(function (err, results) {\n  // results === [[null, 'OK'], [null, 'bar']]\n});\n```\nIf there's a syntax error in the transaction's command chain (e.g. wrong number of arguments, wrong command name, etc),\nthen none of the commands would be executed, and an error is returned:\n\n```javascript\nredis.multi().set('foo').set('foo', 'new value').exec(function (err, results) {\n  // err:\n  //  { [ReplyError: EXECABORT Transaction discarded because of previous errors.]\n  //    name: 'ReplyError',\n  //    message: 'EXECABORT Transaction discarded because of previous errors.',\n  //    command: { name: 'exec', args: [] },\n  //    previousErrors:\n  //     [ { [ReplyError: ERR wrong number of arguments for 'set' command]\n  //         name: 'ReplyError',\n  //         message: 'ERR wrong number of arguments for \\'set\\' command',\n  //         command: [Object] } ] }\n});\n```\n\nIn terms of the interface, `multi` differs from `pipeline` in that when specifying a callback\nto each chained command, the queueing state is passed to the callback instead of the result of the command:\n\n```javascript\nredis.multi().set('foo', 'bar', function (err, result) {\n  // result === 'QUEUED'\n}).exec(/* ... */);\n```\n\nIf you want to use transaction without pipeline, pass `{ pipeline: false }` to `multi`,\nand every command will be sent to Redis immediately without waiting for an `exec` invocation:\n\n```javascript\nredis.multi({ pipeline: false });\nredis.set('foo', 'bar');\nredis.get('foo');\nredis.exec(function (err, result) {\n  // result === [[null, 'OK'], [null, 'bar']]\n});\n```\n\nThe constructor of `multi` also accepts a batch of commands:\n\n```javascript\nredis.multi([\n  ['set', 'foo', 'bar'],\n  ['get', 'foo']\n]).exec(function () { /* ... */ });\n```\n\nInline transactions are supported by pipeline, which means you can group a subset of commands\nin the pipeline into a transaction:\n\n```javascript\nredis.pipeline().get('foo').multi().set('foo', 'bar').get('foo').exec().get('foo').exec();\n```\n\n## Lua Scripting\nioredis supports all of the scripting commands such as `EVAL`, `EVALSHA` and `SCRIPT`.\nHowever, it's tedious to use in real world scenarios since developers have to take\ncare of script caching and to detect when to use `EVAL` and when to use `EVALSHA`.\nioredis expose a `defineCommand` method to make scripting much easier to use:\n\n```javascript\nvar redis = new Redis();\n\n// This will define a command echo:\nredis.defineCommand('echo', {\n  numberOfKeys: 2,\n  lua: 'return {KEYS[1],KEYS[2],ARGV[1],ARGV[2]}'\n});\n\n// Now `echo` can be used just like any other ordinary command,\n// and ioredis will try to use `EVALSHA` internally when possible for better performance.\nredis.echo('k1', 'k2', 'a1', 'a2', function (err, result) {\n  // result === ['k1', 'k2', 'a1', 'a2']\n});\n\n// `echoBuffer` is also defined automatically to return buffers instead of strings:\nredis.echoBuffer('k1', 'k2', 'a1', 'a2', function (err, result) {\n  // result[0] equals to Buffer.from('k1');\n});\n\n// And of course it works with pipeline:\nredis.pipeline().set('foo', 'bar').echo('k1', 'k2', 'a1', 'a2').exec();\n```\n\nIf the number of keys can't be determined when defining a command, you can\nomit the `numberOfKeys` property and pass the number of keys as the first argument\nwhen you call the command:\n\n```javascript\nredis.defineCommand('echoDynamicKeyNumber', {\n  lua: 'return {KEYS[1],KEYS[2],ARGV[1],ARGV[2]}'\n});\n\n// Now you have to pass the number of keys as the first argument every time\n// you invoke the `echoDynamicKeyNumber` command:\nredis.echoDynamicKeyNumber(2, 'k1', 'k2', 'a1', 'a2', function (err, result) {\n  // result === ['k1', 'k2', 'a1', 'a2']\n});\n```\n\n## Transparent Key Prefixing\nThis feature allows you to specify a string that will automatically be prepended\nto all the keys in a command, which makes it easier to manage your key\nnamespaces.\n\n**Warning** This feature won't apply to commands like [KEYS](http://redis.io/commands/KEYS) and [SCAN](http://redis.io/commands/scan) that take patterns rather than actual keys([#239](https://github.com/luin/ioredis/issues/239)),\nand this feature also won't apply to the replies of commands even they are key names ([#325](https://github.com/luin/ioredis/issues/325)).\n\n```javascript\nvar fooRedis = new Redis({ keyPrefix: 'foo:' });\nfooRedis.set('bar', 'baz');  // Actually sends SET foo:bar baz\n\nfooRedis.defineCommand('echo', {\n  numberOfKeys: 2,\n  lua: 'return {KEYS[1],KEYS[2],ARGV[1],ARGV[2]}'\n});\n\n// Works well with pipelining/transaction\nfooRedis.pipeline()\n  // Sends SORT foo:list BY foo:weight_*->fieldname\n  .sort('list', 'BY', 'weight_*->fieldname')\n  // Supports custom commands\n  // Sends EVALSHA xxx foo:k1 foo:k2 a1 a2\n  .echo('k1', 'k2', 'a1', 'a2')\n  .exec()\n```\n\n## Transforming Arguments & Replies\nMost Redis commands take one or more Strings as arguments,\nand replies are sent back as a single String or an Array of Strings. However, sometimes\nyou may want something different. For instance, it would be more convenient if the `HGETALL`\ncommand returns a hash (e.g. `{ key: val1, key2: v2 }`) rather than an array of key values (e.g. `[key1, val1, key2, val2]`).\n\nioredis has a flexible system for transforming arguments and replies. There are two types\nof transformers, argument transformer and reply transformer:\n\n```javascript\nvar Redis = require('ioredis');\n\n// Here's the built-in argument transformer converting\n// hmset('key', { k1: 'v1', k2: 'v2' })\n// or\n// hmset('key', new Map([['k1', 'v1'], ['k2', 'v2']]))\n// into\n// hmset('key', 'k1', 'v1', 'k2', 'v2')\nRedis.Command.setArgumentTransformer('hmset', function (args) {\n  if (args.length === 2) {\n    if (typeof Map !== 'undefined' && args[1] instanceof Map) {\n      // utils is a internal module of ioredis\n      return [args[0]].concat(utils.convertMapToArray(args[1]));\n    }\n    if ( typeof args[1] === 'object' && args[1] !== null) {\n      return [args[0]].concat(utils.convertObjectToArray(args[1]));\n    }\n  }\n  return args;\n});\n\n// Here's the built-in reply transformer converting the HGETALL reply\n// ['k1', 'v1', 'k2', 'v2']\n// into\n// { k1: 'v1', 'k2': 'v2' }\nRedis.Command.setReplyTransformer('hgetall', function (result) {\n  if (Array.isArray(result)) {\n    var obj = {};\n    for (var i = 0; i < result.length; i += 2) {\n      obj[result[i]] = result[i + 1];\n    }\n    return obj;\n  }\n  return result;\n});\n```\n\nThere are three built-in transformers, two argument transformers for `hmset` & `mset` and\na reply transformer for `hgetall`. Transformers for `hmset` and `hgetall` were mentioned\nabove, and the transformer for `mset` is similar to the one for `hmset`:\n\n```javascript\nredis.mset({ k1: 'v1', k2: 'v2' });\nredis.get('k1', function (err, result) {\n  // result === 'v1';\n});\n\nredis.mset(new Map([['k3', 'v3'], ['k4', 'v4']]));\nredis.get('k3', function (err, result) {\n  // result === 'v3';\n});\n```\n\nAnother useful example of a reply transformer is one that changes `hgetall` to return array of arrays instead of objects which avoids a unwanted conversation of hash keys to strings when dealing with binary hash keys:\n\n```javascript\nRedis.Command.setReplyTransformer('hgetall', function (result) {\n  var arr = [];\n  for (var i = 0; i < result.length; i += 2) {\n    arr.push([result[i], result[i + 1]]);\n  }\n  return arr;\n});\nredis.hset('h1', Buffer.from([0x01]), Buffer.from([0x02]));\nredis.hset('h1', Buffer.from([0x03]), Buffer.from([0x04]));\nredis.hgetallBuffer('h1', function (err, result) {\n  // result === [ [ <Buffer 01>, <Buffer 02> ], [ <Buffer 03>, <Buffer 04> ] ];\n});\n```\n\n## Monitor\nRedis supports the MONITOR command,\nwhich lets you see all commands received by the Redis server across all client connections,\nincluding from other client libraries and other computers.\n\nThe `monitor` method returns a monitor instance.\nAfter you send the MONITOR command, no other commands are valid on that connection. ioredis will emit a monitor event for every new monitor message that comes across.\nThe callback for the monitor event takes a timestamp from the Redis server and an array of command arguments.\n\nHere is a simple example:\n\n```javascript\nredis.monitor(function (err, monitor) {\n  monitor.on('monitor', function (time, args, source, database) {\n  });\n});\n```\n\n## Streamify Scanning\nRedis 2.8 added the `SCAN` command to incrementally iterate through the keys in the database. It's different from `KEYS` in that\n`SCAN` only returns a small number of elements each call, so it can be used in production without the downside\nof blocking the server for a long time. However, it requires recording the cursor on the client side each time\nthe `SCAN` command is called in order to iterate through all the keys correctly. Since it's a relatively common use case, ioredis\nprovides a streaming interface for the `SCAN` command to make things much easier. A readable stream can be created by calling `scanStream`:\n\n```javascript\nvar redis = new Redis();\n// Create a readable stream (object mode)\nvar stream = redis.scanStream();\nstream.on('data', function (resultKeys) {\n  // `resultKeys` is an array of strings representing key names.\n  // Note that resultKeys may contain 0 keys, and that it will sometimes\n  // contain duplicates due to SCAN's implementation in Redis.\n  for (var i = 0; i < resultKeys.length; i++) {\n    console.log(resultKeys[i]);\n  }\n});\nstream.on('end', function () {\n  console.log('all keys have been visited');\n});\n```\n\n`scanStream` accepts an option, with which you can specify the `MATCH` pattern and the `COUNT` argument:\n\n```javascript\nvar stream = redis.scanStream({\n  // only returns keys following the pattern of `user:*`\n  match: 'user:*',\n  // returns approximately 100 elements per call\n  count: 100\n});\n```\n\nJust like other commands, `scanStream` has a binary version `scanBufferStream`, which returns an array of buffers. It's useful when\nthe key names are not utf8 strings.\n\nThere are also `hscanStream`, `zscanStream` and `sscanStream` to iterate through elements in a hash, zset and set. The interface of each is\nsimilar to `scanStream` except the first argument is the key name:\n\n```javascript\nvar stream = redis.hscanStream('myhash', {\n  match: 'age:??'\n});\n```\n\nYou can learn more from the [Redis documentation](http://redis.io/commands/scan).\n\n**Useful Tips**\nIt's pretty common that doing an async task in the `data` handler. We'd like the scanning process to be paused until the async task to be finished. `Stream#pause()` and `Stream.resume()` do the trick. For example if we want to migrate data in Redis to MySQL:\n\n```javascript\nvar stream = redis.scanStream();\nstream.on('data', function (resultKeys) {\n  // Pause the stream from scanning more keys until we've migrated the current keys.\n  stream.pause();\n\n  Promise.all(resultKeys.map(migrateKeyToMySQL)).then(() => {\n    // Resume the stream here.\n    stream.resume();\n  });\n});\n\nstream.on('end', function () {\n  console.log('done migration');\n});\n```\n\n## Auto-reconnect\nBy default, ioredis will try to reconnect when the connection to Redis is lost\nexcept when the connection is closed manually by `redis.disconnect()` or `redis.quit()`.\n\nIt's very flexible to control how long to wait to reconnect after disconnection\nusing the `retryStrategy` option:\n\n```javascript\nvar redis = new Redis({\n  // This is the default value of `retryStrategy`\n  retryStrategy: function (times) {\n    var delay = Math.min(times * 50, 2000);\n    return delay;\n  }\n});\n```\n\n`retryStrategy` is a function that will be called when the connection is lost.\nThe argument `times` means this is the nth reconnection being made and\nthe return value represents how long (in ms) to wait to reconnect. When the\nreturn value isn't a number, ioredis will stop trying to reconnect, and the connection\nwill be lost forever if the user doesn't call `redis.connect()` manually.\n\nWhen reconnected, the client will auto subscribe to channels that the previous connection subscribed to.\nThis behavior can be disabled by setting the `autoResubscribe` option to `false`.\n\nAnd if the previous connection has some unfulfilled commands (most likely blocking commands such as `brpop` and `blpop`),\nthe client will resend them when reconnected. This behavior can be disabled by setting the `autoResendUnfulfilledCommands` option to `false`.\n\nBy default, all pending commands will be flushed with an error every 20 retry attempts. That makes sure commands won't wait forever when the connection is down. You can change this behavior by setting `maxRetriesPerRequest`:\n\n```javascript\nvar redis = new Redis({\n  maxRetriesPerRequest: 1\n});\n```\n\nSet maxRetriesPerRequest to `null` to disable this behavior, and every command will wait forever until the connection is alive again (which is the default behavior before ioredis v4).\n\n### Reconnect on error\n\nBesides auto-reconnect when the connection is closed, ioredis supports reconnecting on the specified errors by the `reconnectOnError` option. Here's an example that will reconnect when receiving `READONLY` error:\n\n```javascript\nvar redis = new Redis({\n  reconnectOnError: function (err) {\n    var targetError = 'READONLY';\n    if (err.message.slice(0, targetError.length) === targetError) {\n      // Only reconnect when the error starts with \"READONLY\"\n      return true; // or `return 1;`\n    }\n  }\n});\n```\n\nThis feature is useful when using Amazon ElastiCache. Once failover happens, Amazon ElastiCache will switch the master we currently connected with to a slave, leading to the following writes fails with the error `READONLY`. Using `reconnectOnError`, we can force the connection to reconnect on this error in order to connect to the new master.\n\nFurthermore, if the `reconnectOnError` returns `2`, ioredis will resend the failed command after reconnecting.\n\n## Connection Events\nThe Redis instance will emit some events about the state of the connection to the Redis server.\n\nEvent    | Description\n:------------- | :-------------\nconnect  | emits when a connection is established to the Redis server.\nready    | If `enableReadyCheck` is `true`, client will emit `ready` when the server reports that it is ready to receive commands (e.g. finish loading data from disk).<br>Otherwise, `ready` will be emitted immediately right after the `connect` event.\nerror    | emits when an error occurs while connecting.<br>However, ioredis emits all `error` events silently (only emits when there's at least one listener) so that your application won't crash if you're not listening to the `error` event.\nclose    | emits when an established Redis server connection has closed.\nreconnecting | emits after `close` when a reconnection will be made. The argument of the event is the time (in ms) before reconnecting.\nend     | emits after `close` when no more reconnections will be made, or the connection is failed to establish.\n\nYou can also check out the `Redis#status` property to get the current connection status.\n\nBesides the above connection events, there are several other custom events:\n\nEvent    | Description\n:------------- | :-------------\nselect   | emits when the database changed. The argument is the new db number.\n\n## Offline Queue\nWhen a command can't be processed by Redis (being sent before the `ready` event), by default, it's added to the offline queue and will be\nexecuted when it can be processed. You can disable this feature by setting the `enableOfflineQueue`\noption to `false`:\n\n```javascript\nvar redis = new Redis({ enableOfflineQueue: false });\n```\n\n## TLS Options\nRedis doesn't support TLS natively, however if the redis server you want to connect to is hosted behind a TLS proxy (e.g. [stunnel](https://www.stunnel.org/)) or is offered by a PaaS service that supports TLS connection (e.g. [Redis Labs](https://redislabs.com/)), you can set the `tls` option:\n\n```javascript\nvar redis = new Redis({\n  host: 'localhost',\n  tls: {\n    // Refer to `tls.connect()` section in\n    // https://nodejs.org/api/tls.html\n    // for all supported options\n    ca: fs.readFileSync('cert.pem')\n  }\n});\n```\n\n<hr>\n\n## Sentinel\nioredis supports Sentinel out of the box. It works transparently as all features that work when\nyou connect to a single node also work when you connect to a sentinel group. Make sure to run Redis >= 2.8.12 if you want to use this feature. Sentinels have a default port of 26379.\n\nTo connect using Sentinel, use:\n\n```javascript\nvar redis = new Redis({\n  sentinels: [{ host: 'localhost', port: 26379 }, { host: 'localhost', port: 26380 }],\n  name: 'mymaster'\n});\n\nredis.set('foo', 'bar');\n```\n\nThe arguments passed to the constructor are different from the ones you use to connect to a single node, where:\n\n* `name` identifies a group of Redis instances composed of a master and one or more slaves (`mymaster` in the example);\n* `sentinels` are a list of sentinels to connect to. The list does not need to enumerate all your sentinel instances, but a few so that if one is down the client will try the next one.\n* `role` (optional) with a value of `slave` will return a random slave from the Sentinel group.\n* `preferredSlaves` (optional) can be used to prefer a particular slave or set of slaves based on priority. It accepts a function or array.\n\nioredis **guarantees** that the node you connected to is always a master even after a failover. When a failover happens, instead of trying to reconnect to the failed node (which will be demoted to slave when it's available again), ioredis will ask sentinels for the new master node and connect to it. All commands sent during the failover are queued and will be executed when the new connection is established so that none of the commands will be lost.\n\nIt's possible to connect to a slave instead of a master by specifying the option `role` with the value of `slave` and ioredis will try to connect to a random slave of the specified master, with the guarantee that the connected node is always a slave. If the current node is promoted to master due to a failover, ioredis will disconnect from it and ask the sentinels for another slave node to connect to.\n\nIf you specify the option `preferredSlaves` along with `role: 'slave'` ioredis will attempt to use this value when selecting the slave from the pool of available slaves. The value of `preferredSlaves` should either be a function that accepts an array of avaiable slaves and returns a single result, or an array of slave values priorities by the lowest `prio` value first with a default value of `1`.\n\n```javascript\n// available slaves format\nvar availableSlaves = [{ ip: '127.0.0.1', port: '31231', flags: 'slave' }];\n\n// preferredSlaves array format\nvar preferredSlaves = [\n  { ip: '127.0.0.1', port: '31231', prio: 1 },\n  { ip: '127.0.0.1', port: '31232', prio: 2 }\n];\n\n// preferredSlaves function format\npreferredSlaves = function(availableSlaves) {\n  for (var i = 0; i < availableSlaves.length; i++) {\n    var slave = availableSlaves[i];\n    if (slave.ip === '127.0.0.1') {\n      if (slave.port === '31234') {\n        return slave;\n      }\n    }\n  }\n  // if no preferred slaves are available a random one is used\n  return false;\n};\n\nvar redis = new Redis({\n  sentinels: [{ host: '127.0.0.1', port: 26379 }, { host: '127.0.0.1', port: 26380 }],\n  name: 'mymaster',\n  role: 'slave',\n  preferredSlaves: preferredSlaves\n});\n```\n\nBesides the `retryStrategy` option, there's also a `sentinelRetryStrategy` in Sentinel mode which will be invoked when all the sentinel nodes are unreachable during connecting. If `sentinelRetryStrategy` returns a valid delay time, ioredis will try to reconnect from scratch. The default value of `sentinelRetryStrategy` is:\n\n```javascript\nfunction (times) {\n  var delay = Math.min(times * 10, 1000);\n  return delay;\n}\n```\n\n## Cluster\nRedis Cluster provides a way to run a Redis installation where data is automatically sharded across multiple Redis nodes.\nYou can connect to a Redis Cluster like this:\n\n```javascript\nvar Redis = require('ioredis');\n\nvar cluster = new Redis.Cluster([{\n  port: 6380,\n  host: '127.0.0.1'\n}, {\n  port: 6381,\n  host: '127.0.0.1'\n}]);\n\ncluster.set('foo', 'bar');\ncluster.get('foo', function (err, res) {\n  // res === 'bar'\n});\n```\n\n`Cluster` constructor accepts two arguments, where:\n\n0. The first argument is a list of nodes of the cluster you want to connect to.\nJust like Sentinel, the list does not need to enumerate all your cluster nodes,\nbut a few so that if one is unreachable the client will try the next one, and the client will discover other nodes automatically when at least one node is connected.\n0. The second argument is the options, where:\n\n    * `clusterRetryStrategy`: When none of the startup nodes are reachable, `clusterRetryStrategy` will be invoked. When a number is returned,\n    ioredis will try to reconnect to the startup nodes from scratch after the specified delay (in ms). Otherwise, an error of \"None of startup nodes is available\" will be returned.\n    The default value of this option is:\n\n        ```javascript\n        function (times) {\n          var delay = Math.min(100 + times * 2, 2000);\n          return delay;\n        }\n        ```\n\n        It's possible to modify the `startupNodes` property in order to switch to another set of nodes here:\n\n        ```javascript\n        function (times) {\n          this.startupNodes = [{ port: 6790, host: '127.0.0.1' }];\n          return Math.min(100 + times * 2, 2000);\n        }\n        ```\n\n    * `enableOfflineQueue`: Similar to the `enableOfflineQueue` option of `Redis` class.\n    * `enableReadyCheck`: When enabled, \"ready\" event will only be emitted when `CLUSTER INFO` command\n    reporting the cluster is ready for handling commands. Otherwise, it will be emitted immediately after \"connect\" is emitted.\n    * `scaleReads`: Config where to send the read queries. See below for more details.\n    * `maxRedirections`: When a cluster related error (e.g. `MOVED`, `ASK` and `CLUSTERDOWN` etc.) is received, the client will redirect the\n    command to another node. This option limits the max redirections allowed when sending a command. The default value is `16`.\n    * `retryDelayOnFailover`: If the target node is disconnected when sending a command,\n    ioredis will retry after the specified delay. The default value is `100`. You should make sure `retryDelayOnFailover * maxRedirections > cluster-node-timeout`\n    to insure that no command will fail during a failover.\n    * `retryDelayOnClusterDown`: When a cluster is down, all commands will be rejected with the error of `CLUSTERDOWN`. If this option is a number (by default, it is `100`), the client\n    will resend the commands after the specified time (in ms).\n    * `retryDelayOnTryAgain`: If this option is a number (by default, it is `100`), the client\n    will resend the commands rejected with `TRYAGAIN` error after the specified time (in ms).\n    * `redisOptions`: Default options passed to the constructor of `Redis` when connecting to a node.\n    * `slotsRefreshTimeout`: Milliseconds before a timeout occurs while refreshing slots from the cluster (default `1000`)\n    * `slotsRefreshInterval`: Milliseconds between every automatic slots refresh (default `5000`)\n\n### Read-write splitting\n\nA typical redis cluster contains three or more masters and several slaves for each master. It's possible to scale out redis cluster by sending read queries to slaves and write queries to masters by setting the `scaleReads` option.\n\n`scaleReads` is \"master\" by default, which means ioredis will never send any queries to slaves. There are other three available options:\n\n1. \"all\": Send write queries to masters and read queries to masters or slaves randomly.\n2. \"slave\": Send write queries to masters and read queries to slaves.\n3. a custom `function(nodes, command): node`: Will choose the custom function to select to which node to send read queries (write queries keep being sent to master). The first node in `nodes` is always the master serving the relevant slots. If the function returns an array of nodes, a random node of that list will be selected.\n\nFor example:\n\n```javascript\nvar cluster = new Redis.Cluster([/* nodes */], {\n  scaleReads: 'slave'\n});\ncluster.set('foo', 'bar'); // This query will be sent to one of the masters.\ncluster.get('foo', function (err, res) {\n  // This query will be sent to one of the slaves.\n});\n```\n\n**NB** In the code snippet above, the `res` may not be equal to \"bar\" because of the lag of replication between the master and slaves.\n\n### Running commands to multiple nodes\n\nEvery command will be sent to exactly one node. For commands containing keys, (e.g. `GET`, `SET` and `HGETALL`), ioredis sends them to the node that serving the keys, and for other commands not containing keys, (e.g. `INFO`, `KEYS` and `FLUSHDB`), ioredis sends them to a random node.\n\nSometimes you may want to send a command to multiple nodes (masters or slaves) of the cluster, you can get the nodes via `Cluster#nodes()` method.\n\n`Cluster#nodes()` accepts a parameter role, which can be \"master\", \"slave\" and \"all\" (default), and returns an array of `Redis` instance. For example:\n\n```javascript\n// Send `FLUSHDB` command to all slaves:\nvar slaves = cluster.nodes('slave');\nPromise.all(slaves.map(function (node) {\n  return node.flushdb();\n}));\n\n// Get keys of all the masters:\nvar masters = cluster.nodes('master');\nPromise.all(masters.map(function (node) {\n  return node.keys();\n})).then(function (keys) {\n  // keys: [['key1', 'key2'], ['key3', 'key4']]\n});\n```\n\n### NAT Mapping\nSometimes the cluster is hosted within a internal network that can only be accessed via a NAT (Network Address Translation) instance. See [Accessing ElastiCache from outside AWS](https://docs.aws.amazon.com/AmazonElastiCache/latest/red-ug/accessing-elasticache.html) as an example.\n\nYou can specify nat mapping rules via `natMap` option:\n\n```javascript\nconst cluster = new Redis.Cluster([{\n  host: '203.0.113.73',\n  port: 30001\n}], {\n  natMap: {\n    '10.0.1.230:30001': {host: '203.0.113.73', port: 30001},\n    '10.0.1.231:30001': {host: '203.0.113.73', port: 30002},\n    '10.0.1.232:30001': {host: '203.0.113.73', port: 30003}\n  }\n})\n```\n\nThis option is also useful when the cluster is running inside a Docker container.\n\n### Transaction and pipeline in Cluster mode\nAlmost all features that are supported by `Redis` are also supported by `Redis.Cluster`, e.g. custom commands, transaction and pipeline.\nHowever there are some differences when using transaction and pipeline in Cluster mode:\n\n0. All keys in a pipeline should belong to the same slot since ioredis sends all commands in a pipeline to the same node.\n0. You can't use `multi` without pipeline (aka `cluster.multi({ pipeline: false })`). This is because when you call `cluster.multi({ pipeline: false })`, ioredis doesn't know which node the `multi` command should be sent to.\n0. Chaining custom commands in the pipeline is not supported in Cluster mode.\n\nWhen any commands in a pipeline receives a `MOVED` or `ASK` error, ioredis will resend the whole pipeline to the specified node automatically if all of the following conditions are satisfied:\n\n0. All errors received in the pipeline are the same. For example, we won't resend the pipeline if we got two `MOVED` errors pointing to different nodes.\n0. All commands executed successfully are readonly commands. This makes sure that resending the pipeline won't have side effects.\n\n### Pub/Sub\nPub/Sub in cluster mode works exactly as the same as in standalone mode. Internally, when a node of the cluster receives a message, it will broadcast the message to the other nodes. ioredis makes sure that each message will only be received once by strictly subscribing one node at the same time.\n\n```javascript\nvar nodes = [/* nodes */];\nvar pub = new Redis.Cluster(nodes);\nvar sub = new Redis.Cluster(nodes);\nsub.on('message', function (channel, message) {\n  console.log(channel, message);\n});\n\nsub.subscribe('news', function () {\n  pub.publish('news', 'highlights');\n});\n```\n\n### Events\n\nEvent    | Description\n:------------- | :-------------\nconnect  | emits when a connection is established to the Redis server.\nready    | emits when `CLUSTER INFO` reporting the cluster is able to receive commands (if `enableReadyCheck` is `true`) or immediately after `connect` event (if `enableReadyCheck` is false).\nerror    | emits when an error occurs while connecting with a property of `lastNodeError` representing the last node error received. This event is emitted silently (only emitting if there's at least one listener).\nclose    | emits when an established Redis server connection has closed.\nreconnecting | emits after `close` when a reconnection will be made. The argument of the event is the time (in ms) before reconnecting.\nend     | emits after `close` when no more reconnections will be made.\n+node   | emits when a new node is connected.\n-node   | emits when a node is disconnected.\nnode error | emits when an error occurs when connecting to a node\n\n### Password\nSetting the `password` option to access password-proctected clusters:\n\n```javascript\nvar Redis = require('ioredis');\nvar cluster = new Redis.Cluster(nodes, {\n  redisOptions: {\n    password: 'your-cluster-password'\n  }\n});\n```\n\nIf some of nodes in the cluster using a different password, you should specify them in the first parameter:\n\n```javascript\nvar Redis = require('ioredis');\nvar cluster = new Redis.Cluster([\n  // Use password \"password-for-30001\" for 30001\n  { port: 30001, password: 'password-for-30001'},\n  // Don't use password when accessing 30002\n  { port: 30002, password: null }\n  // Other nodes will use \"fallback-password\"\n], {\n  redisOptions: {\n    password: 'fallback-password'\n  }\n});\n```\n\n<hr>\n\n# Error Handling\nAll the errors returned by the Redis server are instances of `ReplyError`, which can be accessed via `Redis`:\n\n```javascript\nvar Redis = require('ioredis');\nvar redis = new Redis();\n// This command causes a reply error since the SET command requires two arguments.\nredis.set('foo', function (err) {\n  err instanceof Redis.ReplyError\n});\n```\n\nThis is the error stack of the `ReplyError`:\n\n```\nReplyError: ERR wrong number of arguments for 'set' command\n    at ReplyParser._parseResult (/app/node_modules/ioredis/lib/parsers/javascript.js:60:14)\n    at ReplyParser.execute (/app/node_modules/ioredis/lib/parsers/javascript.js:178:20)\n    at Socket.<anonymous> (/app/node_modules/ioredis/lib/redis/event_handler.js:99:22)\n    at Socket.emit (events.js:97:17)\n    at readableAddChunk (_stream_readable.js:143:16)\n    at Socket.Readable.push (_stream_readable.js:106:10)\n    at TCP.onread (net.js:509:20)\n```\n\nBy default, the error stack doesn't make any sense because the whole stack happens in the ioredis\nmodule itself, not in your code. So it's not easy to find out where the error happens in your code.\nioredis provides an option `showFriendlyErrorStack` to solve the problem. When you enable\n`showFriendlyErrorStack`, ioredis will optimize the error stack for you:\n\n```javascript\nvar Redis = require('ioredis');\nvar redis = new Redis({ showFriendlyErrorStack: true });\nredis.set('foo');\n```\n\nAnd the output will be:\n\n```\nReplyError: ERR wrong number of arguments for 'set' command\n    at Object.<anonymous> (/app/index.js:3:7)\n    at Module._compile (module.js:446:26)\n    at Object.Module._extensions..js (module.js:464:10)\n    at Module.load (module.js:341:32)\n    at Function.Module._load (module.js:296:12)\n    at Function.Module.runMain (module.js:487:10)\n    at startup (node.js:111:16)\n    at node.js:799:3\n```\n\nThis time the stack tells you that the error happens on the third line in your code. Pretty sweet!\nHowever, it would decrease the performance significantly to optimize the error stack. So by\ndefault, this option is disabled and can only be used for debugging purposes. You **shouldn't** use this feature in a production environment.\n\n# Plugging in your own Promises Library\nIf you're an advanced user, you may want to plug in your own promise library like [bluebird](https://www.npmjs.com/package/bluebird). Just set Redis.Promise to your favorite ES6-style promise constructor and ioredis will use it.\n\n```javascript\nconst Redis = require('ioredis')\nRedis.Promise = require('bluebird')\n\nconst redis = new Redis()\n\n// Use bluebird\nassert.equal(redis.get().constructor, require('bluebird'))\n\n// You can change the Promise implementation at any time:\nRedis.Promise = global.Promise\nassert.equal(redis.get().constructor, global.Promise)\n```\n\n\n# Running tests\n\nStart a Redis server on 127.0.0.1:6379, and then:\n\n```shell\n$ npm test\n```\n\n`FLUSH ALL` will be invoked after each test, so make sure there's no valuable data in it before running tests.\n\nIf your testing environment does not let you spin up a Redis server [ioredis-mock](https://github.com/stipsan/ioredis-mock) is a drop-in replacement you can use in your tests. It aims to behave identically to ioredis connected to a Redis server so that your integration tests is easier to write and of better quality.\n\n# Debug\n\nYou can set the `DEBUG` env to `ioredis:*` to print debug info:\n\n```shell\n$ DEBUG=ioredis:* node app.js\n```\n\n# Consolidation: It's time for celebration\n\nRight now there are two great redis clients around and both have some advantages above each other. We speak about [node_redis](https://github.com/NodeRedis/node_redis) and ioredis. So after talking to each other about how we could improve in working together we (that is [@BridgeAR](https://github.com/BridgeAR) and [@luin](https://github.com/luin)) decided to work towards a single library on the long run. But step by step.\n\nFirst of all, we want to split small parts of our libraries into others so that we're both able to use the same code. Those libraries are going to be maintained under the NodeRedis organization. This is going to reduce the maintance overhead, allows others to use the very same code, if they need it and it's way easier for others to contribute to both libraries.\n\nWe're very happy about this step towards working together as we both want to give you the best redis experience possible.\n\nIf you want to join our cause by help maintaining something, please don't hesitate to contact either one of us.\n\n# Join in!\n\nI'm happy to receive bug reports, fixes, documentation enhancements, and any other improvements.\n\nAnd since I'm not a native English speaker, if you find any grammar mistakes in the documentation, please also let me know. :)\n\n# Contributors\n\nThis project exists thanks to all the people who contribute:\n\n<a href=\"https://github.com/luin/ioredis/graphs/contributors\"><img src=\"https://opencollective.com/ioredis/contributors.svg?width=890&showBtn=false\" /></a>\n\n# License\n\nMIT\n","readmeFilename":"README.md","bugs":{"url":"https://github.com/luin/ioredis/issues"},"homepage":"https://github.com/luin/ioredis#readme","_id":"ioredis@4.4.0","_npmVersion":"6.4.1","_nodeVersion":"10.15.0","_npmUser":{"name":"ioredis-robot","email":"ioredis-robot@zihua.li"},"dist":{"integrity":"sha512-QH8q9ymc0BsCCFG4nMbXLBsZ8bICnk9Sspemdf335WhK49wZgDVF9+8TNUsj4EQoa3momClKcIpzgvsyRPV93w==","shasum":"7345cd1e41b4a8703b4da57c6e6a88736f933391","tarball":"https://registry.npmjs.org/ioredis/-/ioredis-4.4.0.tgz","fileCount":35,"unpackedSize":216236,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJcL4DtCRA9TVsSAnZWagAAKYwP/RlKfasBe+GUPx70JdmX\nK4jWvuIREUVLr65h6V+tTG7XWbS9Ntx2j8yjEfsE4gQWLo2jgaFuYj9JMZKn\n8J8oIXPiP+6Ue+gCYIbrwOE+6TVqOXlFL8xaotaJHFbkF9kAbPKyAMDhiwLf\nnirO9x8hwgFs8e2nypIskhSk9pbeiwV5I664OR12xcG6J6hLPben/809ZqS4\nAQjo2NNR2ex1JPeZ9bsVQ0vINB2eYwaafK0p0Wna7N6NFV9rIcpTaAmjw8G6\nIkKx5jvycWnLu2QFZL+Q4EQAs7NjB3ZS3lMwQZWQlPoQwNJd1Ey788O6HSlI\nB2nTNUoSvGSgccjqVlLxFrvBu+ZWHLiipMey0M39wHJOvkvdiK8PrKo1zkwE\numvPvBoa2as4/2ItM8QwWTsjqlY8AxH7whLlnx3YOlTGU8zXg8fR3KpErBl/\nKXsy01WE9slac3ZwXnZtyIgXEUCyluc3D7mkNXGWAWTm8jLy/UfMtz6DduP6\n9mSy/kONnJ6o93XFMOyuxkJwcPvFW2B/MOYyugDOKLAAucVGzRy8qfQm9sCF\nmNVTVcy2PvN8dpb3axH4Z0b7EHZdHSVi3xr3Kb/IF783L9tifv+393dtSFoj\nfRGf5hq6AGYihuK06VeRvpNTl+kirtAHiHVD6Atw3yksMDGydT14lIIjXflA\nfNdu\r\n=hCAl\r\n-----END PGP SIGNATURE-----\r\n"},"maintainers":[{"email":"ioredis-robot@zihua.li","name":"ioredis-robot"},{"email":"i@zihua.li","name":"luin"}],"directories":{},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/ioredis_4.4.0_1546617068884_0.06455560807267058"},"_hasShrinkwrap":false},"4.5.0":{"name":"ioredis","version":"4.5.0","description":"A robust, performance-focused and full-featured Redis client for Node.js.","main":"built/index.js","scripts":{"test":"NODE_ENV=test mocha --timeout 8000 -r ts-node/register --exit","test:cov":"NODE_ENV=test node ./node_modules/istanbul/lib/cli.js cover --preserve-comments ./node_modules/mocha/bin/_mocha -- -r ts-node/register -R spec --exit","build":"rm -rf built && tsc","generate-docs":"jsdoc2md lib/redis.js lib/cluster/index.js lib/commander.js > API.md","prepublishOnly":"npm run build && npm test","bench":"matcha benchmarks/*.js","semantic-release":"semantic-release"},"repository":{"type":"git","url":"git://github.com/luin/ioredis.git"},"keywords":["redis","cluster","sentinel","pipelining"],"author":{"name":"luin","email":"i@zihua.li","url":"http://zihua.li"},"license":"MIT","dependencies":{"cluster-key-slot":"^1.0.6","debug":"^3.1.0","denque":"^1.1.0","flexbuffer":"0.0.6","lodash.defaults":"^4.2.0","lodash.flatten":"^4.4.0","redis-commands":"1.4.0","redis-errors":"^1.2.0","redis-parser":"^3.0.0","standard-as-callback":"^1.0.0"},"devDependencies":{"@semantic-release/changelog":"^3.0.0","@semantic-release/git":"^7.0.4","@types/node":"^10.11.5","@types/redis-errors":"1.2.0","bluebird":"^3.5.1","chai":"^3.5.0","cz-conventional-changelog":"^2.0.0","istanbul":"^0.4.2","jsdoc":"^3.4.0","jsdoc-to-markdown":"^4.0.1","mocha":"^5.2.0","server-destroy":"^1.0.1","sinon":"^1.17.3","ts-node":"^7.0.0","typescript":"^3.1.1"},"engines":{"node":">=6"},"config":{"commitizen":{"path":"./node_modules/cz-conventional-changelog"}},"gitHead":"788d3736f941f0bef2e6266c0f683ec8e0e94beb","readme":"[![ioredis](https://cdn.rawgit.com/luin/ioredis/57b5b89e3e9111ff25d8c62c0bc58ed42e5b8d1e/logo.svg)](https://github.com/luin/ioredis)\n\n[![Build Status](https://travis-ci.org/luin/ioredis.svg?branch=master)](https://travis-ci.org/luin/ioredis)\n[![Test Coverage](https://codeclimate.com/github/luin/ioredis/badges/coverage.svg)](https://codeclimate.com/github/luin/ioredis)\n[![Join the chat at https://gitter.im/luin/ioredis](https://badges.gitter.im/Join%20Chat.svg)](https://gitter.im/luin/ioredis?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge)\n[![Commitizen friendly](https://img.shields.io/badge/commitizen-friendly-brightgreen.svg)](http://commitizen.github.io/cz-cli/)\n[![semantic-release](https://img.shields.io/badge/%20%20%F0%9F%93%A6%F0%9F%9A%80-semantic--release-e10079.svg)](https://github.com/semantic-release/semantic-release)\n[![npm latest version](https://img.shields.io/npm/v/ioredis/latest.svg)](https://www.npmjs.com/package/ioredis)\n[![npm next version](https://img.shields.io/npm/v/ioredis/next.svg)](https://www.npmjs.com/package/ioredis)\n<img alt=\"\" src=\"\">\n\nA robust, performance-focused and full-featured [Redis](http://redis.io) client for [Node.js](https://nodejs.org).\n\nSupports Redis >= 2.6.12 and (Node.js >= 6).\n\n# Features\nioredis is a robust, full-featured Redis client that is\nused in the world's biggest online commerce company [Alibaba](http://www.alibaba.com/) and many other awesome companies.\n\n0. Full-featured. It supports [Cluster](http://redis.io/topics/cluster-tutorial), [Sentinel](http://redis.io/topics/sentinel), [Pipelining](http://redis.io/topics/pipelining) and of course [Lua scripting](http://redis.io/commands/eval) & [Pub/Sub](http://redis.io/topics/pubsub) (with the support of binary messages).\n0. High performance.\n0. Delightful API. It works with Node callbacks and Native promises.\n0. Transformation of command arguments and replies.\n0. Transparent key prefixing.\n0. Abstraction for Lua scripting, allowing you to define custom commands.\n0. Support for binary data.\n0. Support for TLS.\n0. Support for offline queue and ready checking.\n0. Support for ES6 types, such as `Map` and `Set`.\n0. Support for GEO commands (Redis 3.2 Unstable).\n0. Sophisticated error handling strategy.\n0. Support for NAT mapping.\n\n# Links\n* [API Documentation](API.md)\n* [Changelog](Changelog.md)\n* [Migrating from node_redis](https://github.com/luin/ioredis/wiki/Migrating-from-node_redis)\n* [Error Handling](#error-handling)\n\n## Become a Sponsor to Support ioredis's Development\nOpen source is hard and time-consuming. If you want to invest in ioredis's future you can become a sponsor and make us spend more time on this library's improvements and new features.\n\n<a href=\"https://opencollective.com/ioredis\"><img src=\"https://opencollective.com/ioredis/tiers/sponsor.svg?avatarHeight=36\"></a>\n\nThank you for using ioredis :-)\n\n<hr>\n<a href=\"https://itunes.apple.com/app/medis-gui-for-redis/id1063631769\"><img align=\"right\" src=\"medis.png\" alt=\"Download on the App Store\"></a>\n\n\n### Advertisement\n\nLooking for a Redis GUI manager for OS X, Windows and Linux? Here's [Medis](https://itunes.apple.com/us/app/medis-gui-for-redis/id1063631769)!\n\nMedis is an open-sourced, beautiful, easy-to-use Redis GUI management application.\n\nMedis starts with all the basic features you need:\n\n* Keys viewing/editing\n* SSH Tunnel for connecting with remote servers\n* Terminal for executing custom commands\n* JSON/MessagePack format viewing/editing and built-in highlighting/validator\n* And other awesome features...\n\n[Medis is open sourced on GitHub](https://github.com/luin/medis)\n\n<hr>\n\n# Quick Start\n\n## Install\n```shell\n$ npm install ioredis\n```\n\n## Basic Usage\n\n```javascript\nvar Redis = require('ioredis');\nvar redis = new Redis();\n\nredis.set('foo', 'bar');\nredis.get('foo', function (err, result) {\n  console.log(result);\n});\n\n// Or using a promise if the last argument isn't a function\nredis.get('foo').then(function (result) {\n  console.log(result);\n});\n\n// Arguments to commands are flattened, so the following are the same:\nredis.sadd('set', 1, 3, 5, 7);\nredis.sadd('set', [1, 3, 5, 7]);\n\n// All arguments are passed directly to the redis server:\nredis.set('key', 100, 'EX', 10);\n```\n\nSee the `examples/` folder for more examples.\n\n## Connect to Redis\nWhen a new `Redis` instance is created,\na connection to Redis will be created at the same time.\nYou can specify which Redis to connect to by:\n\n```javascript\nnew Redis()       // Connect to 127.0.0.1:6379\nnew Redis(6380)   // 127.0.0.1:6380\nnew Redis(6379, '192.168.1.1')        // 192.168.1.1:6379\nnew Redis('/tmp/redis.sock')\nnew Redis({\n  port: 6379,          // Redis port\n  host: '127.0.0.1',   // Redis host\n  family: 4,           // 4 (IPv4) or 6 (IPv6)\n  password: 'auth',\n  db: 0\n})\n```\n\nYou can also specify connection options as a [`redis://` URL](http://www.iana.org/assignments/uri-schemes/prov/redis):\n\n```javascript\n// Connect to 127.0.0.1:6380, db 4, using password \"authpassword\":\nnew Redis('redis://:authpassword@127.0.0.1:6380/4')\n```\n\nSee [API Documentation](API.md#new_Redis) for all available options.\n\n## Pub/Sub\n\nHere is a simple example of the API for publish/subscribe.\nThe following program opens two client connections.\nIt subscribes to a channel with one connection\nand publishes to that channel with the other:\n\n```javascript\nvar Redis = require('ioredis');\nvar redis = new Redis();\nvar pub = new Redis();\nredis.subscribe('news', 'music', function (err, count) {\n  // Now we are subscribed to both the 'news' and 'music' channels.\n  // `count` represents the number of channels we are currently subscribed to.\n\n  pub.publish('news', 'Hello world!');\n  pub.publish('music', 'Hello again!');\n});\n\nredis.on('message', function (channel, message) {\n  // Receive message Hello world! from channel news\n  // Receive message Hello again! from channel music\n  console.log('Receive message %s from channel %s', message, channel);\n});\n\n// There's also an event called 'messageBuffer', which is the same as 'message' except\n// it returns buffers instead of strings.\nredis.on('messageBuffer', function (channel, message) {\n  // Both `channel` and `message` are buffers.\n});\n```\n\n`PSUBSCRIBE` is also supported in a similar way:\n\n```javascript\nredis.psubscribe('pat?ern', function (err, count) {});\nredis.on('pmessage', function (pattern, channel, message) {});\nredis.on('pmessageBuffer', function (pattern, channel, message) {});\n```\n\nWhen a client issues a SUBSCRIBE or PSUBSCRIBE, that connection is put into a \"subscriber\" mode.\nAt that point, only commands that modify the subscription set are valid.\nWhen the subscription set is empty, the connection is put back into regular mode.\n\nIf you need to send regular commands to Redis while in subscriber mode, just open another connection.\n\n## Handle Binary Data\nArguments can be buffers:\n```javascript\nredis.set('foo', Buffer.from('bar'));\n```\n\nAnd every command has a method that returns a Buffer (by adding a suffix of \"Buffer\" to the command name).\nTo get a buffer instead of a utf8 string:\n\n```javascript\nredis.getBuffer('foo', function (err, result) {\n  // result is a buffer.\n});\n```\n\n## Pipelining\nIf you want to send a batch of commands (e.g. > 5), you can use pipelining to queue\nthe commands in memory and then send them to Redis all at once. This way the performance improves by 50%~300% (See [benchmark section](#benchmark)).\n\n`redis.pipeline()` creates a `Pipeline` instance. You can call any Redis\ncommands on it just like the `Redis` instance. The commands are queued in memory\nand flushed to Redis by calling the `exec` method:\n\n```javascript\nvar pipeline = redis.pipeline();\npipeline.set('foo', 'bar');\npipeline.del('cc');\npipeline.exec(function (err, results) {\n  // `err` is always null, and `results` is an array of responses\n  // corresponding to the sequence of queued commands.\n  // Each response follows the format `[err, result]`.\n});\n\n// You can even chain the commands:\nredis.pipeline().set('foo', 'bar').del('cc').exec(function (err, results) {\n});\n\n// `exec` also returns a Promise:\nvar promise = redis.pipeline().set('foo', 'bar').get('foo').exec();\npromise.then(function (result) {\n  // result === [[null, 'OK'], [null, 'bar']]\n});\n```\n\nEach chained command can also have a callback, which will be invoked when the command\ngets a reply:\n\n```javascript\nredis.pipeline().set('foo', 'bar').get('foo', function (err, result) {\n  // result === 'bar'\n}).exec(function (err, result) {\n  // result[1][1] === 'bar'\n});\n```\n\nIn addition to adding commands to the `pipeline` queue individually, you can also pass an array of commands and arguments to the constructor:\n\n```javascript\nredis.pipeline([\n  ['set', 'foo', 'bar'],\n  ['get', 'foo']\n]).exec(function () { /* ... */ });\n```\n\n`#length` property shows how many commands in the pipeline:\n\n```javascript\nconst length = redis.pipeline().set('foo', 'bar').get('foo').length;\n// length === 2\n```\n\n\n## Transaction\nMost of the time, the transaction commands `multi` & `exec` are used together with pipeline.\nTherefore, when `multi` is called, a `Pipeline` instance is created automatically by default,\nso you can use `multi` just like `pipeline`:\n\n```javascript\nredis.multi().set('foo', 'bar').get('foo').exec(function (err, results) {\n  // results === [[null, 'OK'], [null, 'bar']]\n});\n```\nIf there's a syntax error in the transaction's command chain (e.g. wrong number of arguments, wrong command name, etc),\nthen none of the commands would be executed, and an error is returned:\n\n```javascript\nredis.multi().set('foo').set('foo', 'new value').exec(function (err, results) {\n  // err:\n  //  { [ReplyError: EXECABORT Transaction discarded because of previous errors.]\n  //    name: 'ReplyError',\n  //    message: 'EXECABORT Transaction discarded because of previous errors.',\n  //    command: { name: 'exec', args: [] },\n  //    previousErrors:\n  //     [ { [ReplyError: ERR wrong number of arguments for 'set' command]\n  //         name: 'ReplyError',\n  //         message: 'ERR wrong number of arguments for \\'set\\' command',\n  //         command: [Object] } ] }\n});\n```\n\nIn terms of the interface, `multi` differs from `pipeline` in that when specifying a callback\nto each chained command, the queueing state is passed to the callback instead of the result of the command:\n\n```javascript\nredis.multi().set('foo', 'bar', function (err, result) {\n  // result === 'QUEUED'\n}).exec(/* ... */);\n```\n\nIf you want to use transaction without pipeline, pass `{ pipeline: false }` to `multi`,\nand every command will be sent to Redis immediately without waiting for an `exec` invocation:\n\n```javascript\nredis.multi({ pipeline: false });\nredis.set('foo', 'bar');\nredis.get('foo');\nredis.exec(function (err, result) {\n  // result === [[null, 'OK'], [null, 'bar']]\n});\n```\n\nThe constructor of `multi` also accepts a batch of commands:\n\n```javascript\nredis.multi([\n  ['set', 'foo', 'bar'],\n  ['get', 'foo']\n]).exec(function () { /* ... */ });\n```\n\nInline transactions are supported by pipeline, which means you can group a subset of commands\nin the pipeline into a transaction:\n\n```javascript\nredis.pipeline().get('foo').multi().set('foo', 'bar').get('foo').exec().get('foo').exec();\n```\n\n## Lua Scripting\nioredis supports all of the scripting commands such as `EVAL`, `EVALSHA` and `SCRIPT`.\nHowever, it's tedious to use in real world scenarios since developers have to take\ncare of script caching and to detect when to use `EVAL` and when to use `EVALSHA`.\nioredis expose a `defineCommand` method to make scripting much easier to use:\n\n```javascript\nvar redis = new Redis();\n\n// This will define a command echo:\nredis.defineCommand('echo', {\n  numberOfKeys: 2,\n  lua: 'return {KEYS[1],KEYS[2],ARGV[1],ARGV[2]}'\n});\n\n// Now `echo` can be used just like any other ordinary command,\n// and ioredis will try to use `EVALSHA` internally when possible for better performance.\nredis.echo('k1', 'k2', 'a1', 'a2', function (err, result) {\n  // result === ['k1', 'k2', 'a1', 'a2']\n});\n\n// `echoBuffer` is also defined automatically to return buffers instead of strings:\nredis.echoBuffer('k1', 'k2', 'a1', 'a2', function (err, result) {\n  // result[0] equals to Buffer.from('k1');\n});\n\n// And of course it works with pipeline:\nredis.pipeline().set('foo', 'bar').echo('k1', 'k2', 'a1', 'a2').exec();\n```\n\nIf the number of keys can't be determined when defining a command, you can\nomit the `numberOfKeys` property and pass the number of keys as the first argument\nwhen you call the command:\n\n```javascript\nredis.defineCommand('echoDynamicKeyNumber', {\n  lua: 'return {KEYS[1],KEYS[2],ARGV[1],ARGV[2]}'\n});\n\n// Now you have to pass the number of keys as the first argument every time\n// you invoke the `echoDynamicKeyNumber` command:\nredis.echoDynamicKeyNumber(2, 'k1', 'k2', 'a1', 'a2', function (err, result) {\n  // result === ['k1', 'k2', 'a1', 'a2']\n});\n```\n\n## Transparent Key Prefixing\nThis feature allows you to specify a string that will automatically be prepended\nto all the keys in a command, which makes it easier to manage your key\nnamespaces.\n\n**Warning** This feature won't apply to commands like [KEYS](http://redis.io/commands/KEYS) and [SCAN](http://redis.io/commands/scan) that take patterns rather than actual keys([#239](https://github.com/luin/ioredis/issues/239)),\nand this feature also won't apply to the replies of commands even they are key names ([#325](https://github.com/luin/ioredis/issues/325)).\n\n```javascript\nvar fooRedis = new Redis({ keyPrefix: 'foo:' });\nfooRedis.set('bar', 'baz');  // Actually sends SET foo:bar baz\n\nfooRedis.defineCommand('echo', {\n  numberOfKeys: 2,\n  lua: 'return {KEYS[1],KEYS[2],ARGV[1],ARGV[2]}'\n});\n\n// Works well with pipelining/transaction\nfooRedis.pipeline()\n  // Sends SORT foo:list BY foo:weight_*->fieldname\n  .sort('list', 'BY', 'weight_*->fieldname')\n  // Supports custom commands\n  // Sends EVALSHA xxx foo:k1 foo:k2 a1 a2\n  .echo('k1', 'k2', 'a1', 'a2')\n  .exec()\n```\n\n## Transforming Arguments & Replies\nMost Redis commands take one or more Strings as arguments,\nand replies are sent back as a single String or an Array of Strings. However, sometimes\nyou may want something different. For instance, it would be more convenient if the `HGETALL`\ncommand returns a hash (e.g. `{ key: val1, key2: v2 }`) rather than an array of key values (e.g. `[key1, val1, key2, val2]`).\n\nioredis has a flexible system for transforming arguments and replies. There are two types\nof transformers, argument transformer and reply transformer:\n\n```javascript\nvar Redis = require('ioredis');\n\n// Here's the built-in argument transformer converting\n// hmset('key', { k1: 'v1', k2: 'v2' })\n// or\n// hmset('key', new Map([['k1', 'v1'], ['k2', 'v2']]))\n// into\n// hmset('key', 'k1', 'v1', 'k2', 'v2')\nRedis.Command.setArgumentTransformer('hmset', function (args) {\n  if (args.length === 2) {\n    if (typeof Map !== 'undefined' && args[1] instanceof Map) {\n      // utils is a internal module of ioredis\n      return [args[0]].concat(utils.convertMapToArray(args[1]));\n    }\n    if ( typeof args[1] === 'object' && args[1] !== null) {\n      return [args[0]].concat(utils.convertObjectToArray(args[1]));\n    }\n  }\n  return args;\n});\n\n// Here's the built-in reply transformer converting the HGETALL reply\n// ['k1', 'v1', 'k2', 'v2']\n// into\n// { k1: 'v1', 'k2': 'v2' }\nRedis.Command.setReplyTransformer('hgetall', function (result) {\n  if (Array.isArray(result)) {\n    var obj = {};\n    for (var i = 0; i < result.length; i += 2) {\n      obj[result[i]] = result[i + 1];\n    }\n    return obj;\n  }\n  return result;\n});\n```\n\nThere are three built-in transformers, two argument transformers for `hmset` & `mset` and\na reply transformer for `hgetall`. Transformers for `hmset` and `hgetall` were mentioned\nabove, and the transformer for `mset` is similar to the one for `hmset`:\n\n```javascript\nredis.mset({ k1: 'v1', k2: 'v2' });\nredis.get('k1', function (err, result) {\n  // result === 'v1';\n});\n\nredis.mset(new Map([['k3', 'v3'], ['k4', 'v4']]));\nredis.get('k3', function (err, result) {\n  // result === 'v3';\n});\n```\n\nAnother useful example of a reply transformer is one that changes `hgetall` to return array of arrays instead of objects which avoids a unwanted conversation of hash keys to strings when dealing with binary hash keys:\n\n```javascript\nRedis.Command.setReplyTransformer('hgetall', function (result) {\n  var arr = [];\n  for (var i = 0; i < result.length; i += 2) {\n    arr.push([result[i], result[i + 1]]);\n  }\n  return arr;\n});\nredis.hset('h1', Buffer.from([0x01]), Buffer.from([0x02]));\nredis.hset('h1', Buffer.from([0x03]), Buffer.from([0x04]));\nredis.hgetallBuffer('h1', function (err, result) {\n  // result === [ [ <Buffer 01>, <Buffer 02> ], [ <Buffer 03>, <Buffer 04> ] ];\n});\n```\n\n## Monitor\nRedis supports the MONITOR command,\nwhich lets you see all commands received by the Redis server across all client connections,\nincluding from other client libraries and other computers.\n\nThe `monitor` method returns a monitor instance.\nAfter you send the MONITOR command, no other commands are valid on that connection. ioredis will emit a monitor event for every new monitor message that comes across.\nThe callback for the monitor event takes a timestamp from the Redis server and an array of command arguments.\n\nHere is a simple example:\n\n```javascript\nredis.monitor(function (err, monitor) {\n  monitor.on('monitor', function (time, args, source, database) {\n  });\n});\n```\n\n## Streamify Scanning\nRedis 2.8 added the `SCAN` command to incrementally iterate through the keys in the database. It's different from `KEYS` in that\n`SCAN` only returns a small number of elements each call, so it can be used in production without the downside\nof blocking the server for a long time. However, it requires recording the cursor on the client side each time\nthe `SCAN` command is called in order to iterate through all the keys correctly. Since it's a relatively common use case, ioredis\nprovides a streaming interface for the `SCAN` command to make things much easier. A readable stream can be created by calling `scanStream`:\n\n```javascript\nvar redis = new Redis();\n// Create a readable stream (object mode)\nvar stream = redis.scanStream();\nstream.on('data', function (resultKeys) {\n  // `resultKeys` is an array of strings representing key names.\n  // Note that resultKeys may contain 0 keys, and that it will sometimes\n  // contain duplicates due to SCAN's implementation in Redis.\n  for (var i = 0; i < resultKeys.length; i++) {\n    console.log(resultKeys[i]);\n  }\n});\nstream.on('end', function () {\n  console.log('all keys have been visited');\n});\n```\n\n`scanStream` accepts an option, with which you can specify the `MATCH` pattern and the `COUNT` argument:\n\n```javascript\nvar stream = redis.scanStream({\n  // only returns keys following the pattern of `user:*`\n  match: 'user:*',\n  // returns approximately 100 elements per call\n  count: 100\n});\n```\n\nJust like other commands, `scanStream` has a binary version `scanBufferStream`, which returns an array of buffers. It's useful when\nthe key names are not utf8 strings.\n\nThere are also `hscanStream`, `zscanStream` and `sscanStream` to iterate through elements in a hash, zset and set. The interface of each is\nsimilar to `scanStream` except the first argument is the key name:\n\n```javascript\nvar stream = redis.hscanStream('myhash', {\n  match: 'age:??'\n});\n```\n\nYou can learn more from the [Redis documentation](http://redis.io/commands/scan).\n\n**Useful Tips**\nIt's pretty common that doing an async task in the `data` handler. We'd like the scanning process to be paused until the async task to be finished. `Stream#pause()` and `Stream.resume()` do the trick. For example if we want to migrate data in Redis to MySQL:\n\n```javascript\nvar stream = redis.scanStream();\nstream.on('data', function (resultKeys) {\n  // Pause the stream from scanning more keys until we've migrated the current keys.\n  stream.pause();\n\n  Promise.all(resultKeys.map(migrateKeyToMySQL)).then(() => {\n    // Resume the stream here.\n    stream.resume();\n  });\n});\n\nstream.on('end', function () {\n  console.log('done migration');\n});\n```\n\n## Auto-reconnect\nBy default, ioredis will try to reconnect when the connection to Redis is lost\nexcept when the connection is closed manually by `redis.disconnect()` or `redis.quit()`.\n\nIt's very flexible to control how long to wait to reconnect after disconnection\nusing the `retryStrategy` option:\n\n```javascript\nvar redis = new Redis({\n  // This is the default value of `retryStrategy`\n  retryStrategy: function (times) {\n    var delay = Math.min(times * 50, 2000);\n    return delay;\n  }\n});\n```\n\n`retryStrategy` is a function that will be called when the connection is lost.\nThe argument `times` means this is the nth reconnection being made and\nthe return value represents how long (in ms) to wait to reconnect. When the\nreturn value isn't a number, ioredis will stop trying to reconnect, and the connection\nwill be lost forever if the user doesn't call `redis.connect()` manually.\n\nWhen reconnected, the client will auto subscribe to channels that the previous connection subscribed to.\nThis behavior can be disabled by setting the `autoResubscribe` option to `false`.\n\nAnd if the previous connection has some unfulfilled commands (most likely blocking commands such as `brpop` and `blpop`),\nthe client will resend them when reconnected. This behavior can be disabled by setting the `autoResendUnfulfilledCommands` option to `false`.\n\nBy default, all pending commands will be flushed with an error every 20 retry attempts. That makes sure commands won't wait forever when the connection is down. You can change this behavior by setting `maxRetriesPerRequest`:\n\n```javascript\nvar redis = new Redis({\n  maxRetriesPerRequest: 1\n});\n```\n\nSet maxRetriesPerRequest to `null` to disable this behavior, and every command will wait forever until the connection is alive again (which is the default behavior before ioredis v4).\n\n### Reconnect on error\n\nBesides auto-reconnect when the connection is closed, ioredis supports reconnecting on the specified errors by the `reconnectOnError` option. Here's an example that will reconnect when receiving `READONLY` error:\n\n```javascript\nvar redis = new Redis({\n  reconnectOnError: function (err) {\n    var targetError = 'READONLY';\n    if (err.message.slice(0, targetError.length) === targetError) {\n      // Only reconnect when the error starts with \"READONLY\"\n      return true; // or `return 1;`\n    }\n  }\n});\n```\n\nThis feature is useful when using Amazon ElastiCache. Once failover happens, Amazon ElastiCache will switch the master we currently connected with to a slave, leading to the following writes fails with the error `READONLY`. Using `reconnectOnError`, we can force the connection to reconnect on this error in order to connect to the new master.\n\nFurthermore, if the `reconnectOnError` returns `2`, ioredis will resend the failed command after reconnecting.\n\n## Connection Events\nThe Redis instance will emit some events about the state of the connection to the Redis server.\n\nEvent    | Description\n:------------- | :-------------\nconnect  | emits when a connection is established to the Redis server.\nready    | If `enableReadyCheck` is `true`, client will emit `ready` when the server reports that it is ready to receive commands (e.g. finish loading data from disk).<br>Otherwise, `ready` will be emitted immediately right after the `connect` event.\nerror    | emits when an error occurs while connecting.<br>However, ioredis emits all `error` events silently (only emits when there's at least one listener) so that your application won't crash if you're not listening to the `error` event.\nclose    | emits when an established Redis server connection has closed.\nreconnecting | emits after `close` when a reconnection will be made. The argument of the event is the time (in ms) before reconnecting.\nend     | emits after `close` when no more reconnections will be made, or the connection is failed to establish.\n\nYou can also check out the `Redis#status` property to get the current connection status.\n\nBesides the above connection events, there are several other custom events:\n\nEvent    | Description\n:------------- | :-------------\nselect   | emits when the database changed. The argument is the new db number.\n\n## Offline Queue\nWhen a command can't be processed by Redis (being sent before the `ready` event), by default, it's added to the offline queue and will be\nexecuted when it can be processed. You can disable this feature by setting the `enableOfflineQueue`\noption to `false`:\n\n```javascript\nvar redis = new Redis({ enableOfflineQueue: false });\n```\n\n## TLS Options\nRedis doesn't support TLS natively, however if the redis server you want to connect to is hosted behind a TLS proxy (e.g. [stunnel](https://www.stunnel.org/)) or is offered by a PaaS service that supports TLS connection (e.g. [Redis Labs](https://redislabs.com/)), you can set the `tls` option:\n\n```javascript\nvar redis = new Redis({\n  host: 'localhost',\n  tls: {\n    // Refer to `tls.connect()` section in\n    // https://nodejs.org/api/tls.html\n    // for all supported options\n    ca: fs.readFileSync('cert.pem')\n  }\n});\n```\n\n<hr>\n\n## Sentinel\nioredis supports Sentinel out of the box. It works transparently as all features that work when\nyou connect to a single node also work when you connect to a sentinel group. Make sure to run Redis >= 2.8.12 if you want to use this feature. Sentinels have a default port of 26379.\n\nTo connect using Sentinel, use:\n\n```javascript\nvar redis = new Redis({\n  sentinels: [{ host: 'localhost', port: 26379 }, { host: 'localhost', port: 26380 }],\n  name: 'mymaster'\n});\n\nredis.set('foo', 'bar');\n```\n\nThe arguments passed to the constructor are different from the ones you use to connect to a single node, where:\n\n* `name` identifies a group of Redis instances composed of a master and one or more slaves (`mymaster` in the example);\n* `sentinels` are a list of sentinels to connect to. The list does not need to enumerate all your sentinel instances, but a few so that if one is down the client will try the next one.\n* `role` (optional) with a value of `slave` will return a random slave from the Sentinel group.\n* `preferredSlaves` (optional) can be used to prefer a particular slave or set of slaves based on priority. It accepts a function or array.\n\nioredis **guarantees** that the node you connected to is always a master even after a failover. When a failover happens, instead of trying to reconnect to the failed node (which will be demoted to slave when it's available again), ioredis will ask sentinels for the new master node and connect to it. All commands sent during the failover are queued and will be executed when the new connection is established so that none of the commands will be lost.\n\nIt's possible to connect to a slave instead of a master by specifying the option `role` with the value of `slave` and ioredis will try to connect to a random slave of the specified master, with the guarantee that the connected node is always a slave. If the current node is promoted to master due to a failover, ioredis will disconnect from it and ask the sentinels for another slave node to connect to.\n\nIf you specify the option `preferredSlaves` along with `role: 'slave'` ioredis will attempt to use this value when selecting the slave from the pool of available slaves. The value of `preferredSlaves` should either be a function that accepts an array of avaiable slaves and returns a single result, or an array of slave values priorities by the lowest `prio` value first with a default value of `1`.\n\n```javascript\n// available slaves format\nvar availableSlaves = [{ ip: '127.0.0.1', port: '31231', flags: 'slave' }];\n\n// preferredSlaves array format\nvar preferredSlaves = [\n  { ip: '127.0.0.1', port: '31231', prio: 1 },\n  { ip: '127.0.0.1', port: '31232', prio: 2 }\n];\n\n// preferredSlaves function format\npreferredSlaves = function(availableSlaves) {\n  for (var i = 0; i < availableSlaves.length; i++) {\n    var slave = availableSlaves[i];\n    if (slave.ip === '127.0.0.1') {\n      if (slave.port === '31234') {\n        return slave;\n      }\n    }\n  }\n  // if no preferred slaves are available a random one is used\n  return false;\n};\n\nvar redis = new Redis({\n  sentinels: [{ host: '127.0.0.1', port: 26379 }, { host: '127.0.0.1', port: 26380 }],\n  name: 'mymaster',\n  role: 'slave',\n  preferredSlaves: preferredSlaves\n});\n```\n\nBesides the `retryStrategy` option, there's also a `sentinelRetryStrategy` in Sentinel mode which will be invoked when all the sentinel nodes are unreachable during connecting. If `sentinelRetryStrategy` returns a valid delay time, ioredis will try to reconnect from scratch. The default value of `sentinelRetryStrategy` is:\n\n```javascript\nfunction (times) {\n  var delay = Math.min(times * 10, 1000);\n  return delay;\n}\n```\n\n## Cluster\nRedis Cluster provides a way to run a Redis installation where data is automatically sharded across multiple Redis nodes.\nYou can connect to a Redis Cluster like this:\n\n```javascript\nvar Redis = require('ioredis');\n\nvar cluster = new Redis.Cluster([{\n  port: 6380,\n  host: '127.0.0.1'\n}, {\n  port: 6381,\n  host: '127.0.0.1'\n}]);\n\ncluster.set('foo', 'bar');\ncluster.get('foo', function (err, res) {\n  // res === 'bar'\n});\n```\n\n`Cluster` constructor accepts two arguments, where:\n\n0. The first argument is a list of nodes of the cluster you want to connect to.\nJust like Sentinel, the list does not need to enumerate all your cluster nodes,\nbut a few so that if one is unreachable the client will try the next one, and the client will discover other nodes automatically when at least one node is connected.\n0. The second argument is the options, where:\n\n    * `clusterRetryStrategy`: When none of the startup nodes are reachable, `clusterRetryStrategy` will be invoked. When a number is returned,\n    ioredis will try to reconnect to the startup nodes from scratch after the specified delay (in ms). Otherwise, an error of \"None of startup nodes is available\" will be returned.\n    The default value of this option is:\n\n        ```javascript\n        function (times) {\n          var delay = Math.min(100 + times * 2, 2000);\n          return delay;\n        }\n        ```\n\n        It's possible to modify the `startupNodes` property in order to switch to another set of nodes here:\n\n        ```javascript\n        function (times) {\n          this.startupNodes = [{ port: 6790, host: '127.0.0.1' }];\n          return Math.min(100 + times * 2, 2000);\n        }\n        ```\n\n    * `enableOfflineQueue`: Similar to the `enableOfflineQueue` option of `Redis` class.\n    * `enableReadyCheck`: When enabled, \"ready\" event will only be emitted when `CLUSTER INFO` command\n    reporting the cluster is ready for handling commands. Otherwise, it will be emitted immediately after \"connect\" is emitted.\n    * `scaleReads`: Config where to send the read queries. See below for more details.\n    * `maxRedirections`: When a cluster related error (e.g. `MOVED`, `ASK` and `CLUSTERDOWN` etc.) is received, the client will redirect the\n    command to another node. This option limits the max redirections allowed when sending a command. The default value is `16`.\n    * `retryDelayOnFailover`: If the target node is disconnected when sending a command,\n    ioredis will retry after the specified delay. The default value is `100`. You should make sure `retryDelayOnFailover * maxRedirections > cluster-node-timeout`\n    to insure that no command will fail during a failover.\n    * `retryDelayOnClusterDown`: When a cluster is down, all commands will be rejected with the error of `CLUSTERDOWN`. If this option is a number (by default, it is `100`), the client\n    will resend the commands after the specified time (in ms).\n    * `retryDelayOnTryAgain`: If this option is a number (by default, it is `100`), the client\n    will resend the commands rejected with `TRYAGAIN` error after the specified time (in ms).\n    * `redisOptions`: Default options passed to the constructor of `Redis` when connecting to a node.\n    * `slotsRefreshTimeout`: Milliseconds before a timeout occurs while refreshing slots from the cluster (default `1000`)\n    * `slotsRefreshInterval`: Milliseconds between every automatic slots refresh (default `5000`)\n\n### Read-write splitting\n\nA typical redis cluster contains three or more masters and several slaves for each master. It's possible to scale out redis cluster by sending read queries to slaves and write queries to masters by setting the `scaleReads` option.\n\n`scaleReads` is \"master\" by default, which means ioredis will never send any queries to slaves. There are other three available options:\n\n1. \"all\": Send write queries to masters and read queries to masters or slaves randomly.\n2. \"slave\": Send write queries to masters and read queries to slaves.\n3. a custom `function(nodes, command): node`: Will choose the custom function to select to which node to send read queries (write queries keep being sent to master). The first node in `nodes` is always the master serving the relevant slots. If the function returns an array of nodes, a random node of that list will be selected.\n\nFor example:\n\n```javascript\nvar cluster = new Redis.Cluster([/* nodes */], {\n  scaleReads: 'slave'\n});\ncluster.set('foo', 'bar'); // This query will be sent to one of the masters.\ncluster.get('foo', function (err, res) {\n  // This query will be sent to one of the slaves.\n});\n```\n\n**NB** In the code snippet above, the `res` may not be equal to \"bar\" because of the lag of replication between the master and slaves.\n\n### Running commands to multiple nodes\n\nEvery command will be sent to exactly one node. For commands containing keys, (e.g. `GET`, `SET` and `HGETALL`), ioredis sends them to the node that serving the keys, and for other commands not containing keys, (e.g. `INFO`, `KEYS` and `FLUSHDB`), ioredis sends them to a random node.\n\nSometimes you may want to send a command to multiple nodes (masters or slaves) of the cluster, you can get the nodes via `Cluster#nodes()` method.\n\n`Cluster#nodes()` accepts a parameter role, which can be \"master\", \"slave\" and \"all\" (default), and returns an array of `Redis` instance. For example:\n\n```javascript\n// Send `FLUSHDB` command to all slaves:\nvar slaves = cluster.nodes('slave');\nPromise.all(slaves.map(function (node) {\n  return node.flushdb();\n}));\n\n// Get keys of all the masters:\nvar masters = cluster.nodes('master');\nPromise.all(masters.map(function (node) {\n  return node.keys();\n})).then(function (keys) {\n  // keys: [['key1', 'key2'], ['key3', 'key4']]\n});\n```\n\n### NAT Mapping\nSometimes the cluster is hosted within a internal network that can only be accessed via a NAT (Network Address Translation) instance. See [Accessing ElastiCache from outside AWS](https://docs.aws.amazon.com/AmazonElastiCache/latest/red-ug/accessing-elasticache.html) as an example.\n\nYou can specify nat mapping rules via `natMap` option:\n\n```javascript\nconst cluster = new Redis.Cluster([{\n  host: '203.0.113.73',\n  port: 30001\n}], {\n  natMap: {\n    '10.0.1.230:30001': {host: '203.0.113.73', port: 30001},\n    '10.0.1.231:30001': {host: '203.0.113.73', port: 30002},\n    '10.0.1.232:30001': {host: '203.0.113.73', port: 30003}\n  }\n})\n```\n\nThis option is also useful when the cluster is running inside a Docker container.\n\n### Transaction and pipeline in Cluster mode\nAlmost all features that are supported by `Redis` are also supported by `Redis.Cluster`, e.g. custom commands, transaction and pipeline.\nHowever there are some differences when using transaction and pipeline in Cluster mode:\n\n0. All keys in a pipeline should belong to the same slot since ioredis sends all commands in a pipeline to the same node.\n0. You can't use `multi` without pipeline (aka `cluster.multi({ pipeline: false })`). This is because when you call `cluster.multi({ pipeline: false })`, ioredis doesn't know which node the `multi` command should be sent to.\n0. Chaining custom commands in the pipeline is not supported in Cluster mode.\n\nWhen any commands in a pipeline receives a `MOVED` or `ASK` error, ioredis will resend the whole pipeline to the specified node automatically if all of the following conditions are satisfied:\n\n0. All errors received in the pipeline are the same. For example, we won't resend the pipeline if we got two `MOVED` errors pointing to different nodes.\n0. All commands executed successfully are readonly commands. This makes sure that resending the pipeline won't have side effects.\n\n### Pub/Sub\nPub/Sub in cluster mode works exactly as the same as in standalone mode. Internally, when a node of the cluster receives a message, it will broadcast the message to the other nodes. ioredis makes sure that each message will only be received once by strictly subscribing one node at the same time.\n\n```javascript\nvar nodes = [/* nodes */];\nvar pub = new Redis.Cluster(nodes);\nvar sub = new Redis.Cluster(nodes);\nsub.on('message', function (channel, message) {\n  console.log(channel, message);\n});\n\nsub.subscribe('news', function () {\n  pub.publish('news', 'highlights');\n});\n```\n\n### Events\n\nEvent    | Description\n:------------- | :-------------\nconnect  | emits when a connection is established to the Redis server.\nready    | emits when `CLUSTER INFO` reporting the cluster is able to receive commands (if `enableReadyCheck` is `true`) or immediately after `connect` event (if `enableReadyCheck` is false).\nerror    | emits when an error occurs while connecting with a property of `lastNodeError` representing the last node error received. This event is emitted silently (only emitting if there's at least one listener).\nclose    | emits when an established Redis server connection has closed.\nreconnecting | emits after `close` when a reconnection will be made. The argument of the event is the time (in ms) before reconnecting.\nend     | emits after `close` when no more reconnections will be made.\n+node   | emits when a new node is connected.\n-node   | emits when a node is disconnected.\nnode error | emits when an error occurs when connecting to a node\n\n### Password\nSetting the `password` option to access password-protected clusters:\n\n```javascript\nvar Redis = require('ioredis');\nvar cluster = new Redis.Cluster(nodes, {\n  redisOptions: {\n    password: 'your-cluster-password'\n  }\n});\n```\n\nIf some of nodes in the cluster using a different password, you should specify them in the first parameter:\n\n```javascript\nvar Redis = require('ioredis');\nvar cluster = new Redis.Cluster([\n  // Use password \"password-for-30001\" for 30001\n  { port: 30001, password: 'password-for-30001'},\n  // Don't use password when accessing 30002\n  { port: 30002, password: null }\n  // Other nodes will use \"fallback-password\"\n], {\n  redisOptions: {\n    password: 'fallback-password'\n  }\n});\n```\n\n<hr>\n\n# Error Handling\nAll the errors returned by the Redis server are instances of `ReplyError`, which can be accessed via `Redis`:\n\n```javascript\nvar Redis = require('ioredis');\nvar redis = new Redis();\n// This command causes a reply error since the SET command requires two arguments.\nredis.set('foo', function (err) {\n  err instanceof Redis.ReplyError\n});\n```\n\nThis is the error stack of the `ReplyError`:\n\n```\nReplyError: ERR wrong number of arguments for 'set' command\n    at ReplyParser._parseResult (/app/node_modules/ioredis/lib/parsers/javascript.js:60:14)\n    at ReplyParser.execute (/app/node_modules/ioredis/lib/parsers/javascript.js:178:20)\n    at Socket.<anonymous> (/app/node_modules/ioredis/lib/redis/event_handler.js:99:22)\n    at Socket.emit (events.js:97:17)\n    at readableAddChunk (_stream_readable.js:143:16)\n    at Socket.Readable.push (_stream_readable.js:106:10)\n    at TCP.onread (net.js:509:20)\n```\n\nBy default, the error stack doesn't make any sense because the whole stack happens in the ioredis\nmodule itself, not in your code. So it's not easy to find out where the error happens in your code.\nioredis provides an option `showFriendlyErrorStack` to solve the problem. When you enable\n`showFriendlyErrorStack`, ioredis will optimize the error stack for you:\n\n```javascript\nvar Redis = require('ioredis');\nvar redis = new Redis({ showFriendlyErrorStack: true });\nredis.set('foo');\n```\n\nAnd the output will be:\n\n```\nReplyError: ERR wrong number of arguments for 'set' command\n    at Object.<anonymous> (/app/index.js:3:7)\n    at Module._compile (module.js:446:26)\n    at Object.Module._extensions..js (module.js:464:10)\n    at Module.load (module.js:341:32)\n    at Function.Module._load (module.js:296:12)\n    at Function.Module.runMain (module.js:487:10)\n    at startup (node.js:111:16)\n    at node.js:799:3\n```\n\nThis time the stack tells you that the error happens on the third line in your code. Pretty sweet!\nHowever, it would decrease the performance significantly to optimize the error stack. So by\ndefault, this option is disabled and can only be used for debugging purposes. You **shouldn't** use this feature in a production environment.\n\n# Plugging in your own Promises Library\nIf you're an advanced user, you may want to plug in your own promise library like [bluebird](https://www.npmjs.com/package/bluebird). Just set Redis.Promise to your favorite ES6-style promise constructor and ioredis will use it.\n\n```javascript\nconst Redis = require('ioredis')\nRedis.Promise = require('bluebird')\n\nconst redis = new Redis()\n\n// Use bluebird\nassert.equal(redis.get().constructor, require('bluebird'))\n\n// You can change the Promise implementation at any time:\nRedis.Promise = global.Promise\nassert.equal(redis.get().constructor, global.Promise)\n```\n\n\n# Running tests\n\nStart a Redis server on 127.0.0.1:6379, and then:\n\n```shell\n$ npm test\n```\n\n`FLUSH ALL` will be invoked after each test, so make sure there's no valuable data in it before running tests.\n\nIf your testing environment does not let you spin up a Redis server [ioredis-mock](https://github.com/stipsan/ioredis-mock) is a drop-in replacement you can use in your tests. It aims to behave identically to ioredis connected to a Redis server so that your integration tests is easier to write and of better quality.\n\n# Debug\n\nYou can set the `DEBUG` env to `ioredis:*` to print debug info:\n\n```shell\n$ DEBUG=ioredis:* node app.js\n```\n\n# Consolidation: It's time for celebration\n\nRight now there are two great redis clients around and both have some advantages above each other. We speak about [node_redis](https://github.com/NodeRedis/node_redis) and ioredis. So after talking to each other about how we could improve in working together we (that is [@BridgeAR](https://github.com/BridgeAR) and [@luin](https://github.com/luin)) decided to work towards a single library on the long run. But step by step.\n\nFirst of all, we want to split small parts of our libraries into others so that we're both able to use the same code. Those libraries are going to be maintained under the NodeRedis organization. This is going to reduce the maintance overhead, allows others to use the very same code, if they need it and it's way easier for others to contribute to both libraries.\n\nWe're very happy about this step towards working together as we both want to give you the best redis experience possible.\n\nIf you want to join our cause by help maintaining something, please don't hesitate to contact either one of us.\n\n# Join in!\n\nI'm happy to receive bug reports, fixes, documentation enhancements, and any other improvements.\n\nAnd since I'm not a native English speaker, if you find any grammar mistakes in the documentation, please also let me know. :)\n\n# Contributors\n\nThis project exists thanks to all the people who contribute:\n\n<a href=\"https://github.com/luin/ioredis/graphs/contributors\"><img src=\"https://opencollective.com/ioredis/contributors.svg?width=890&showBtn=false\" /></a>\n\n# License\n\nMIT\n","readmeFilename":"README.md","bugs":{"url":"https://github.com/luin/ioredis/issues"},"homepage":"https://github.com/luin/ioredis#readme","_id":"ioredis@4.5.0","_npmVersion":"6.4.1","_nodeVersion":"10.15.0","_npmUser":{"name":"ioredis-robot","email":"ioredis-robot@zihua.li"},"dist":{"integrity":"sha512-0YuBCORXH5mKSBrbgtr1n3XTWS7pRqsvTJmXlkWysJnpsec2xY0ftJKkh7W0jGjOMS9WRbhdiluOjQJudLGTIQ==","shasum":"095a2e32b932e1ea8d5a816fc40401270332a3c1","tarball":"https://registry.npmjs.org/ioredis/-/ioredis-4.5.0.tgz","fileCount":35,"unpackedSize":217105,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJcM4RICRA9TVsSAnZWagAA1scP/iXsVL3yhaqdw6dW9Dga\nVPjObeeGu4ru/PEBiLaawFQuCR5moB+u5JHpjRMmOnyMuMvJvJnRazn8eytJ\nIPsMkYfEEIv0Fm/ORvlOiED8hoWMvUne+Fvh0St5fUytd3OUGQtflqYLYNEa\n/9rLKKeDQaI0NpT+y0LDepq7Y2C9asoLujTPMTtN4JBMtTNeKmIdzj00KsVP\nrTiK/VGPFnL2Mht8WpcCBJxaof3777CCU/Qe5V2YlvM8WpIBECUAyk7MXK7S\nyZk8g7YUNXh65aZBeo5x2RBWyXRwuyTl57du3/u48bkeqfGA0tz9x3weZWIE\nPaAxU/K64mkwiaHde2awCbMyMGd+T19J+zB+g8NFBmPa0fHpJu7U4qSdeYhK\nWOlj0O2TvkFFTaQHvbqmMWjoY6bwTz7I6L15JYef9Rr0umPhmdWUzzBfhbX9\n5ZbZ0V1IV/41bgdhN5lR1QeSKyRLQaagE1KNXcUCn8CBWHwtrM3btvIkowA7\nYJ+aUGCD8tGsKI7OLAWJrxazUIQVCrtcYmq0IkYcjLkTeIzv4N/NywPfPVo+\nifMQnjy53KzWOfC9zMCCgQp05CQBc2I4Rjb6X3NQFYVmAqQc7oA1To2iU2V7\nlaN22AnZ5PPIu+ZvRt6oKN/FSZk3Ycfp1oBtVH9uwhL3s7ryeliafwdFQvKG\nhpUz\r\n=qaF/\r\n-----END PGP SIGNATURE-----\r\n"},"maintainers":[{"email":"ioredis-robot@zihua.li","name":"ioredis-robot"},{"email":"i@zihua.li","name":"luin"}],"directories":{},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/ioredis_4.5.0_1546880071891_0.46353397829920295"},"_hasShrinkwrap":false},"4.5.1":{"name":"ioredis","version":"4.5.1","description":"A robust, performance-focused and full-featured Redis client for Node.js.","main":"built/index.js","scripts":{"test":"NODE_ENV=test mocha --timeout 8000 -r ts-node/register --exit","test:cov":"NODE_ENV=test node ./node_modules/istanbul/lib/cli.js cover --preserve-comments ./node_modules/mocha/bin/_mocha -- -r ts-node/register -R spec --exit","build":"rm -rf built && tsc","generate-docs":"jsdoc2md lib/redis.js lib/cluster/index.js lib/commander.js > API.md","prepublishOnly":"npm run build && npm test","bench":"matcha benchmarks/*.js","semantic-release":"semantic-release"},"repository":{"type":"git","url":"git://github.com/luin/ioredis.git"},"keywords":["redis","cluster","sentinel","pipelining"],"author":{"name":"luin","email":"i@zihua.li","url":"http://zihua.li"},"license":"MIT","dependencies":{"cluster-key-slot":"^1.0.6","debug":"^3.1.0","denque":"^1.1.0","flexbuffer":"0.0.6","lodash.defaults":"^4.2.0","lodash.flatten":"^4.4.0","redis-commands":"1.4.0","redis-errors":"^1.2.0","redis-parser":"^3.0.0","standard-as-callback":"^1.0.0"},"devDependencies":{"@semantic-release/changelog":"^3.0.0","@semantic-release/git":"^7.0.4","@types/node":"^10.11.5","@types/redis-errors":"1.2.0","bluebird":"^3.5.1","chai":"^3.5.0","cz-conventional-changelog":"^2.0.0","istanbul":"^0.4.2","jsdoc":"^3.4.0","jsdoc-to-markdown":"^4.0.1","mocha":"^5.2.0","server-destroy":"^1.0.1","sinon":"^1.17.3","ts-node":"^7.0.0","typescript":"^3.1.1"},"engines":{"node":">=6"},"config":{"commitizen":{"path":"./node_modules/cz-conventional-changelog"}},"gitHead":"5099e395ae7a109e368a220ee6fd282299a25262","bugs":{"url":"https://github.com/luin/ioredis/issues"},"homepage":"https://github.com/luin/ioredis#readme","_id":"ioredis@4.5.1","_npmVersion":"6.4.1","_nodeVersion":"10.15.0","_npmUser":{"name":"ioredis-robot","email":"ioredis-robot@zihua.li"},"dist":{"integrity":"sha512-p1BblrFZdb5Oc5EBsEb4EoycDqn7xi/NTNT4bDvo/w6B08eMNO1E7RAOOEA1GAb65+8Hbs2LgUyz3cZOTiP3xg==","shasum":"b1c1c1657697caa3a617acb9370e3c0694edb775","tarball":"https://registry.npmjs.org/ioredis/-/ioredis-4.5.1.tgz","fileCount":35,"unpackedSize":217582,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJcO3lsCRA9TVsSAnZWagAAgmwP/1G9pxx7fnXMoC/BXH37\nRlR9OkeADxN4feTix1mxHZ4h16U5ka/UCLMEzkkBou42ltXzVwsyUaRUxYgb\nF/WJJ9DTMLVABG0seOGJN0q1V5DgO8dQrlTHxOjSqZaGK7c2eNepeSk986Nd\ngajQqIOkf1GE9AxI+CxvN0FTbWYNgOnA/iGz+G0VjItgRRAsmYcgILWQrbSg\ne/NtSZoE1b9kx4yFQu6AsGK3YK18lbzZqfA0+eZm4LqnrgXXe1XF9FAh6VaJ\nL2bDpowhp8BTRXl/sZkY0nQS2IsQ1bHazDcpMG2muuU/jZUFz4gdf7bYMkbB\nBLR2SpF30RFuLRe6zTId73xCRGNkLuDjuilbSKx+RW7qscAk/ogH+N99gf+h\nnazQc1fsmwS+OasU6g4RgVzJV6jAjuxw/m1d6sMRBmgfxcuy2uhVZnAN8+uK\nyz7HiZoOOlA2lNGvZUZLpwq04Yj8W4bVm5V61DBT8vXgF2XgZ6iqxzBF5UZB\nVRCjnVR36w6/uKoCpos/s7LB97Xb2BIca6fqUrmgsKy5IcRuJyji4dUFWR4w\nvQaltYyXRMYL5JEmERk+YlE/KlNA63gciYc6dCZTCN8mehN9r74WYoP5M9gF\nYFx4j9sIIMyprxwEdyJbLf82l67iUiTYFcq0U/9us1/HrdMe3BUpe0d2NgPR\nKyPj\r\n=bpQt\r\n-----END PGP SIGNATURE-----\r\n"},"maintainers":[{"email":"ioredis-robot@zihua.li","name":"ioredis-robot"},{"email":"i@zihua.li","name":"luin"}],"directories":{},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/ioredis_4.5.1_1547401580191_0.5629719059874585"},"_hasShrinkwrap":false},"4.6.0":{"name":"ioredis","version":"4.6.0","description":"A robust, performance-focused and full-featured Redis client for Node.js.","main":"built/index.js","scripts":{"test":"NODE_ENV=test mocha --timeout 8000 -r ts-node/register --exit","test:cov":"NODE_ENV=test node ./node_modules/istanbul/lib/cli.js cover --preserve-comments ./node_modules/mocha/bin/_mocha -- -r ts-node/register -R spec --exit","build":"rm -rf built && tsc","generate-docs":"jsdoc2md lib/redis.js lib/cluster/index.js lib/commander.js > API.md","prepublishOnly":"npm run build && npm test","bench":"matcha benchmarks/*.js","semantic-release":"semantic-release"},"repository":{"type":"git","url":"git://github.com/luin/ioredis.git"},"keywords":["redis","cluster","sentinel","pipelining"],"author":{"name":"luin","email":"i@zihua.li","url":"http://zihua.li"},"license":"MIT","dependencies":{"cluster-key-slot":"^1.0.6","debug":"^3.1.0","denque":"^1.1.0","flexbuffer":"0.0.6","lodash.defaults":"^4.2.0","lodash.flatten":"^4.4.0","redis-commands":"1.4.0","redis-errors":"^1.2.0","redis-parser":"^3.0.0","standard-as-callback":"^1.0.0"},"devDependencies":{"@semantic-release/changelog":"^3.0.0","@semantic-release/git":"^7.0.4","@types/node":"^10.11.5","@types/redis-errors":"1.2.0","bluebird":"^3.5.1","chai":"^3.5.0","cz-conventional-changelog":"^2.0.0","istanbul":"^0.4.2","jsdoc":"^3.4.0","jsdoc-to-markdown":"^4.0.1","mocha":"^5.2.0","server-destroy":"^1.0.1","sinon":"^1.17.3","ts-node":"^7.0.0","typescript":"^3.1.1"},"engines":{"node":">=6"},"config":{"commitizen":{"path":"./node_modules/cz-conventional-changelog"}},"gitHead":"fbcf692f5de8c653139e4b053c6356ab6d67e463","readme":"[![ioredis](https://cdn.rawgit.com/luin/ioredis/57b5b89e3e9111ff25d8c62c0bc58ed42e5b8d1e/logo.svg)](https://github.com/luin/ioredis)\n\n[![Build Status](https://travis-ci.org/luin/ioredis.svg?branch=master)](https://travis-ci.org/luin/ioredis)\n[![Test Coverage](https://codeclimate.com/github/luin/ioredis/badges/coverage.svg)](https://codeclimate.com/github/luin/ioredis)\n[![Join the chat at https://gitter.im/luin/ioredis](https://badges.gitter.im/Join%20Chat.svg)](https://gitter.im/luin/ioredis?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge)\n[![Commitizen friendly](https://img.shields.io/badge/commitizen-friendly-brightgreen.svg)](http://commitizen.github.io/cz-cli/)\n[![semantic-release](https://img.shields.io/badge/%20%20%F0%9F%93%A6%F0%9F%9A%80-semantic--release-e10079.svg)](https://github.com/semantic-release/semantic-release)\n[![npm latest version](https://img.shields.io/npm/v/ioredis/latest.svg)](https://www.npmjs.com/package/ioredis)\n[![npm next version](https://img.shields.io/npm/v/ioredis/next.svg)](https://www.npmjs.com/package/ioredis)\n<img alt=\"\" src=\"\">\n\nA robust, performance-focused and full-featured [Redis](http://redis.io) client for [Node.js](https://nodejs.org).\n\nSupports Redis >= 2.6.12 and (Node.js >= 6).\n\n# Features\nioredis is a robust, full-featured Redis client that is\nused in the world's biggest online commerce company [Alibaba](http://www.alibaba.com/) and many other awesome companies.\n\n0. Full-featured. It supports [Cluster](http://redis.io/topics/cluster-tutorial), [Sentinel](http://redis.io/topics/sentinel), [Pipelining](http://redis.io/topics/pipelining) and of course [Lua scripting](http://redis.io/commands/eval) & [Pub/Sub](http://redis.io/topics/pubsub) (with the support of binary messages).\n0. High performance.\n0. Delightful API. It works with Node callbacks and Native promises.\n0. Transformation of command arguments and replies.\n0. Transparent key prefixing.\n0. Abstraction for Lua scripting, allowing you to define custom commands.\n0. Support for binary data.\n0. Support for TLS.\n0. Support for offline queue and ready checking.\n0. Support for ES6 types, such as `Map` and `Set`.\n0. Support for GEO commands (Redis 3.2 Unstable).\n0. Sophisticated error handling strategy.\n0. Support for NAT mapping.\n\n# Links\n* [API Documentation](API.md)\n* [Changelog](Changelog.md)\n* [Migrating from node_redis](https://github.com/luin/ioredis/wiki/Migrating-from-node_redis)\n* [Error Handling](#error-handling)\n\n## Become a Sponsor to Support ioredis's Development\nOpen source is hard and time-consuming. If you want to invest in ioredis's future you can become a sponsor and make us spend more time on this library's improvements and new features.\n\n<a href=\"https://opencollective.com/ioredis\"><img src=\"https://opencollective.com/ioredis/tiers/sponsor.svg?avatarHeight=36\"></a>\n\nThank you for using ioredis :-)\n\n<hr>\n<a href=\"https://itunes.apple.com/app/medis-gui-for-redis/id1063631769\"><img align=\"right\" src=\"medis.png\" alt=\"Download on the App Store\"></a>\n\n\n### Advertisement\n\nLooking for a Redis GUI manager for OS X, Windows and Linux? Here's [Medis](https://itunes.apple.com/us/app/medis-gui-for-redis/id1063631769)!\n\nMedis is an open-sourced, beautiful, easy-to-use Redis GUI management application.\n\nMedis starts with all the basic features you need:\n\n* Keys viewing/editing\n* SSH Tunnel for connecting with remote servers\n* Terminal for executing custom commands\n* JSON/MessagePack format viewing/editing and built-in highlighting/validator\n* And other awesome features...\n\n[Medis is open sourced on GitHub](https://github.com/luin/medis)\n\n<hr>\n\n# Quick Start\n\n## Install\n```shell\n$ npm install ioredis\n```\n\n## Basic Usage\n\n```javascript\nvar Redis = require('ioredis');\nvar redis = new Redis();\n\nredis.set('foo', 'bar');\nredis.get('foo', function (err, result) {\n  console.log(result);\n});\n\n// Or using a promise if the last argument isn't a function\nredis.get('foo').then(function (result) {\n  console.log(result);\n});\n\n// Arguments to commands are flattened, so the following are the same:\nredis.sadd('set', 1, 3, 5, 7);\nredis.sadd('set', [1, 3, 5, 7]);\n\n// All arguments are passed directly to the redis server:\nredis.set('key', 100, 'EX', 10);\n```\n\nSee the `examples/` folder for more examples.\n\n## Connect to Redis\nWhen a new `Redis` instance is created,\na connection to Redis will be created at the same time.\nYou can specify which Redis to connect to by:\n\n```javascript\nnew Redis()       // Connect to 127.0.0.1:6379\nnew Redis(6380)   // 127.0.0.1:6380\nnew Redis(6379, '192.168.1.1')        // 192.168.1.1:6379\nnew Redis('/tmp/redis.sock')\nnew Redis({\n  port: 6379,          // Redis port\n  host: '127.0.0.1',   // Redis host\n  family: 4,           // 4 (IPv4) or 6 (IPv6)\n  password: 'auth',\n  db: 0\n})\n```\n\nYou can also specify connection options as a [`redis://` URL](http://www.iana.org/assignments/uri-schemes/prov/redis):\n\n```javascript\n// Connect to 127.0.0.1:6380, db 4, using password \"authpassword\":\nnew Redis('redis://:authpassword@127.0.0.1:6380/4')\n```\n\nSee [API Documentation](API.md#new_Redis) for all available options.\n\n## Pub/Sub\n\nHere is a simple example of the API for publish/subscribe.\nThe following program opens two client connections.\nIt subscribes to a channel with one connection\nand publishes to that channel with the other:\n\n```javascript\nvar Redis = require('ioredis');\nvar redis = new Redis();\nvar pub = new Redis();\nredis.subscribe('news', 'music', function (err, count) {\n  // Now we are subscribed to both the 'news' and 'music' channels.\n  // `count` represents the number of channels we are currently subscribed to.\n\n  pub.publish('news', 'Hello world!');\n  pub.publish('music', 'Hello again!');\n});\n\nredis.on('message', function (channel, message) {\n  // Receive message Hello world! from channel news\n  // Receive message Hello again! from channel music\n  console.log('Receive message %s from channel %s', message, channel);\n});\n\n// There's also an event called 'messageBuffer', which is the same as 'message' except\n// it returns buffers instead of strings.\nredis.on('messageBuffer', function (channel, message) {\n  // Both `channel` and `message` are buffers.\n});\n```\n\n`PSUBSCRIBE` is also supported in a similar way:\n\n```javascript\nredis.psubscribe('pat?ern', function (err, count) {});\nredis.on('pmessage', function (pattern, channel, message) {});\nredis.on('pmessageBuffer', function (pattern, channel, message) {});\n```\n\nWhen a client issues a SUBSCRIBE or PSUBSCRIBE, that connection is put into a \"subscriber\" mode.\nAt that point, only commands that modify the subscription set are valid.\nWhen the subscription set is empty, the connection is put back into regular mode.\n\nIf you need to send regular commands to Redis while in subscriber mode, just open another connection.\n\n## Handle Binary Data\nArguments can be buffers:\n```javascript\nredis.set('foo', Buffer.from('bar'));\n```\n\nAnd every command has a method that returns a Buffer (by adding a suffix of \"Buffer\" to the command name).\nTo get a buffer instead of a utf8 string:\n\n```javascript\nredis.getBuffer('foo', function (err, result) {\n  // result is a buffer.\n});\n```\n\n## Pipelining\nIf you want to send a batch of commands (e.g. > 5), you can use pipelining to queue\nthe commands in memory and then send them to Redis all at once. This way the performance improves by 50%~300% (See [benchmark section](#benchmark)).\n\n`redis.pipeline()` creates a `Pipeline` instance. You can call any Redis\ncommands on it just like the `Redis` instance. The commands are queued in memory\nand flushed to Redis by calling the `exec` method:\n\n```javascript\nvar pipeline = redis.pipeline();\npipeline.set('foo', 'bar');\npipeline.del('cc');\npipeline.exec(function (err, results) {\n  // `err` is always null, and `results` is an array of responses\n  // corresponding to the sequence of queued commands.\n  // Each response follows the format `[err, result]`.\n});\n\n// You can even chain the commands:\nredis.pipeline().set('foo', 'bar').del('cc').exec(function (err, results) {\n});\n\n// `exec` also returns a Promise:\nvar promise = redis.pipeline().set('foo', 'bar').get('foo').exec();\npromise.then(function (result) {\n  // result === [[null, 'OK'], [null, 'bar']]\n});\n```\n\nEach chained command can also have a callback, which will be invoked when the command\ngets a reply:\n\n```javascript\nredis.pipeline().set('foo', 'bar').get('foo', function (err, result) {\n  // result === 'bar'\n}).exec(function (err, result) {\n  // result[1][1] === 'bar'\n});\n```\n\nIn addition to adding commands to the `pipeline` queue individually, you can also pass an array of commands and arguments to the constructor:\n\n```javascript\nredis.pipeline([\n  ['set', 'foo', 'bar'],\n  ['get', 'foo']\n]).exec(function () { /* ... */ });\n```\n\n`#length` property shows how many commands in the pipeline:\n\n```javascript\nconst length = redis.pipeline().set('foo', 'bar').get('foo').length;\n// length === 2\n```\n\n\n## Transaction\nMost of the time, the transaction commands `multi` & `exec` are used together with pipeline.\nTherefore, when `multi` is called, a `Pipeline` instance is created automatically by default,\nso you can use `multi` just like `pipeline`:\n\n```javascript\nredis.multi().set('foo', 'bar').get('foo').exec(function (err, results) {\n  // results === [[null, 'OK'], [null, 'bar']]\n});\n```\nIf there's a syntax error in the transaction's command chain (e.g. wrong number of arguments, wrong command name, etc),\nthen none of the commands would be executed, and an error is returned:\n\n```javascript\nredis.multi().set('foo').set('foo', 'new value').exec(function (err, results) {\n  // err:\n  //  { [ReplyError: EXECABORT Transaction discarded because of previous errors.]\n  //    name: 'ReplyError',\n  //    message: 'EXECABORT Transaction discarded because of previous errors.',\n  //    command: { name: 'exec', args: [] },\n  //    previousErrors:\n  //     [ { [ReplyError: ERR wrong number of arguments for 'set' command]\n  //         name: 'ReplyError',\n  //         message: 'ERR wrong number of arguments for \\'set\\' command',\n  //         command: [Object] } ] }\n});\n```\n\nIn terms of the interface, `multi` differs from `pipeline` in that when specifying a callback\nto each chained command, the queueing state is passed to the callback instead of the result of the command:\n\n```javascript\nredis.multi().set('foo', 'bar', function (err, result) {\n  // result === 'QUEUED'\n}).exec(/* ... */);\n```\n\nIf you want to use transaction without pipeline, pass `{ pipeline: false }` to `multi`,\nand every command will be sent to Redis immediately without waiting for an `exec` invocation:\n\n```javascript\nredis.multi({ pipeline: false });\nredis.set('foo', 'bar');\nredis.get('foo');\nredis.exec(function (err, result) {\n  // result === [[null, 'OK'], [null, 'bar']]\n});\n```\n\nThe constructor of `multi` also accepts a batch of commands:\n\n```javascript\nredis.multi([\n  ['set', 'foo', 'bar'],\n  ['get', 'foo']\n]).exec(function () { /* ... */ });\n```\n\nInline transactions are supported by pipeline, which means you can group a subset of commands\nin the pipeline into a transaction:\n\n```javascript\nredis.pipeline().get('foo').multi().set('foo', 'bar').get('foo').exec().get('foo').exec();\n```\n\n## Lua Scripting\nioredis supports all of the scripting commands such as `EVAL`, `EVALSHA` and `SCRIPT`.\nHowever, it's tedious to use in real world scenarios since developers have to take\ncare of script caching and to detect when to use `EVAL` and when to use `EVALSHA`.\nioredis expose a `defineCommand` method to make scripting much easier to use:\n\n```javascript\nvar redis = new Redis();\n\n// This will define a command echo:\nredis.defineCommand('echo', {\n  numberOfKeys: 2,\n  lua: 'return {KEYS[1],KEYS[2],ARGV[1],ARGV[2]}'\n});\n\n// Now `echo` can be used just like any other ordinary command,\n// and ioredis will try to use `EVALSHA` internally when possible for better performance.\nredis.echo('k1', 'k2', 'a1', 'a2', function (err, result) {\n  // result === ['k1', 'k2', 'a1', 'a2']\n});\n\n// `echoBuffer` is also defined automatically to return buffers instead of strings:\nredis.echoBuffer('k1', 'k2', 'a1', 'a2', function (err, result) {\n  // result[0] equals to Buffer.from('k1');\n});\n\n// And of course it works with pipeline:\nredis.pipeline().set('foo', 'bar').echo('k1', 'k2', 'a1', 'a2').exec();\n```\n\nIf the number of keys can't be determined when defining a command, you can\nomit the `numberOfKeys` property and pass the number of keys as the first argument\nwhen you call the command:\n\n```javascript\nredis.defineCommand('echoDynamicKeyNumber', {\n  lua: 'return {KEYS[1],KEYS[2],ARGV[1],ARGV[2]}'\n});\n\n// Now you have to pass the number of keys as the first argument every time\n// you invoke the `echoDynamicKeyNumber` command:\nredis.echoDynamicKeyNumber(2, 'k1', 'k2', 'a1', 'a2', function (err, result) {\n  // result === ['k1', 'k2', 'a1', 'a2']\n});\n```\n\n## Transparent Key Prefixing\nThis feature allows you to specify a string that will automatically be prepended\nto all the keys in a command, which makes it easier to manage your key\nnamespaces.\n\n**Warning** This feature won't apply to commands like [KEYS](http://redis.io/commands/KEYS) and [SCAN](http://redis.io/commands/scan) that take patterns rather than actual keys([#239](https://github.com/luin/ioredis/issues/239)),\nand this feature also won't apply to the replies of commands even they are key names ([#325](https://github.com/luin/ioredis/issues/325)).\n\n```javascript\nvar fooRedis = new Redis({ keyPrefix: 'foo:' });\nfooRedis.set('bar', 'baz');  // Actually sends SET foo:bar baz\n\nfooRedis.defineCommand('echo', {\n  numberOfKeys: 2,\n  lua: 'return {KEYS[1],KEYS[2],ARGV[1],ARGV[2]}'\n});\n\n// Works well with pipelining/transaction\nfooRedis.pipeline()\n  // Sends SORT foo:list BY foo:weight_*->fieldname\n  .sort('list', 'BY', 'weight_*->fieldname')\n  // Supports custom commands\n  // Sends EVALSHA xxx foo:k1 foo:k2 a1 a2\n  .echo('k1', 'k2', 'a1', 'a2')\n  .exec()\n```\n\n## Transforming Arguments & Replies\nMost Redis commands take one or more Strings as arguments,\nand replies are sent back as a single String or an Array of Strings. However, sometimes\nyou may want something different. For instance, it would be more convenient if the `HGETALL`\ncommand returns a hash (e.g. `{ key: val1, key2: v2 }`) rather than an array of key values (e.g. `[key1, val1, key2, val2]`).\n\nioredis has a flexible system for transforming arguments and replies. There are two types\nof transformers, argument transformer and reply transformer:\n\n```javascript\nvar Redis = require('ioredis');\n\n// Here's the built-in argument transformer converting\n// hmset('key', { k1: 'v1', k2: 'v2' })\n// or\n// hmset('key', new Map([['k1', 'v1'], ['k2', 'v2']]))\n// into\n// hmset('key', 'k1', 'v1', 'k2', 'v2')\nRedis.Command.setArgumentTransformer('hmset', function (args) {\n  if (args.length === 2) {\n    if (typeof Map !== 'undefined' && args[1] instanceof Map) {\n      // utils is a internal module of ioredis\n      return [args[0]].concat(utils.convertMapToArray(args[1]));\n    }\n    if ( typeof args[1] === 'object' && args[1] !== null) {\n      return [args[0]].concat(utils.convertObjectToArray(args[1]));\n    }\n  }\n  return args;\n});\n\n// Here's the built-in reply transformer converting the HGETALL reply\n// ['k1', 'v1', 'k2', 'v2']\n// into\n// { k1: 'v1', 'k2': 'v2' }\nRedis.Command.setReplyTransformer('hgetall', function (result) {\n  if (Array.isArray(result)) {\n    var obj = {};\n    for (var i = 0; i < result.length; i += 2) {\n      obj[result[i]] = result[i + 1];\n    }\n    return obj;\n  }\n  return result;\n});\n```\n\nThere are three built-in transformers, two argument transformers for `hmset` & `mset` and\na reply transformer for `hgetall`. Transformers for `hmset` and `hgetall` were mentioned\nabove, and the transformer for `mset` is similar to the one for `hmset`:\n\n```javascript\nredis.mset({ k1: 'v1', k2: 'v2' });\nredis.get('k1', function (err, result) {\n  // result === 'v1';\n});\n\nredis.mset(new Map([['k3', 'v3'], ['k4', 'v4']]));\nredis.get('k3', function (err, result) {\n  // result === 'v3';\n});\n```\n\nAnother useful example of a reply transformer is one that changes `hgetall` to return array of arrays instead of objects which avoids a unwanted conversation of hash keys to strings when dealing with binary hash keys:\n\n```javascript\nRedis.Command.setReplyTransformer('hgetall', function (result) {\n  var arr = [];\n  for (var i = 0; i < result.length; i += 2) {\n    arr.push([result[i], result[i + 1]]);\n  }\n  return arr;\n});\nredis.hset('h1', Buffer.from([0x01]), Buffer.from([0x02]));\nredis.hset('h1', Buffer.from([0x03]), Buffer.from([0x04]));\nredis.hgetallBuffer('h1', function (err, result) {\n  // result === [ [ <Buffer 01>, <Buffer 02> ], [ <Buffer 03>, <Buffer 04> ] ];\n});\n```\n\n## Monitor\nRedis supports the MONITOR command,\nwhich lets you see all commands received by the Redis server across all client connections,\nincluding from other client libraries and other computers.\n\nThe `monitor` method returns a monitor instance.\nAfter you send the MONITOR command, no other commands are valid on that connection. ioredis will emit a monitor event for every new monitor message that comes across.\nThe callback for the monitor event takes a timestamp from the Redis server and an array of command arguments.\n\nHere is a simple example:\n\n```javascript\nredis.monitor(function (err, monitor) {\n  monitor.on('monitor', function (time, args, source, database) {\n  });\n});\n```\n\n## Streamify Scanning\nRedis 2.8 added the `SCAN` command to incrementally iterate through the keys in the database. It's different from `KEYS` in that\n`SCAN` only returns a small number of elements each call, so it can be used in production without the downside\nof blocking the server for a long time. However, it requires recording the cursor on the client side each time\nthe `SCAN` command is called in order to iterate through all the keys correctly. Since it's a relatively common use case, ioredis\nprovides a streaming interface for the `SCAN` command to make things much easier. A readable stream can be created by calling `scanStream`:\n\n```javascript\nvar redis = new Redis();\n// Create a readable stream (object mode)\nvar stream = redis.scanStream();\nstream.on('data', function (resultKeys) {\n  // `resultKeys` is an array of strings representing key names.\n  // Note that resultKeys may contain 0 keys, and that it will sometimes\n  // contain duplicates due to SCAN's implementation in Redis.\n  for (var i = 0; i < resultKeys.length; i++) {\n    console.log(resultKeys[i]);\n  }\n});\nstream.on('end', function () {\n  console.log('all keys have been visited');\n});\n```\n\n`scanStream` accepts an option, with which you can specify the `MATCH` pattern and the `COUNT` argument:\n\n```javascript\nvar stream = redis.scanStream({\n  // only returns keys following the pattern of `user:*`\n  match: 'user:*',\n  // returns approximately 100 elements per call\n  count: 100\n});\n```\n\nJust like other commands, `scanStream` has a binary version `scanBufferStream`, which returns an array of buffers. It's useful when\nthe key names are not utf8 strings.\n\nThere are also `hscanStream`, `zscanStream` and `sscanStream` to iterate through elements in a hash, zset and set. The interface of each is\nsimilar to `scanStream` except the first argument is the key name:\n\n```javascript\nvar stream = redis.hscanStream('myhash', {\n  match: 'age:??'\n});\n```\n\nYou can learn more from the [Redis documentation](http://redis.io/commands/scan).\n\n**Useful Tips**\nIt's pretty common that doing an async task in the `data` handler. We'd like the scanning process to be paused until the async task to be finished. `Stream#pause()` and `Stream.resume()` do the trick. For example if we want to migrate data in Redis to MySQL:\n\n```javascript\nvar stream = redis.scanStream();\nstream.on('data', function (resultKeys) {\n  // Pause the stream from scanning more keys until we've migrated the current keys.\n  stream.pause();\n\n  Promise.all(resultKeys.map(migrateKeyToMySQL)).then(() => {\n    // Resume the stream here.\n    stream.resume();\n  });\n});\n\nstream.on('end', function () {\n  console.log('done migration');\n});\n```\n\n## Auto-reconnect\nBy default, ioredis will try to reconnect when the connection to Redis is lost\nexcept when the connection is closed manually by `redis.disconnect()` or `redis.quit()`.\n\nIt's very flexible to control how long to wait to reconnect after disconnection\nusing the `retryStrategy` option:\n\n```javascript\nvar redis = new Redis({\n  // This is the default value of `retryStrategy`\n  retryStrategy: function (times) {\n    var delay = Math.min(times * 50, 2000);\n    return delay;\n  }\n});\n```\n\n`retryStrategy` is a function that will be called when the connection is lost.\nThe argument `times` means this is the nth reconnection being made and\nthe return value represents how long (in ms) to wait to reconnect. When the\nreturn value isn't a number, ioredis will stop trying to reconnect, and the connection\nwill be lost forever if the user doesn't call `redis.connect()` manually.\n\nWhen reconnected, the client will auto subscribe to channels that the previous connection subscribed to.\nThis behavior can be disabled by setting the `autoResubscribe` option to `false`.\n\nAnd if the previous connection has some unfulfilled commands (most likely blocking commands such as `brpop` and `blpop`),\nthe client will resend them when reconnected. This behavior can be disabled by setting the `autoResendUnfulfilledCommands` option to `false`.\n\nBy default, all pending commands will be flushed with an error every 20 retry attempts. That makes sure commands won't wait forever when the connection is down. You can change this behavior by setting `maxRetriesPerRequest`:\n\n```javascript\nvar redis = new Redis({\n  maxRetriesPerRequest: 1\n});\n```\n\nSet maxRetriesPerRequest to `null` to disable this behavior, and every command will wait forever until the connection is alive again (which is the default behavior before ioredis v4).\n\n### Reconnect on error\n\nBesides auto-reconnect when the connection is closed, ioredis supports reconnecting on the specified errors by the `reconnectOnError` option. Here's an example that will reconnect when receiving `READONLY` error:\n\n```javascript\nvar redis = new Redis({\n  reconnectOnError: function (err) {\n    var targetError = 'READONLY';\n    if (err.message.slice(0, targetError.length) === targetError) {\n      // Only reconnect when the error starts with \"READONLY\"\n      return true; // or `return 1;`\n    }\n  }\n});\n```\n\nThis feature is useful when using Amazon ElastiCache. Once failover happens, Amazon ElastiCache will switch the master we currently connected with to a slave, leading to the following writes fails with the error `READONLY`. Using `reconnectOnError`, we can force the connection to reconnect on this error in order to connect to the new master.\n\nFurthermore, if the `reconnectOnError` returns `2`, ioredis will resend the failed command after reconnecting.\n\n## Connection Events\nThe Redis instance will emit some events about the state of the connection to the Redis server.\n\nEvent    | Description\n:------------- | :-------------\nconnect  | emits when a connection is established to the Redis server.\nready    | If `enableReadyCheck` is `true`, client will emit `ready` when the server reports that it is ready to receive commands (e.g. finish loading data from disk).<br>Otherwise, `ready` will be emitted immediately right after the `connect` event.\nerror    | emits when an error occurs while connecting.<br>However, ioredis emits all `error` events silently (only emits when there's at least one listener) so that your application won't crash if you're not listening to the `error` event.\nclose    | emits when an established Redis server connection has closed.\nreconnecting | emits after `close` when a reconnection will be made. The argument of the event is the time (in ms) before reconnecting.\nend     | emits after `close` when no more reconnections will be made, or the connection is failed to establish.\n\nYou can also check out the `Redis#status` property to get the current connection status.\n\nBesides the above connection events, there are several other custom events:\n\nEvent    | Description\n:------------- | :-------------\nselect   | emits when the database changed. The argument is the new db number.\n\n## Offline Queue\nWhen a command can't be processed by Redis (being sent before the `ready` event), by default, it's added to the offline queue and will be\nexecuted when it can be processed. You can disable this feature by setting the `enableOfflineQueue`\noption to `false`:\n\n```javascript\nvar redis = new Redis({ enableOfflineQueue: false });\n```\n\n## TLS Options\nRedis doesn't support TLS natively, however if the redis server you want to connect to is hosted behind a TLS proxy (e.g. [stunnel](https://www.stunnel.org/)) or is offered by a PaaS service that supports TLS connection (e.g. [Redis Labs](https://redislabs.com/)), you can set the `tls` option:\n\n```javascript\nvar redis = new Redis({\n  host: 'localhost',\n  tls: {\n    // Refer to `tls.connect()` section in\n    // https://nodejs.org/api/tls.html\n    // for all supported options\n    ca: fs.readFileSync('cert.pem')\n  }\n});\n```\n\n<hr>\n\n## Sentinel\nioredis supports Sentinel out of the box. It works transparently as all features that work when\nyou connect to a single node also work when you connect to a sentinel group. Make sure to run Redis >= 2.8.12 if you want to use this feature. Sentinels have a default port of 26379.\n\nTo connect using Sentinel, use:\n\n```javascript\nvar redis = new Redis({\n  sentinels: [{ host: 'localhost', port: 26379 }, { host: 'localhost', port: 26380 }],\n  name: 'mymaster'\n});\n\nredis.set('foo', 'bar');\n```\n\nThe arguments passed to the constructor are different from the ones you use to connect to a single node, where:\n\n* `name` identifies a group of Redis instances composed of a master and one or more slaves (`mymaster` in the example);\n* `sentinels` are a list of sentinels to connect to. The list does not need to enumerate all your sentinel instances, but a few so that if one is down the client will try the next one.\n* `role` (optional) with a value of `slave` will return a random slave from the Sentinel group.\n* `preferredSlaves` (optional) can be used to prefer a particular slave or set of slaves based on priority. It accepts a function or array.\n\nioredis **guarantees** that the node you connected to is always a master even after a failover. When a failover happens, instead of trying to reconnect to the failed node (which will be demoted to slave when it's available again), ioredis will ask sentinels for the new master node and connect to it. All commands sent during the failover are queued and will be executed when the new connection is established so that none of the commands will be lost.\n\nIt's possible to connect to a slave instead of a master by specifying the option `role` with the value of `slave` and ioredis will try to connect to a random slave of the specified master, with the guarantee that the connected node is always a slave. If the current node is promoted to master due to a failover, ioredis will disconnect from it and ask the sentinels for another slave node to connect to.\n\nIf you specify the option `preferredSlaves` along with `role: 'slave'` ioredis will attempt to use this value when selecting the slave from the pool of available slaves. The value of `preferredSlaves` should either be a function that accepts an array of avaiable slaves and returns a single result, or an array of slave values priorities by the lowest `prio` value first with a default value of `1`.\n\n```javascript\n// available slaves format\nvar availableSlaves = [{ ip: '127.0.0.1', port: '31231', flags: 'slave' }];\n\n// preferredSlaves array format\nvar preferredSlaves = [\n  { ip: '127.0.0.1', port: '31231', prio: 1 },\n  { ip: '127.0.0.1', port: '31232', prio: 2 }\n];\n\n// preferredSlaves function format\npreferredSlaves = function(availableSlaves) {\n  for (var i = 0; i < availableSlaves.length; i++) {\n    var slave = availableSlaves[i];\n    if (slave.ip === '127.0.0.1') {\n      if (slave.port === '31234') {\n        return slave;\n      }\n    }\n  }\n  // if no preferred slaves are available a random one is used\n  return false;\n};\n\nvar redis = new Redis({\n  sentinels: [{ host: '127.0.0.1', port: 26379 }, { host: '127.0.0.1', port: 26380 }],\n  name: 'mymaster',\n  role: 'slave',\n  preferredSlaves: preferredSlaves\n});\n```\n\nBesides the `retryStrategy` option, there's also a `sentinelRetryStrategy` in Sentinel mode which will be invoked when all the sentinel nodes are unreachable during connecting. If `sentinelRetryStrategy` returns a valid delay time, ioredis will try to reconnect from scratch. The default value of `sentinelRetryStrategy` is:\n\n```javascript\nfunction (times) {\n  var delay = Math.min(times * 10, 1000);\n  return delay;\n}\n```\n\n## Cluster\nRedis Cluster provides a way to run a Redis installation where data is automatically sharded across multiple Redis nodes.\nYou can connect to a Redis Cluster like this:\n\n```javascript\nvar Redis = require('ioredis');\n\nvar cluster = new Redis.Cluster([{\n  port: 6380,\n  host: '127.0.0.1'\n}, {\n  port: 6381,\n  host: '127.0.0.1'\n}]);\n\ncluster.set('foo', 'bar');\ncluster.get('foo', function (err, res) {\n  // res === 'bar'\n});\n```\n\n`Cluster` constructor accepts two arguments, where:\n\n0. The first argument is a list of nodes of the cluster you want to connect to.\nJust like Sentinel, the list does not need to enumerate all your cluster nodes,\nbut a few so that if one is unreachable the client will try the next one, and the client will discover other nodes automatically when at least one node is connected.\n0. The second argument is the options, where:\n\n    * `clusterRetryStrategy`: When none of the startup nodes are reachable, `clusterRetryStrategy` will be invoked. When a number is returned,\n    ioredis will try to reconnect to the startup nodes from scratch after the specified delay (in ms). Otherwise, an error of \"None of startup nodes is available\" will be returned.\n    The default value of this option is:\n\n        ```javascript\n        function (times) {\n          var delay = Math.min(100 + times * 2, 2000);\n          return delay;\n        }\n        ```\n\n        It's possible to modify the `startupNodes` property in order to switch to another set of nodes here:\n\n        ```javascript\n        function (times) {\n          this.startupNodes = [{ port: 6790, host: '127.0.0.1' }];\n          return Math.min(100 + times * 2, 2000);\n        }\n        ```\n\n    * `enableOfflineQueue`: Similar to the `enableOfflineQueue` option of `Redis` class.\n    * `enableReadyCheck`: When enabled, \"ready\" event will only be emitted when `CLUSTER INFO` command\n    reporting the cluster is ready for handling commands. Otherwise, it will be emitted immediately after \"connect\" is emitted.\n    * `scaleReads`: Config where to send the read queries. See below for more details.\n    * `maxRedirections`: When a cluster related error (e.g. `MOVED`, `ASK` and `CLUSTERDOWN` etc.) is received, the client will redirect the\n    command to another node. This option limits the max redirections allowed when sending a command. The default value is `16`.\n    * `retryDelayOnFailover`: If the target node is disconnected when sending a command,\n    ioredis will retry after the specified delay. The default value is `100`. You should make sure `retryDelayOnFailover * maxRedirections > cluster-node-timeout`\n    to insure that no command will fail during a failover.\n    * `retryDelayOnClusterDown`: When a cluster is down, all commands will be rejected with the error of `CLUSTERDOWN`. If this option is a number (by default, it is `100`), the client\n    will resend the commands after the specified time (in ms).\n    * `retryDelayOnTryAgain`: If this option is a number (by default, it is `100`), the client\n    will resend the commands rejected with `TRYAGAIN` error after the specified time (in ms).\n    * `redisOptions`: Default options passed to the constructor of `Redis` when connecting to a node.\n    * `slotsRefreshTimeout`: Milliseconds before a timeout occurs while refreshing slots from the cluster (default `1000`)\n    * `slotsRefreshInterval`: Milliseconds between every automatic slots refresh (default `5000`)\n\n### Read-write splitting\n\nA typical redis cluster contains three or more masters and several slaves for each master. It's possible to scale out redis cluster by sending read queries to slaves and write queries to masters by setting the `scaleReads` option.\n\n`scaleReads` is \"master\" by default, which means ioredis will never send any queries to slaves. There are other three available options:\n\n1. \"all\": Send write queries to masters and read queries to masters or slaves randomly.\n2. \"slave\": Send write queries to masters and read queries to slaves.\n3. a custom `function(nodes, command): node`: Will choose the custom function to select to which node to send read queries (write queries keep being sent to master). The first node in `nodes` is always the master serving the relevant slots. If the function returns an array of nodes, a random node of that list will be selected.\n\nFor example:\n\n```javascript\nvar cluster = new Redis.Cluster([/* nodes */], {\n  scaleReads: 'slave'\n});\ncluster.set('foo', 'bar'); // This query will be sent to one of the masters.\ncluster.get('foo', function (err, res) {\n  // This query will be sent to one of the slaves.\n});\n```\n\n**NB** In the code snippet above, the `res` may not be equal to \"bar\" because of the lag of replication between the master and slaves.\n\n### Running commands to multiple nodes\n\nEvery command will be sent to exactly one node. For commands containing keys, (e.g. `GET`, `SET` and `HGETALL`), ioredis sends them to the node that serving the keys, and for other commands not containing keys, (e.g. `INFO`, `KEYS` and `FLUSHDB`), ioredis sends them to a random node.\n\nSometimes you may want to send a command to multiple nodes (masters or slaves) of the cluster, you can get the nodes via `Cluster#nodes()` method.\n\n`Cluster#nodes()` accepts a parameter role, which can be \"master\", \"slave\" and \"all\" (default), and returns an array of `Redis` instance. For example:\n\n```javascript\n// Send `FLUSHDB` command to all slaves:\nvar slaves = cluster.nodes('slave');\nPromise.all(slaves.map(function (node) {\n  return node.flushdb();\n}));\n\n// Get keys of all the masters:\nvar masters = cluster.nodes('master');\nPromise.all(masters.map(function (node) {\n  return node.keys();\n})).then(function (keys) {\n  // keys: [['key1', 'key2'], ['key3', 'key4']]\n});\n```\n\n### NAT Mapping\nSometimes the cluster is hosted within a internal network that can only be accessed via a NAT (Network Address Translation) instance. See [Accessing ElastiCache from outside AWS](https://docs.aws.amazon.com/AmazonElastiCache/latest/red-ug/accessing-elasticache.html) as an example.\n\nYou can specify nat mapping rules via `natMap` option:\n\n```javascript\nconst cluster = new Redis.Cluster([{\n  host: '203.0.113.73',\n  port: 30001\n}], {\n  natMap: {\n    '10.0.1.230:30001': {host: '203.0.113.73', port: 30001},\n    '10.0.1.231:30001': {host: '203.0.113.73', port: 30002},\n    '10.0.1.232:30001': {host: '203.0.113.73', port: 30003}\n  }\n})\n```\n\nThis option is also useful when the cluster is running inside a Docker container.\n\n### Transaction and pipeline in Cluster mode\nAlmost all features that are supported by `Redis` are also supported by `Redis.Cluster`, e.g. custom commands, transaction and pipeline.\nHowever there are some differences when using transaction and pipeline in Cluster mode:\n\n0. All keys in a pipeline should belong to the same slot since ioredis sends all commands in a pipeline to the same node.\n0. You can't use `multi` without pipeline (aka `cluster.multi({ pipeline: false })`). This is because when you call `cluster.multi({ pipeline: false })`, ioredis doesn't know which node the `multi` command should be sent to.\n0. Chaining custom commands in the pipeline is not supported in Cluster mode.\n\nWhen any commands in a pipeline receives a `MOVED` or `ASK` error, ioredis will resend the whole pipeline to the specified node automatically if all of the following conditions are satisfied:\n\n0. All errors received in the pipeline are the same. For example, we won't resend the pipeline if we got two `MOVED` errors pointing to different nodes.\n0. All commands executed successfully are readonly commands. This makes sure that resending the pipeline won't have side effects.\n\n### Pub/Sub\nPub/Sub in cluster mode works exactly as the same as in standalone mode. Internally, when a node of the cluster receives a message, it will broadcast the message to the other nodes. ioredis makes sure that each message will only be received once by strictly subscribing one node at the same time.\n\n```javascript\nvar nodes = [/* nodes */];\nvar pub = new Redis.Cluster(nodes);\nvar sub = new Redis.Cluster(nodes);\nsub.on('message', function (channel, message) {\n  console.log(channel, message);\n});\n\nsub.subscribe('news', function () {\n  pub.publish('news', 'highlights');\n});\n```\n\n### Events\n\nEvent    | Description\n:------------- | :-------------\nconnect  | emits when a connection is established to the Redis server.\nready    | emits when `CLUSTER INFO` reporting the cluster is able to receive commands (if `enableReadyCheck` is `true`) or immediately after `connect` event (if `enableReadyCheck` is false).\nerror    | emits when an error occurs while connecting with a property of `lastNodeError` representing the last node error received. This event is emitted silently (only emitting if there's at least one listener).\nclose    | emits when an established Redis server connection has closed.\nreconnecting | emits after `close` when a reconnection will be made. The argument of the event is the time (in ms) before reconnecting.\nend     | emits after `close` when no more reconnections will be made.\n+node   | emits when a new node is connected.\n-node   | emits when a node is disconnected.\nnode error | emits when an error occurs when connecting to a node\n\n### Password\nSetting the `password` option to access password-protected clusters:\n\n```javascript\nvar Redis = require('ioredis');\nvar cluster = new Redis.Cluster(nodes, {\n  redisOptions: {\n    password: 'your-cluster-password'\n  }\n});\n```\n\nIf some of nodes in the cluster using a different password, you should specify them in the first parameter:\n\n```javascript\nvar Redis = require('ioredis');\nvar cluster = new Redis.Cluster([\n  // Use password \"password-for-30001\" for 30001\n  { port: 30001, password: 'password-for-30001'},\n  // Don't use password when accessing 30002\n  { port: 30002, password: null }\n  // Other nodes will use \"fallback-password\"\n], {\n  redisOptions: {\n    password: 'fallback-password'\n  }\n});\n```\n\n<hr>\n\n# Error Handling\nAll the errors returned by the Redis server are instances of `ReplyError`, which can be accessed via `Redis`:\n\n```javascript\nvar Redis = require('ioredis');\nvar redis = new Redis();\n// This command causes a reply error since the SET command requires two arguments.\nredis.set('foo', function (err) {\n  err instanceof Redis.ReplyError\n});\n```\n\nThis is the error stack of the `ReplyError`:\n\n```\nReplyError: ERR wrong number of arguments for 'set' command\n    at ReplyParser._parseResult (/app/node_modules/ioredis/lib/parsers/javascript.js:60:14)\n    at ReplyParser.execute (/app/node_modules/ioredis/lib/parsers/javascript.js:178:20)\n    at Socket.<anonymous> (/app/node_modules/ioredis/lib/redis/event_handler.js:99:22)\n    at Socket.emit (events.js:97:17)\n    at readableAddChunk (_stream_readable.js:143:16)\n    at Socket.Readable.push (_stream_readable.js:106:10)\n    at TCP.onread (net.js:509:20)\n```\n\nBy default, the error stack doesn't make any sense because the whole stack happens in the ioredis\nmodule itself, not in your code. So it's not easy to find out where the error happens in your code.\nioredis provides an option `showFriendlyErrorStack` to solve the problem. When you enable\n`showFriendlyErrorStack`, ioredis will optimize the error stack for you:\n\n```javascript\nvar Redis = require('ioredis');\nvar redis = new Redis({ showFriendlyErrorStack: true });\nredis.set('foo');\n```\n\nAnd the output will be:\n\n```\nReplyError: ERR wrong number of arguments for 'set' command\n    at Object.<anonymous> (/app/index.js:3:7)\n    at Module._compile (module.js:446:26)\n    at Object.Module._extensions..js (module.js:464:10)\n    at Module.load (module.js:341:32)\n    at Function.Module._load (module.js:296:12)\n    at Function.Module.runMain (module.js:487:10)\n    at startup (node.js:111:16)\n    at node.js:799:3\n```\n\nThis time the stack tells you that the error happens on the third line in your code. Pretty sweet!\nHowever, it would decrease the performance significantly to optimize the error stack. So by\ndefault, this option is disabled and can only be used for debugging purposes. You **shouldn't** use this feature in a production environment.\n\n# Plugging in your own Promises Library\nIf you're an advanced user, you may want to plug in your own promise library like [bluebird](https://www.npmjs.com/package/bluebird). Just set Redis.Promise to your favorite ES6-style promise constructor and ioredis will use it.\n\n```javascript\nconst Redis = require('ioredis')\nRedis.Promise = require('bluebird')\n\nconst redis = new Redis()\n\n// Use bluebird\nassert.equal(redis.get().constructor, require('bluebird'))\n\n// You can change the Promise implementation at any time:\nRedis.Promise = global.Promise\nassert.equal(redis.get().constructor, global.Promise)\n```\n\n\n# Running tests\n\nStart a Redis server on 127.0.0.1:6379, and then:\n\n```shell\n$ npm test\n```\n\n`FLUSH ALL` will be invoked after each test, so make sure there's no valuable data in it before running tests.\n\nIf your testing environment does not let you spin up a Redis server [ioredis-mock](https://github.com/stipsan/ioredis-mock) is a drop-in replacement you can use in your tests. It aims to behave identically to ioredis connected to a Redis server so that your integration tests is easier to write and of better quality.\n\n# Debug\n\nYou can set the `DEBUG` env to `ioredis:*` to print debug info:\n\n```shell\n$ DEBUG=ioredis:* node app.js\n```\n\n# Consolidation: It's time for celebration\n\nRight now there are two great redis clients around and both have some advantages above each other. We speak about [node_redis](https://github.com/NodeRedis/node_redis) and ioredis. So after talking to each other about how we could improve in working together we (that is [@BridgeAR](https://github.com/BridgeAR) and [@luin](https://github.com/luin)) decided to work towards a single library on the long run. But step by step.\n\nFirst of all, we want to split small parts of our libraries into others so that we're both able to use the same code. Those libraries are going to be maintained under the NodeRedis organization. This is going to reduce the maintance overhead, allows others to use the very same code, if they need it and it's way easier for others to contribute to both libraries.\n\nWe're very happy about this step towards working together as we both want to give you the best redis experience possible.\n\nIf you want to join our cause by help maintaining something, please don't hesitate to contact either one of us.\n\n# Join in!\n\nI'm happy to receive bug reports, fixes, documentation enhancements, and any other improvements.\n\nAnd since I'm not a native English speaker, if you find any grammar mistakes in the documentation, please also let me know. :)\n\n# Contributors\n\nThis project exists thanks to all the people who contribute:\n\n<a href=\"https://github.com/luin/ioredis/graphs/contributors\"><img src=\"https://opencollective.com/ioredis/contributors.svg?width=890&showBtn=false\" /></a>\n\n# License\n\nMIT\n\n\n[![FOSSA Status](https://app.fossa.io/api/projects/git%2Bgithub.com%2Fluin%2Fioredis.svg?type=large)](https://app.fossa.io/projects/git%2Bgithub.com%2Fluin%2Fioredis?ref=badge_large)\n","readmeFilename":"README.md","bugs":{"url":"https://github.com/luin/ioredis/issues"},"homepage":"https://github.com/luin/ioredis#readme","_id":"ioredis@4.6.0","_npmVersion":"6.4.1","_nodeVersion":"10.15.0","_npmUser":{"name":"ioredis-robot","email":"ioredis-robot@zihua.li"},"dist":{"integrity":"sha512-0sOwKs9P51ubQrxatQ0N3Y07GPt3odaWvASyFfwGfsi86Dd0O+QVCf9tRB3YzuS3uaiZ4y3mstfZt7vuJtXqQA==","shasum":"9f71718817e747128aa64ef9362adbc8919ef14a","tarball":"https://registry.npmjs.org/ioredis/-/ioredis-4.6.0.tgz","fileCount":35,"unpackedSize":218298,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJcRTYnCRA9TVsSAnZWagAAUlMQAIr6oJfu4Bd2igU+fUPN\nC61Aqv0zXDaIY0z8OA7SsVDkfDQ1u7EcZjE9A9B0mK5KpSbrF1Mc8tRPQJet\nj5qD1UN2tItnznFAQtKXvt/HboIjc+bRR3bLjF1+wTS1v+7C23NiRSJb9vWt\nHh9BbV9fblL/W/ifmO7DRmaCSL3GPQ3jucY6l1zYhJ/QNioX6+1CIWpuSSP2\nOJ7FCQv3M9RW3eqdxEgkgdqZoxQl2lTSXMqrQAzPqXi1U+L8G2aGJXw6lDGn\nla41PcgvwgQ5ozd+MH3L2Yvk8gNIFb4E3LPXw+LsZ0ng2ms/f59Hz8EDZJNx\nOwMtRmwiZ5NZcfXYoJKSkC3JBP7MjRNNALtvggqi1TKRtUxjlqzWaER1k2Ar\nWZxi9u+HHeFW0IRcYmomWixy6XWnN+kiqETcatmaYNom1gzIymXdlqZSugcB\nET2FGcHprVKittdd7tgTJGhYB00w4YTkjLCeT3Tfd3Z7XtvrlQfwPMpAZdr6\n6w9fMAD+05dq4k+rel/zfi21s5bOF0X6fAmXh4j2h7FwppSNRrVPwrTa/RGj\nHBI03lrou0o4eVywAfakkXyUjnRwYNDre9IRWUCcnX0sZC2sGbrgtAlSbivF\nqczXRltVnelYLsxRvSjbOHYLVLwh97n6/Y9C/JGArUtI/dyPTcxPIIe9yloQ\nqq9h\r\n=hBHl\r\n-----END PGP SIGNATURE-----\r\n"},"maintainers":[{"email":"ioredis-robot@zihua.li","name":"ioredis-robot"},{"email":"i@zihua.li","name":"luin"}],"directories":{},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/ioredis_4.6.0_1548039718821_0.09683130380917415"},"_hasShrinkwrap":false},"4.6.1":{"name":"ioredis","version":"4.6.1","description":"A robust, performance-focused and full-featured Redis client for Node.js.","main":"built/index.js","scripts":{"test":"NODE_ENV=test mocha --timeout 8000 -r ts-node/register --exit","test:cov":"NODE_ENV=test node ./node_modules/istanbul/lib/cli.js cover --preserve-comments ./node_modules/mocha/bin/_mocha -- -r ts-node/register -R spec --exit","build":"rm -rf built && tsc","generate-docs":"jsdoc2md lib/redis.js lib/cluster/index.js lib/commander.js > API.md","prepublishOnly":"npm run build && npm test","bench":"matcha benchmarks/*.js","semantic-release":"semantic-release"},"repository":{"type":"git","url":"git://github.com/luin/ioredis.git"},"keywords":["redis","cluster","sentinel","pipelining"],"author":{"name":"luin","email":"i@zihua.li","url":"http://zihua.li"},"license":"MIT","dependencies":{"cluster-key-slot":"^1.0.6","debug":"^3.1.0","denque":"^1.1.0","flexbuffer":"0.0.6","lodash.defaults":"^4.2.0","lodash.flatten":"^4.4.0","redis-commands":"1.4.0","redis-errors":"^1.2.0","redis-parser":"^3.0.0","standard-as-callback":"^1.0.0"},"devDependencies":{"@semantic-release/changelog":"^3.0.0","@semantic-release/git":"^7.0.4","@types/node":"^10.11.5","@types/redis-errors":"1.2.0","bluebird":"^3.5.1","chai":"^3.5.0","cz-conventional-changelog":"^2.0.0","istanbul":"^0.4.2","jsdoc":"^3.4.0","jsdoc-to-markdown":"^4.0.1","mocha":"^5.2.0","server-destroy":"^1.0.1","sinon":"^1.17.3","ts-node":"^7.0.0","typescript":"^3.1.1"},"engines":{"node":">=6"},"config":{"commitizen":{"path":"./node_modules/cz-conventional-changelog"}},"gitHead":"f46490df404a11f3f91e60127a7d70eb3386f660","readme":"[![ioredis](https://cdn.rawgit.com/luin/ioredis/57b5b89e3e9111ff25d8c62c0bc58ed42e5b8d1e/logo.svg)](https://github.com/luin/ioredis)\n\n[![Build Status](https://travis-ci.org/luin/ioredis.svg?branch=master)](https://travis-ci.org/luin/ioredis)\n[![Test Coverage](https://codeclimate.com/github/luin/ioredis/badges/coverage.svg)](https://codeclimate.com/github/luin/ioredis)\n[![Join the chat at https://gitter.im/luin/ioredis](https://badges.gitter.im/Join%20Chat.svg)](https://gitter.im/luin/ioredis?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge)\n[![Commitizen friendly](https://img.shields.io/badge/commitizen-friendly-brightgreen.svg)](http://commitizen.github.io/cz-cli/)\n[![semantic-release](https://img.shields.io/badge/%20%20%F0%9F%93%A6%F0%9F%9A%80-semantic--release-e10079.svg)](https://github.com/semantic-release/semantic-release)\n[![npm latest version](https://img.shields.io/npm/v/ioredis/latest.svg)](https://www.npmjs.com/package/ioredis)\n[![npm next version](https://img.shields.io/npm/v/ioredis/next.svg)](https://www.npmjs.com/package/ioredis)\n<img alt=\"\" src=\"\">\n\nA robust, performance-focused and full-featured [Redis](http://redis.io) client for [Node.js](https://nodejs.org).\n\nSupports Redis >= 2.6.12 and (Node.js >= 6).\n\n# Features\nioredis is a robust, full-featured Redis client that is\nused in the world's biggest online commerce company [Alibaba](http://www.alibaba.com/) and many other awesome companies.\n\n0. Full-featured. It supports [Cluster](http://redis.io/topics/cluster-tutorial), [Sentinel](http://redis.io/topics/sentinel), [Pipelining](http://redis.io/topics/pipelining) and of course [Lua scripting](http://redis.io/commands/eval) & [Pub/Sub](http://redis.io/topics/pubsub) (with the support of binary messages).\n0. High performance.\n0. Delightful API. It works with Node callbacks and Native promises.\n0. Transformation of command arguments and replies.\n0. Transparent key prefixing.\n0. Abstraction for Lua scripting, allowing you to define custom commands.\n0. Support for binary data.\n0. Support for TLS.\n0. Support for offline queue and ready checking.\n0. Support for ES6 types, such as `Map` and `Set`.\n0. Support for GEO commands (Redis 3.2 Unstable).\n0. Sophisticated error handling strategy.\n0. Support for NAT mapping.\n\n# Links\n* [API Documentation](API.md)\n* [Changelog](Changelog.md)\n* [Migrating from node_redis](https://github.com/luin/ioredis/wiki/Migrating-from-node_redis)\n* [Error Handling](#error-handling)\n\n## Become a Sponsor to Support ioredis's Development\nOpen source is hard and time-consuming. If you want to invest in ioredis's future you can become a sponsor and make us spend more time on this library's improvements and new features.\n\n<a href=\"https://opencollective.com/ioredis\"><img src=\"https://opencollective.com/ioredis/tiers/sponsor.svg?avatarHeight=36\"></a>\n\nThank you for using ioredis :-)\n\n<hr>\n<a href=\"https://itunes.apple.com/app/medis-gui-for-redis/id1063631769\"><img align=\"right\" src=\"medis.png\" alt=\"Download on the App Store\"></a>\n\n\n### Advertisement\n\nLooking for a Redis GUI manager for OS X, Windows and Linux? Here's [Medis](https://itunes.apple.com/us/app/medis-gui-for-redis/id1063631769)!\n\nMedis is an open-sourced, beautiful, easy-to-use Redis GUI management application.\n\nMedis starts with all the basic features you need:\n\n* Keys viewing/editing\n* SSH Tunnel for connecting with remote servers\n* Terminal for executing custom commands\n* JSON/MessagePack format viewing/editing and built-in highlighting/validator\n* And other awesome features...\n\n[Medis is open sourced on GitHub](https://github.com/luin/medis)\n\n<hr>\n\n# Quick Start\n\n## Install\n```shell\n$ npm install ioredis\n```\n\n## Basic Usage\n\n```javascript\nvar Redis = require('ioredis');\nvar redis = new Redis();\n\nredis.set('foo', 'bar');\nredis.get('foo', function (err, result) {\n  console.log(result);\n});\n\n// Or using a promise if the last argument isn't a function\nredis.get('foo').then(function (result) {\n  console.log(result);\n});\n\n// Arguments to commands are flattened, so the following are the same:\nredis.sadd('set', 1, 3, 5, 7);\nredis.sadd('set', [1, 3, 5, 7]);\n\n// All arguments are passed directly to the redis server:\nredis.set('key', 100, 'EX', 10);\n```\n\nSee the `examples/` folder for more examples.\n\n## Connect to Redis\nWhen a new `Redis` instance is created,\na connection to Redis will be created at the same time.\nYou can specify which Redis to connect to by:\n\n```javascript\nnew Redis()       // Connect to 127.0.0.1:6379\nnew Redis(6380)   // 127.0.0.1:6380\nnew Redis(6379, '192.168.1.1')        // 192.168.1.1:6379\nnew Redis('/tmp/redis.sock')\nnew Redis({\n  port: 6379,          // Redis port\n  host: '127.0.0.1',   // Redis host\n  family: 4,           // 4 (IPv4) or 6 (IPv6)\n  password: 'auth',\n  db: 0\n})\n```\n\nYou can also specify connection options as a [`redis://` URL](http://www.iana.org/assignments/uri-schemes/prov/redis):\n\n```javascript\n// Connect to 127.0.0.1:6380, db 4, using password \"authpassword\":\nnew Redis('redis://:authpassword@127.0.0.1:6380/4')\n```\n\nSee [API Documentation](API.md#new_Redis) for all available options.\n\n## Pub/Sub\n\nHere is a simple example of the API for publish/subscribe.\nThe following program opens two client connections.\nIt subscribes to a channel with one connection\nand publishes to that channel with the other:\n\n```javascript\nvar Redis = require('ioredis');\nvar redis = new Redis();\nvar pub = new Redis();\nredis.subscribe('news', 'music', function (err, count) {\n  // Now we are subscribed to both the 'news' and 'music' channels.\n  // `count` represents the number of channels we are currently subscribed to.\n\n  pub.publish('news', 'Hello world!');\n  pub.publish('music', 'Hello again!');\n});\n\nredis.on('message', function (channel, message) {\n  // Receive message Hello world! from channel news\n  // Receive message Hello again! from channel music\n  console.log('Receive message %s from channel %s', message, channel);\n});\n\n// There's also an event called 'messageBuffer', which is the same as 'message' except\n// it returns buffers instead of strings.\nredis.on('messageBuffer', function (channel, message) {\n  // Both `channel` and `message` are buffers.\n});\n```\n\n`PSUBSCRIBE` is also supported in a similar way:\n\n```javascript\nredis.psubscribe('pat?ern', function (err, count) {});\nredis.on('pmessage', function (pattern, channel, message) {});\nredis.on('pmessageBuffer', function (pattern, channel, message) {});\n```\n\nWhen a client issues a SUBSCRIBE or PSUBSCRIBE, that connection is put into a \"subscriber\" mode.\nAt that point, only commands that modify the subscription set are valid.\nWhen the subscription set is empty, the connection is put back into regular mode.\n\nIf you need to send regular commands to Redis while in subscriber mode, just open another connection.\n\n## Handle Binary Data\nArguments can be buffers:\n```javascript\nredis.set('foo', Buffer.from('bar'));\n```\n\nAnd every command has a method that returns a Buffer (by adding a suffix of \"Buffer\" to the command name).\nTo get a buffer instead of a utf8 string:\n\n```javascript\nredis.getBuffer('foo', function (err, result) {\n  // result is a buffer.\n});\n```\n\n## Pipelining\nIf you want to send a batch of commands (e.g. > 5), you can use pipelining to queue\nthe commands in memory and then send them to Redis all at once. This way the performance improves by 50%~300% (See [benchmark section](#benchmark)).\n\n`redis.pipeline()` creates a `Pipeline` instance. You can call any Redis\ncommands on it just like the `Redis` instance. The commands are queued in memory\nand flushed to Redis by calling the `exec` method:\n\n```javascript\nvar pipeline = redis.pipeline();\npipeline.set('foo', 'bar');\npipeline.del('cc');\npipeline.exec(function (err, results) {\n  // `err` is always null, and `results` is an array of responses\n  // corresponding to the sequence of queued commands.\n  // Each response follows the format `[err, result]`.\n});\n\n// You can even chain the commands:\nredis.pipeline().set('foo', 'bar').del('cc').exec(function (err, results) {\n});\n\n// `exec` also returns a Promise:\nvar promise = redis.pipeline().set('foo', 'bar').get('foo').exec();\npromise.then(function (result) {\n  // result === [[null, 'OK'], [null, 'bar']]\n});\n```\n\nEach chained command can also have a callback, which will be invoked when the command\ngets a reply:\n\n```javascript\nredis.pipeline().set('foo', 'bar').get('foo', function (err, result) {\n  // result === 'bar'\n}).exec(function (err, result) {\n  // result[1][1] === 'bar'\n});\n```\n\nIn addition to adding commands to the `pipeline` queue individually, you can also pass an array of commands and arguments to the constructor:\n\n```javascript\nredis.pipeline([\n  ['set', 'foo', 'bar'],\n  ['get', 'foo']\n]).exec(function () { /* ... */ });\n```\n\n`#length` property shows how many commands in the pipeline:\n\n```javascript\nconst length = redis.pipeline().set('foo', 'bar').get('foo').length;\n// length === 2\n```\n\n\n## Transaction\nMost of the time, the transaction commands `multi` & `exec` are used together with pipeline.\nTherefore, when `multi` is called, a `Pipeline` instance is created automatically by default,\nso you can use `multi` just like `pipeline`:\n\n```javascript\nredis.multi().set('foo', 'bar').get('foo').exec(function (err, results) {\n  // results === [[null, 'OK'], [null, 'bar']]\n});\n```\nIf there's a syntax error in the transaction's command chain (e.g. wrong number of arguments, wrong command name, etc),\nthen none of the commands would be executed, and an error is returned:\n\n```javascript\nredis.multi().set('foo').set('foo', 'new value').exec(function (err, results) {\n  // err:\n  //  { [ReplyError: EXECABORT Transaction discarded because of previous errors.]\n  //    name: 'ReplyError',\n  //    message: 'EXECABORT Transaction discarded because of previous errors.',\n  //    command: { name: 'exec', args: [] },\n  //    previousErrors:\n  //     [ { [ReplyError: ERR wrong number of arguments for 'set' command]\n  //         name: 'ReplyError',\n  //         message: 'ERR wrong number of arguments for \\'set\\' command',\n  //         command: [Object] } ] }\n});\n```\n\nIn terms of the interface, `multi` differs from `pipeline` in that when specifying a callback\nto each chained command, the queueing state is passed to the callback instead of the result of the command:\n\n```javascript\nredis.multi().set('foo', 'bar', function (err, result) {\n  // result === 'QUEUED'\n}).exec(/* ... */);\n```\n\nIf you want to use transaction without pipeline, pass `{ pipeline: false }` to `multi`,\nand every command will be sent to Redis immediately without waiting for an `exec` invocation:\n\n```javascript\nredis.multi({ pipeline: false });\nredis.set('foo', 'bar');\nredis.get('foo');\nredis.exec(function (err, result) {\n  // result === [[null, 'OK'], [null, 'bar']]\n});\n```\n\nThe constructor of `multi` also accepts a batch of commands:\n\n```javascript\nredis.multi([\n  ['set', 'foo', 'bar'],\n  ['get', 'foo']\n]).exec(function () { /* ... */ });\n```\n\nInline transactions are supported by pipeline, which means you can group a subset of commands\nin the pipeline into a transaction:\n\n```javascript\nredis.pipeline().get('foo').multi().set('foo', 'bar').get('foo').exec().get('foo').exec();\n```\n\n## Lua Scripting\nioredis supports all of the scripting commands such as `EVAL`, `EVALSHA` and `SCRIPT`.\nHowever, it's tedious to use in real world scenarios since developers have to take\ncare of script caching and to detect when to use `EVAL` and when to use `EVALSHA`.\nioredis expose a `defineCommand` method to make scripting much easier to use:\n\n```javascript\nvar redis = new Redis();\n\n// This will define a command echo:\nredis.defineCommand('echo', {\n  numberOfKeys: 2,\n  lua: 'return {KEYS[1],KEYS[2],ARGV[1],ARGV[2]}'\n});\n\n// Now `echo` can be used just like any other ordinary command,\n// and ioredis will try to use `EVALSHA` internally when possible for better performance.\nredis.echo('k1', 'k2', 'a1', 'a2', function (err, result) {\n  // result === ['k1', 'k2', 'a1', 'a2']\n});\n\n// `echoBuffer` is also defined automatically to return buffers instead of strings:\nredis.echoBuffer('k1', 'k2', 'a1', 'a2', function (err, result) {\n  // result[0] equals to Buffer.from('k1');\n});\n\n// And of course it works with pipeline:\nredis.pipeline().set('foo', 'bar').echo('k1', 'k2', 'a1', 'a2').exec();\n```\n\nIf the number of keys can't be determined when defining a command, you can\nomit the `numberOfKeys` property and pass the number of keys as the first argument\nwhen you call the command:\n\n```javascript\nredis.defineCommand('echoDynamicKeyNumber', {\n  lua: 'return {KEYS[1],KEYS[2],ARGV[1],ARGV[2]}'\n});\n\n// Now you have to pass the number of keys as the first argument every time\n// you invoke the `echoDynamicKeyNumber` command:\nredis.echoDynamicKeyNumber(2, 'k1', 'k2', 'a1', 'a2', function (err, result) {\n  // result === ['k1', 'k2', 'a1', 'a2']\n});\n```\n\n## Transparent Key Prefixing\nThis feature allows you to specify a string that will automatically be prepended\nto all the keys in a command, which makes it easier to manage your key\nnamespaces.\n\n**Warning** This feature won't apply to commands like [KEYS](http://redis.io/commands/KEYS) and [SCAN](http://redis.io/commands/scan) that take patterns rather than actual keys([#239](https://github.com/luin/ioredis/issues/239)),\nand this feature also won't apply to the replies of commands even they are key names ([#325](https://github.com/luin/ioredis/issues/325)).\n\n```javascript\nvar fooRedis = new Redis({ keyPrefix: 'foo:' });\nfooRedis.set('bar', 'baz');  // Actually sends SET foo:bar baz\n\nfooRedis.defineCommand('echo', {\n  numberOfKeys: 2,\n  lua: 'return {KEYS[1],KEYS[2],ARGV[1],ARGV[2]}'\n});\n\n// Works well with pipelining/transaction\nfooRedis.pipeline()\n  // Sends SORT foo:list BY foo:weight_*->fieldname\n  .sort('list', 'BY', 'weight_*->fieldname')\n  // Supports custom commands\n  // Sends EVALSHA xxx foo:k1 foo:k2 a1 a2\n  .echo('k1', 'k2', 'a1', 'a2')\n  .exec()\n```\n\n## Transforming Arguments & Replies\nMost Redis commands take one or more Strings as arguments,\nand replies are sent back as a single String or an Array of Strings. However, sometimes\nyou may want something different. For instance, it would be more convenient if the `HGETALL`\ncommand returns a hash (e.g. `{ key: val1, key2: v2 }`) rather than an array of key values (e.g. `[key1, val1, key2, val2]`).\n\nioredis has a flexible system for transforming arguments and replies. There are two types\nof transformers, argument transformer and reply transformer:\n\n```javascript\nvar Redis = require('ioredis');\n\n// Here's the built-in argument transformer converting\n// hmset('key', { k1: 'v1', k2: 'v2' })\n// or\n// hmset('key', new Map([['k1', 'v1'], ['k2', 'v2']]))\n// into\n// hmset('key', 'k1', 'v1', 'k2', 'v2')\nRedis.Command.setArgumentTransformer('hmset', function (args) {\n  if (args.length === 2) {\n    if (typeof Map !== 'undefined' && args[1] instanceof Map) {\n      // utils is a internal module of ioredis\n      return [args[0]].concat(utils.convertMapToArray(args[1]));\n    }\n    if ( typeof args[1] === 'object' && args[1] !== null) {\n      return [args[0]].concat(utils.convertObjectToArray(args[1]));\n    }\n  }\n  return args;\n});\n\n// Here's the built-in reply transformer converting the HGETALL reply\n// ['k1', 'v1', 'k2', 'v2']\n// into\n// { k1: 'v1', 'k2': 'v2' }\nRedis.Command.setReplyTransformer('hgetall', function (result) {\n  if (Array.isArray(result)) {\n    var obj = {};\n    for (var i = 0; i < result.length; i += 2) {\n      obj[result[i]] = result[i + 1];\n    }\n    return obj;\n  }\n  return result;\n});\n```\n\nThere are three built-in transformers, two argument transformers for `hmset` & `mset` and\na reply transformer for `hgetall`. Transformers for `hmset` and `hgetall` were mentioned\nabove, and the transformer for `mset` is similar to the one for `hmset`:\n\n```javascript\nredis.mset({ k1: 'v1', k2: 'v2' });\nredis.get('k1', function (err, result) {\n  // result === 'v1';\n});\n\nredis.mset(new Map([['k3', 'v3'], ['k4', 'v4']]));\nredis.get('k3', function (err, result) {\n  // result === 'v3';\n});\n```\n\nAnother useful example of a reply transformer is one that changes `hgetall` to return array of arrays instead of objects which avoids a unwanted conversation of hash keys to strings when dealing with binary hash keys:\n\n```javascript\nRedis.Command.setReplyTransformer('hgetall', function (result) {\n  var arr = [];\n  for (var i = 0; i < result.length; i += 2) {\n    arr.push([result[i], result[i + 1]]);\n  }\n  return arr;\n});\nredis.hset('h1', Buffer.from([0x01]), Buffer.from([0x02]));\nredis.hset('h1', Buffer.from([0x03]), Buffer.from([0x04]));\nredis.hgetallBuffer('h1', function (err, result) {\n  // result === [ [ <Buffer 01>, <Buffer 02> ], [ <Buffer 03>, <Buffer 04> ] ];\n});\n```\n\n## Monitor\nRedis supports the MONITOR command,\nwhich lets you see all commands received by the Redis server across all client connections,\nincluding from other client libraries and other computers.\n\nThe `monitor` method returns a monitor instance.\nAfter you send the MONITOR command, no other commands are valid on that connection. ioredis will emit a monitor event for every new monitor message that comes across.\nThe callback for the monitor event takes a timestamp from the Redis server and an array of command arguments.\n\nHere is a simple example:\n\n```javascript\nredis.monitor(function (err, monitor) {\n  monitor.on('monitor', function (time, args, source, database) {\n  });\n});\n```\n\n## Streamify Scanning\nRedis 2.8 added the `SCAN` command to incrementally iterate through the keys in the database. It's different from `KEYS` in that\n`SCAN` only returns a small number of elements each call, so it can be used in production without the downside\nof blocking the server for a long time. However, it requires recording the cursor on the client side each time\nthe `SCAN` command is called in order to iterate through all the keys correctly. Since it's a relatively common use case, ioredis\nprovides a streaming interface for the `SCAN` command to make things much easier. A readable stream can be created by calling `scanStream`:\n\n```javascript\nvar redis = new Redis();\n// Create a readable stream (object mode)\nvar stream = redis.scanStream();\nstream.on('data', function (resultKeys) {\n  // `resultKeys` is an array of strings representing key names.\n  // Note that resultKeys may contain 0 keys, and that it will sometimes\n  // contain duplicates due to SCAN's implementation in Redis.\n  for (var i = 0; i < resultKeys.length; i++) {\n    console.log(resultKeys[i]);\n  }\n});\nstream.on('end', function () {\n  console.log('all keys have been visited');\n});\n```\n\n`scanStream` accepts an option, with which you can specify the `MATCH` pattern and the `COUNT` argument:\n\n```javascript\nvar stream = redis.scanStream({\n  // only returns keys following the pattern of `user:*`\n  match: 'user:*',\n  // returns approximately 100 elements per call\n  count: 100\n});\n```\n\nJust like other commands, `scanStream` has a binary version `scanBufferStream`, which returns an array of buffers. It's useful when\nthe key names are not utf8 strings.\n\nThere are also `hscanStream`, `zscanStream` and `sscanStream` to iterate through elements in a hash, zset and set. The interface of each is\nsimilar to `scanStream` except the first argument is the key name:\n\n```javascript\nvar stream = redis.hscanStream('myhash', {\n  match: 'age:??'\n});\n```\n\nYou can learn more from the [Redis documentation](http://redis.io/commands/scan).\n\n**Useful Tips**\nIt's pretty common that doing an async task in the `data` handler. We'd like the scanning process to be paused until the async task to be finished. `Stream#pause()` and `Stream.resume()` do the trick. For example if we want to migrate data in Redis to MySQL:\n\n```javascript\nvar stream = redis.scanStream();\nstream.on('data', function (resultKeys) {\n  // Pause the stream from scanning more keys until we've migrated the current keys.\n  stream.pause();\n\n  Promise.all(resultKeys.map(migrateKeyToMySQL)).then(() => {\n    // Resume the stream here.\n    stream.resume();\n  });\n});\n\nstream.on('end', function () {\n  console.log('done migration');\n});\n```\n\n## Auto-reconnect\nBy default, ioredis will try to reconnect when the connection to Redis is lost\nexcept when the connection is closed manually by `redis.disconnect()` or `redis.quit()`.\n\nIt's very flexible to control how long to wait to reconnect after disconnection\nusing the `retryStrategy` option:\n\n```javascript\nvar redis = new Redis({\n  // This is the default value of `retryStrategy`\n  retryStrategy: function (times) {\n    var delay = Math.min(times * 50, 2000);\n    return delay;\n  }\n});\n```\n\n`retryStrategy` is a function that will be called when the connection is lost.\nThe argument `times` means this is the nth reconnection being made and\nthe return value represents how long (in ms) to wait to reconnect. When the\nreturn value isn't a number, ioredis will stop trying to reconnect, and the connection\nwill be lost forever if the user doesn't call `redis.connect()` manually.\n\nWhen reconnected, the client will auto subscribe to channels that the previous connection subscribed to.\nThis behavior can be disabled by setting the `autoResubscribe` option to `false`.\n\nAnd if the previous connection has some unfulfilled commands (most likely blocking commands such as `brpop` and `blpop`),\nthe client will resend them when reconnected. This behavior can be disabled by setting the `autoResendUnfulfilledCommands` option to `false`.\n\nBy default, all pending commands will be flushed with an error every 20 retry attempts. That makes sure commands won't wait forever when the connection is down. You can change this behavior by setting `maxRetriesPerRequest`:\n\n```javascript\nvar redis = new Redis({\n  maxRetriesPerRequest: 1\n});\n```\n\nSet maxRetriesPerRequest to `null` to disable this behavior, and every command will wait forever until the connection is alive again (which is the default behavior before ioredis v4).\n\n### Reconnect on error\n\nBesides auto-reconnect when the connection is closed, ioredis supports reconnecting on the specified errors by the `reconnectOnError` option. Here's an example that will reconnect when receiving `READONLY` error:\n\n```javascript\nvar redis = new Redis({\n  reconnectOnError: function (err) {\n    var targetError = 'READONLY';\n    if (err.message.slice(0, targetError.length) === targetError) {\n      // Only reconnect when the error starts with \"READONLY\"\n      return true; // or `return 1;`\n    }\n  }\n});\n```\n\nThis feature is useful when using Amazon ElastiCache. Once failover happens, Amazon ElastiCache will switch the master we currently connected with to a slave, leading to the following writes fails with the error `READONLY`. Using `reconnectOnError`, we can force the connection to reconnect on this error in order to connect to the new master.\n\nFurthermore, if the `reconnectOnError` returns `2`, ioredis will resend the failed command after reconnecting.\n\n## Connection Events\nThe Redis instance will emit some events about the state of the connection to the Redis server.\n\nEvent    | Description\n:------------- | :-------------\nconnect  | emits when a connection is established to the Redis server.\nready    | If `enableReadyCheck` is `true`, client will emit `ready` when the server reports that it is ready to receive commands (e.g. finish loading data from disk).<br>Otherwise, `ready` will be emitted immediately right after the `connect` event.\nerror    | emits when an error occurs while connecting.<br>However, ioredis emits all `error` events silently (only emits when there's at least one listener) so that your application won't crash if you're not listening to the `error` event.\nclose    | emits when an established Redis server connection has closed.\nreconnecting | emits after `close` when a reconnection will be made. The argument of the event is the time (in ms) before reconnecting.\nend     | emits after `close` when no more reconnections will be made, or the connection is failed to establish.\n\nYou can also check out the `Redis#status` property to get the current connection status.\n\nBesides the above connection events, there are several other custom events:\n\nEvent    | Description\n:------------- | :-------------\nselect   | emits when the database changed. The argument is the new db number.\n\n## Offline Queue\nWhen a command can't be processed by Redis (being sent before the `ready` event), by default, it's added to the offline queue and will be\nexecuted when it can be processed. You can disable this feature by setting the `enableOfflineQueue`\noption to `false`:\n\n```javascript\nvar redis = new Redis({ enableOfflineQueue: false });\n```\n\n## TLS Options\nRedis doesn't support TLS natively, however if the redis server you want to connect to is hosted behind a TLS proxy (e.g. [stunnel](https://www.stunnel.org/)) or is offered by a PaaS service that supports TLS connection (e.g. [Redis Labs](https://redislabs.com/)), you can set the `tls` option:\n\n```javascript\nvar redis = new Redis({\n  host: 'localhost',\n  tls: {\n    // Refer to `tls.connect()` section in\n    // https://nodejs.org/api/tls.html\n    // for all supported options\n    ca: fs.readFileSync('cert.pem')\n  }\n});\n```\n\n<hr>\n\n## Sentinel\nioredis supports Sentinel out of the box. It works transparently as all features that work when\nyou connect to a single node also work when you connect to a sentinel group. Make sure to run Redis >= 2.8.12 if you want to use this feature. Sentinels have a default port of 26379.\n\nTo connect using Sentinel, use:\n\n```javascript\nvar redis = new Redis({\n  sentinels: [{ host: 'localhost', port: 26379 }, { host: 'localhost', port: 26380 }],\n  name: 'mymaster'\n});\n\nredis.set('foo', 'bar');\n```\n\nThe arguments passed to the constructor are different from the ones you use to connect to a single node, where:\n\n* `name` identifies a group of Redis instances composed of a master and one or more slaves (`mymaster` in the example);\n* `sentinels` are a list of sentinels to connect to. The list does not need to enumerate all your sentinel instances, but a few so that if one is down the client will try the next one.\n* `role` (optional) with a value of `slave` will return a random slave from the Sentinel group.\n* `preferredSlaves` (optional) can be used to prefer a particular slave or set of slaves based on priority. It accepts a function or array.\n\nioredis **guarantees** that the node you connected to is always a master even after a failover. When a failover happens, instead of trying to reconnect to the failed node (which will be demoted to slave when it's available again), ioredis will ask sentinels for the new master node and connect to it. All commands sent during the failover are queued and will be executed when the new connection is established so that none of the commands will be lost.\n\nIt's possible to connect to a slave instead of a master by specifying the option `role` with the value of `slave` and ioredis will try to connect to a random slave of the specified master, with the guarantee that the connected node is always a slave. If the current node is promoted to master due to a failover, ioredis will disconnect from it and ask the sentinels for another slave node to connect to.\n\nIf you specify the option `preferredSlaves` along with `role: 'slave'` ioredis will attempt to use this value when selecting the slave from the pool of available slaves. The value of `preferredSlaves` should either be a function that accepts an array of avaiable slaves and returns a single result, or an array of slave values priorities by the lowest `prio` value first with a default value of `1`.\n\n```javascript\n// available slaves format\nvar availableSlaves = [{ ip: '127.0.0.1', port: '31231', flags: 'slave' }];\n\n// preferredSlaves array format\nvar preferredSlaves = [\n  { ip: '127.0.0.1', port: '31231', prio: 1 },\n  { ip: '127.0.0.1', port: '31232', prio: 2 }\n];\n\n// preferredSlaves function format\npreferredSlaves = function(availableSlaves) {\n  for (var i = 0; i < availableSlaves.length; i++) {\n    var slave = availableSlaves[i];\n    if (slave.ip === '127.0.0.1') {\n      if (slave.port === '31234') {\n        return slave;\n      }\n    }\n  }\n  // if no preferred slaves are available a random one is used\n  return false;\n};\n\nvar redis = new Redis({\n  sentinels: [{ host: '127.0.0.1', port: 26379 }, { host: '127.0.0.1', port: 26380 }],\n  name: 'mymaster',\n  role: 'slave',\n  preferredSlaves: preferredSlaves\n});\n```\n\nBesides the `retryStrategy` option, there's also a `sentinelRetryStrategy` in Sentinel mode which will be invoked when all the sentinel nodes are unreachable during connecting. If `sentinelRetryStrategy` returns a valid delay time, ioredis will try to reconnect from scratch. The default value of `sentinelRetryStrategy` is:\n\n```javascript\nfunction (times) {\n  var delay = Math.min(times * 10, 1000);\n  return delay;\n}\n```\n\n## Cluster\nRedis Cluster provides a way to run a Redis installation where data is automatically sharded across multiple Redis nodes.\nYou can connect to a Redis Cluster like this:\n\n```javascript\nvar Redis = require('ioredis');\n\nvar cluster = new Redis.Cluster([{\n  port: 6380,\n  host: '127.0.0.1'\n}, {\n  port: 6381,\n  host: '127.0.0.1'\n}]);\n\ncluster.set('foo', 'bar');\ncluster.get('foo', function (err, res) {\n  // res === 'bar'\n});\n```\n\n`Cluster` constructor accepts two arguments, where:\n\n0. The first argument is a list of nodes of the cluster you want to connect to.\nJust like Sentinel, the list does not need to enumerate all your cluster nodes,\nbut a few so that if one is unreachable the client will try the next one, and the client will discover other nodes automatically when at least one node is connected.\n0. The second argument is the options, where:\n\n    * `clusterRetryStrategy`: When none of the startup nodes are reachable, `clusterRetryStrategy` will be invoked. When a number is returned,\n    ioredis will try to reconnect to the startup nodes from scratch after the specified delay (in ms). Otherwise, an error of \"None of startup nodes is available\" will be returned.\n    The default value of this option is:\n\n        ```javascript\n        function (times) {\n          var delay = Math.min(100 + times * 2, 2000);\n          return delay;\n        }\n        ```\n\n        It's possible to modify the `startupNodes` property in order to switch to another set of nodes here:\n\n        ```javascript\n        function (times) {\n          this.startupNodes = [{ port: 6790, host: '127.0.0.1' }];\n          return Math.min(100 + times * 2, 2000);\n        }\n        ```\n\n    * `enableOfflineQueue`: Similar to the `enableOfflineQueue` option of `Redis` class.\n    * `enableReadyCheck`: When enabled, \"ready\" event will only be emitted when `CLUSTER INFO` command\n    reporting the cluster is ready for handling commands. Otherwise, it will be emitted immediately after \"connect\" is emitted.\n    * `scaleReads`: Config where to send the read queries. See below for more details.\n    * `maxRedirections`: When a cluster related error (e.g. `MOVED`, `ASK` and `CLUSTERDOWN` etc.) is received, the client will redirect the\n    command to another node. This option limits the max redirections allowed when sending a command. The default value is `16`.\n    * `retryDelayOnFailover`: If the target node is disconnected when sending a command,\n    ioredis will retry after the specified delay. The default value is `100`. You should make sure `retryDelayOnFailover * maxRedirections > cluster-node-timeout`\n    to insure that no command will fail during a failover.\n    * `retryDelayOnClusterDown`: When a cluster is down, all commands will be rejected with the error of `CLUSTERDOWN`. If this option is a number (by default, it is `100`), the client\n    will resend the commands after the specified time (in ms).\n    * `retryDelayOnTryAgain`: If this option is a number (by default, it is `100`), the client\n    will resend the commands rejected with `TRYAGAIN` error after the specified time (in ms).\n    * `redisOptions`: Default options passed to the constructor of `Redis` when connecting to a node.\n    * `slotsRefreshTimeout`: Milliseconds before a timeout occurs while refreshing slots from the cluster (default `1000`)\n    * `slotsRefreshInterval`: Milliseconds between every automatic slots refresh (default `5000`)\n\n### Read-write splitting\n\nA typical redis cluster contains three or more masters and several slaves for each master. It's possible to scale out redis cluster by sending read queries to slaves and write queries to masters by setting the `scaleReads` option.\n\n`scaleReads` is \"master\" by default, which means ioredis will never send any queries to slaves. There are other three available options:\n\n1. \"all\": Send write queries to masters and read queries to masters or slaves randomly.\n2. \"slave\": Send write queries to masters and read queries to slaves.\n3. a custom `function(nodes, command): node`: Will choose the custom function to select to which node to send read queries (write queries keep being sent to master). The first node in `nodes` is always the master serving the relevant slots. If the function returns an array of nodes, a random node of that list will be selected.\n\nFor example:\n\n```javascript\nvar cluster = new Redis.Cluster([/* nodes */], {\n  scaleReads: 'slave'\n});\ncluster.set('foo', 'bar'); // This query will be sent to one of the masters.\ncluster.get('foo', function (err, res) {\n  // This query will be sent to one of the slaves.\n});\n```\n\n**NB** In the code snippet above, the `res` may not be equal to \"bar\" because of the lag of replication between the master and slaves.\n\n### Running commands to multiple nodes\n\nEvery command will be sent to exactly one node. For commands containing keys, (e.g. `GET`, `SET` and `HGETALL`), ioredis sends them to the node that serving the keys, and for other commands not containing keys, (e.g. `INFO`, `KEYS` and `FLUSHDB`), ioredis sends them to a random node.\n\nSometimes you may want to send a command to multiple nodes (masters or slaves) of the cluster, you can get the nodes via `Cluster#nodes()` method.\n\n`Cluster#nodes()` accepts a parameter role, which can be \"master\", \"slave\" and \"all\" (default), and returns an array of `Redis` instance. For example:\n\n```javascript\n// Send `FLUSHDB` command to all slaves:\nvar slaves = cluster.nodes('slave');\nPromise.all(slaves.map(function (node) {\n  return node.flushdb();\n}));\n\n// Get keys of all the masters:\nvar masters = cluster.nodes('master');\nPromise.all(masters.map(function (node) {\n  return node.keys();\n})).then(function (keys) {\n  // keys: [['key1', 'key2'], ['key3', 'key4']]\n});\n```\n\n### NAT Mapping\nSometimes the cluster is hosted within a internal network that can only be accessed via a NAT (Network Address Translation) instance. See [Accessing ElastiCache from outside AWS](https://docs.aws.amazon.com/AmazonElastiCache/latest/red-ug/accessing-elasticache.html) as an example.\n\nYou can specify nat mapping rules via `natMap` option:\n\n```javascript\nconst cluster = new Redis.Cluster([{\n  host: '203.0.113.73',\n  port: 30001\n}], {\n  natMap: {\n    '10.0.1.230:30001': {host: '203.0.113.73', port: 30001},\n    '10.0.1.231:30001': {host: '203.0.113.73', port: 30002},\n    '10.0.1.232:30001': {host: '203.0.113.73', port: 30003}\n  }\n})\n```\n\nThis option is also useful when the cluster is running inside a Docker container.\n\n### Transaction and pipeline in Cluster mode\nAlmost all features that are supported by `Redis` are also supported by `Redis.Cluster`, e.g. custom commands, transaction and pipeline.\nHowever there are some differences when using transaction and pipeline in Cluster mode:\n\n0. All keys in a pipeline should belong to the same slot since ioredis sends all commands in a pipeline to the same node.\n0. You can't use `multi` without pipeline (aka `cluster.multi({ pipeline: false })`). This is because when you call `cluster.multi({ pipeline: false })`, ioredis doesn't know which node the `multi` command should be sent to.\n0. Chaining custom commands in the pipeline is not supported in Cluster mode.\n\nWhen any commands in a pipeline receives a `MOVED` or `ASK` error, ioredis will resend the whole pipeline to the specified node automatically if all of the following conditions are satisfied:\n\n0. All errors received in the pipeline are the same. For example, we won't resend the pipeline if we got two `MOVED` errors pointing to different nodes.\n0. All commands executed successfully are readonly commands. This makes sure that resending the pipeline won't have side effects.\n\n### Pub/Sub\nPub/Sub in cluster mode works exactly as the same as in standalone mode. Internally, when a node of the cluster receives a message, it will broadcast the message to the other nodes. ioredis makes sure that each message will only be received once by strictly subscribing one node at the same time.\n\n```javascript\nvar nodes = [/* nodes */];\nvar pub = new Redis.Cluster(nodes);\nvar sub = new Redis.Cluster(nodes);\nsub.on('message', function (channel, message) {\n  console.log(channel, message);\n});\n\nsub.subscribe('news', function () {\n  pub.publish('news', 'highlights');\n});\n```\n\n### Events\n\nEvent    | Description\n:------------- | :-------------\nconnect  | emits when a connection is established to the Redis server.\nready    | emits when `CLUSTER INFO` reporting the cluster is able to receive commands (if `enableReadyCheck` is `true`) or immediately after `connect` event (if `enableReadyCheck` is false).\nerror    | emits when an error occurs while connecting with a property of `lastNodeError` representing the last node error received. This event is emitted silently (only emitting if there's at least one listener).\nclose    | emits when an established Redis server connection has closed.\nreconnecting | emits after `close` when a reconnection will be made. The argument of the event is the time (in ms) before reconnecting.\nend     | emits after `close` when no more reconnections will be made.\n+node   | emits when a new node is connected.\n-node   | emits when a node is disconnected.\nnode error | emits when an error occurs when connecting to a node\n\n### Password\nSetting the `password` option to access password-protected clusters:\n\n```javascript\nvar Redis = require('ioredis');\nvar cluster = new Redis.Cluster(nodes, {\n  redisOptions: {\n    password: 'your-cluster-password'\n  }\n});\n```\n\nIf some of nodes in the cluster using a different password, you should specify them in the first parameter:\n\n```javascript\nvar Redis = require('ioredis');\nvar cluster = new Redis.Cluster([\n  // Use password \"password-for-30001\" for 30001\n  { port: 30001, password: 'password-for-30001'},\n  // Don't use password when accessing 30002\n  { port: 30002, password: null }\n  // Other nodes will use \"fallback-password\"\n], {\n  redisOptions: {\n    password: 'fallback-password'\n  }\n});\n```\n\n<hr>\n\n# Error Handling\nAll the errors returned by the Redis server are instances of `ReplyError`, which can be accessed via `Redis`:\n\n```javascript\nvar Redis = require('ioredis');\nvar redis = new Redis();\n// This command causes a reply error since the SET command requires two arguments.\nredis.set('foo', function (err) {\n  err instanceof Redis.ReplyError\n});\n```\n\nThis is the error stack of the `ReplyError`:\n\n```\nReplyError: ERR wrong number of arguments for 'set' command\n    at ReplyParser._parseResult (/app/node_modules/ioredis/lib/parsers/javascript.js:60:14)\n    at ReplyParser.execute (/app/node_modules/ioredis/lib/parsers/javascript.js:178:20)\n    at Socket.<anonymous> (/app/node_modules/ioredis/lib/redis/event_handler.js:99:22)\n    at Socket.emit (events.js:97:17)\n    at readableAddChunk (_stream_readable.js:143:16)\n    at Socket.Readable.push (_stream_readable.js:106:10)\n    at TCP.onread (net.js:509:20)\n```\n\nBy default, the error stack doesn't make any sense because the whole stack happens in the ioredis\nmodule itself, not in your code. So it's not easy to find out where the error happens in your code.\nioredis provides an option `showFriendlyErrorStack` to solve the problem. When you enable\n`showFriendlyErrorStack`, ioredis will optimize the error stack for you:\n\n```javascript\nvar Redis = require('ioredis');\nvar redis = new Redis({ showFriendlyErrorStack: true });\nredis.set('foo');\n```\n\nAnd the output will be:\n\n```\nReplyError: ERR wrong number of arguments for 'set' command\n    at Object.<anonymous> (/app/index.js:3:7)\n    at Module._compile (module.js:446:26)\n    at Object.Module._extensions..js (module.js:464:10)\n    at Module.load (module.js:341:32)\n    at Function.Module._load (module.js:296:12)\n    at Function.Module.runMain (module.js:487:10)\n    at startup (node.js:111:16)\n    at node.js:799:3\n```\n\nThis time the stack tells you that the error happens on the third line in your code. Pretty sweet!\nHowever, it would decrease the performance significantly to optimize the error stack. So by\ndefault, this option is disabled and can only be used for debugging purposes. You **shouldn't** use this feature in a production environment.\n\n# Plugging in your own Promises Library\nIf you're an advanced user, you may want to plug in your own promise library like [bluebird](https://www.npmjs.com/package/bluebird). Just set Redis.Promise to your favorite ES6-style promise constructor and ioredis will use it.\n\n```javascript\nconst Redis = require('ioredis')\nRedis.Promise = require('bluebird')\n\nconst redis = new Redis()\n\n// Use bluebird\nassert.equal(redis.get().constructor, require('bluebird'))\n\n// You can change the Promise implementation at any time:\nRedis.Promise = global.Promise\nassert.equal(redis.get().constructor, global.Promise)\n```\n\n\n# Running tests\n\nStart a Redis server on 127.0.0.1:6379, and then:\n\n```shell\n$ npm test\n```\n\n`FLUSH ALL` will be invoked after each test, so make sure there's no valuable data in it before running tests.\n\nIf your testing environment does not let you spin up a Redis server [ioredis-mock](https://github.com/stipsan/ioredis-mock) is a drop-in replacement you can use in your tests. It aims to behave identically to ioredis connected to a Redis server so that your integration tests is easier to write and of better quality.\n\n# Debug\n\nYou can set the `DEBUG` env to `ioredis:*` to print debug info:\n\n```shell\n$ DEBUG=ioredis:* node app.js\n```\n\n# Consolidation: It's time for celebration\n\nRight now there are two great redis clients around and both have some advantages above each other. We speak about [node_redis](https://github.com/NodeRedis/node_redis) and ioredis. So after talking to each other about how we could improve in working together we (that is [@BridgeAR](https://github.com/BridgeAR) and [@luin](https://github.com/luin)) decided to work towards a single library on the long run. But step by step.\n\nFirst of all, we want to split small parts of our libraries into others so that we're both able to use the same code. Those libraries are going to be maintained under the NodeRedis organization. This is going to reduce the maintance overhead, allows others to use the very same code, if they need it and it's way easier for others to contribute to both libraries.\n\nWe're very happy about this step towards working together as we both want to give you the best redis experience possible.\n\nIf you want to join our cause by help maintaining something, please don't hesitate to contact either one of us.\n\n# Join in!\n\nI'm happy to receive bug reports, fixes, documentation enhancements, and any other improvements.\n\nAnd since I'm not a native English speaker, if you find any grammar mistakes in the documentation, please also let me know. :)\n\n# Contributors\n\nThis project exists thanks to all the people who contribute:\n\n<a href=\"https://github.com/luin/ioredis/graphs/contributors\"><img src=\"https://opencollective.com/ioredis/contributors.svg?width=890&showBtn=false\" /></a>\n\n# License\n\nMIT\n\n\n[![FOSSA Status](https://app.fossa.io/api/projects/git%2Bgithub.com%2Fluin%2Fioredis.svg?type=large)](https://app.fossa.io/projects/git%2Bgithub.com%2Fluin%2Fioredis?ref=badge_large)\n","readmeFilename":"README.md","bugs":{"url":"https://github.com/luin/ioredis/issues"},"homepage":"https://github.com/luin/ioredis#readme","_id":"ioredis@4.6.1","_npmVersion":"6.4.1","_nodeVersion":"10.15.0","_npmUser":{"name":"ioredis-robot","email":"ioredis-robot@zihua.li"},"dist":{"integrity":"sha512-uacgkfVJ4cmH3eNKrjbrslUqi495e8vtRysuz4sqzJtRBp4sHRUlyxIlS6Hw6lWo58nA+SRBKzAzkieMWoSZbg==","shasum":"7a63148231f4b23ab08756e1238c24f6a5b2c78a","tarball":"https://registry.npmjs.org/ioredis/-/ioredis-4.6.1.tgz","fileCount":35,"unpackedSize":218752,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJcUJOiCRA9TVsSAnZWagAA3TAP/06lU8LlPI6NDKDlkOi4\nCdmZwPQuNwsoNdxhaGyqEHcjVqtI3eoQ7Ex7y8PsjmWHBsFiWPRR75Uj0LZ9\nP4yUSBrHdp2wX6pm6zHM2bXxLGPXRkGBSPGehRTpyToGKsR5g4qr3xYLhFkB\nQoF2uub8uBe4/r+NshjZiPBmZtsW8Xm7z9MRIhiECI0xMnBXo7mMM68RD9Jq\nN98Qh8S+SRedIF61XAbOqfCZa7xv7a0eMj4jD21OeuUGEszU4OsRntfx7poE\nwVfaKzT1IgGgdo+W97GXDh+TMRVbkpscutL22918+xx9+h1B4yGaGx9kCQHm\nTh4DQVlSNyzTt6geYlvFYyEb4/1eAvMmcm+HYxlMHwyZ2ln0Wuu+h3y26Dko\nDgmMTjCeb0CKXY3twte9AGvnS3xBvy5UAOI2HcG0l3UmMUgceK5L0a9rnF3E\nUMzNZt8oVIqNZUNR7uVXTsMas7JAixocE9h2CToayllGtUi16Vr4eFk52WMX\nLUi2b07KINWMp77eFP+AICmNcpzsxpV9YhNAQRyIHLDfrixwmxeYZIMWt9H4\nBEKu7ffiPnOhY3xSaziADbHbv5O1WWwMbXFwv25gHym9RrD20jShvNekGqEc\nPa3V0MQ32q89opp5nt3q/vNEgthBJX1AeS8B7b2NPIPx2vqsEVRHzstFlUuL\n6EQm\r\n=xFNI\r\n-----END PGP SIGNATURE-----\r\n"},"maintainers":[{"email":"ioredis-robot@zihua.li","name":"ioredis-robot"},{"email":"i@zihua.li","name":"luin"}],"directories":{},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/ioredis_4.6.1_1548784545787_0.5061971545396411"},"_hasShrinkwrap":false},"4.6.2":{"name":"ioredis","version":"4.6.2","description":"A robust, performance-focused and full-featured Redis client for Node.js.","main":"built/index.js","scripts":{"test":"NODE_ENV=test mocha --timeout 8000 -r ts-node/register --exit","test:cov":"NODE_ENV=test node ./node_modules/istanbul/lib/cli.js cover --preserve-comments ./node_modules/mocha/bin/_mocha -- -r ts-node/register -R spec --exit","build":"rm -rf built && tsc","generate-docs":"jsdoc2md lib/redis.js lib/cluster/index.js lib/commander.js > API.md","prepublishOnly":"npm run build && npm test","bench":"matcha benchmarks/*.js","semantic-release":"semantic-release"},"repository":{"type":"git","url":"git://github.com/luin/ioredis.git"},"keywords":["redis","cluster","sentinel","pipelining"],"author":{"name":"luin","email":"i@zihua.li","url":"http://zihua.li"},"license":"MIT","dependencies":{"cluster-key-slot":"^1.0.6","debug":"^3.1.0","denque":"^1.1.0","flexbuffer":"0.0.6","lodash.defaults":"^4.2.0","lodash.flatten":"^4.4.0","redis-commands":"1.4.0","redis-errors":"^1.2.0","redis-parser":"^3.0.0","standard-as-callback":"^1.0.0"},"devDependencies":{"@semantic-release/changelog":"^3.0.0","@semantic-release/git":"^7.0.4","@types/node":"^10.11.5","@types/redis-errors":"1.2.0","bluebird":"^3.5.1","chai":"^3.5.0","cz-conventional-changelog":"^2.0.0","istanbul":"^0.4.2","jsdoc":"^3.4.0","jsdoc-to-markdown":"^4.0.1","mocha":"^5.2.0","server-destroy":"^1.0.1","sinon":"^1.17.3","ts-node":"^7.0.0","typescript":"^3.1.1"},"engines":{"node":">=6"},"config":{"commitizen":{"path":"./node_modules/cz-conventional-changelog"}},"gitHead":"85b532641b79eff08fd7510510197a31a43d1a4b","bugs":{"url":"https://github.com/luin/ioredis/issues"},"homepage":"https://github.com/luin/ioredis#readme","_id":"ioredis@4.6.2","_npmVersion":"6.4.1","_nodeVersion":"10.15.1","_npmUser":{"name":"ioredis-robot","email":"ioredis-robot@zihua.li"},"dist":{"integrity":"sha512-zlc/LeoeriHTXm5z3rakPcfRcUV9x+xr0E+7/L7KH0D5z7sI5ngEQWR2RUxnwFcxUcCkvrXMztRIdBP3DhqMAQ==","shasum":"840847117fe0190a9309085847311a07183fc385","tarball":"https://registry.npmjs.org/ioredis/-/ioredis-4.6.2.tgz","fileCount":35,"unpackedSize":219100,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJcVbQdCRA9TVsSAnZWagAARvgP/idXZ3HZnuS/JSe9df+s\nkeaKKc8GPw4LCaQYLIYn7xfn4dc1tYLAnTU03vMe7OFqKelaeZC1iJEhV5dG\ngX5WYSxUYubMekxdNAVbjg4kAoMh7t7WXZ63o+SkcW0MhC/+uEnx2qq3yGmx\nMhjKlwdFfytn9G21M51iFOvO10SpDH1r0ljt6pOHKALpxtPEku10V456Sbqi\nGIELPddvmVSG/ZaS4qj0Cwv+X0dTuR5KDUWzj4j48h4amYOwxSS0oOLSuVAe\nvDmakcjbqPf9KI7vnsvMQ0BUkL4NPSxRGv3LtBZC85eJZtPH6qh6pjs4j2JD\neJnhGYW+W1TWM9Xfl9WoNKUbdNkxAaoCCHw+iuyXinQEJX4/8UEPXcNt8tAP\nKjDZEUNiKbk/LmP5ztgzIqTKvctX6ZXZWttOKUE9JcGuxnHeYDAjrrb4qTp/\nFVvNFM0uGwk62oDJu5i5Vf1Bjk/KFsPCxyLiAHMVIikXuGs2K0bhoXWULnrL\nbiNIWy2nP+KmFuMlee8HDESLSoofbAcn0gELw3qY9bWBWgcAIFzuI0/SaM8h\nl7RuBw8HDf7k53iH++KV5c12K+fxchxRcJCr5mNVjt3ohs4Cm0ratfb23AOj\nRRx/ETGlC3cQe8g6gBspiLF1oKAV04VXh22ZCP1Jpa3OS80zmkb33eTuOxoD\nObuP\r\n=yqjK\r\n-----END PGP SIGNATURE-----\r\n"},"maintainers":[{"email":"ioredis-robot@zihua.li","name":"ioredis-robot"},{"email":"i@zihua.li","name":"luin"}],"directories":{},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/ioredis_4.6.2_1549120540806_0.43301556981483413"},"_hasShrinkwrap":false},"4.6.3":{"name":"ioredis","version":"4.6.3","description":"A robust, performance-focused and full-featured Redis client for Node.js.","main":"built/index.js","scripts":{"test":"NODE_ENV=test mocha --timeout 8000 -r ts-node/register --exit","test:cov":"NODE_ENV=test node ./node_modules/istanbul/lib/cli.js cover --preserve-comments ./node_modules/mocha/bin/_mocha -- -r ts-node/register -R spec --exit","build":"rm -rf built && tsc","generate-docs":"jsdoc2md lib/redis.js lib/cluster/index.js lib/commander.js > API.md","prepublishOnly":"npm run build && npm test","bench":"matcha benchmarks/*.js","semantic-release":"semantic-release"},"repository":{"type":"git","url":"git://github.com/luin/ioredis.git"},"keywords":["redis","cluster","sentinel","pipelining"],"author":{"name":"luin","email":"i@zihua.li","url":"http://zihua.li"},"license":"MIT","dependencies":{"cluster-key-slot":"^1.0.6","debug":"^3.1.0","denque":"^1.1.0","flexbuffer":"0.0.6","lodash.defaults":"^4.2.0","lodash.flatten":"^4.4.0","redis-commands":"1.4.0","redis-errors":"^1.2.0","redis-parser":"^3.0.0","standard-as-callback":"^1.0.0"},"devDependencies":{"@semantic-release/changelog":"^3.0.0","@semantic-release/git":"^7.0.4","@types/node":"^10.11.5","@types/redis-errors":"1.2.0","bluebird":"^3.5.1","chai":"^3.5.0","cz-conventional-changelog":"^2.0.0","istanbul":"^0.4.2","jsdoc":"^3.4.0","jsdoc-to-markdown":"^4.0.1","mocha":"^5.2.0","server-destroy":"^1.0.1","sinon":"^1.17.3","ts-node":"^7.0.0","typescript":"^3.1.1"},"engines":{"node":">=6"},"config":{"commitizen":{"path":"./node_modules/cz-conventional-changelog"}},"gitHead":"cb551cbbf9210b0e9bed5d6df8e3cccacaef3865","readme":"[![ioredis](https://cdn.rawgit.com/luin/ioredis/57b5b89e3e9111ff25d8c62c0bc58ed42e5b8d1e/logo.svg)](https://github.com/luin/ioredis)\n\n[![Build Status](https://travis-ci.org/luin/ioredis.svg?branch=master)](https://travis-ci.org/luin/ioredis)\n[![Test Coverage](https://codeclimate.com/github/luin/ioredis/badges/coverage.svg)](https://codeclimate.com/github/luin/ioredis)\n[![Join the chat at https://gitter.im/luin/ioredis](https://badges.gitter.im/Join%20Chat.svg)](https://gitter.im/luin/ioredis?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge)\n[![Commitizen friendly](https://img.shields.io/badge/commitizen-friendly-brightgreen.svg)](http://commitizen.github.io/cz-cli/)\n[![semantic-release](https://img.shields.io/badge/%20%20%F0%9F%93%A6%F0%9F%9A%80-semantic--release-e10079.svg)](https://github.com/semantic-release/semantic-release)\n[![npm latest version](https://img.shields.io/npm/v/ioredis/latest.svg)](https://www.npmjs.com/package/ioredis)\n[![npm next version](https://img.shields.io/npm/v/ioredis/next.svg)](https://www.npmjs.com/package/ioredis)\n<img alt=\"\" src=\"\">\n\nA robust, performance-focused and full-featured [Redis](http://redis.io) client for [Node.js](https://nodejs.org).\n\nSupports Redis >= 2.6.12 and (Node.js >= 6).\n\n# Features\nioredis is a robust, full-featured Redis client that is\nused in the world's biggest online commerce company [Alibaba](http://www.alibaba.com/) and many other awesome companies.\n\n0. Full-featured. It supports [Cluster](http://redis.io/topics/cluster-tutorial), [Sentinel](http://redis.io/topics/sentinel), [Pipelining](http://redis.io/topics/pipelining) and of course [Lua scripting](http://redis.io/commands/eval) & [Pub/Sub](http://redis.io/topics/pubsub) (with the support of binary messages).\n0. High performance.\n0. Delightful API. It works with Node callbacks and Native promises.\n0. Transformation of command arguments and replies.\n0. Transparent key prefixing.\n0. Abstraction for Lua scripting, allowing you to define custom commands.\n0. Support for binary data.\n0. Support for TLS.\n0. Support for offline queue and ready checking.\n0. Support for ES6 types, such as `Map` and `Set`.\n0. Support for GEO commands (Redis 3.2 Unstable).\n0. Sophisticated error handling strategy.\n0. Support for NAT mapping.\n\n# Links\n* [API Documentation](API.md)\n* [Changelog](Changelog.md)\n* [Migrating from node_redis](https://github.com/luin/ioredis/wiki/Migrating-from-node_redis)\n* [Error Handling](#error-handling)\n\n## Become a Sponsor to Support ioredis's Development\nOpen source is hard and time-consuming. If you want to invest in ioredis's future you can become a sponsor and make us spend more time on this library's improvements and new features.\n\n<a href=\"https://opencollective.com/ioredis\"><img src=\"https://opencollective.com/ioredis/tiers/sponsor.svg?avatarHeight=36\"></a>\n\nThank you for using ioredis :-)\n\n<hr>\n<a href=\"https://itunes.apple.com/app/medis-gui-for-redis/id1063631769\"><img align=\"right\" src=\"medis.png\" alt=\"Download on the App Store\"></a>\n\n\n### Advertisement\n\nLooking for a Redis GUI manager for OS X, Windows and Linux? Here's [Medis](https://itunes.apple.com/us/app/medis-gui-for-redis/id1063631769)!\n\nMedis is an open-sourced, beautiful, easy-to-use Redis GUI management application.\n\nMedis starts with all the basic features you need:\n\n* Keys viewing/editing\n* SSH Tunnel for connecting with remote servers\n* Terminal for executing custom commands\n* JSON/MessagePack format viewing/editing and built-in highlighting/validator\n* And other awesome features...\n\n[Medis is open sourced on GitHub](https://github.com/luin/medis)\n\n<hr>\n\n# Quick Start\n\n## Install\n```shell\n$ npm install ioredis\n```\n\n## Basic Usage\n\n```javascript\nvar Redis = require('ioredis');\nvar redis = new Redis();\n\nredis.set('foo', 'bar');\nredis.get('foo', function (err, result) {\n  console.log(result);\n});\n\n// Or using a promise if the last argument isn't a function\nredis.get('foo').then(function (result) {\n  console.log(result);\n});\n\n// Arguments to commands are flattened, so the following are the same:\nredis.sadd('set', 1, 3, 5, 7);\nredis.sadd('set', [1, 3, 5, 7]);\n\n// All arguments are passed directly to the redis server:\nredis.set('key', 100, 'EX', 10);\n```\n\nSee the `examples/` folder for more examples.\n\n## Connect to Redis\nWhen a new `Redis` instance is created,\na connection to Redis will be created at the same time.\nYou can specify which Redis to connect to by:\n\n```javascript\nnew Redis()       // Connect to 127.0.0.1:6379\nnew Redis(6380)   // 127.0.0.1:6380\nnew Redis(6379, '192.168.1.1')        // 192.168.1.1:6379\nnew Redis('/tmp/redis.sock')\nnew Redis({\n  port: 6379,          // Redis port\n  host: '127.0.0.1',   // Redis host\n  family: 4,           // 4 (IPv4) or 6 (IPv6)\n  password: 'auth',\n  db: 0\n})\n```\n\nYou can also specify connection options as a [`redis://` URL](http://www.iana.org/assignments/uri-schemes/prov/redis):\n\n```javascript\n// Connect to 127.0.0.1:6380, db 4, using password \"authpassword\":\nnew Redis('redis://:authpassword@127.0.0.1:6380/4')\n```\n\nSee [API Documentation](API.md#new_Redis) for all available options.\n\n## Pub/Sub\n\nHere is a simple example of the API for publish/subscribe.\nThe following program opens two client connections.\nIt subscribes to a channel with one connection\nand publishes to that channel with the other:\n\n```javascript\nvar Redis = require('ioredis');\nvar redis = new Redis();\nvar pub = new Redis();\nredis.subscribe('news', 'music', function (err, count) {\n  // Now we are subscribed to both the 'news' and 'music' channels.\n  // `count` represents the number of channels we are currently subscribed to.\n\n  pub.publish('news', 'Hello world!');\n  pub.publish('music', 'Hello again!');\n});\n\nredis.on('message', function (channel, message) {\n  // Receive message Hello world! from channel news\n  // Receive message Hello again! from channel music\n  console.log('Receive message %s from channel %s', message, channel);\n});\n\n// There's also an event called 'messageBuffer', which is the same as 'message' except\n// it returns buffers instead of strings.\nredis.on('messageBuffer', function (channel, message) {\n  // Both `channel` and `message` are buffers.\n});\n```\n\n`PSUBSCRIBE` is also supported in a similar way:\n\n```javascript\nredis.psubscribe('pat?ern', function (err, count) {});\nredis.on('pmessage', function (pattern, channel, message) {});\nredis.on('pmessageBuffer', function (pattern, channel, message) {});\n```\n\nWhen a client issues a SUBSCRIBE or PSUBSCRIBE, that connection is put into a \"subscriber\" mode.\nAt that point, only commands that modify the subscription set are valid.\nWhen the subscription set is empty, the connection is put back into regular mode.\n\nIf you need to send regular commands to Redis while in subscriber mode, just open another connection.\n\n## Handle Binary Data\nArguments can be buffers:\n```javascript\nredis.set('foo', Buffer.from('bar'));\n```\n\nAnd every command has a method that returns a Buffer (by adding a suffix of \"Buffer\" to the command name).\nTo get a buffer instead of a utf8 string:\n\n```javascript\nredis.getBuffer('foo', function (err, result) {\n  // result is a buffer.\n});\n```\n\n## Pipelining\nIf you want to send a batch of commands (e.g. > 5), you can use pipelining to queue\nthe commands in memory and then send them to Redis all at once. This way the performance improves by 50%~300% (See [benchmark section](#benchmark)).\n\n`redis.pipeline()` creates a `Pipeline` instance. You can call any Redis\ncommands on it just like the `Redis` instance. The commands are queued in memory\nand flushed to Redis by calling the `exec` method:\n\n```javascript\nvar pipeline = redis.pipeline();\npipeline.set('foo', 'bar');\npipeline.del('cc');\npipeline.exec(function (err, results) {\n  // `err` is always null, and `results` is an array of responses\n  // corresponding to the sequence of queued commands.\n  // Each response follows the format `[err, result]`.\n});\n\n// You can even chain the commands:\nredis.pipeline().set('foo', 'bar').del('cc').exec(function (err, results) {\n});\n\n// `exec` also returns a Promise:\nvar promise = redis.pipeline().set('foo', 'bar').get('foo').exec();\npromise.then(function (result) {\n  // result === [[null, 'OK'], [null, 'bar']]\n});\n```\n\nEach chained command can also have a callback, which will be invoked when the command\ngets a reply:\n\n```javascript\nredis.pipeline().set('foo', 'bar').get('foo', function (err, result) {\n  // result === 'bar'\n}).exec(function (err, result) {\n  // result[1][1] === 'bar'\n});\n```\n\nIn addition to adding commands to the `pipeline` queue individually, you can also pass an array of commands and arguments to the constructor:\n\n```javascript\nredis.pipeline([\n  ['set', 'foo', 'bar'],\n  ['get', 'foo']\n]).exec(function () { /* ... */ });\n```\n\n`#length` property shows how many commands in the pipeline:\n\n```javascript\nconst length = redis.pipeline().set('foo', 'bar').get('foo').length;\n// length === 2\n```\n\n\n## Transaction\nMost of the time, the transaction commands `multi` & `exec` are used together with pipeline.\nTherefore, when `multi` is called, a `Pipeline` instance is created automatically by default,\nso you can use `multi` just like `pipeline`:\n\n```javascript\nredis.multi().set('foo', 'bar').get('foo').exec(function (err, results) {\n  // results === [[null, 'OK'], [null, 'bar']]\n});\n```\nIf there's a syntax error in the transaction's command chain (e.g. wrong number of arguments, wrong command name, etc),\nthen none of the commands would be executed, and an error is returned:\n\n```javascript\nredis.multi().set('foo').set('foo', 'new value').exec(function (err, results) {\n  // err:\n  //  { [ReplyError: EXECABORT Transaction discarded because of previous errors.]\n  //    name: 'ReplyError',\n  //    message: 'EXECABORT Transaction discarded because of previous errors.',\n  //    command: { name: 'exec', args: [] },\n  //    previousErrors:\n  //     [ { [ReplyError: ERR wrong number of arguments for 'set' command]\n  //         name: 'ReplyError',\n  //         message: 'ERR wrong number of arguments for \\'set\\' command',\n  //         command: [Object] } ] }\n});\n```\n\nIn terms of the interface, `multi` differs from `pipeline` in that when specifying a callback\nto each chained command, the queueing state is passed to the callback instead of the result of the command:\n\n```javascript\nredis.multi().set('foo', 'bar', function (err, result) {\n  // result === 'QUEUED'\n}).exec(/* ... */);\n```\n\nIf you want to use transaction without pipeline, pass `{ pipeline: false }` to `multi`,\nand every command will be sent to Redis immediately without waiting for an `exec` invocation:\n\n```javascript\nredis.multi({ pipeline: false });\nredis.set('foo', 'bar');\nredis.get('foo');\nredis.exec(function (err, result) {\n  // result === [[null, 'OK'], [null, 'bar']]\n});\n```\n\nThe constructor of `multi` also accepts a batch of commands:\n\n```javascript\nredis.multi([\n  ['set', 'foo', 'bar'],\n  ['get', 'foo']\n]).exec(function () { /* ... */ });\n```\n\nInline transactions are supported by pipeline, which means you can group a subset of commands\nin the pipeline into a transaction:\n\n```javascript\nredis.pipeline().get('foo').multi().set('foo', 'bar').get('foo').exec().get('foo').exec();\n```\n\n## Lua Scripting\nioredis supports all of the scripting commands such as `EVAL`, `EVALSHA` and `SCRIPT`.\nHowever, it's tedious to use in real world scenarios since developers have to take\ncare of script caching and to detect when to use `EVAL` and when to use `EVALSHA`.\nioredis expose a `defineCommand` method to make scripting much easier to use:\n\n```javascript\nvar redis = new Redis();\n\n// This will define a command echo:\nredis.defineCommand('echo', {\n  numberOfKeys: 2,\n  lua: 'return {KEYS[1],KEYS[2],ARGV[1],ARGV[2]}'\n});\n\n// Now `echo` can be used just like any other ordinary command,\n// and ioredis will try to use `EVALSHA` internally when possible for better performance.\nredis.echo('k1', 'k2', 'a1', 'a2', function (err, result) {\n  // result === ['k1', 'k2', 'a1', 'a2']\n});\n\n// `echoBuffer` is also defined automatically to return buffers instead of strings:\nredis.echoBuffer('k1', 'k2', 'a1', 'a2', function (err, result) {\n  // result[0] equals to Buffer.from('k1');\n});\n\n// And of course it works with pipeline:\nredis.pipeline().set('foo', 'bar').echo('k1', 'k2', 'a1', 'a2').exec();\n```\n\nIf the number of keys can't be determined when defining a command, you can\nomit the `numberOfKeys` property and pass the number of keys as the first argument\nwhen you call the command:\n\n```javascript\nredis.defineCommand('echoDynamicKeyNumber', {\n  lua: 'return {KEYS[1],KEYS[2],ARGV[1],ARGV[2]}'\n});\n\n// Now you have to pass the number of keys as the first argument every time\n// you invoke the `echoDynamicKeyNumber` command:\nredis.echoDynamicKeyNumber(2, 'k1', 'k2', 'a1', 'a2', function (err, result) {\n  // result === ['k1', 'k2', 'a1', 'a2']\n});\n```\n\n## Transparent Key Prefixing\nThis feature allows you to specify a string that will automatically be prepended\nto all the keys in a command, which makes it easier to manage your key\nnamespaces.\n\n**Warning** This feature won't apply to commands like [KEYS](http://redis.io/commands/KEYS) and [SCAN](http://redis.io/commands/scan) that take patterns rather than actual keys([#239](https://github.com/luin/ioredis/issues/239)),\nand this feature also won't apply to the replies of commands even they are key names ([#325](https://github.com/luin/ioredis/issues/325)).\n\n```javascript\nvar fooRedis = new Redis({ keyPrefix: 'foo:' });\nfooRedis.set('bar', 'baz');  // Actually sends SET foo:bar baz\n\nfooRedis.defineCommand('echo', {\n  numberOfKeys: 2,\n  lua: 'return {KEYS[1],KEYS[2],ARGV[1],ARGV[2]}'\n});\n\n// Works well with pipelining/transaction\nfooRedis.pipeline()\n  // Sends SORT foo:list BY foo:weight_*->fieldname\n  .sort('list', 'BY', 'weight_*->fieldname')\n  // Supports custom commands\n  // Sends EVALSHA xxx foo:k1 foo:k2 a1 a2\n  .echo('k1', 'k2', 'a1', 'a2')\n  .exec()\n```\n\n## Transforming Arguments & Replies\nMost Redis commands take one or more Strings as arguments,\nand replies are sent back as a single String or an Array of Strings. However, sometimes\nyou may want something different. For instance, it would be more convenient if the `HGETALL`\ncommand returns a hash (e.g. `{ key: val1, key2: v2 }`) rather than an array of key values (e.g. `[key1, val1, key2, val2]`).\n\nioredis has a flexible system for transforming arguments and replies. There are two types\nof transformers, argument transformer and reply transformer:\n\n```javascript\nvar Redis = require('ioredis');\n\n// Here's the built-in argument transformer converting\n// hmset('key', { k1: 'v1', k2: 'v2' })\n// or\n// hmset('key', new Map([['k1', 'v1'], ['k2', 'v2']]))\n// into\n// hmset('key', 'k1', 'v1', 'k2', 'v2')\nRedis.Command.setArgumentTransformer('hmset', function (args) {\n  if (args.length === 2) {\n    if (typeof Map !== 'undefined' && args[1] instanceof Map) {\n      // utils is a internal module of ioredis\n      return [args[0]].concat(utils.convertMapToArray(args[1]));\n    }\n    if ( typeof args[1] === 'object' && args[1] !== null) {\n      return [args[0]].concat(utils.convertObjectToArray(args[1]));\n    }\n  }\n  return args;\n});\n\n// Here's the built-in reply transformer converting the HGETALL reply\n// ['k1', 'v1', 'k2', 'v2']\n// into\n// { k1: 'v1', 'k2': 'v2' }\nRedis.Command.setReplyTransformer('hgetall', function (result) {\n  if (Array.isArray(result)) {\n    var obj = {};\n    for (var i = 0; i < result.length; i += 2) {\n      obj[result[i]] = result[i + 1];\n    }\n    return obj;\n  }\n  return result;\n});\n```\n\nThere are three built-in transformers, two argument transformers for `hmset` & `mset` and\na reply transformer for `hgetall`. Transformers for `hmset` and `hgetall` were mentioned\nabove, and the transformer for `mset` is similar to the one for `hmset`:\n\n```javascript\nredis.mset({ k1: 'v1', k2: 'v2' });\nredis.get('k1', function (err, result) {\n  // result === 'v1';\n});\n\nredis.mset(new Map([['k3', 'v3'], ['k4', 'v4']]));\nredis.get('k3', function (err, result) {\n  // result === 'v3';\n});\n```\n\nAnother useful example of a reply transformer is one that changes `hgetall` to return array of arrays instead of objects which avoids a unwanted conversation of hash keys to strings when dealing with binary hash keys:\n\n```javascript\nRedis.Command.setReplyTransformer('hgetall', function (result) {\n  var arr = [];\n  for (var i = 0; i < result.length; i += 2) {\n    arr.push([result[i], result[i + 1]]);\n  }\n  return arr;\n});\nredis.hset('h1', Buffer.from([0x01]), Buffer.from([0x02]));\nredis.hset('h1', Buffer.from([0x03]), Buffer.from([0x04]));\nredis.hgetallBuffer('h1', function (err, result) {\n  // result === [ [ <Buffer 01>, <Buffer 02> ], [ <Buffer 03>, <Buffer 04> ] ];\n});\n```\n\n## Monitor\nRedis supports the MONITOR command,\nwhich lets you see all commands received by the Redis server across all client connections,\nincluding from other client libraries and other computers.\n\nThe `monitor` method returns a monitor instance.\nAfter you send the MONITOR command, no other commands are valid on that connection. ioredis will emit a monitor event for every new monitor message that comes across.\nThe callback for the monitor event takes a timestamp from the Redis server and an array of command arguments.\n\nHere is a simple example:\n\n```javascript\nredis.monitor(function (err, monitor) {\n  monitor.on('monitor', function (time, args, source, database) {\n  });\n});\n```\n\n## Streamify Scanning\nRedis 2.8 added the `SCAN` command to incrementally iterate through the keys in the database. It's different from `KEYS` in that\n`SCAN` only returns a small number of elements each call, so it can be used in production without the downside\nof blocking the server for a long time. However, it requires recording the cursor on the client side each time\nthe `SCAN` command is called in order to iterate through all the keys correctly. Since it's a relatively common use case, ioredis\nprovides a streaming interface for the `SCAN` command to make things much easier. A readable stream can be created by calling `scanStream`:\n\n```javascript\nvar redis = new Redis();\n// Create a readable stream (object mode)\nvar stream = redis.scanStream();\nstream.on('data', function (resultKeys) {\n  // `resultKeys` is an array of strings representing key names.\n  // Note that resultKeys may contain 0 keys, and that it will sometimes\n  // contain duplicates due to SCAN's implementation in Redis.\n  for (var i = 0; i < resultKeys.length; i++) {\n    console.log(resultKeys[i]);\n  }\n});\nstream.on('end', function () {\n  console.log('all keys have been visited');\n});\n```\n\n`scanStream` accepts an option, with which you can specify the `MATCH` pattern and the `COUNT` argument:\n\n```javascript\nvar stream = redis.scanStream({\n  // only returns keys following the pattern of `user:*`\n  match: 'user:*',\n  // returns approximately 100 elements per call\n  count: 100\n});\n```\n\nJust like other commands, `scanStream` has a binary version `scanBufferStream`, which returns an array of buffers. It's useful when\nthe key names are not utf8 strings.\n\nThere are also `hscanStream`, `zscanStream` and `sscanStream` to iterate through elements in a hash, zset and set. The interface of each is\nsimilar to `scanStream` except the first argument is the key name:\n\n```javascript\nvar stream = redis.hscanStream('myhash', {\n  match: 'age:??'\n});\n```\n\nYou can learn more from the [Redis documentation](http://redis.io/commands/scan).\n\n**Useful Tips**\nIt's pretty common that doing an async task in the `data` handler. We'd like the scanning process to be paused until the async task to be finished. `Stream#pause()` and `Stream.resume()` do the trick. For example if we want to migrate data in Redis to MySQL:\n\n```javascript\nvar stream = redis.scanStream();\nstream.on('data', function (resultKeys) {\n  // Pause the stream from scanning more keys until we've migrated the current keys.\n  stream.pause();\n\n  Promise.all(resultKeys.map(migrateKeyToMySQL)).then(() => {\n    // Resume the stream here.\n    stream.resume();\n  });\n});\n\nstream.on('end', function () {\n  console.log('done migration');\n});\n```\n\n## Auto-reconnect\nBy default, ioredis will try to reconnect when the connection to Redis is lost\nexcept when the connection is closed manually by `redis.disconnect()` or `redis.quit()`.\n\nIt's very flexible to control how long to wait to reconnect after disconnection\nusing the `retryStrategy` option:\n\n```javascript\nvar redis = new Redis({\n  // This is the default value of `retryStrategy`\n  retryStrategy: function (times) {\n    var delay = Math.min(times * 50, 2000);\n    return delay;\n  }\n});\n```\n\n`retryStrategy` is a function that will be called when the connection is lost.\nThe argument `times` means this is the nth reconnection being made and\nthe return value represents how long (in ms) to wait to reconnect. When the\nreturn value isn't a number, ioredis will stop trying to reconnect, and the connection\nwill be lost forever if the user doesn't call `redis.connect()` manually.\n\nWhen reconnected, the client will auto subscribe to channels that the previous connection subscribed to.\nThis behavior can be disabled by setting the `autoResubscribe` option to `false`.\n\nAnd if the previous connection has some unfulfilled commands (most likely blocking commands such as `brpop` and `blpop`),\nthe client will resend them when reconnected. This behavior can be disabled by setting the `autoResendUnfulfilledCommands` option to `false`.\n\nBy default, all pending commands will be flushed with an error every 20 retry attempts. That makes sure commands won't wait forever when the connection is down. You can change this behavior by setting `maxRetriesPerRequest`:\n\n```javascript\nvar redis = new Redis({\n  maxRetriesPerRequest: 1\n});\n```\n\nSet maxRetriesPerRequest to `null` to disable this behavior, and every command will wait forever until the connection is alive again (which is the default behavior before ioredis v4).\n\n### Reconnect on error\n\nBesides auto-reconnect when the connection is closed, ioredis supports reconnecting on the specified errors by the `reconnectOnError` option. Here's an example that will reconnect when receiving `READONLY` error:\n\n```javascript\nvar redis = new Redis({\n  reconnectOnError: function (err) {\n    var targetError = 'READONLY';\n    if (err.message.slice(0, targetError.length) === targetError) {\n      // Only reconnect when the error starts with \"READONLY\"\n      return true; // or `return 1;`\n    }\n  }\n});\n```\n\nThis feature is useful when using Amazon ElastiCache. Once failover happens, Amazon ElastiCache will switch the master we currently connected with to a slave, leading to the following writes fails with the error `READONLY`. Using `reconnectOnError`, we can force the connection to reconnect on this error in order to connect to the new master.\n\nFurthermore, if the `reconnectOnError` returns `2`, ioredis will resend the failed command after reconnecting.\n\n## Connection Events\nThe Redis instance will emit some events about the state of the connection to the Redis server.\n\nEvent    | Description\n:------------- | :-------------\nconnect  | emits when a connection is established to the Redis server.\nready    | If `enableReadyCheck` is `true`, client will emit `ready` when the server reports that it is ready to receive commands (e.g. finish loading data from disk).<br>Otherwise, `ready` will be emitted immediately right after the `connect` event.\nerror    | emits when an error occurs while connecting.<br>However, ioredis emits all `error` events silently (only emits when there's at least one listener) so that your application won't crash if you're not listening to the `error` event.\nclose    | emits when an established Redis server connection has closed.\nreconnecting | emits after `close` when a reconnection will be made. The argument of the event is the time (in ms) before reconnecting.\nend     | emits after `close` when no more reconnections will be made, or the connection is failed to establish.\n\nYou can also check out the `Redis#status` property to get the current connection status.\n\nBesides the above connection events, there are several other custom events:\n\nEvent    | Description\n:------------- | :-------------\nselect   | emits when the database changed. The argument is the new db number.\n\n## Offline Queue\nWhen a command can't be processed by Redis (being sent before the `ready` event), by default, it's added to the offline queue and will be\nexecuted when it can be processed. You can disable this feature by setting the `enableOfflineQueue`\noption to `false`:\n\n```javascript\nvar redis = new Redis({ enableOfflineQueue: false });\n```\n\n## TLS Options\nRedis doesn't support TLS natively, however if the redis server you want to connect to is hosted behind a TLS proxy (e.g. [stunnel](https://www.stunnel.org/)) or is offered by a PaaS service that supports TLS connection (e.g. [Redis Labs](https://redislabs.com/)), you can set the `tls` option:\n\n```javascript\nvar redis = new Redis({\n  host: 'localhost',\n  tls: {\n    // Refer to `tls.connect()` section in\n    // https://nodejs.org/api/tls.html\n    // for all supported options\n    ca: fs.readFileSync('cert.pem')\n  }\n});\n```\n\n<hr>\n\n## Sentinel\nioredis supports Sentinel out of the box. It works transparently as all features that work when\nyou connect to a single node also work when you connect to a sentinel group. Make sure to run Redis >= 2.8.12 if you want to use this feature. Sentinels have a default port of 26379.\n\nTo connect using Sentinel, use:\n\n```javascript\nvar redis = new Redis({\n  sentinels: [{ host: 'localhost', port: 26379 }, { host: 'localhost', port: 26380 }],\n  name: 'mymaster'\n});\n\nredis.set('foo', 'bar');\n```\n\nThe arguments passed to the constructor are different from the ones you use to connect to a single node, where:\n\n* `name` identifies a group of Redis instances composed of a master and one or more slaves (`mymaster` in the example);\n* `sentinels` are a list of sentinels to connect to. The list does not need to enumerate all your sentinel instances, but a few so that if one is down the client will try the next one.\n* `role` (optional) with a value of `slave` will return a random slave from the Sentinel group.\n* `preferredSlaves` (optional) can be used to prefer a particular slave or set of slaves based on priority. It accepts a function or array.\n\nioredis **guarantees** that the node you connected to is always a master even after a failover. When a failover happens, instead of trying to reconnect to the failed node (which will be demoted to slave when it's available again), ioredis will ask sentinels for the new master node and connect to it. All commands sent during the failover are queued and will be executed when the new connection is established so that none of the commands will be lost.\n\nIt's possible to connect to a slave instead of a master by specifying the option `role` with the value of `slave` and ioredis will try to connect to a random slave of the specified master, with the guarantee that the connected node is always a slave. If the current node is promoted to master due to a failover, ioredis will disconnect from it and ask the sentinels for another slave node to connect to.\n\nIf you specify the option `preferredSlaves` along with `role: 'slave'` ioredis will attempt to use this value when selecting the slave from the pool of available slaves. The value of `preferredSlaves` should either be a function that accepts an array of avaiable slaves and returns a single result, or an array of slave values priorities by the lowest `prio` value first with a default value of `1`.\n\n```javascript\n// available slaves format\nvar availableSlaves = [{ ip: '127.0.0.1', port: '31231', flags: 'slave' }];\n\n// preferredSlaves array format\nvar preferredSlaves = [\n  { ip: '127.0.0.1', port: '31231', prio: 1 },\n  { ip: '127.0.0.1', port: '31232', prio: 2 }\n];\n\n// preferredSlaves function format\npreferredSlaves = function(availableSlaves) {\n  for (var i = 0; i < availableSlaves.length; i++) {\n    var slave = availableSlaves[i];\n    if (slave.ip === '127.0.0.1') {\n      if (slave.port === '31234') {\n        return slave;\n      }\n    }\n  }\n  // if no preferred slaves are available a random one is used\n  return false;\n};\n\nvar redis = new Redis({\n  sentinels: [{ host: '127.0.0.1', port: 26379 }, { host: '127.0.0.1', port: 26380 }],\n  name: 'mymaster',\n  role: 'slave',\n  preferredSlaves: preferredSlaves\n});\n```\n\nBesides the `retryStrategy` option, there's also a `sentinelRetryStrategy` in Sentinel mode which will be invoked when all the sentinel nodes are unreachable during connecting. If `sentinelRetryStrategy` returns a valid delay time, ioredis will try to reconnect from scratch. The default value of `sentinelRetryStrategy` is:\n\n```javascript\nfunction (times) {\n  var delay = Math.min(times * 10, 1000);\n  return delay;\n}\n```\n\n## Cluster\nRedis Cluster provides a way to run a Redis installation where data is automatically sharded across multiple Redis nodes.\nYou can connect to a Redis Cluster like this:\n\n```javascript\nvar Redis = require('ioredis');\n\nvar cluster = new Redis.Cluster([{\n  port: 6380,\n  host: '127.0.0.1'\n}, {\n  port: 6381,\n  host: '127.0.0.1'\n}]);\n\ncluster.set('foo', 'bar');\ncluster.get('foo', function (err, res) {\n  // res === 'bar'\n});\n```\n\n`Cluster` constructor accepts two arguments, where:\n\n0. The first argument is a list of nodes of the cluster you want to connect to.\nJust like Sentinel, the list does not need to enumerate all your cluster nodes,\nbut a few so that if one is unreachable the client will try the next one, and the client will discover other nodes automatically when at least one node is connected.\n0. The second argument is the options, where:\n\n    * `clusterRetryStrategy`: When none of the startup nodes are reachable, `clusterRetryStrategy` will be invoked. When a number is returned,\n    ioredis will try to reconnect to the startup nodes from scratch after the specified delay (in ms). Otherwise, an error of \"None of startup nodes is available\" will be returned.\n    The default value of this option is:\n\n        ```javascript\n        function (times) {\n          var delay = Math.min(100 + times * 2, 2000);\n          return delay;\n        }\n        ```\n\n        It's possible to modify the `startupNodes` property in order to switch to another set of nodes here:\n\n        ```javascript\n        function (times) {\n          this.startupNodes = [{ port: 6790, host: '127.0.0.1' }];\n          return Math.min(100 + times * 2, 2000);\n        }\n        ```\n\n    * `enableOfflineQueue`: Similar to the `enableOfflineQueue` option of `Redis` class.\n    * `enableReadyCheck`: When enabled, \"ready\" event will only be emitted when `CLUSTER INFO` command\n    reporting the cluster is ready for handling commands. Otherwise, it will be emitted immediately after \"connect\" is emitted.\n    * `scaleReads`: Config where to send the read queries. See below for more details.\n    * `maxRedirections`: When a cluster related error (e.g. `MOVED`, `ASK` and `CLUSTERDOWN` etc.) is received, the client will redirect the\n    command to another node. This option limits the max redirections allowed when sending a command. The default value is `16`.\n    * `retryDelayOnFailover`: If the target node is disconnected when sending a command,\n    ioredis will retry after the specified delay. The default value is `100`. You should make sure `retryDelayOnFailover * maxRedirections > cluster-node-timeout`\n    to insure that no command will fail during a failover.\n    * `retryDelayOnClusterDown`: When a cluster is down, all commands will be rejected with the error of `CLUSTERDOWN`. If this option is a number (by default, it is `100`), the client\n    will resend the commands after the specified time (in ms).\n    * `retryDelayOnTryAgain`: If this option is a number (by default, it is `100`), the client\n    will resend the commands rejected with `TRYAGAIN` error after the specified time (in ms).\n    * `redisOptions`: Default options passed to the constructor of `Redis` when connecting to a node.\n    * `slotsRefreshTimeout`: Milliseconds before a timeout occurs while refreshing slots from the cluster (default `1000`)\n    * `slotsRefreshInterval`: Milliseconds between every automatic slots refresh (default `5000`)\n\n### Read-write splitting\n\nA typical redis cluster contains three or more masters and several slaves for each master. It's possible to scale out redis cluster by sending read queries to slaves and write queries to masters by setting the `scaleReads` option.\n\n`scaleReads` is \"master\" by default, which means ioredis will never send any queries to slaves. There are other three available options:\n\n1. \"all\": Send write queries to masters and read queries to masters or slaves randomly.\n2. \"slave\": Send write queries to masters and read queries to slaves.\n3. a custom `function(nodes, command): node`: Will choose the custom function to select to which node to send read queries (write queries keep being sent to master). The first node in `nodes` is always the master serving the relevant slots. If the function returns an array of nodes, a random node of that list will be selected.\n\nFor example:\n\n```javascript\nvar cluster = new Redis.Cluster([/* nodes */], {\n  scaleReads: 'slave'\n});\ncluster.set('foo', 'bar'); // This query will be sent to one of the masters.\ncluster.get('foo', function (err, res) {\n  // This query will be sent to one of the slaves.\n});\n```\n\n**NB** In the code snippet above, the `res` may not be equal to \"bar\" because of the lag of replication between the master and slaves.\n\n### Running commands to multiple nodes\n\nEvery command will be sent to exactly one node. For commands containing keys, (e.g. `GET`, `SET` and `HGETALL`), ioredis sends them to the node that serving the keys, and for other commands not containing keys, (e.g. `INFO`, `KEYS` and `FLUSHDB`), ioredis sends them to a random node.\n\nSometimes you may want to send a command to multiple nodes (masters or slaves) of the cluster, you can get the nodes via `Cluster#nodes()` method.\n\n`Cluster#nodes()` accepts a parameter role, which can be \"master\", \"slave\" and \"all\" (default), and returns an array of `Redis` instance. For example:\n\n```javascript\n// Send `FLUSHDB` command to all slaves:\nvar slaves = cluster.nodes('slave');\nPromise.all(slaves.map(function (node) {\n  return node.flushdb();\n}));\n\n// Get keys of all the masters:\nvar masters = cluster.nodes('master');\nPromise.all(masters.map(function (node) {\n  return node.keys();\n})).then(function (keys) {\n  // keys: [['key1', 'key2'], ['key3', 'key4']]\n});\n```\n\n### NAT Mapping\nSometimes the cluster is hosted within a internal network that can only be accessed via a NAT (Network Address Translation) instance. See [Accessing ElastiCache from outside AWS](https://docs.aws.amazon.com/AmazonElastiCache/latest/red-ug/accessing-elasticache.html) as an example.\n\nYou can specify nat mapping rules via `natMap` option:\n\n```javascript\nconst cluster = new Redis.Cluster([{\n  host: '203.0.113.73',\n  port: 30001\n}], {\n  natMap: {\n    '10.0.1.230:30001': {host: '203.0.113.73', port: 30001},\n    '10.0.1.231:30001': {host: '203.0.113.73', port: 30002},\n    '10.0.1.232:30001': {host: '203.0.113.73', port: 30003}\n  }\n})\n```\n\nThis option is also useful when the cluster is running inside a Docker container.\n\n### Transaction and pipeline in Cluster mode\nAlmost all features that are supported by `Redis` are also supported by `Redis.Cluster`, e.g. custom commands, transaction and pipeline.\nHowever there are some differences when using transaction and pipeline in Cluster mode:\n\n0. All keys in a pipeline should belong to the same slot since ioredis sends all commands in a pipeline to the same node.\n0. You can't use `multi` without pipeline (aka `cluster.multi({ pipeline: false })`). This is because when you call `cluster.multi({ pipeline: false })`, ioredis doesn't know which node the `multi` command should be sent to.\n0. Chaining custom commands in the pipeline is not supported in Cluster mode.\n\nWhen any commands in a pipeline receives a `MOVED` or `ASK` error, ioredis will resend the whole pipeline to the specified node automatically if all of the following conditions are satisfied:\n\n0. All errors received in the pipeline are the same. For example, we won't resend the pipeline if we got two `MOVED` errors pointing to different nodes.\n0. All commands executed successfully are readonly commands. This makes sure that resending the pipeline won't have side effects.\n\n### Pub/Sub\nPub/Sub in cluster mode works exactly as the same as in standalone mode. Internally, when a node of the cluster receives a message, it will broadcast the message to the other nodes. ioredis makes sure that each message will only be received once by strictly subscribing one node at the same time.\n\n```javascript\nvar nodes = [/* nodes */];\nvar pub = new Redis.Cluster(nodes);\nvar sub = new Redis.Cluster(nodes);\nsub.on('message', function (channel, message) {\n  console.log(channel, message);\n});\n\nsub.subscribe('news', function () {\n  pub.publish('news', 'highlights');\n});\n```\n\n### Events\n\nEvent    | Description\n:------------- | :-------------\nconnect  | emits when a connection is established to the Redis server.\nready    | emits when `CLUSTER INFO` reporting the cluster is able to receive commands (if `enableReadyCheck` is `true`) or immediately after `connect` event (if `enableReadyCheck` is false).\nerror    | emits when an error occurs while connecting with a property of `lastNodeError` representing the last node error received. This event is emitted silently (only emitting if there's at least one listener).\nclose    | emits when an established Redis server connection has closed.\nreconnecting | emits after `close` when a reconnection will be made. The argument of the event is the time (in ms) before reconnecting.\nend     | emits after `close` when no more reconnections will be made.\n+node   | emits when a new node is connected.\n-node   | emits when a node is disconnected.\nnode error | emits when an error occurs when connecting to a node. The second argument indicates the address of the node.\n\n### Password\nSetting the `password` option to access password-protected clusters:\n\n```javascript\nvar Redis = require('ioredis');\nvar cluster = new Redis.Cluster(nodes, {\n  redisOptions: {\n    password: 'your-cluster-password'\n  }\n});\n```\n\nIf some of nodes in the cluster using a different password, you should specify them in the first parameter:\n\n```javascript\nvar Redis = require('ioredis');\nvar cluster = new Redis.Cluster([\n  // Use password \"password-for-30001\" for 30001\n  { port: 30001, password: 'password-for-30001'},\n  // Don't use password when accessing 30002\n  { port: 30002, password: null }\n  // Other nodes will use \"fallback-password\"\n], {\n  redisOptions: {\n    password: 'fallback-password'\n  }\n});\n```\n\n<hr>\n\n# Error Handling\nAll the errors returned by the Redis server are instances of `ReplyError`, which can be accessed via `Redis`:\n\n```javascript\nvar Redis = require('ioredis');\nvar redis = new Redis();\n// This command causes a reply error since the SET command requires two arguments.\nredis.set('foo', function (err) {\n  err instanceof Redis.ReplyError\n});\n```\n\nThis is the error stack of the `ReplyError`:\n\n```\nReplyError: ERR wrong number of arguments for 'set' command\n    at ReplyParser._parseResult (/app/node_modules/ioredis/lib/parsers/javascript.js:60:14)\n    at ReplyParser.execute (/app/node_modules/ioredis/lib/parsers/javascript.js:178:20)\n    at Socket.<anonymous> (/app/node_modules/ioredis/lib/redis/event_handler.js:99:22)\n    at Socket.emit (events.js:97:17)\n    at readableAddChunk (_stream_readable.js:143:16)\n    at Socket.Readable.push (_stream_readable.js:106:10)\n    at TCP.onread (net.js:509:20)\n```\n\nBy default, the error stack doesn't make any sense because the whole stack happens in the ioredis\nmodule itself, not in your code. So it's not easy to find out where the error happens in your code.\nioredis provides an option `showFriendlyErrorStack` to solve the problem. When you enable\n`showFriendlyErrorStack`, ioredis will optimize the error stack for you:\n\n```javascript\nvar Redis = require('ioredis');\nvar redis = new Redis({ showFriendlyErrorStack: true });\nredis.set('foo');\n```\n\nAnd the output will be:\n\n```\nReplyError: ERR wrong number of arguments for 'set' command\n    at Object.<anonymous> (/app/index.js:3:7)\n    at Module._compile (module.js:446:26)\n    at Object.Module._extensions..js (module.js:464:10)\n    at Module.load (module.js:341:32)\n    at Function.Module._load (module.js:296:12)\n    at Function.Module.runMain (module.js:487:10)\n    at startup (node.js:111:16)\n    at node.js:799:3\n```\n\nThis time the stack tells you that the error happens on the third line in your code. Pretty sweet!\nHowever, it would decrease the performance significantly to optimize the error stack. So by\ndefault, this option is disabled and can only be used for debugging purposes. You **shouldn't** use this feature in a production environment.\n\n# Plugging in your own Promises Library\nIf you're an advanced user, you may want to plug in your own promise library like [bluebird](https://www.npmjs.com/package/bluebird). Just set Redis.Promise to your favorite ES6-style promise constructor and ioredis will use it.\n\n```javascript\nconst Redis = require('ioredis')\nRedis.Promise = require('bluebird')\n\nconst redis = new Redis()\n\n// Use bluebird\nassert.equal(redis.get().constructor, require('bluebird'))\n\n// You can change the Promise implementation at any time:\nRedis.Promise = global.Promise\nassert.equal(redis.get().constructor, global.Promise)\n```\n\n\n# Running tests\n\nStart a Redis server on 127.0.0.1:6379, and then:\n\n```shell\n$ npm test\n```\n\n`FLUSH ALL` will be invoked after each test, so make sure there's no valuable data in it before running tests.\n\nIf your testing environment does not let you spin up a Redis server [ioredis-mock](https://github.com/stipsan/ioredis-mock) is a drop-in replacement you can use in your tests. It aims to behave identically to ioredis connected to a Redis server so that your integration tests is easier to write and of better quality.\n\n# Debug\n\nYou can set the `DEBUG` env to `ioredis:*` to print debug info:\n\n```shell\n$ DEBUG=ioredis:* node app.js\n```\n\n# Consolidation: It's time for celebration\n\nRight now there are two great redis clients around and both have some advantages above each other. We speak about [node_redis](https://github.com/NodeRedis/node_redis) and ioredis. So after talking to each other about how we could improve in working together we (that is [@BridgeAR](https://github.com/BridgeAR) and [@luin](https://github.com/luin)) decided to work towards a single library on the long run. But step by step.\n\nFirst of all, we want to split small parts of our libraries into others so that we're both able to use the same code. Those libraries are going to be maintained under the NodeRedis organization. This is going to reduce the maintance overhead, allows others to use the very same code, if they need it and it's way easier for others to contribute to both libraries.\n\nWe're very happy about this step towards working together as we both want to give you the best redis experience possible.\n\nIf you want to join our cause by help maintaining something, please don't hesitate to contact either one of us.\n\n# Join in!\n\nI'm happy to receive bug reports, fixes, documentation enhancements, and any other improvements.\n\nAnd since I'm not a native English speaker, if you find any grammar mistakes in the documentation, please also let me know. :)\n\n# Contributors\n\nThis project exists thanks to all the people who contribute:\n\n<a href=\"https://github.com/luin/ioredis/graphs/contributors\"><img src=\"https://opencollective.com/ioredis/contributors.svg?width=890&showBtn=false\" /></a>\n\n# License\n\nMIT\n\n\n[![FOSSA Status](https://app.fossa.io/api/projects/git%2Bgithub.com%2Fluin%2Fioredis.svg?type=large)](https://app.fossa.io/projects/git%2Bgithub.com%2Fluin%2Fioredis?ref=badge_large)\n","readmeFilename":"README.md","bugs":{"url":"https://github.com/luin/ioredis/issues"},"homepage":"https://github.com/luin/ioredis#readme","_id":"ioredis@4.6.3","_npmVersion":"6.4.1","_nodeVersion":"10.15.1","_npmUser":{"name":"ioredis-robot","email":"ioredis-robot@zihua.li"},"dist":{"integrity":"sha512-pQs2h1IcgtwKPqQGZvpoyUgAiU1vUDs5sNYCbdxZuZA3O0xtF6WZC0xsoF5l11BGd7ldRY91GwZnG+CRMKS25A==","shasum":"944f10883193da8610ed643a0a40b3485956c59e","tarball":"https://registry.npmjs.org/ioredis/-/ioredis-4.6.3.tgz","fileCount":35,"unpackedSize":219534,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJcVoHZCRA9TVsSAnZWagAAUcYP/ijyQ/ssKBwO0zasZlMb\neK+HouiVEjLYrscb4SRu/asGeIJHpTz98kaRpGEXp5I8BJKOZJHQngA/Kf15\ni+jOtminh/pGBQdbNZyxUH6NeVwXVYMRAbCuXqUMdqivp/o6o8JufiZ5EGU/\nl0I7jp5xmy/GM8LpJaHv1Kbv5ugcj+tc41Foa1+3hoI1m2kiESIgWxS64ZAe\ncgyZMC51AsWtbze7zLQm6kVr9AGpPBZQqDxhb45GmdGEh8SP8sKHkaMzsSZZ\nGK9TCnWyFly5tS8ZXR8nErD05LpuZluLPjxK0SogzSzr4pKlKeEngRRhEg4n\nru3kY3cvdCwYiXKJTstzE3ABiNzOkH6uA2ghcqhkrh1id4hrlhtYj0v04Ao/\nb9Dcpn+X0N7nX0igut8a9NnTRCeLmhEmPIVEObsWqu71Nnp8fU7t5IDzdyhC\nneF+3Dr0s2i/O2Jx3o+JX7P7I2f4Uh6qYMnVsz8ZGYaDcnYfBN8xiikVzQOM\nb4y1cpsCnr2T8dTSGxdFeItLXbY0kS22LTaHF4TwwmtHmO/u2xsVSYiuo8Zc\nFJ14BZpJMeaMiBFPx1b4Tt4FXBr5hhRixL00r4qg6o4iPsz2X9ufVv778eb9\n7pa5r5VEf1eLNTbbr+KDYAAm24u8rHml7HQiw0EayRMDpvcIgOnXkUCDez0N\nuilV\r\n=fkhb\r\n-----END PGP SIGNATURE-----\r\n"},"maintainers":[{"email":"ioredis-robot@zihua.li","name":"ioredis-robot"},{"email":"i@zihua.li","name":"luin"}],"directories":{},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/ioredis_4.6.3_1549173208647_0.1825002963396476"},"_hasShrinkwrap":false},"4.7.0":{"name":"ioredis","version":"4.7.0","description":"A robust, performance-focused and full-featured Redis client for Node.js.","main":"built/index.js","scripts":{"test":"NODE_ENV=test mocha --timeout 8000 -r ts-node/register --exit","test:cov":"NODE_ENV=test node ./node_modules/istanbul/lib/cli.js cover --preserve-comments ./node_modules/mocha/bin/_mocha -- -r ts-node/register -R spec --exit","build":"rm -rf built && tsc","generate-docs":"jsdoc2md lib/redis.js lib/cluster/index.js lib/commander.js > API.md","prepublishOnly":"npm run build && npm test","bench":"matcha benchmarks/*.js","semantic-release":"semantic-release"},"repository":{"type":"git","url":"git://github.com/luin/ioredis.git"},"keywords":["redis","cluster","sentinel","pipelining"],"author":{"name":"luin","email":"i@zihua.li","url":"http://zihua.li"},"license":"MIT","dependencies":{"cluster-key-slot":"^1.0.6","debug":"^3.1.0","denque":"^1.1.0","flexbuffer":"0.0.6","lodash.defaults":"^4.2.0","lodash.flatten":"^4.4.0","redis-commands":"1.4.0","redis-errors":"^1.2.0","redis-parser":"^3.0.0","standard-as-callback":"^2.0.1"},"devDependencies":{"@semantic-release/changelog":"^3.0.0","@semantic-release/git":"^7.0.4","@types/node":"^10.11.5","@types/redis-errors":"1.2.0","bluebird":"^3.5.1","chai":"^3.5.0","cz-conventional-changelog":"^2.0.0","istanbul":"^0.4.2","jsdoc":"^3.4.0","jsdoc-to-markdown":"^4.0.1","mocha":"^5.2.0","server-destroy":"^1.0.1","sinon":"^1.17.3","ts-node":"^7.0.0","typescript":"^3.1.1"},"engines":{"node":">=6"},"config":{"commitizen":{"path":"./node_modules/cz-conventional-changelog"}},"gitHead":"6246b52e15125e76ffa7694099767ce371e94b29","readme":"[![ioredis](https://cdn.rawgit.com/luin/ioredis/57b5b89e3e9111ff25d8c62c0bc58ed42e5b8d1e/logo.svg)](https://github.com/luin/ioredis)\n\n[![Build Status](https://travis-ci.org/luin/ioredis.svg?branch=master)](https://travis-ci.org/luin/ioredis)\n[![Test Coverage](https://codeclimate.com/github/luin/ioredis/badges/coverage.svg)](https://codeclimate.com/github/luin/ioredis)\n[![Join the chat at https://gitter.im/luin/ioredis](https://badges.gitter.im/Join%20Chat.svg)](https://gitter.im/luin/ioredis?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge)\n[![Commitizen friendly](https://img.shields.io/badge/commitizen-friendly-brightgreen.svg)](http://commitizen.github.io/cz-cli/)\n[![semantic-release](https://img.shields.io/badge/%20%20%F0%9F%93%A6%F0%9F%9A%80-semantic--release-e10079.svg)](https://github.com/semantic-release/semantic-release)\n[![npm latest version](https://img.shields.io/npm/v/ioredis/latest.svg)](https://www.npmjs.com/package/ioredis)\n[![npm next version](https://img.shields.io/npm/v/ioredis/next.svg)](https://www.npmjs.com/package/ioredis)\n<img alt=\"\" src=\"\">\n\nA robust, performance-focused and full-featured [Redis](http://redis.io) client for [Node.js](https://nodejs.org).\n\nSupports Redis >= 2.6.12 and (Node.js >= 6).\n\n# Features\nioredis is a robust, full-featured Redis client that is\nused in the world's biggest online commerce company [Alibaba](http://www.alibaba.com/) and many other awesome companies.\n\n0. Full-featured. It supports [Cluster](http://redis.io/topics/cluster-tutorial), [Sentinel](http://redis.io/topics/sentinel), [Pipelining](http://redis.io/topics/pipelining) and of course [Lua scripting](http://redis.io/commands/eval) & [Pub/Sub](http://redis.io/topics/pubsub) (with the support of binary messages).\n0. High performance.\n0. Delightful API. It works with Node callbacks and Native promises.\n0. Transformation of command arguments and replies.\n0. Transparent key prefixing.\n0. Abstraction for Lua scripting, allowing you to define custom commands.\n0. Support for binary data.\n0. Support for TLS.\n0. Support for offline queue and ready checking.\n0. Support for ES6 types, such as `Map` and `Set`.\n0. Support for GEO commands (Redis 3.2 Unstable).\n0. Sophisticated error handling strategy.\n0. Support for NAT mapping.\n\n# Links\n* [API Documentation](API.md)\n* [Changelog](Changelog.md)\n* [Migrating from node_redis](https://github.com/luin/ioredis/wiki/Migrating-from-node_redis)\n* [Error Handling](#error-handling)\n\n## Become a Sponsor to Support ioredis's Development\nOpen source is hard and time-consuming. If you want to invest in ioredis's future you can become a sponsor and make us spend more time on this library's improvements and new features.\n\n<a href=\"https://opencollective.com/ioredis\"><img src=\"https://opencollective.com/ioredis/tiers/sponsor.svg?avatarHeight=36\"></a>\n\nThank you for using ioredis :-)\n\n<hr>\n<a href=\"https://itunes.apple.com/app/medis-gui-for-redis/id1063631769\"><img align=\"right\" src=\"medis.png\" alt=\"Download on the App Store\"></a>\n\n\n### Advertisement\n\nLooking for a Redis GUI manager for OS X, Windows and Linux? Here's [Medis](https://itunes.apple.com/us/app/medis-gui-for-redis/id1063631769)!\n\nMedis is an open-sourced, beautiful, easy-to-use Redis GUI management application.\n\nMedis starts with all the basic features you need:\n\n* Keys viewing/editing\n* SSH Tunnel for connecting with remote servers\n* Terminal for executing custom commands\n* JSON/MessagePack format viewing/editing and built-in highlighting/validator\n* And other awesome features...\n\n[Medis is open sourced on GitHub](https://github.com/luin/medis)\n\n<hr>\n\n# Quick Start\n\n## Install\n```shell\n$ npm install ioredis\n```\n\n## Basic Usage\n\n```javascript\nvar Redis = require('ioredis');\nvar redis = new Redis();\n\nredis.set('foo', 'bar');\nredis.get('foo', function (err, result) {\n  console.log(result);\n});\n\n// Or using a promise if the last argument isn't a function\nredis.get('foo').then(function (result) {\n  console.log(result);\n});\n\n// Arguments to commands are flattened, so the following are the same:\nredis.sadd('set', 1, 3, 5, 7);\nredis.sadd('set', [1, 3, 5, 7]);\n\n// All arguments are passed directly to the redis server:\nredis.set('key', 100, 'EX', 10);\n```\n\nSee the `examples/` folder for more examples.\n\n## Connect to Redis\nWhen a new `Redis` instance is created,\na connection to Redis will be created at the same time.\nYou can specify which Redis to connect to by:\n\n```javascript\nnew Redis()       // Connect to 127.0.0.1:6379\nnew Redis(6380)   // 127.0.0.1:6380\nnew Redis(6379, '192.168.1.1')        // 192.168.1.1:6379\nnew Redis('/tmp/redis.sock')\nnew Redis({\n  port: 6379,          // Redis port\n  host: '127.0.0.1',   // Redis host\n  family: 4,           // 4 (IPv4) or 6 (IPv6)\n  password: 'auth',\n  db: 0\n})\n```\n\nYou can also specify connection options as a [`redis://` URL](http://www.iana.org/assignments/uri-schemes/prov/redis):\n\n```javascript\n// Connect to 127.0.0.1:6380, db 4, using password \"authpassword\":\nnew Redis('redis://:authpassword@127.0.0.1:6380/4')\n```\n\nSee [API Documentation](API.md#new_Redis) for all available options.\n\n## Pub/Sub\n\nHere is a simple example of the API for publish/subscribe.\nThe following program opens two client connections.\nIt subscribes to a channel with one connection\nand publishes to that channel with the other:\n\n```javascript\nvar Redis = require('ioredis');\nvar redis = new Redis();\nvar pub = new Redis();\nredis.subscribe('news', 'music', function (err, count) {\n  // Now we are subscribed to both the 'news' and 'music' channels.\n  // `count` represents the number of channels we are currently subscribed to.\n\n  pub.publish('news', 'Hello world!');\n  pub.publish('music', 'Hello again!');\n});\n\nredis.on('message', function (channel, message) {\n  // Receive message Hello world! from channel news\n  // Receive message Hello again! from channel music\n  console.log('Receive message %s from channel %s', message, channel);\n});\n\n// There's also an event called 'messageBuffer', which is the same as 'message' except\n// it returns buffers instead of strings.\nredis.on('messageBuffer', function (channel, message) {\n  // Both `channel` and `message` are buffers.\n});\n```\n\n`PSUBSCRIBE` is also supported in a similar way:\n\n```javascript\nredis.psubscribe('pat?ern', function (err, count) {});\nredis.on('pmessage', function (pattern, channel, message) {});\nredis.on('pmessageBuffer', function (pattern, channel, message) {});\n```\n\nWhen a client issues a SUBSCRIBE or PSUBSCRIBE, that connection is put into a \"subscriber\" mode.\nAt that point, only commands that modify the subscription set are valid.\nWhen the subscription set is empty, the connection is put back into regular mode.\n\nIf you need to send regular commands to Redis while in subscriber mode, just open another connection.\n\n## Handle Binary Data\nArguments can be buffers:\n```javascript\nredis.set('foo', Buffer.from('bar'));\n```\n\nAnd every command has a method that returns a Buffer (by adding a suffix of \"Buffer\" to the command name).\nTo get a buffer instead of a utf8 string:\n\n```javascript\nredis.getBuffer('foo', function (err, result) {\n  // result is a buffer.\n});\n```\n\n## Pipelining\nIf you want to send a batch of commands (e.g. > 5), you can use pipelining to queue\nthe commands in memory and then send them to Redis all at once. This way the performance improves by 50%~300% (See [benchmark section](#benchmark)).\n\n`redis.pipeline()` creates a `Pipeline` instance. You can call any Redis\ncommands on it just like the `Redis` instance. The commands are queued in memory\nand flushed to Redis by calling the `exec` method:\n\n```javascript\nvar pipeline = redis.pipeline();\npipeline.set('foo', 'bar');\npipeline.del('cc');\npipeline.exec(function (err, results) {\n  // `err` is always null, and `results` is an array of responses\n  // corresponding to the sequence of queued commands.\n  // Each response follows the format `[err, result]`.\n});\n\n// You can even chain the commands:\nredis.pipeline().set('foo', 'bar').del('cc').exec(function (err, results) {\n});\n\n// `exec` also returns a Promise:\nvar promise = redis.pipeline().set('foo', 'bar').get('foo').exec();\npromise.then(function (result) {\n  // result === [[null, 'OK'], [null, 'bar']]\n});\n```\n\nEach chained command can also have a callback, which will be invoked when the command\ngets a reply:\n\n```javascript\nredis.pipeline().set('foo', 'bar').get('foo', function (err, result) {\n  // result === 'bar'\n}).exec(function (err, result) {\n  // result[1][1] === 'bar'\n});\n```\n\nIn addition to adding commands to the `pipeline` queue individually, you can also pass an array of commands and arguments to the constructor:\n\n```javascript\nredis.pipeline([\n  ['set', 'foo', 'bar'],\n  ['get', 'foo']\n]).exec(function () { /* ... */ });\n```\n\n`#length` property shows how many commands in the pipeline:\n\n```javascript\nconst length = redis.pipeline().set('foo', 'bar').get('foo').length;\n// length === 2\n```\n\n\n## Transaction\nMost of the time, the transaction commands `multi` & `exec` are used together with pipeline.\nTherefore, when `multi` is called, a `Pipeline` instance is created automatically by default,\nso you can use `multi` just like `pipeline`:\n\n```javascript\nredis.multi().set('foo', 'bar').get('foo').exec(function (err, results) {\n  // results === [[null, 'OK'], [null, 'bar']]\n});\n```\nIf there's a syntax error in the transaction's command chain (e.g. wrong number of arguments, wrong command name, etc),\nthen none of the commands would be executed, and an error is returned:\n\n```javascript\nredis.multi().set('foo').set('foo', 'new value').exec(function (err, results) {\n  // err:\n  //  { [ReplyError: EXECABORT Transaction discarded because of previous errors.]\n  //    name: 'ReplyError',\n  //    message: 'EXECABORT Transaction discarded because of previous errors.',\n  //    command: { name: 'exec', args: [] },\n  //    previousErrors:\n  //     [ { [ReplyError: ERR wrong number of arguments for 'set' command]\n  //         name: 'ReplyError',\n  //         message: 'ERR wrong number of arguments for \\'set\\' command',\n  //         command: [Object] } ] }\n});\n```\n\nIn terms of the interface, `multi` differs from `pipeline` in that when specifying a callback\nto each chained command, the queueing state is passed to the callback instead of the result of the command:\n\n```javascript\nredis.multi().set('foo', 'bar', function (err, result) {\n  // result === 'QUEUED'\n}).exec(/* ... */);\n```\n\nIf you want to use transaction without pipeline, pass `{ pipeline: false }` to `multi`,\nand every command will be sent to Redis immediately without waiting for an `exec` invocation:\n\n```javascript\nredis.multi({ pipeline: false });\nredis.set('foo', 'bar');\nredis.get('foo');\nredis.exec(function (err, result) {\n  // result === [[null, 'OK'], [null, 'bar']]\n});\n```\n\nThe constructor of `multi` also accepts a batch of commands:\n\n```javascript\nredis.multi([\n  ['set', 'foo', 'bar'],\n  ['get', 'foo']\n]).exec(function () { /* ... */ });\n```\n\nInline transactions are supported by pipeline, which means you can group a subset of commands\nin the pipeline into a transaction:\n\n```javascript\nredis.pipeline().get('foo').multi().set('foo', 'bar').get('foo').exec().get('foo').exec();\n```\n\n## Lua Scripting\nioredis supports all of the scripting commands such as `EVAL`, `EVALSHA` and `SCRIPT`.\nHowever, it's tedious to use in real world scenarios since developers have to take\ncare of script caching and to detect when to use `EVAL` and when to use `EVALSHA`.\nioredis expose a `defineCommand` method to make scripting much easier to use:\n\n```javascript\nvar redis = new Redis();\n\n// This will define a command echo:\nredis.defineCommand('echo', {\n  numberOfKeys: 2,\n  lua: 'return {KEYS[1],KEYS[2],ARGV[1],ARGV[2]}'\n});\n\n// Now `echo` can be used just like any other ordinary command,\n// and ioredis will try to use `EVALSHA` internally when possible for better performance.\nredis.echo('k1', 'k2', 'a1', 'a2', function (err, result) {\n  // result === ['k1', 'k2', 'a1', 'a2']\n});\n\n// `echoBuffer` is also defined automatically to return buffers instead of strings:\nredis.echoBuffer('k1', 'k2', 'a1', 'a2', function (err, result) {\n  // result[0] equals to Buffer.from('k1');\n});\n\n// And of course it works with pipeline:\nredis.pipeline().set('foo', 'bar').echo('k1', 'k2', 'a1', 'a2').exec();\n```\n\nIf the number of keys can't be determined when defining a command, you can\nomit the `numberOfKeys` property and pass the number of keys as the first argument\nwhen you call the command:\n\n```javascript\nredis.defineCommand('echoDynamicKeyNumber', {\n  lua: 'return {KEYS[1],KEYS[2],ARGV[1],ARGV[2]}'\n});\n\n// Now you have to pass the number of keys as the first argument every time\n// you invoke the `echoDynamicKeyNumber` command:\nredis.echoDynamicKeyNumber(2, 'k1', 'k2', 'a1', 'a2', function (err, result) {\n  // result === ['k1', 'k2', 'a1', 'a2']\n});\n```\n\n## Transparent Key Prefixing\nThis feature allows you to specify a string that will automatically be prepended\nto all the keys in a command, which makes it easier to manage your key\nnamespaces.\n\n**Warning** This feature won't apply to commands like [KEYS](http://redis.io/commands/KEYS) and [SCAN](http://redis.io/commands/scan) that take patterns rather than actual keys([#239](https://github.com/luin/ioredis/issues/239)),\nand this feature also won't apply to the replies of commands even they are key names ([#325](https://github.com/luin/ioredis/issues/325)).\n\n```javascript\nvar fooRedis = new Redis({ keyPrefix: 'foo:' });\nfooRedis.set('bar', 'baz');  // Actually sends SET foo:bar baz\n\nfooRedis.defineCommand('echo', {\n  numberOfKeys: 2,\n  lua: 'return {KEYS[1],KEYS[2],ARGV[1],ARGV[2]}'\n});\n\n// Works well with pipelining/transaction\nfooRedis.pipeline()\n  // Sends SORT foo:list BY foo:weight_*->fieldname\n  .sort('list', 'BY', 'weight_*->fieldname')\n  // Supports custom commands\n  // Sends EVALSHA xxx foo:k1 foo:k2 a1 a2\n  .echo('k1', 'k2', 'a1', 'a2')\n  .exec()\n```\n\n## Transforming Arguments & Replies\nMost Redis commands take one or more Strings as arguments,\nand replies are sent back as a single String or an Array of Strings. However, sometimes\nyou may want something different. For instance, it would be more convenient if the `HGETALL`\ncommand returns a hash (e.g. `{ key: val1, key2: v2 }`) rather than an array of key values (e.g. `[key1, val1, key2, val2]`).\n\nioredis has a flexible system for transforming arguments and replies. There are two types\nof transformers, argument transformer and reply transformer:\n\n```javascript\nvar Redis = require('ioredis');\n\n// Here's the built-in argument transformer converting\n// hmset('key', { k1: 'v1', k2: 'v2' })\n// or\n// hmset('key', new Map([['k1', 'v1'], ['k2', 'v2']]))\n// into\n// hmset('key', 'k1', 'v1', 'k2', 'v2')\nRedis.Command.setArgumentTransformer('hmset', function (args) {\n  if (args.length === 2) {\n    if (typeof Map !== 'undefined' && args[1] instanceof Map) {\n      // utils is a internal module of ioredis\n      return [args[0]].concat(utils.convertMapToArray(args[1]));\n    }\n    if ( typeof args[1] === 'object' && args[1] !== null) {\n      return [args[0]].concat(utils.convertObjectToArray(args[1]));\n    }\n  }\n  return args;\n});\n\n// Here's the built-in reply transformer converting the HGETALL reply\n// ['k1', 'v1', 'k2', 'v2']\n// into\n// { k1: 'v1', 'k2': 'v2' }\nRedis.Command.setReplyTransformer('hgetall', function (result) {\n  if (Array.isArray(result)) {\n    var obj = {};\n    for (var i = 0; i < result.length; i += 2) {\n      obj[result[i]] = result[i + 1];\n    }\n    return obj;\n  }\n  return result;\n});\n```\n\nThere are three built-in transformers, two argument transformers for `hmset` & `mset` and\na reply transformer for `hgetall`. Transformers for `hmset` and `hgetall` were mentioned\nabove, and the transformer for `mset` is similar to the one for `hmset`:\n\n```javascript\nredis.mset({ k1: 'v1', k2: 'v2' });\nredis.get('k1', function (err, result) {\n  // result === 'v1';\n});\n\nredis.mset(new Map([['k3', 'v3'], ['k4', 'v4']]));\nredis.get('k3', function (err, result) {\n  // result === 'v3';\n});\n```\n\nAnother useful example of a reply transformer is one that changes `hgetall` to return array of arrays instead of objects which avoids a unwanted conversation of hash keys to strings when dealing with binary hash keys:\n\n```javascript\nRedis.Command.setReplyTransformer('hgetall', function (result) {\n  var arr = [];\n  for (var i = 0; i < result.length; i += 2) {\n    arr.push([result[i], result[i + 1]]);\n  }\n  return arr;\n});\nredis.hset('h1', Buffer.from([0x01]), Buffer.from([0x02]));\nredis.hset('h1', Buffer.from([0x03]), Buffer.from([0x04]));\nredis.hgetallBuffer('h1', function (err, result) {\n  // result === [ [ <Buffer 01>, <Buffer 02> ], [ <Buffer 03>, <Buffer 04> ] ];\n});\n```\n\n## Monitor\nRedis supports the MONITOR command,\nwhich lets you see all commands received by the Redis server across all client connections,\nincluding from other client libraries and other computers.\n\nThe `monitor` method returns a monitor instance.\nAfter you send the MONITOR command, no other commands are valid on that connection. ioredis will emit a monitor event for every new monitor message that comes across.\nThe callback for the monitor event takes a timestamp from the Redis server and an array of command arguments.\n\nHere is a simple example:\n\n```javascript\nredis.monitor(function (err, monitor) {\n  monitor.on('monitor', function (time, args, source, database) {\n  });\n});\n```\n\n## Streamify Scanning\nRedis 2.8 added the `SCAN` command to incrementally iterate through the keys in the database. It's different from `KEYS` in that\n`SCAN` only returns a small number of elements each call, so it can be used in production without the downside\nof blocking the server for a long time. However, it requires recording the cursor on the client side each time\nthe `SCAN` command is called in order to iterate through all the keys correctly. Since it's a relatively common use case, ioredis\nprovides a streaming interface for the `SCAN` command to make things much easier. A readable stream can be created by calling `scanStream`:\n\n```javascript\nvar redis = new Redis();\n// Create a readable stream (object mode)\nvar stream = redis.scanStream();\nstream.on('data', function (resultKeys) {\n  // `resultKeys` is an array of strings representing key names.\n  // Note that resultKeys may contain 0 keys, and that it will sometimes\n  // contain duplicates due to SCAN's implementation in Redis.\n  for (var i = 0; i < resultKeys.length; i++) {\n    console.log(resultKeys[i]);\n  }\n});\nstream.on('end', function () {\n  console.log('all keys have been visited');\n});\n```\n\n`scanStream` accepts an option, with which you can specify the `MATCH` pattern and the `COUNT` argument:\n\n```javascript\nvar stream = redis.scanStream({\n  // only returns keys following the pattern of `user:*`\n  match: 'user:*',\n  // returns approximately 100 elements per call\n  count: 100\n});\n```\n\nJust like other commands, `scanStream` has a binary version `scanBufferStream`, which returns an array of buffers. It's useful when\nthe key names are not utf8 strings.\n\nThere are also `hscanStream`, `zscanStream` and `sscanStream` to iterate through elements in a hash, zset and set. The interface of each is\nsimilar to `scanStream` except the first argument is the key name:\n\n```javascript\nvar stream = redis.hscanStream('myhash', {\n  match: 'age:??'\n});\n```\n\nYou can learn more from the [Redis documentation](http://redis.io/commands/scan).\n\n**Useful Tips**\nIt's pretty common that doing an async task in the `data` handler. We'd like the scanning process to be paused until the async task to be finished. `Stream#pause()` and `Stream.resume()` do the trick. For example if we want to migrate data in Redis to MySQL:\n\n```javascript\nvar stream = redis.scanStream();\nstream.on('data', function (resultKeys) {\n  // Pause the stream from scanning more keys until we've migrated the current keys.\n  stream.pause();\n\n  Promise.all(resultKeys.map(migrateKeyToMySQL)).then(() => {\n    // Resume the stream here.\n    stream.resume();\n  });\n});\n\nstream.on('end', function () {\n  console.log('done migration');\n});\n```\n\n## Auto-reconnect\nBy default, ioredis will try to reconnect when the connection to Redis is lost\nexcept when the connection is closed manually by `redis.disconnect()` or `redis.quit()`.\n\nIt's very flexible to control how long to wait to reconnect after disconnection\nusing the `retryStrategy` option:\n\n```javascript\nvar redis = new Redis({\n  // This is the default value of `retryStrategy`\n  retryStrategy: function (times) {\n    var delay = Math.min(times * 50, 2000);\n    return delay;\n  }\n});\n```\n\n`retryStrategy` is a function that will be called when the connection is lost.\nThe argument `times` means this is the nth reconnection being made and\nthe return value represents how long (in ms) to wait to reconnect. When the\nreturn value isn't a number, ioredis will stop trying to reconnect, and the connection\nwill be lost forever if the user doesn't call `redis.connect()` manually.\n\nWhen reconnected, the client will auto subscribe to channels that the previous connection subscribed to.\nThis behavior can be disabled by setting the `autoResubscribe` option to `false`.\n\nAnd if the previous connection has some unfulfilled commands (most likely blocking commands such as `brpop` and `blpop`),\nthe client will resend them when reconnected. This behavior can be disabled by setting the `autoResendUnfulfilledCommands` option to `false`.\n\nBy default, all pending commands will be flushed with an error every 20 retry attempts. That makes sure commands won't wait forever when the connection is down. You can change this behavior by setting `maxRetriesPerRequest`:\n\n```javascript\nvar redis = new Redis({\n  maxRetriesPerRequest: 1\n});\n```\n\nSet maxRetriesPerRequest to `null` to disable this behavior, and every command will wait forever until the connection is alive again (which is the default behavior before ioredis v4).\n\n### Reconnect on error\n\nBesides auto-reconnect when the connection is closed, ioredis supports reconnecting on the specified errors by the `reconnectOnError` option. Here's an example that will reconnect when receiving `READONLY` error:\n\n```javascript\nvar redis = new Redis({\n  reconnectOnError: function (err) {\n    var targetError = 'READONLY';\n    if (err.message.slice(0, targetError.length) === targetError) {\n      // Only reconnect when the error starts with \"READONLY\"\n      return true; // or `return 1;`\n    }\n  }\n});\n```\n\nThis feature is useful when using Amazon ElastiCache. Once failover happens, Amazon ElastiCache will switch the master we currently connected with to a slave, leading to the following writes fails with the error `READONLY`. Using `reconnectOnError`, we can force the connection to reconnect on this error in order to connect to the new master.\n\nFurthermore, if the `reconnectOnError` returns `2`, ioredis will resend the failed command after reconnecting.\n\n## Connection Events\nThe Redis instance will emit some events about the state of the connection to the Redis server.\n\nEvent    | Description\n:------------- | :-------------\nconnect  | emits when a connection is established to the Redis server.\nready    | If `enableReadyCheck` is `true`, client will emit `ready` when the server reports that it is ready to receive commands (e.g. finish loading data from disk).<br>Otherwise, `ready` will be emitted immediately right after the `connect` event.\nerror    | emits when an error occurs while connecting.<br>However, ioredis emits all `error` events silently (only emits when there's at least one listener) so that your application won't crash if you're not listening to the `error` event.\nclose    | emits when an established Redis server connection has closed.\nreconnecting | emits after `close` when a reconnection will be made. The argument of the event is the time (in ms) before reconnecting.\nend     | emits after `close` when no more reconnections will be made, or the connection is failed to establish.\n\nYou can also check out the `Redis#status` property to get the current connection status.\n\nBesides the above connection events, there are several other custom events:\n\nEvent    | Description\n:------------- | :-------------\nselect   | emits when the database changed. The argument is the new db number.\n\n## Offline Queue\nWhen a command can't be processed by Redis (being sent before the `ready` event), by default, it's added to the offline queue and will be\nexecuted when it can be processed. You can disable this feature by setting the `enableOfflineQueue`\noption to `false`:\n\n```javascript\nvar redis = new Redis({ enableOfflineQueue: false });\n```\n\n## TLS Options\nRedis doesn't support TLS natively, however if the redis server you want to connect to is hosted behind a TLS proxy (e.g. [stunnel](https://www.stunnel.org/)) or is offered by a PaaS service that supports TLS connection (e.g. [Redis Labs](https://redislabs.com/)), you can set the `tls` option:\n\n```javascript\nvar redis = new Redis({\n  host: 'localhost',\n  tls: {\n    // Refer to `tls.connect()` section in\n    // https://nodejs.org/api/tls.html\n    // for all supported options\n    ca: fs.readFileSync('cert.pem')\n  }\n});\n```\n\n<hr>\n\n## Sentinel\nioredis supports Sentinel out of the box. It works transparently as all features that work when\nyou connect to a single node also work when you connect to a sentinel group. Make sure to run Redis >= 2.8.12 if you want to use this feature. Sentinels have a default port of 26379.\n\nTo connect using Sentinel, use:\n\n```javascript\nvar redis = new Redis({\n  sentinels: [{ host: 'localhost', port: 26379 }, { host: 'localhost', port: 26380 }],\n  name: 'mymaster'\n});\n\nredis.set('foo', 'bar');\n```\n\nThe arguments passed to the constructor are different from the ones you use to connect to a single node, where:\n\n* `name` identifies a group of Redis instances composed of a master and one or more slaves (`mymaster` in the example);\n* `sentinels` are a list of sentinels to connect to. The list does not need to enumerate all your sentinel instances, but a few so that if one is down the client will try the next one.\n* `role` (optional) with a value of `slave` will return a random slave from the Sentinel group.\n* `preferredSlaves` (optional) can be used to prefer a particular slave or set of slaves based on priority. It accepts a function or array.\n\nioredis **guarantees** that the node you connected to is always a master even after a failover. When a failover happens, instead of trying to reconnect to the failed node (which will be demoted to slave when it's available again), ioredis will ask sentinels for the new master node and connect to it. All commands sent during the failover are queued and will be executed when the new connection is established so that none of the commands will be lost.\n\nIt's possible to connect to a slave instead of a master by specifying the option `role` with the value of `slave` and ioredis will try to connect to a random slave of the specified master, with the guarantee that the connected node is always a slave. If the current node is promoted to master due to a failover, ioredis will disconnect from it and ask the sentinels for another slave node to connect to.\n\nIf you specify the option `preferredSlaves` along with `role: 'slave'` ioredis will attempt to use this value when selecting the slave from the pool of available slaves. The value of `preferredSlaves` should either be a function that accepts an array of avaiable slaves and returns a single result, or an array of slave values priorities by the lowest `prio` value first with a default value of `1`.\n\n```javascript\n// available slaves format\nvar availableSlaves = [{ ip: '127.0.0.1', port: '31231', flags: 'slave' }];\n\n// preferredSlaves array format\nvar preferredSlaves = [\n  { ip: '127.0.0.1', port: '31231', prio: 1 },\n  { ip: '127.0.0.1', port: '31232', prio: 2 }\n];\n\n// preferredSlaves function format\npreferredSlaves = function(availableSlaves) {\n  for (var i = 0; i < availableSlaves.length; i++) {\n    var slave = availableSlaves[i];\n    if (slave.ip === '127.0.0.1') {\n      if (slave.port === '31234') {\n        return slave;\n      }\n    }\n  }\n  // if no preferred slaves are available a random one is used\n  return false;\n};\n\nvar redis = new Redis({\n  sentinels: [{ host: '127.0.0.1', port: 26379 }, { host: '127.0.0.1', port: 26380 }],\n  name: 'mymaster',\n  role: 'slave',\n  preferredSlaves: preferredSlaves\n});\n```\n\nBesides the `retryStrategy` option, there's also a `sentinelRetryStrategy` in Sentinel mode which will be invoked when all the sentinel nodes are unreachable during connecting. If `sentinelRetryStrategy` returns a valid delay time, ioredis will try to reconnect from scratch. The default value of `sentinelRetryStrategy` is:\n\n```javascript\nfunction (times) {\n  var delay = Math.min(times * 10, 1000);\n  return delay;\n}\n```\n\n## Cluster\nRedis Cluster provides a way to run a Redis installation where data is automatically sharded across multiple Redis nodes.\nYou can connect to a Redis Cluster like this:\n\n```javascript\nvar Redis = require('ioredis');\n\nvar cluster = new Redis.Cluster([{\n  port: 6380,\n  host: '127.0.0.1'\n}, {\n  port: 6381,\n  host: '127.0.0.1'\n}]);\n\ncluster.set('foo', 'bar');\ncluster.get('foo', function (err, res) {\n  // res === 'bar'\n});\n```\n\n`Cluster` constructor accepts two arguments, where:\n\n0. The first argument is a list of nodes of the cluster you want to connect to.\nJust like Sentinel, the list does not need to enumerate all your cluster nodes,\nbut a few so that if one is unreachable the client will try the next one, and the client will discover other nodes automatically when at least one node is connected.\n0. The second argument is the options, where:\n\n    * `clusterRetryStrategy`: When none of the startup nodes are reachable, `clusterRetryStrategy` will be invoked. When a number is returned,\n    ioredis will try to reconnect to the startup nodes from scratch after the specified delay (in ms). Otherwise, an error of \"None of startup nodes is available\" will be returned.\n    The default value of this option is:\n\n        ```javascript\n        function (times) {\n          var delay = Math.min(100 + times * 2, 2000);\n          return delay;\n        }\n        ```\n\n        It's possible to modify the `startupNodes` property in order to switch to another set of nodes here:\n\n        ```javascript\n        function (times) {\n          this.startupNodes = [{ port: 6790, host: '127.0.0.1' }];\n          return Math.min(100 + times * 2, 2000);\n        }\n        ```\n\n    * `enableOfflineQueue`: Similar to the `enableOfflineQueue` option of `Redis` class.\n    * `enableReadyCheck`: When enabled, \"ready\" event will only be emitted when `CLUSTER INFO` command\n    reporting the cluster is ready for handling commands. Otherwise, it will be emitted immediately after \"connect\" is emitted.\n    * `scaleReads`: Config where to send the read queries. See below for more details.\n    * `maxRedirections`: When a cluster related error (e.g. `MOVED`, `ASK` and `CLUSTERDOWN` etc.) is received, the client will redirect the\n    command to another node. This option limits the max redirections allowed when sending a command. The default value is `16`.\n    * `retryDelayOnFailover`: If the target node is disconnected when sending a command,\n    ioredis will retry after the specified delay. The default value is `100`. You should make sure `retryDelayOnFailover * maxRedirections > cluster-node-timeout`\n    to insure that no command will fail during a failover.\n    * `retryDelayOnClusterDown`: When a cluster is down, all commands will be rejected with the error of `CLUSTERDOWN`. If this option is a number (by default, it is `100`), the client\n    will resend the commands after the specified time (in ms).\n    * `retryDelayOnTryAgain`: If this option is a number (by default, it is `100`), the client\n    will resend the commands rejected with `TRYAGAIN` error after the specified time (in ms).\n    * `redisOptions`: Default options passed to the constructor of `Redis` when connecting to a node.\n    * `slotsRefreshTimeout`: Milliseconds before a timeout occurs while refreshing slots from the cluster (default `1000`)\n    * `slotsRefreshInterval`: Milliseconds between every automatic slots refresh (default `5000`)\n\n### Read-write splitting\n\nA typical redis cluster contains three or more masters and several slaves for each master. It's possible to scale out redis cluster by sending read queries to slaves and write queries to masters by setting the `scaleReads` option.\n\n`scaleReads` is \"master\" by default, which means ioredis will never send any queries to slaves. There are other three available options:\n\n1. \"all\": Send write queries to masters and read queries to masters or slaves randomly.\n2. \"slave\": Send write queries to masters and read queries to slaves.\n3. a custom `function(nodes, command): node`: Will choose the custom function to select to which node to send read queries (write queries keep being sent to master). The first node in `nodes` is always the master serving the relevant slots. If the function returns an array of nodes, a random node of that list will be selected.\n\nFor example:\n\n```javascript\nvar cluster = new Redis.Cluster([/* nodes */], {\n  scaleReads: 'slave'\n});\ncluster.set('foo', 'bar'); // This query will be sent to one of the masters.\ncluster.get('foo', function (err, res) {\n  // This query will be sent to one of the slaves.\n});\n```\n\n**NB** In the code snippet above, the `res` may not be equal to \"bar\" because of the lag of replication between the master and slaves.\n\n### Running commands to multiple nodes\n\nEvery command will be sent to exactly one node. For commands containing keys, (e.g. `GET`, `SET` and `HGETALL`), ioredis sends them to the node that serving the keys, and for other commands not containing keys, (e.g. `INFO`, `KEYS` and `FLUSHDB`), ioredis sends them to a random node.\n\nSometimes you may want to send a command to multiple nodes (masters or slaves) of the cluster, you can get the nodes via `Cluster#nodes()` method.\n\n`Cluster#nodes()` accepts a parameter role, which can be \"master\", \"slave\" and \"all\" (default), and returns an array of `Redis` instance. For example:\n\n```javascript\n// Send `FLUSHDB` command to all slaves:\nvar slaves = cluster.nodes('slave');\nPromise.all(slaves.map(function (node) {\n  return node.flushdb();\n}));\n\n// Get keys of all the masters:\nvar masters = cluster.nodes('master');\nPromise.all(masters.map(function (node) {\n  return node.keys();\n})).then(function (keys) {\n  // keys: [['key1', 'key2'], ['key3', 'key4']]\n});\n```\n\n### NAT Mapping\nSometimes the cluster is hosted within a internal network that can only be accessed via a NAT (Network Address Translation) instance. See [Accessing ElastiCache from outside AWS](https://docs.aws.amazon.com/AmazonElastiCache/latest/red-ug/accessing-elasticache.html) as an example.\n\nYou can specify nat mapping rules via `natMap` option:\n\n```javascript\nconst cluster = new Redis.Cluster([{\n  host: '203.0.113.73',\n  port: 30001\n}], {\n  natMap: {\n    '10.0.1.230:30001': {host: '203.0.113.73', port: 30001},\n    '10.0.1.231:30001': {host: '203.0.113.73', port: 30002},\n    '10.0.1.232:30001': {host: '203.0.113.73', port: 30003}\n  }\n})\n```\n\nThis option is also useful when the cluster is running inside a Docker container.\n\n### Transaction and pipeline in Cluster mode\nAlmost all features that are supported by `Redis` are also supported by `Redis.Cluster`, e.g. custom commands, transaction and pipeline.\nHowever there are some differences when using transaction and pipeline in Cluster mode:\n\n0. All keys in a pipeline should belong to the same slot since ioredis sends all commands in a pipeline to the same node.\n0. You can't use `multi` without pipeline (aka `cluster.multi({ pipeline: false })`). This is because when you call `cluster.multi({ pipeline: false })`, ioredis doesn't know which node the `multi` command should be sent to.\n0. Chaining custom commands in the pipeline is not supported in Cluster mode.\n\nWhen any commands in a pipeline receives a `MOVED` or `ASK` error, ioredis will resend the whole pipeline to the specified node automatically if all of the following conditions are satisfied:\n\n0. All errors received in the pipeline are the same. For example, we won't resend the pipeline if we got two `MOVED` errors pointing to different nodes.\n0. All commands executed successfully are readonly commands. This makes sure that resending the pipeline won't have side effects.\n\n### Pub/Sub\nPub/Sub in cluster mode works exactly as the same as in standalone mode. Internally, when a node of the cluster receives a message, it will broadcast the message to the other nodes. ioredis makes sure that each message will only be received once by strictly subscribing one node at the same time.\n\n```javascript\nvar nodes = [/* nodes */];\nvar pub = new Redis.Cluster(nodes);\nvar sub = new Redis.Cluster(nodes);\nsub.on('message', function (channel, message) {\n  console.log(channel, message);\n});\n\nsub.subscribe('news', function () {\n  pub.publish('news', 'highlights');\n});\n```\n\n### Events\n\nEvent    | Description\n:------------- | :-------------\nconnect  | emits when a connection is established to the Redis server.\nready    | emits when `CLUSTER INFO` reporting the cluster is able to receive commands (if `enableReadyCheck` is `true`) or immediately after `connect` event (if `enableReadyCheck` is false).\nerror    | emits when an error occurs while connecting with a property of `lastNodeError` representing the last node error received. This event is emitted silently (only emitting if there's at least one listener).\nclose    | emits when an established Redis server connection has closed.\nreconnecting | emits after `close` when a reconnection will be made. The argument of the event is the time (in ms) before reconnecting.\nend     | emits after `close` when no more reconnections will be made.\n+node   | emits when a new node is connected.\n-node   | emits when a node is disconnected.\nnode error | emits when an error occurs when connecting to a node. The second argument indicates the address of the node.\n\n### Password\nSetting the `password` option to access password-protected clusters:\n\n```javascript\nvar Redis = require('ioredis');\nvar cluster = new Redis.Cluster(nodes, {\n  redisOptions: {\n    password: 'your-cluster-password'\n  }\n});\n```\n\nIf some of nodes in the cluster using a different password, you should specify them in the first parameter:\n\n```javascript\nvar Redis = require('ioredis');\nvar cluster = new Redis.Cluster([\n  // Use password \"password-for-30001\" for 30001\n  { port: 30001, password: 'password-for-30001'},\n  // Don't use password when accessing 30002\n  { port: 30002, password: null }\n  // Other nodes will use \"fallback-password\"\n], {\n  redisOptions: {\n    password: 'fallback-password'\n  }\n});\n```\n\n<hr>\n\n# Error Handling\nAll the errors returned by the Redis server are instances of `ReplyError`, which can be accessed via `Redis`:\n\n```javascript\nvar Redis = require('ioredis');\nvar redis = new Redis();\n// This command causes a reply error since the SET command requires two arguments.\nredis.set('foo', function (err) {\n  err instanceof Redis.ReplyError\n});\n```\n\nThis is the error stack of the `ReplyError`:\n\n```\nReplyError: ERR wrong number of arguments for 'set' command\n    at ReplyParser._parseResult (/app/node_modules/ioredis/lib/parsers/javascript.js:60:14)\n    at ReplyParser.execute (/app/node_modules/ioredis/lib/parsers/javascript.js:178:20)\n    at Socket.<anonymous> (/app/node_modules/ioredis/lib/redis/event_handler.js:99:22)\n    at Socket.emit (events.js:97:17)\n    at readableAddChunk (_stream_readable.js:143:16)\n    at Socket.Readable.push (_stream_readable.js:106:10)\n    at TCP.onread (net.js:509:20)\n```\n\nBy default, the error stack doesn't make any sense because the whole stack happens in the ioredis\nmodule itself, not in your code. So it's not easy to find out where the error happens in your code.\nioredis provides an option `showFriendlyErrorStack` to solve the problem. When you enable\n`showFriendlyErrorStack`, ioredis will optimize the error stack for you:\n\n```javascript\nvar Redis = require('ioredis');\nvar redis = new Redis({ showFriendlyErrorStack: true });\nredis.set('foo');\n```\n\nAnd the output will be:\n\n```\nReplyError: ERR wrong number of arguments for 'set' command\n    at Object.<anonymous> (/app/index.js:3:7)\n    at Module._compile (module.js:446:26)\n    at Object.Module._extensions..js (module.js:464:10)\n    at Module.load (module.js:341:32)\n    at Function.Module._load (module.js:296:12)\n    at Function.Module.runMain (module.js:487:10)\n    at startup (node.js:111:16)\n    at node.js:799:3\n```\n\nThis time the stack tells you that the error happens on the third line in your code. Pretty sweet!\nHowever, it would decrease the performance significantly to optimize the error stack. So by\ndefault, this option is disabled and can only be used for debugging purposes. You **shouldn't** use this feature in a production environment.\n\n# Plugging in your own Promises Library\nIf you're an advanced user, you may want to plug in your own promise library like [bluebird](https://www.npmjs.com/package/bluebird). Just set Redis.Promise to your favorite ES6-style promise constructor and ioredis will use it.\n\n```javascript\nconst Redis = require('ioredis')\nRedis.Promise = require('bluebird')\n\nconst redis = new Redis()\n\n// Use bluebird\nassert.equal(redis.get().constructor, require('bluebird'))\n\n// You can change the Promise implementation at any time:\nRedis.Promise = global.Promise\nassert.equal(redis.get().constructor, global.Promise)\n```\n\n\n# Running tests\n\nStart a Redis server on 127.0.0.1:6379, and then:\n\n```shell\n$ npm test\n```\n\n`FLUSH ALL` will be invoked after each test, so make sure there's no valuable data in it before running tests.\n\nIf your testing environment does not let you spin up a Redis server [ioredis-mock](https://github.com/stipsan/ioredis-mock) is a drop-in replacement you can use in your tests. It aims to behave identically to ioredis connected to a Redis server so that your integration tests is easier to write and of better quality.\n\n# Debug\n\nYou can set the `DEBUG` env to `ioredis:*` to print debug info:\n\n```shell\n$ DEBUG=ioredis:* node app.js\n```\n\n# Consolidation: It's time for celebration\n\nRight now there are two great redis clients around and both have some advantages above each other. We speak about [node_redis](https://github.com/NodeRedis/node_redis) and ioredis. So after talking to each other about how we could improve in working together we (that is [@BridgeAR](https://github.com/BridgeAR) and [@luin](https://github.com/luin)) decided to work towards a single library on the long run. But step by step.\n\nFirst of all, we want to split small parts of our libraries into others so that we're both able to use the same code. Those libraries are going to be maintained under the NodeRedis organization. This is going to reduce the maintance overhead, allows others to use the very same code, if they need it and it's way easier for others to contribute to both libraries.\n\nWe're very happy about this step towards working together as we both want to give you the best redis experience possible.\n\nIf you want to join our cause by help maintaining something, please don't hesitate to contact either one of us.\n\n# Join in!\n\nI'm happy to receive bug reports, fixes, documentation enhancements, and any other improvements.\n\nAnd since I'm not a native English speaker, if you find any grammar mistakes in the documentation, please also let me know. :)\n\n# Contributors\n\nThis project exists thanks to all the people who contribute:\n\n<a href=\"https://github.com/luin/ioredis/graphs/contributors\"><img src=\"https://opencollective.com/ioredis/contributors.svg?width=890&showBtn=false\" /></a>\n\n# License\n\nMIT\n\n\n[![FOSSA Status](https://app.fossa.io/api/projects/git%2Bgithub.com%2Fluin%2Fioredis.svg?type=large)](https://app.fossa.io/projects/git%2Bgithub.com%2Fluin%2Fioredis?ref=badge_large)\n","readmeFilename":"README.md","bugs":{"url":"https://github.com/luin/ioredis/issues"},"homepage":"https://github.com/luin/ioredis#readme","_id":"ioredis@4.7.0","_npmVersion":"6.4.1","_nodeVersion":"10.15.3","_npmUser":{"name":"ioredis-robot","email":"ioredis-robot@zihua.li"},"dist":{"integrity":"sha512-B8yUM2sBoAV5jgIPsqRSv2n2WVC06+PhwlR63mJqAOOTbUB5DX+AiJ9J+Yt/g3cbCQUkVzZUGdfKI37YLXnB1g==","shasum":"144cec0d6f054f67b99837944cf18dc8cbd8136a","tarball":"https://registry.npmjs.org/ioredis/-/ioredis-4.7.0.tgz","fileCount":35,"unpackedSize":220699,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJch3QrCRA9TVsSAnZWagAA6aEQAJYvi3enTPOvHK+B9ZYs\nBoccCtUhOK1SVC+sIECRBPQyXzcsxGgZgSo+6wGm3OMmhxrTuK1QMiI1hhE3\nNizGwAZKNiaCWkmPo/cIcxEtijR33sNGbRy7r6n48Fr+s/a06a3PQR+9WA3s\nwKWJ+Uswn/CqOyCbHdeDdV4HXZB7nMiWI5ZNgpKF8eXrYaGiLI4izPksZS+3\nOUWAsJSX6bA6zpZaWpw9avGUdulxjwWh46ZVRK8SvJ6RTRutEKS8xaXbfShU\n1fArpjQa02gt8dOsgpSMIMqYC+ZdJ5kqeTSx8C2/LBLKJiM8hl/MVmAq4eGS\ng/VHSWYUUSey0L9aGYoXGxDBAotDbIMTLcu3OuJZTFEwom9NbKy3VjH3jXSl\nc6mDYjrfTTlIkPLeUeYCl3UnIncTPPj4ZmJ5Z+ngAtzFBc3AhReoMKhz4LUw\nWxUXQj2qVKg5zcJcelfZN7cfXEHl50mm8hjOzXVSnMQu87ub1DfCEfvlqakc\nmRxPZI0JWk2jbp6YWbLJUPqrFOKOi0X0qZzQE7CRYfOsuMwafPZziE/Kk4zJ\niuPulCFQgL+iu5mgyuuY3tHb0y6Ny68itzWA8v6sOyuEDgyas8I88oW+udga\nhySWdgloCp/7M2TKGQxmoL5gbSYQaIAIBX9JAB40gJZ9ejvb/PJhYZiFAAvC\n/NIq\r\n=XRw5\r\n-----END PGP SIGNATURE-----\r\n"},"maintainers":[{"email":"ioredis-robot@zihua.li","name":"ioredis-robot"},{"email":"i@zihua.li","name":"luin"}],"directories":{},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/ioredis_4.7.0_1552380971294_0.23399508110125478"},"_hasShrinkwrap":false},"4.8.0":{"name":"ioredis","version":"4.8.0","description":"A robust, performance-focused and full-featured Redis client for Node.js.","main":"built/index.js","scripts":{"test":"NODE_ENV=test mocha --timeout 8000 -r ts-node/register --exit","test:cov":"NODE_ENV=test node ./node_modules/istanbul/lib/cli.js cover --preserve-comments ./node_modules/mocha/bin/_mocha -- -r ts-node/register -R spec --exit","build":"rm -rf built && tsc","generate-docs":"jsdoc2md lib/redis.js lib/cluster/index.js lib/commander.js > API.md","prepublishOnly":"npm run build && npm test","bench":"matcha benchmarks/*.js","semantic-release":"semantic-release"},"repository":{"type":"git","url":"git://github.com/luin/ioredis.git"},"keywords":["redis","cluster","sentinel","pipelining"],"author":{"name":"luin","email":"i@zihua.li","url":"http://zihua.li"},"license":"MIT","dependencies":{"cluster-key-slot":"^1.0.6","debug":"^3.1.0","denque":"^1.1.0","flexbuffer":"0.0.6","lodash.defaults":"^4.2.0","lodash.flatten":"^4.4.0","redis-commands":"1.4.0","redis-errors":"^1.2.0","redis-parser":"^3.0.0","standard-as-callback":"^2.0.1"},"devDependencies":{"@semantic-release/changelog":"^3.0.0","@semantic-release/git":"^7.0.4","@types/node":"^10.11.5","@types/redis-errors":"1.2.0","bluebird":"^3.5.1","chai":"^3.5.0","cz-conventional-changelog":"^2.0.0","istanbul":"^0.4.2","jsdoc":"^3.4.0","jsdoc-to-markdown":"^4.0.1","mocha":"^5.2.0","server-destroy":"^1.0.1","sinon":"^1.17.3","ts-node":"^7.0.0","typescript":"^3.1.1"},"engines":{"node":">=6"},"config":{"commitizen":{"path":"./node_modules/cz-conventional-changelog"}},"gitHead":"7684b6696777975d0cda3769e56a9619a79b14ad","readme":"[![ioredis](https://cdn.rawgit.com/luin/ioredis/57b5b89e3e9111ff25d8c62c0bc58ed42e5b8d1e/logo.svg)](https://github.com/luin/ioredis)\n\n[![Build Status](https://travis-ci.org/luin/ioredis.svg?branch=master)](https://travis-ci.org/luin/ioredis)\n[![Test Coverage](https://codeclimate.com/github/luin/ioredis/badges/coverage.svg)](https://codeclimate.com/github/luin/ioredis)\n[![Join the chat at https://gitter.im/luin/ioredis](https://badges.gitter.im/Join%20Chat.svg)](https://gitter.im/luin/ioredis?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge)\n[![Commitizen friendly](https://img.shields.io/badge/commitizen-friendly-brightgreen.svg)](http://commitizen.github.io/cz-cli/)\n[![semantic-release](https://img.shields.io/badge/%20%20%F0%9F%93%A6%F0%9F%9A%80-semantic--release-e10079.svg)](https://github.com/semantic-release/semantic-release)\n[![npm latest version](https://img.shields.io/npm/v/ioredis/latest.svg)](https://www.npmjs.com/package/ioredis)\n[![npm next version](https://img.shields.io/npm/v/ioredis/next.svg)](https://www.npmjs.com/package/ioredis)\n<img alt=\"\" src=\"\">\n\nA robust, performance-focused and full-featured [Redis](http://redis.io) client for [Node.js](https://nodejs.org).\n\nSupports Redis >= 2.6.12 and (Node.js >= 6).\n\n# Features\nioredis is a robust, full-featured Redis client that is\nused in the world's biggest online commerce company [Alibaba](http://www.alibaba.com/) and many other awesome companies.\n\n0. Full-featured. It supports [Cluster](http://redis.io/topics/cluster-tutorial), [Sentinel](http://redis.io/topics/sentinel), [Pipelining](http://redis.io/topics/pipelining) and of course [Lua scripting](http://redis.io/commands/eval) & [Pub/Sub](http://redis.io/topics/pubsub) (with the support of binary messages).\n0. High performance.\n0. Delightful API. It works with Node callbacks and Native promises.\n0. Transformation of command arguments and replies.\n0. Transparent key prefixing.\n0. Abstraction for Lua scripting, allowing you to define custom commands.\n0. Support for binary data.\n0. Support for TLS.\n0. Support for offline queue and ready checking.\n0. Support for ES6 types, such as `Map` and `Set`.\n0. Support for GEO commands (Redis 3.2 Unstable).\n0. Sophisticated error handling strategy.\n0. Support for NAT mapping.\n\n# Links\n* [API Documentation](API.md)\n* [Changelog](Changelog.md)\n* [Migrating from node_redis](https://github.com/luin/ioredis/wiki/Migrating-from-node_redis)\n* [Error Handling](#error-handling)\n\n## Become a Sponsor to Support ioredis's Development\nOpen source is hard and time-consuming. If you want to invest in ioredis's future you can become a sponsor and make us spend more time on this library's improvements and new features.\n\n<a href=\"https://opencollective.com/ioredis\"><img src=\"https://opencollective.com/ioredis/tiers/sponsor.svg?avatarHeight=36\"></a>\n\nThank you for using ioredis :-)\n\n<hr>\n<a href=\"https://itunes.apple.com/app/medis-gui-for-redis/id1063631769\"><img align=\"right\" src=\"medis.png\" alt=\"Download on the App Store\"></a>\n\n\n### Advertisement\n\nLooking for a Redis GUI manager for OS X, Windows and Linux? Here's [Medis](https://itunes.apple.com/us/app/medis-gui-for-redis/id1063631769)!\n\nMedis is an open-sourced, beautiful, easy-to-use Redis GUI management application.\n\nMedis starts with all the basic features you need:\n\n* Keys viewing/editing\n* SSH Tunnel for connecting with remote servers\n* Terminal for executing custom commands\n* JSON/MessagePack format viewing/editing and built-in highlighting/validator\n* And other awesome features...\n\n[Medis is open sourced on GitHub](https://github.com/luin/medis)\n\n<hr>\n\n# Quick Start\n\n## Install\n```shell\n$ npm install ioredis\n```\n\n## Basic Usage\n\n```javascript\nvar Redis = require('ioredis');\nvar redis = new Redis();\n\nredis.set('foo', 'bar');\nredis.get('foo', function (err, result) {\n  console.log(result);\n});\n\n// Or using a promise if the last argument isn't a function\nredis.get('foo').then(function (result) {\n  console.log(result);\n});\n\n// Arguments to commands are flattened, so the following are the same:\nredis.sadd('set', 1, 3, 5, 7);\nredis.sadd('set', [1, 3, 5, 7]);\n\n// All arguments are passed directly to the redis server:\nredis.set('key', 100, 'EX', 10);\n```\n\nSee the `examples/` folder for more examples.\n\n## Connect to Redis\nWhen a new `Redis` instance is created,\na connection to Redis will be created at the same time.\nYou can specify which Redis to connect to by:\n\n```javascript\nnew Redis()       // Connect to 127.0.0.1:6379\nnew Redis(6380)   // 127.0.0.1:6380\nnew Redis(6379, '192.168.1.1')        // 192.168.1.1:6379\nnew Redis('/tmp/redis.sock')\nnew Redis({\n  port: 6379,          // Redis port\n  host: '127.0.0.1',   // Redis host\n  family: 4,           // 4 (IPv4) or 6 (IPv6)\n  password: 'auth',\n  db: 0\n})\n```\n\nYou can also specify connection options as a [`redis://` URL](http://www.iana.org/assignments/uri-schemes/prov/redis):\n\n```javascript\n// Connect to 127.0.0.1:6380, db 4, using password \"authpassword\":\nnew Redis('redis://:authpassword@127.0.0.1:6380/4')\n```\n\nSee [API Documentation](API.md#new_Redis) for all available options.\n\n## Pub/Sub\n\nHere is a simple example of the API for publish/subscribe.\nThe following program opens two client connections.\nIt subscribes to a channel with one connection\nand publishes to that channel with the other:\n\n```javascript\nvar Redis = require('ioredis');\nvar redis = new Redis();\nvar pub = new Redis();\nredis.subscribe('news', 'music', function (err, count) {\n  // Now we are subscribed to both the 'news' and 'music' channels.\n  // `count` represents the number of channels we are currently subscribed to.\n\n  pub.publish('news', 'Hello world!');\n  pub.publish('music', 'Hello again!');\n});\n\nredis.on('message', function (channel, message) {\n  // Receive message Hello world! from channel news\n  // Receive message Hello again! from channel music\n  console.log('Receive message %s from channel %s', message, channel);\n});\n\n// There's also an event called 'messageBuffer', which is the same as 'message' except\n// it returns buffers instead of strings.\nredis.on('messageBuffer', function (channel, message) {\n  // Both `channel` and `message` are buffers.\n});\n```\n\n`PSUBSCRIBE` is also supported in a similar way:\n\n```javascript\nredis.psubscribe('pat?ern', function (err, count) {});\nredis.on('pmessage', function (pattern, channel, message) {});\nredis.on('pmessageBuffer', function (pattern, channel, message) {});\n```\n\nWhen a client issues a SUBSCRIBE or PSUBSCRIBE, that connection is put into a \"subscriber\" mode.\nAt that point, only commands that modify the subscription set are valid.\nWhen the subscription set is empty, the connection is put back into regular mode.\n\nIf you need to send regular commands to Redis while in subscriber mode, just open another connection.\n\n## Handle Binary Data\nArguments can be buffers:\n```javascript\nredis.set('foo', Buffer.from('bar'));\n```\n\nAnd every command has a method that returns a Buffer (by adding a suffix of \"Buffer\" to the command name).\nTo get a buffer instead of a utf8 string:\n\n```javascript\nredis.getBuffer('foo', function (err, result) {\n  // result is a buffer.\n});\n```\n\n## Pipelining\nIf you want to send a batch of commands (e.g. > 5), you can use pipelining to queue\nthe commands in memory and then send them to Redis all at once. This way the performance improves by 50%~300% (See [benchmark section](#benchmark)).\n\n`redis.pipeline()` creates a `Pipeline` instance. You can call any Redis\ncommands on it just like the `Redis` instance. The commands are queued in memory\nand flushed to Redis by calling the `exec` method:\n\n```javascript\nvar pipeline = redis.pipeline();\npipeline.set('foo', 'bar');\npipeline.del('cc');\npipeline.exec(function (err, results) {\n  // `err` is always null, and `results` is an array of responses\n  // corresponding to the sequence of queued commands.\n  // Each response follows the format `[err, result]`.\n});\n\n// You can even chain the commands:\nredis.pipeline().set('foo', 'bar').del('cc').exec(function (err, results) {\n});\n\n// `exec` also returns a Promise:\nvar promise = redis.pipeline().set('foo', 'bar').get('foo').exec();\npromise.then(function (result) {\n  // result === [[null, 'OK'], [null, 'bar']]\n});\n```\n\nEach chained command can also have a callback, which will be invoked when the command\ngets a reply:\n\n```javascript\nredis.pipeline().set('foo', 'bar').get('foo', function (err, result) {\n  // result === 'bar'\n}).exec(function (err, result) {\n  // result[1][1] === 'bar'\n});\n```\n\nIn addition to adding commands to the `pipeline` queue individually, you can also pass an array of commands and arguments to the constructor:\n\n```javascript\nredis.pipeline([\n  ['set', 'foo', 'bar'],\n  ['get', 'foo']\n]).exec(function () { /* ... */ });\n```\n\n`#length` property shows how many commands in the pipeline:\n\n```javascript\nconst length = redis.pipeline().set('foo', 'bar').get('foo').length;\n// length === 2\n```\n\n\n## Transaction\nMost of the time, the transaction commands `multi` & `exec` are used together with pipeline.\nTherefore, when `multi` is called, a `Pipeline` instance is created automatically by default,\nso you can use `multi` just like `pipeline`:\n\n```javascript\nredis.multi().set('foo', 'bar').get('foo').exec(function (err, results) {\n  // results === [[null, 'OK'], [null, 'bar']]\n});\n```\nIf there's a syntax error in the transaction's command chain (e.g. wrong number of arguments, wrong command name, etc),\nthen none of the commands would be executed, and an error is returned:\n\n```javascript\nredis.multi().set('foo').set('foo', 'new value').exec(function (err, results) {\n  // err:\n  //  { [ReplyError: EXECABORT Transaction discarded because of previous errors.]\n  //    name: 'ReplyError',\n  //    message: 'EXECABORT Transaction discarded because of previous errors.',\n  //    command: { name: 'exec', args: [] },\n  //    previousErrors:\n  //     [ { [ReplyError: ERR wrong number of arguments for 'set' command]\n  //         name: 'ReplyError',\n  //         message: 'ERR wrong number of arguments for \\'set\\' command',\n  //         command: [Object] } ] }\n});\n```\n\nIn terms of the interface, `multi` differs from `pipeline` in that when specifying a callback\nto each chained command, the queueing state is passed to the callback instead of the result of the command:\n\n```javascript\nredis.multi().set('foo', 'bar', function (err, result) {\n  // result === 'QUEUED'\n}).exec(/* ... */);\n```\n\nIf you want to use transaction without pipeline, pass `{ pipeline: false }` to `multi`,\nand every command will be sent to Redis immediately without waiting for an `exec` invocation:\n\n```javascript\nredis.multi({ pipeline: false });\nredis.set('foo', 'bar');\nredis.get('foo');\nredis.exec(function (err, result) {\n  // result === [[null, 'OK'], [null, 'bar']]\n});\n```\n\nThe constructor of `multi` also accepts a batch of commands:\n\n```javascript\nredis.multi([\n  ['set', 'foo', 'bar'],\n  ['get', 'foo']\n]).exec(function () { /* ... */ });\n```\n\nInline transactions are supported by pipeline, which means you can group a subset of commands\nin the pipeline into a transaction:\n\n```javascript\nredis.pipeline().get('foo').multi().set('foo', 'bar').get('foo').exec().get('foo').exec();\n```\n\n## Lua Scripting\nioredis supports all of the scripting commands such as `EVAL`, `EVALSHA` and `SCRIPT`.\nHowever, it's tedious to use in real world scenarios since developers have to take\ncare of script caching and to detect when to use `EVAL` and when to use `EVALSHA`.\nioredis expose a `defineCommand` method to make scripting much easier to use:\n\n```javascript\nvar redis = new Redis();\n\n// This will define a command echo:\nredis.defineCommand('echo', {\n  numberOfKeys: 2,\n  lua: 'return {KEYS[1],KEYS[2],ARGV[1],ARGV[2]}'\n});\n\n// Now `echo` can be used just like any other ordinary command,\n// and ioredis will try to use `EVALSHA` internally when possible for better performance.\nredis.echo('k1', 'k2', 'a1', 'a2', function (err, result) {\n  // result === ['k1', 'k2', 'a1', 'a2']\n});\n\n// `echoBuffer` is also defined automatically to return buffers instead of strings:\nredis.echoBuffer('k1', 'k2', 'a1', 'a2', function (err, result) {\n  // result[0] equals to Buffer.from('k1');\n});\n\n// And of course it works with pipeline:\nredis.pipeline().set('foo', 'bar').echo('k1', 'k2', 'a1', 'a2').exec();\n```\n\nIf the number of keys can't be determined when defining a command, you can\nomit the `numberOfKeys` property and pass the number of keys as the first argument\nwhen you call the command:\n\n```javascript\nredis.defineCommand('echoDynamicKeyNumber', {\n  lua: 'return {KEYS[1],KEYS[2],ARGV[1],ARGV[2]}'\n});\n\n// Now you have to pass the number of keys as the first argument every time\n// you invoke the `echoDynamicKeyNumber` command:\nredis.echoDynamicKeyNumber(2, 'k1', 'k2', 'a1', 'a2', function (err, result) {\n  // result === ['k1', 'k2', 'a1', 'a2']\n});\n```\n\n## Transparent Key Prefixing\nThis feature allows you to specify a string that will automatically be prepended\nto all the keys in a command, which makes it easier to manage your key\nnamespaces.\n\n**Warning** This feature won't apply to commands like [KEYS](http://redis.io/commands/KEYS) and [SCAN](http://redis.io/commands/scan) that take patterns rather than actual keys([#239](https://github.com/luin/ioredis/issues/239)),\nand this feature also won't apply to the replies of commands even they are key names ([#325](https://github.com/luin/ioredis/issues/325)).\n\n```javascript\nvar fooRedis = new Redis({ keyPrefix: 'foo:' });\nfooRedis.set('bar', 'baz');  // Actually sends SET foo:bar baz\n\nfooRedis.defineCommand('echo', {\n  numberOfKeys: 2,\n  lua: 'return {KEYS[1],KEYS[2],ARGV[1],ARGV[2]}'\n});\n\n// Works well with pipelining/transaction\nfooRedis.pipeline()\n  // Sends SORT foo:list BY foo:weight_*->fieldname\n  .sort('list', 'BY', 'weight_*->fieldname')\n  // Supports custom commands\n  // Sends EVALSHA xxx foo:k1 foo:k2 a1 a2\n  .echo('k1', 'k2', 'a1', 'a2')\n  .exec()\n```\n\n## Transforming Arguments & Replies\nMost Redis commands take one or more Strings as arguments,\nand replies are sent back as a single String or an Array of Strings. However, sometimes\nyou may want something different. For instance, it would be more convenient if the `HGETALL`\ncommand returns a hash (e.g. `{ key: val1, key2: v2 }`) rather than an array of key values (e.g. `[key1, val1, key2, val2]`).\n\nioredis has a flexible system for transforming arguments and replies. There are two types\nof transformers, argument transformer and reply transformer:\n\n```javascript\nvar Redis = require('ioredis');\n\n// Here's the built-in argument transformer converting\n// hmset('key', { k1: 'v1', k2: 'v2' })\n// or\n// hmset('key', new Map([['k1', 'v1'], ['k2', 'v2']]))\n// into\n// hmset('key', 'k1', 'v1', 'k2', 'v2')\nRedis.Command.setArgumentTransformer('hmset', function (args) {\n  if (args.length === 2) {\n    if (typeof Map !== 'undefined' && args[1] instanceof Map) {\n      // utils is a internal module of ioredis\n      return [args[0]].concat(utils.convertMapToArray(args[1]));\n    }\n    if ( typeof args[1] === 'object' && args[1] !== null) {\n      return [args[0]].concat(utils.convertObjectToArray(args[1]));\n    }\n  }\n  return args;\n});\n\n// Here's the built-in reply transformer converting the HGETALL reply\n// ['k1', 'v1', 'k2', 'v2']\n// into\n// { k1: 'v1', 'k2': 'v2' }\nRedis.Command.setReplyTransformer('hgetall', function (result) {\n  if (Array.isArray(result)) {\n    var obj = {};\n    for (var i = 0; i < result.length; i += 2) {\n      obj[result[i]] = result[i + 1];\n    }\n    return obj;\n  }\n  return result;\n});\n```\n\nThere are three built-in transformers, two argument transformers for `hmset` & `mset` and\na reply transformer for `hgetall`. Transformers for `hmset` and `hgetall` were mentioned\nabove, and the transformer for `mset` is similar to the one for `hmset`:\n\n```javascript\nredis.mset({ k1: 'v1', k2: 'v2' });\nredis.get('k1', function (err, result) {\n  // result === 'v1';\n});\n\nredis.mset(new Map([['k3', 'v3'], ['k4', 'v4']]));\nredis.get('k3', function (err, result) {\n  // result === 'v3';\n});\n```\n\nAnother useful example of a reply transformer is one that changes `hgetall` to return array of arrays instead of objects which avoids a unwanted conversation of hash keys to strings when dealing with binary hash keys:\n\n```javascript\nRedis.Command.setReplyTransformer('hgetall', function (result) {\n  var arr = [];\n  for (var i = 0; i < result.length; i += 2) {\n    arr.push([result[i], result[i + 1]]);\n  }\n  return arr;\n});\nredis.hset('h1', Buffer.from([0x01]), Buffer.from([0x02]));\nredis.hset('h1', Buffer.from([0x03]), Buffer.from([0x04]));\nredis.hgetallBuffer('h1', function (err, result) {\n  // result === [ [ <Buffer 01>, <Buffer 02> ], [ <Buffer 03>, <Buffer 04> ] ];\n});\n```\n\n## Monitor\nRedis supports the MONITOR command,\nwhich lets you see all commands received by the Redis server across all client connections,\nincluding from other client libraries and other computers.\n\nThe `monitor` method returns a monitor instance.\nAfter you send the MONITOR command, no other commands are valid on that connection. ioredis will emit a monitor event for every new monitor message that comes across.\nThe callback for the monitor event takes a timestamp from the Redis server and an array of command arguments.\n\nHere is a simple example:\n\n```javascript\nredis.monitor(function (err, monitor) {\n  monitor.on('monitor', function (time, args, source, database) {\n  });\n});\n```\n\n## Streamify Scanning\nRedis 2.8 added the `SCAN` command to incrementally iterate through the keys in the database. It's different from `KEYS` in that\n`SCAN` only returns a small number of elements each call, so it can be used in production without the downside\nof blocking the server for a long time. However, it requires recording the cursor on the client side each time\nthe `SCAN` command is called in order to iterate through all the keys correctly. Since it's a relatively common use case, ioredis\nprovides a streaming interface for the `SCAN` command to make things much easier. A readable stream can be created by calling `scanStream`:\n\n```javascript\nvar redis = new Redis();\n// Create a readable stream (object mode)\nvar stream = redis.scanStream();\nstream.on('data', function (resultKeys) {\n  // `resultKeys` is an array of strings representing key names.\n  // Note that resultKeys may contain 0 keys, and that it will sometimes\n  // contain duplicates due to SCAN's implementation in Redis.\n  for (var i = 0; i < resultKeys.length; i++) {\n    console.log(resultKeys[i]);\n  }\n});\nstream.on('end', function () {\n  console.log('all keys have been visited');\n});\n```\n\n`scanStream` accepts an option, with which you can specify the `MATCH` pattern and the `COUNT` argument:\n\n```javascript\nvar stream = redis.scanStream({\n  // only returns keys following the pattern of `user:*`\n  match: 'user:*',\n  // returns approximately 100 elements per call\n  count: 100\n});\n```\n\nJust like other commands, `scanStream` has a binary version `scanBufferStream`, which returns an array of buffers. It's useful when\nthe key names are not utf8 strings.\n\nThere are also `hscanStream`, `zscanStream` and `sscanStream` to iterate through elements in a hash, zset and set. The interface of each is\nsimilar to `scanStream` except the first argument is the key name:\n\n```javascript\nvar stream = redis.hscanStream('myhash', {\n  match: 'age:??'\n});\n```\n\nYou can learn more from the [Redis documentation](http://redis.io/commands/scan).\n\n**Useful Tips**\nIt's pretty common that doing an async task in the `data` handler. We'd like the scanning process to be paused until the async task to be finished. `Stream#pause()` and `Stream.resume()` do the trick. For example if we want to migrate data in Redis to MySQL:\n\n```javascript\nvar stream = redis.scanStream();\nstream.on('data', function (resultKeys) {\n  // Pause the stream from scanning more keys until we've migrated the current keys.\n  stream.pause();\n\n  Promise.all(resultKeys.map(migrateKeyToMySQL)).then(() => {\n    // Resume the stream here.\n    stream.resume();\n  });\n});\n\nstream.on('end', function () {\n  console.log('done migration');\n});\n```\n\n## Auto-reconnect\nBy default, ioredis will try to reconnect when the connection to Redis is lost\nexcept when the connection is closed manually by `redis.disconnect()` or `redis.quit()`.\n\nIt's very flexible to control how long to wait to reconnect after disconnection\nusing the `retryStrategy` option:\n\n```javascript\nvar redis = new Redis({\n  // This is the default value of `retryStrategy`\n  retryStrategy: function (times) {\n    var delay = Math.min(times * 50, 2000);\n    return delay;\n  }\n});\n```\n\n`retryStrategy` is a function that will be called when the connection is lost.\nThe argument `times` means this is the nth reconnection being made and\nthe return value represents how long (in ms) to wait to reconnect. When the\nreturn value isn't a number, ioredis will stop trying to reconnect, and the connection\nwill be lost forever if the user doesn't call `redis.connect()` manually.\n\nWhen reconnected, the client will auto subscribe to channels that the previous connection subscribed to.\nThis behavior can be disabled by setting the `autoResubscribe` option to `false`.\n\nAnd if the previous connection has some unfulfilled commands (most likely blocking commands such as `brpop` and `blpop`),\nthe client will resend them when reconnected. This behavior can be disabled by setting the `autoResendUnfulfilledCommands` option to `false`.\n\nBy default, all pending commands will be flushed with an error every 20 retry attempts. That makes sure commands won't wait forever when the connection is down. You can change this behavior by setting `maxRetriesPerRequest`:\n\n```javascript\nvar redis = new Redis({\n  maxRetriesPerRequest: 1\n});\n```\n\nSet maxRetriesPerRequest to `null` to disable this behavior, and every command will wait forever until the connection is alive again (which is the default behavior before ioredis v4).\n\n### Reconnect on error\n\nBesides auto-reconnect when the connection is closed, ioredis supports reconnecting on the specified errors by the `reconnectOnError` option. Here's an example that will reconnect when receiving `READONLY` error:\n\n```javascript\nvar redis = new Redis({\n  reconnectOnError: function (err) {\n    var targetError = 'READONLY';\n    if (err.message.slice(0, targetError.length) === targetError) {\n      // Only reconnect when the error starts with \"READONLY\"\n      return true; // or `return 1;`\n    }\n  }\n});\n```\n\nThis feature is useful when using Amazon ElastiCache. Once failover happens, Amazon ElastiCache will switch the master we currently connected with to a slave, leading to the following writes fails with the error `READONLY`. Using `reconnectOnError`, we can force the connection to reconnect on this error in order to connect to the new master.\n\nFurthermore, if the `reconnectOnError` returns `2`, ioredis will resend the failed command after reconnecting.\n\n## Connection Events\nThe Redis instance will emit some events about the state of the connection to the Redis server.\n\nEvent    | Description\n:------------- | :-------------\nconnect  | emits when a connection is established to the Redis server.\nready    | If `enableReadyCheck` is `true`, client will emit `ready` when the server reports that it is ready to receive commands (e.g. finish loading data from disk).<br>Otherwise, `ready` will be emitted immediately right after the `connect` event.\nerror    | emits when an error occurs while connecting.<br>However, ioredis emits all `error` events silently (only emits when there's at least one listener) so that your application won't crash if you're not listening to the `error` event.\nclose    | emits when an established Redis server connection has closed.\nreconnecting | emits after `close` when a reconnection will be made. The argument of the event is the time (in ms) before reconnecting.\nend     | emits after `close` when no more reconnections will be made, or the connection is failed to establish.\n\nYou can also check out the `Redis#status` property to get the current connection status.\n\nBesides the above connection events, there are several other custom events:\n\nEvent    | Description\n:------------- | :-------------\nselect   | emits when the database changed. The argument is the new db number.\n\n## Offline Queue\nWhen a command can't be processed by Redis (being sent before the `ready` event), by default, it's added to the offline queue and will be\nexecuted when it can be processed. You can disable this feature by setting the `enableOfflineQueue`\noption to `false`:\n\n```javascript\nvar redis = new Redis({ enableOfflineQueue: false });\n```\n\n## TLS Options\nRedis doesn't support TLS natively, however if the redis server you want to connect to is hosted behind a TLS proxy (e.g. [stunnel](https://www.stunnel.org/)) or is offered by a PaaS service that supports TLS connection (e.g. [Redis Labs](https://redislabs.com/)), you can set the `tls` option:\n\n```javascript\nvar redis = new Redis({\n  host: 'localhost',\n  tls: {\n    // Refer to `tls.connect()` section in\n    // https://nodejs.org/api/tls.html\n    // for all supported options\n    ca: fs.readFileSync('cert.pem')\n  }\n});\n```\n\n<hr>\n\n## Sentinel\nioredis supports Sentinel out of the box. It works transparently as all features that work when\nyou connect to a single node also work when you connect to a sentinel group. Make sure to run Redis >= 2.8.12 if you want to use this feature. Sentinels have a default port of 26379.\n\nTo connect using Sentinel, use:\n\n```javascript\nvar redis = new Redis({\n  sentinels: [{ host: 'localhost', port: 26379 }, { host: 'localhost', port: 26380 }],\n  name: 'mymaster'\n});\n\nredis.set('foo', 'bar');\n```\n\nThe arguments passed to the constructor are different from the ones you use to connect to a single node, where:\n\n* `name` identifies a group of Redis instances composed of a master and one or more slaves (`mymaster` in the example);\n* `sentinels` are a list of sentinels to connect to. The list does not need to enumerate all your sentinel instances, but a few so that if one is down the client will try the next one.\n* `role` (optional) with a value of `slave` will return a random slave from the Sentinel group.\n* `preferredSlaves` (optional) can be used to prefer a particular slave or set of slaves based on priority. It accepts a function or array.\n\nioredis **guarantees** that the node you connected to is always a master even after a failover. When a failover happens, instead of trying to reconnect to the failed node (which will be demoted to slave when it's available again), ioredis will ask sentinels for the new master node and connect to it. All commands sent during the failover are queued and will be executed when the new connection is established so that none of the commands will be lost.\n\nIt's possible to connect to a slave instead of a master by specifying the option `role` with the value of `slave` and ioredis will try to connect to a random slave of the specified master, with the guarantee that the connected node is always a slave. If the current node is promoted to master due to a failover, ioredis will disconnect from it and ask the sentinels for another slave node to connect to.\n\nIf you specify the option `preferredSlaves` along with `role: 'slave'` ioredis will attempt to use this value when selecting the slave from the pool of available slaves. The value of `preferredSlaves` should either be a function that accepts an array of avaiable slaves and returns a single result, or an array of slave values priorities by the lowest `prio` value first with a default value of `1`.\n\n```javascript\n// available slaves format\nvar availableSlaves = [{ ip: '127.0.0.1', port: '31231', flags: 'slave' }];\n\n// preferredSlaves array format\nvar preferredSlaves = [\n  { ip: '127.0.0.1', port: '31231', prio: 1 },\n  { ip: '127.0.0.1', port: '31232', prio: 2 }\n];\n\n// preferredSlaves function format\npreferredSlaves = function(availableSlaves) {\n  for (var i = 0; i < availableSlaves.length; i++) {\n    var slave = availableSlaves[i];\n    if (slave.ip === '127.0.0.1') {\n      if (slave.port === '31234') {\n        return slave;\n      }\n    }\n  }\n  // if no preferred slaves are available a random one is used\n  return false;\n};\n\nvar redis = new Redis({\n  sentinels: [{ host: '127.0.0.1', port: 26379 }, { host: '127.0.0.1', port: 26380 }],\n  name: 'mymaster',\n  role: 'slave',\n  preferredSlaves: preferredSlaves\n});\n```\n\nBesides the `retryStrategy` option, there's also a `sentinelRetryStrategy` in Sentinel mode which will be invoked when all the sentinel nodes are unreachable during connecting. If `sentinelRetryStrategy` returns a valid delay time, ioredis will try to reconnect from scratch. The default value of `sentinelRetryStrategy` is:\n\n```javascript\nfunction (times) {\n  var delay = Math.min(times * 10, 1000);\n  return delay;\n}\n```\n\n## Cluster\nRedis Cluster provides a way to run a Redis installation where data is automatically sharded across multiple Redis nodes.\nYou can connect to a Redis Cluster like this:\n\n```javascript\nvar Redis = require('ioredis');\n\nvar cluster = new Redis.Cluster([{\n  port: 6380,\n  host: '127.0.0.1'\n}, {\n  port: 6381,\n  host: '127.0.0.1'\n}]);\n\ncluster.set('foo', 'bar');\ncluster.get('foo', function (err, res) {\n  // res === 'bar'\n});\n```\n\n`Cluster` constructor accepts two arguments, where:\n\n0. The first argument is a list of nodes of the cluster you want to connect to.\nJust like Sentinel, the list does not need to enumerate all your cluster nodes,\nbut a few so that if one is unreachable the client will try the next one, and the client will discover other nodes automatically when at least one node is connected.\n0. The second argument is the options, where:\n\n    * `clusterRetryStrategy`: When none of the startup nodes are reachable, `clusterRetryStrategy` will be invoked. When a number is returned,\n    ioredis will try to reconnect to the startup nodes from scratch after the specified delay (in ms). Otherwise, an error of \"None of startup nodes is available\" will be returned.\n    The default value of this option is:\n\n        ```javascript\n        function (times) {\n          var delay = Math.min(100 + times * 2, 2000);\n          return delay;\n        }\n        ```\n\n        It's possible to modify the `startupNodes` property in order to switch to another set of nodes here:\n\n        ```javascript\n        function (times) {\n          this.startupNodes = [{ port: 6790, host: '127.0.0.1' }];\n          return Math.min(100 + times * 2, 2000);\n        }\n        ```\n\n    * `enableOfflineQueue`: Similar to the `enableOfflineQueue` option of `Redis` class.\n    * `enableReadyCheck`: When enabled, \"ready\" event will only be emitted when `CLUSTER INFO` command\n    reporting the cluster is ready for handling commands. Otherwise, it will be emitted immediately after \"connect\" is emitted.\n    * `scaleReads`: Config where to send the read queries. See below for more details.\n    * `maxRedirections`: When a cluster related error (e.g. `MOVED`, `ASK` and `CLUSTERDOWN` etc.) is received, the client will redirect the\n    command to another node. This option limits the max redirections allowed when sending a command. The default value is `16`.\n    * `retryDelayOnFailover`: If the target node is disconnected when sending a command,\n    ioredis will retry after the specified delay. The default value is `100`. You should make sure `retryDelayOnFailover * maxRedirections > cluster-node-timeout`\n    to insure that no command will fail during a failover.\n    * `retryDelayOnClusterDown`: When a cluster is down, all commands will be rejected with the error of `CLUSTERDOWN`. If this option is a number (by default, it is `100`), the client\n    will resend the commands after the specified time (in ms).\n    * `retryDelayOnTryAgain`: If this option is a number (by default, it is `100`), the client\n    will resend the commands rejected with `TRYAGAIN` error after the specified time (in ms).\n    * `redisOptions`: Default options passed to the constructor of `Redis` when connecting to a node.\n    * `slotsRefreshTimeout`: Milliseconds before a timeout occurs while refreshing slots from the cluster (default `1000`)\n    * `slotsRefreshInterval`: Milliseconds between every automatic slots refresh (default `5000`)\n\n### Read-write splitting\n\nA typical redis cluster contains three or more masters and several slaves for each master. It's possible to scale out redis cluster by sending read queries to slaves and write queries to masters by setting the `scaleReads` option.\n\n`scaleReads` is \"master\" by default, which means ioredis will never send any queries to slaves. There are other three available options:\n\n1. \"all\": Send write queries to masters and read queries to masters or slaves randomly.\n2. \"slave\": Send write queries to masters and read queries to slaves.\n3. a custom `function(nodes, command): node`: Will choose the custom function to select to which node to send read queries (write queries keep being sent to master). The first node in `nodes` is always the master serving the relevant slots. If the function returns an array of nodes, a random node of that list will be selected.\n\nFor example:\n\n```javascript\nvar cluster = new Redis.Cluster([/* nodes */], {\n  scaleReads: 'slave'\n});\ncluster.set('foo', 'bar'); // This query will be sent to one of the masters.\ncluster.get('foo', function (err, res) {\n  // This query will be sent to one of the slaves.\n});\n```\n\n**NB** In the code snippet above, the `res` may not be equal to \"bar\" because of the lag of replication between the master and slaves.\n\n### Running commands to multiple nodes\n\nEvery command will be sent to exactly one node. For commands containing keys, (e.g. `GET`, `SET` and `HGETALL`), ioredis sends them to the node that serving the keys, and for other commands not containing keys, (e.g. `INFO`, `KEYS` and `FLUSHDB`), ioredis sends them to a random node.\n\nSometimes you may want to send a command to multiple nodes (masters or slaves) of the cluster, you can get the nodes via `Cluster#nodes()` method.\n\n`Cluster#nodes()` accepts a parameter role, which can be \"master\", \"slave\" and \"all\" (default), and returns an array of `Redis` instance. For example:\n\n```javascript\n// Send `FLUSHDB` command to all slaves:\nvar slaves = cluster.nodes('slave');\nPromise.all(slaves.map(function (node) {\n  return node.flushdb();\n}));\n\n// Get keys of all the masters:\nvar masters = cluster.nodes('master');\nPromise.all(masters.map(function (node) {\n  return node.keys();\n})).then(function (keys) {\n  // keys: [['key1', 'key2'], ['key3', 'key4']]\n});\n```\n\n### NAT Mapping\nSometimes the cluster is hosted within a internal network that can only be accessed via a NAT (Network Address Translation) instance. See [Accessing ElastiCache from outside AWS](https://docs.aws.amazon.com/AmazonElastiCache/latest/red-ug/accessing-elasticache.html) as an example.\n\nYou can specify nat mapping rules via `natMap` option:\n\n```javascript\nconst cluster = new Redis.Cluster([{\n  host: '203.0.113.73',\n  port: 30001\n}], {\n  natMap: {\n    '10.0.1.230:30001': {host: '203.0.113.73', port: 30001},\n    '10.0.1.231:30001': {host: '203.0.113.73', port: 30002},\n    '10.0.1.232:30001': {host: '203.0.113.73', port: 30003}\n  }\n})\n```\n\nThis option is also useful when the cluster is running inside a Docker container.\n\n### Transaction and pipeline in Cluster mode\nAlmost all features that are supported by `Redis` are also supported by `Redis.Cluster`, e.g. custom commands, transaction and pipeline.\nHowever there are some differences when using transaction and pipeline in Cluster mode:\n\n0. All keys in a pipeline should belong to the same slot since ioredis sends all commands in a pipeline to the same node.\n0. You can't use `multi` without pipeline (aka `cluster.multi({ pipeline: false })`). This is because when you call `cluster.multi({ pipeline: false })`, ioredis doesn't know which node the `multi` command should be sent to.\n0. Chaining custom commands in the pipeline is not supported in Cluster mode.\n\nWhen any commands in a pipeline receives a `MOVED` or `ASK` error, ioredis will resend the whole pipeline to the specified node automatically if all of the following conditions are satisfied:\n\n0. All errors received in the pipeline are the same. For example, we won't resend the pipeline if we got two `MOVED` errors pointing to different nodes.\n0. All commands executed successfully are readonly commands. This makes sure that resending the pipeline won't have side effects.\n\n### Pub/Sub\nPub/Sub in cluster mode works exactly as the same as in standalone mode. Internally, when a node of the cluster receives a message, it will broadcast the message to the other nodes. ioredis makes sure that each message will only be received once by strictly subscribing one node at the same time.\n\n```javascript\nvar nodes = [/* nodes */];\nvar pub = new Redis.Cluster(nodes);\nvar sub = new Redis.Cluster(nodes);\nsub.on('message', function (channel, message) {\n  console.log(channel, message);\n});\n\nsub.subscribe('news', function () {\n  pub.publish('news', 'highlights');\n});\n```\n\n### Events\n\nEvent    | Description\n:------------- | :-------------\nconnect  | emits when a connection is established to the Redis server.\nready    | emits when `CLUSTER INFO` reporting the cluster is able to receive commands (if `enableReadyCheck` is `true`) or immediately after `connect` event (if `enableReadyCheck` is false).\nerror    | emits when an error occurs while connecting with a property of `lastNodeError` representing the last node error received. This event is emitted silently (only emitting if there's at least one listener).\nclose    | emits when an established Redis server connection has closed.\nreconnecting | emits after `close` when a reconnection will be made. The argument of the event is the time (in ms) before reconnecting.\nend     | emits after `close` when no more reconnections will be made.\n+node   | emits when a new node is connected.\n-node   | emits when a node is disconnected.\nnode error | emits when an error occurs when connecting to a node. The second argument indicates the address of the node.\n\n### Password\nSetting the `password` option to access password-protected clusters:\n\n```javascript\nvar Redis = require('ioredis');\nvar cluster = new Redis.Cluster(nodes, {\n  redisOptions: {\n    password: 'your-cluster-password'\n  }\n});\n```\n\nIf some of nodes in the cluster using a different password, you should specify them in the first parameter:\n\n```javascript\nvar Redis = require('ioredis');\nvar cluster = new Redis.Cluster([\n  // Use password \"password-for-30001\" for 30001\n  { port: 30001, password: 'password-for-30001'},\n  // Don't use password when accessing 30002\n  { port: 30002, password: null }\n  // Other nodes will use \"fallback-password\"\n], {\n  redisOptions: {\n    password: 'fallback-password'\n  }\n});\n```\n\n<hr>\n\n# Error Handling\nAll the errors returned by the Redis server are instances of `ReplyError`, which can be accessed via `Redis`:\n\n```javascript\nvar Redis = require('ioredis');\nvar redis = new Redis();\n// This command causes a reply error since the SET command requires two arguments.\nredis.set('foo', function (err) {\n  err instanceof Redis.ReplyError\n});\n```\n\nThis is the error stack of the `ReplyError`:\n\n```\nReplyError: ERR wrong number of arguments for 'set' command\n    at ReplyParser._parseResult (/app/node_modules/ioredis/lib/parsers/javascript.js:60:14)\n    at ReplyParser.execute (/app/node_modules/ioredis/lib/parsers/javascript.js:178:20)\n    at Socket.<anonymous> (/app/node_modules/ioredis/lib/redis/event_handler.js:99:22)\n    at Socket.emit (events.js:97:17)\n    at readableAddChunk (_stream_readable.js:143:16)\n    at Socket.Readable.push (_stream_readable.js:106:10)\n    at TCP.onread (net.js:509:20)\n```\n\nBy default, the error stack doesn't make any sense because the whole stack happens in the ioredis\nmodule itself, not in your code. So it's not easy to find out where the error happens in your code.\nioredis provides an option `showFriendlyErrorStack` to solve the problem. When you enable\n`showFriendlyErrorStack`, ioredis will optimize the error stack for you:\n\n```javascript\nvar Redis = require('ioredis');\nvar redis = new Redis({ showFriendlyErrorStack: true });\nredis.set('foo');\n```\n\nAnd the output will be:\n\n```\nReplyError: ERR wrong number of arguments for 'set' command\n    at Object.<anonymous> (/app/index.js:3:7)\n    at Module._compile (module.js:446:26)\n    at Object.Module._extensions..js (module.js:464:10)\n    at Module.load (module.js:341:32)\n    at Function.Module._load (module.js:296:12)\n    at Function.Module.runMain (module.js:487:10)\n    at startup (node.js:111:16)\n    at node.js:799:3\n```\n\nThis time the stack tells you that the error happens on the third line in your code. Pretty sweet!\nHowever, it would decrease the performance significantly to optimize the error stack. So by\ndefault, this option is disabled and can only be used for debugging purposes. You **shouldn't** use this feature in a production environment.\n\n# Plugging in your own Promises Library\nIf you're an advanced user, you may want to plug in your own promise library like [bluebird](https://www.npmjs.com/package/bluebird). Just set Redis.Promise to your favorite ES6-style promise constructor and ioredis will use it.\n\n```javascript\nconst Redis = require('ioredis')\nRedis.Promise = require('bluebird')\n\nconst redis = new Redis()\n\n// Use bluebird\nassert.equal(redis.get().constructor, require('bluebird'))\n\n// You can change the Promise implementation at any time:\nRedis.Promise = global.Promise\nassert.equal(redis.get().constructor, global.Promise)\n```\n\n\n# Running tests\n\nStart a Redis server on 127.0.0.1:6379, and then:\n\n```shell\n$ npm test\n```\n\n`FLUSH ALL` will be invoked after each test, so make sure there's no valuable data in it before running tests.\n\nIf your testing environment does not let you spin up a Redis server [ioredis-mock](https://github.com/stipsan/ioredis-mock) is a drop-in replacement you can use in your tests. It aims to behave identically to ioredis connected to a Redis server so that your integration tests is easier to write and of better quality.\n\n# Debug\n\nYou can set the `DEBUG` env to `ioredis:*` to print debug info:\n\n```shell\n$ DEBUG=ioredis:* node app.js\n```\n\n# Consolidation: It's time for celebration\n\nRight now there are two great redis clients around and both have some advantages above each other. We speak about [node_redis](https://github.com/NodeRedis/node_redis) and ioredis. So after talking to each other about how we could improve in working together we (that is [@BridgeAR](https://github.com/BridgeAR) and [@luin](https://github.com/luin)) decided to work towards a single library on the long run. But step by step.\n\nFirst of all, we want to split small parts of our libraries into others so that we're both able to use the same code. Those libraries are going to be maintained under the NodeRedis organization. This is going to reduce the maintance overhead, allows others to use the very same code, if they need it and it's way easier for others to contribute to both libraries.\n\nWe're very happy about this step towards working together as we both want to give you the best redis experience possible.\n\nIf you want to join our cause by help maintaining something, please don't hesitate to contact either one of us.\n\n# Join in!\n\nI'm happy to receive bug reports, fixes, documentation enhancements, and any other improvements.\n\nAnd since I'm not a native English speaker, if you find any grammar mistakes in the documentation, please also let me know. :)\n\n# Contributors\n\nThis project exists thanks to all the people who contribute:\n\n<a href=\"https://github.com/luin/ioredis/graphs/contributors\"><img src=\"https://opencollective.com/ioredis/contributors.svg?width=890&showBtn=false\" /></a>\n\n# License\n\nMIT\n\n\n[![FOSSA Status](https://app.fossa.io/api/projects/git%2Bgithub.com%2Fluin%2Fioredis.svg?type=large)](https://app.fossa.io/projects/git%2Bgithub.com%2Fluin%2Fioredis?ref=badge_large)\n","readmeFilename":"README.md","bugs":{"url":"https://github.com/luin/ioredis/issues"},"homepage":"https://github.com/luin/ioredis#readme","_id":"ioredis@4.8.0","_npmVersion":"6.4.1","_nodeVersion":"10.15.3","_npmUser":{"name":"ioredis-robot","email":"ioredis-robot@zihua.li"},"dist":{"integrity":"sha512-D8pR/xyA333i+sotCHpTK8qbwrXLE9pKOGo+Aosn7FbuyJ5mcoXezByWkUe7KEW8LF9XD5lJPS4+u6P+0aIpzA==","shasum":"b6a53f8da422b21ee8797735fa4f6545fd7ce628","tarball":"https://registry.npmjs.org/ioredis/-/ioredis-4.8.0.tgz","fileCount":35,"unpackedSize":221290,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJch9LQCRA9TVsSAnZWagAAtQIQAIu6+EMamr/V9cwox2Lh\n3wXgPlBwDs7ralKi39WwAkwupLv/FWJhdMpqlg+xNaObdruiV7AP9dBwcc2/\nkNCYWU+IgDxdiy/8oPRhEWQYZOq6hx21WxGYNvee4lfnu9XWxyV6FOYjC7HZ\nWpDdS3SkBcHoUJOJUOrN0PpWLJY+A8/5Yy+TgDwgduF/zN9+5T2oyYIB3F2V\nfg7jh39WHCbNJIwcxCcqtDgQqBimj8Oa0Z+qvTGARQUJT2XyKEsqGJXiUQ+w\nfaJa7AI20iGkDAxWcWFvNmTRn5bnQL7/4BFwVEP8tfd2tNRN1tm2IIlVnuJU\nsnLdtcf83EVNg/mLU51/K3lidcgBw+SVmI6LiV2s36lu5D0L0jUaeyCDrh6G\nUa1Zw9HrMRUyNhxaDhhwhW7CEvOOxHhai0myxB/9NWBbcbfBLeg8dct99HDf\n+fuAZj2zZV+WMYHSXZuhcSBZ3Scn4LubthJxQv4IXMOivqPyZm8FMoCjuBQW\ndH7CJpLV/RwGHwVvxRnL007dZJHYn/rUSjdHaG07Kg5X5chOV61w3BxDgQ9z\nQzQaEJTCtV16HSDGZBtzMCy9eGPNwMyLX648/GEmIpaJqH1ORvDxLpz2ukO2\nN2UjgAolCLocc+oIfb7P9xOg3XvtScknP8AdcGuQwirndXJtleyQo1T1u42J\nNMgV\r\n=aFkk\r\n-----END PGP SIGNATURE-----\r\n"},"maintainers":[{"email":"ioredis-robot@zihua.li","name":"ioredis-robot"},{"email":"i@zihua.li","name":"luin"}],"directories":{},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/ioredis_4.8.0_1552405199843_0.3828810991347966"},"_hasShrinkwrap":false},"4.9.0":{"name":"ioredis","version":"4.9.0","description":"A robust, performance-focused and full-featured Redis client for Node.js.","main":"built/index.js","scripts":{"test":"NODE_ENV=test mocha --timeout 8000 -r ts-node/register --exit","test:cov":"NODE_ENV=test node ./node_modules/istanbul/lib/cli.js cover --preserve-comments ./node_modules/mocha/bin/_mocha -- -r ts-node/register -R spec --exit","build":"rm -rf built && tsc","generate-docs":"jsdoc2md lib/redis.js lib/cluster/index.js lib/commander.js > API.md","prepublishOnly":"npm run build && npm test","bench":"matcha benchmarks/*.js","semantic-release":"semantic-release"},"repository":{"type":"git","url":"git://github.com/luin/ioredis.git"},"keywords":["redis","cluster","sentinel","pipelining"],"author":{"name":"luin","email":"i@zihua.li","url":"http://zihua.li"},"license":"MIT","dependencies":{"cluster-key-slot":"^1.0.6","debug":"^3.1.0","denque":"^1.1.0","flexbuffer":"0.0.6","lodash.defaults":"^4.2.0","lodash.flatten":"^4.4.0","redis-commands":"1.4.0","redis-errors":"^1.2.0","redis-parser":"^3.0.0","standard-as-callback":"^2.0.1"},"devDependencies":{"@semantic-release/changelog":"^3.0.0","@semantic-release/git":"^7.0.4","@types/node":"^10.11.5","@types/redis-errors":"1.2.0","bluebird":"^3.5.1","chai":"^3.5.0","cz-conventional-changelog":"^2.0.0","istanbul":"^0.4.2","jsdoc":"^3.4.0","jsdoc-to-markdown":"^4.0.1","mocha":"^5.2.0","server-destroy":"^1.0.1","sinon":"^1.17.3","ts-node":"^7.0.0","typescript":"^3.1.1"},"engines":{"node":">=6"},"config":{"commitizen":{"path":"./node_modules/cz-conventional-changelog"}},"gitHead":"5d50842efa5ca1e8c8e830f955b20c0badc2a20e","bugs":{"url":"https://github.com/luin/ioredis/issues"},"homepage":"https://github.com/luin/ioredis#readme","_id":"ioredis@4.9.0","_npmVersion":"6.4.1","_nodeVersion":"10.15.3","_npmUser":{"name":"ioredis-robot","email":"ioredis-robot@zihua.li"},"dist":{"integrity":"sha512-YzfCLsN++Ct43QqGK9CWxaEK6OUvJ7rnENieAPNw3DVp/oF2uBrP2NJChbhO74Ng3LWA+i5zdIEUsZYr6dKDIQ==","shasum":"0c52de498363309ebd48b5f6695d9d432b0f6669","tarball":"https://registry.npmjs.org/ioredis/-/ioredis-4.9.0.tgz","fileCount":35,"unpackedSize":221690,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJcjx5MCRA9TVsSAnZWagAA+sMP/0M28jRaLJMbRexdDFIm\nMqDvPc2d9xNaiecXqJJaSwI7YBZyArR5LVrs3R/w2CdtEDDrcmlLcuw3Sf0W\nMG+UQoSra156Teu+wW0Gnv6NZX6FL6ozQgcwF1Sj1qVxOa5OHWh/tmudOMIl\nSCcIOfyQr7EW+tNz2LCc+TSMcqMHy+Zs5yWlPu+8f15G9HjupwjuEgvW5mGZ\n4XhIDot7ykeazLSiRH0eTqGUvKxo2Q+LWNQMhrvf2+7wZbCpT0tBp5sX6bb5\n/jP4RHq/3LpFEzP2QmePPKijjjyNt/bdwXBcWkomnEFGWTfSDbykPwo5RQou\ntLmRYknbS+dfeJ7wmKZGkP4Ri8y22tuUGvca03Bhy8XpHqG5027upIgR1kip\nBQ+kFlPeC/K/vuEUwnj2x2EEaEN7EzzjdBEDeGMzssxLjxHeTcQy9Bk+vuZR\nCvG41joFER2hQPe3nNxAYN053DXFjalWMOpV6ZPVmXWOQ/BRLReE8iRk7Fnk\nBO+cKMqT6sOTWDH/wUJhRAoYrT0LbWL6Yy1NfhQUVNluVdkI+BuH9hhEWapU\nKq/IwjM2V0hxQZmAQGJe9X9pWqntwnJUuL7Zmr3j8BXCNhVGpsDRiM7StR6Z\nZ5ksuOIiT1598iyY45g6nemFQjYogiTJOYnkrWauBms3v6ob/6jqz46Sq6FE\n1Xo0\r\n=Be9p\r\n-----END PGP SIGNATURE-----\r\n"},"maintainers":[{"email":"ioredis-robot@zihua.li","name":"ioredis-robot"},{"email":"i@zihua.li","name":"luin"}],"directories":{},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/ioredis_4.9.0_1552883276048_0.45323373589685656"},"_hasShrinkwrap":false},"4.9.1":{"name":"ioredis","version":"4.9.1","description":"A robust, performance-focused and full-featured Redis client for Node.js.","main":"built/index.js","scripts":{"test":"NODE_ENV=test mocha --timeout 8000 -r ts-node/register --exit","test:cov":"NODE_ENV=test node ./node_modules/istanbul/lib/cli.js cover --preserve-comments ./node_modules/mocha/bin/_mocha -- -r ts-node/register -R spec --exit","build":"rm -rf built && tsc","generate-docs":"jsdoc2md lib/redis.js lib/cluster/index.js lib/commander.js > API.md","prepublishOnly":"npm run build && npm test","bench":"matcha benchmarks/*.js","semantic-release":"semantic-release"},"repository":{"type":"git","url":"git://github.com/luin/ioredis.git"},"keywords":["redis","cluster","sentinel","pipelining"],"author":{"name":"luin","email":"i@zihua.li","url":"http://zihua.li"},"license":"MIT","dependencies":{"cluster-key-slot":"^1.0.6","debug":"^3.1.0","denque":"^1.1.0","flexbuffer":"github:mercadolibre/flexbuffer-node#1487df393a30872e3e81b246711a4cf6b0b23314","lodash.defaults":"^4.2.0","lodash.flatten":"^4.4.0","redis-commands":"1.4.0","redis-errors":"^1.2.0","redis-parser":"^3.0.0","standard-as-callback":"^2.0.1"},"devDependencies":{"@semantic-release/changelog":"^3.0.0","@semantic-release/git":"^7.0.4","@types/node":"^10.11.5","@types/redis-errors":"1.2.0","bluebird":"^3.5.1","chai":"^3.5.0","cz-conventional-changelog":"^2.0.0","istanbul":"^0.4.2","jsdoc":"^3.4.0","jsdoc-to-markdown":"^4.0.1","mocha":"^5.2.0","server-destroy":"^1.0.1","sinon":"^1.17.3","ts-node":"^7.0.0","typescript":"^3.1.1"},"engines":{"node":">=6"},"config":{"commitizen":{"path":"./node_modules/cz-conventional-changelog"}},"gitHead":"7736c1cf27af1cb991b95f592a5fbe89646facf6","readme":"[![ioredis](https://cdn.rawgit.com/luin/ioredis/57b5b89e3e9111ff25d8c62c0bc58ed42e5b8d1e/logo.svg)](https://github.com/luin/ioredis)\n\n[![Build Status](https://travis-ci.org/luin/ioredis.svg?branch=master)](https://travis-ci.org/luin/ioredis)\n[![Test Coverage](https://codeclimate.com/github/luin/ioredis/badges/coverage.svg)](https://codeclimate.com/github/luin/ioredis)\n[![Join the chat at https://gitter.im/luin/ioredis](https://badges.gitter.im/Join%20Chat.svg)](https://gitter.im/luin/ioredis?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge)\n[![Commitizen friendly](https://img.shields.io/badge/commitizen-friendly-brightgreen.svg)](http://commitizen.github.io/cz-cli/)\n[![semantic-release](https://img.shields.io/badge/%20%20%F0%9F%93%A6%F0%9F%9A%80-semantic--release-e10079.svg)](https://github.com/semantic-release/semantic-release)\n[![npm latest version](https://img.shields.io/npm/v/ioredis/latest.svg)](https://www.npmjs.com/package/ioredis)\n[![npm next version](https://img.shields.io/npm/v/ioredis/next.svg)](https://www.npmjs.com/package/ioredis)\n<img alt=\"\" src=\"\">\n\nA robust, performance-focused and full-featured [Redis](http://redis.io) client for [Node.js](https://nodejs.org).\n\nSupports Redis >= 2.6.12 and (Node.js >= 6).\n\n# Features\nioredis is a robust, full-featured Redis client that is\nused in the world's biggest online commerce company [Alibaba](http://www.alibaba.com/) and many other awesome companies.\n\n0. Full-featured. It supports [Cluster](http://redis.io/topics/cluster-tutorial), [Sentinel](http://redis.io/topics/sentinel), [Pipelining](http://redis.io/topics/pipelining) and of course [Lua scripting](http://redis.io/commands/eval) & [Pub/Sub](http://redis.io/topics/pubsub) (with the support of binary messages).\n0. High performance.\n0. Delightful API. It works with Node callbacks and Native promises.\n0. Transformation of command arguments and replies.\n0. Transparent key prefixing.\n0. Abstraction for Lua scripting, allowing you to define custom commands.\n0. Support for binary data.\n0. Support for TLS.\n0. Support for offline queue and ready checking.\n0. Support for ES6 types, such as `Map` and `Set`.\n0. Support for GEO commands (Redis 3.2 Unstable).\n0. Sophisticated error handling strategy.\n0. Support for NAT mapping.\n\n# Links\n* [API Documentation](API.md)\n* [Changelog](Changelog.md)\n* [Migrating from node_redis](https://github.com/luin/ioredis/wiki/Migrating-from-node_redis)\n* [Error Handling](#error-handling)\n\n## Become a Sponsor to Support ioredis's Development\nOpen source is hard and time-consuming. If you want to invest in ioredis's future you can become a sponsor and make us spend more time on this library's improvements and new features.\n\n<a href=\"https://opencollective.com/ioredis\"><img src=\"https://opencollective.com/ioredis/tiers/sponsor.svg?avatarHeight=36\"></a>\n\nThank you for using ioredis :-)\n\n<hr>\n<a href=\"https://itunes.apple.com/app/medis-gui-for-redis/id1063631769\"><img align=\"right\" src=\"medis.png\" alt=\"Download on the App Store\"></a>\n\n\n### Advertisement\n\nLooking for a Redis GUI manager for OS X, Windows and Linux? Here's [Medis](https://itunes.apple.com/us/app/medis-gui-for-redis/id1063631769)!\n\nMedis is an open-sourced, beautiful, easy-to-use Redis GUI management application.\n\nMedis starts with all the basic features you need:\n\n* Keys viewing/editing\n* SSH Tunnel for connecting with remote servers\n* Terminal for executing custom commands\n* JSON/MessagePack format viewing/editing and built-in highlighting/validator\n* And other awesome features...\n\n[Medis is open sourced on GitHub](https://github.com/luin/medis)\n\n<hr>\n\n# Quick Start\n\n## Install\n```shell\n$ npm install ioredis\n```\n\n## Basic Usage\n\n```javascript\nvar Redis = require('ioredis');\nvar redis = new Redis();\n\nredis.set('foo', 'bar');\nredis.get('foo', function (err, result) {\n  console.log(result);\n});\n\n// Or using a promise if the last argument isn't a function\nredis.get('foo').then(function (result) {\n  console.log(result);\n});\n\n// Arguments to commands are flattened, so the following are the same:\nredis.sadd('set', 1, 3, 5, 7);\nredis.sadd('set', [1, 3, 5, 7]);\n\n// All arguments are passed directly to the redis server:\nredis.set('key', 100, 'EX', 10);\n```\n\nSee the `examples/` folder for more examples.\n\n## Connect to Redis\nWhen a new `Redis` instance is created,\na connection to Redis will be created at the same time.\nYou can specify which Redis to connect to by:\n\n```javascript\nnew Redis()       // Connect to 127.0.0.1:6379\nnew Redis(6380)   // 127.0.0.1:6380\nnew Redis(6379, '192.168.1.1')        // 192.168.1.1:6379\nnew Redis('/tmp/redis.sock')\nnew Redis({\n  port: 6379,          // Redis port\n  host: '127.0.0.1',   // Redis host\n  family: 4,           // 4 (IPv4) or 6 (IPv6)\n  password: 'auth',\n  db: 0\n})\n```\n\nYou can also specify connection options as a [`redis://` URL](http://www.iana.org/assignments/uri-schemes/prov/redis):\n\n```javascript\n// Connect to 127.0.0.1:6380, db 4, using password \"authpassword\":\nnew Redis('redis://:authpassword@127.0.0.1:6380/4')\n```\n\nSee [API Documentation](API.md#new_Redis) for all available options.\n\n## Pub/Sub\n\nHere is a simple example of the API for publish/subscribe.\nThe following program opens two client connections.\nIt subscribes to a channel with one connection\nand publishes to that channel with the other:\n\n```javascript\nvar Redis = require('ioredis');\nvar redis = new Redis();\nvar pub = new Redis();\nredis.subscribe('news', 'music', function (err, count) {\n  // Now we are subscribed to both the 'news' and 'music' channels.\n  // `count` represents the number of channels we are currently subscribed to.\n\n  pub.publish('news', 'Hello world!');\n  pub.publish('music', 'Hello again!');\n});\n\nredis.on('message', function (channel, message) {\n  // Receive message Hello world! from channel news\n  // Receive message Hello again! from channel music\n  console.log('Receive message %s from channel %s', message, channel);\n});\n\n// There's also an event called 'messageBuffer', which is the same as 'message' except\n// it returns buffers instead of strings.\nredis.on('messageBuffer', function (channel, message) {\n  // Both `channel` and `message` are buffers.\n});\n```\n\n`PSUBSCRIBE` is also supported in a similar way:\n\n```javascript\nredis.psubscribe('pat?ern', function (err, count) {});\nredis.on('pmessage', function (pattern, channel, message) {});\nredis.on('pmessageBuffer', function (pattern, channel, message) {});\n```\n\nWhen a client issues a SUBSCRIBE or PSUBSCRIBE, that connection is put into a \"subscriber\" mode.\nAt that point, only commands that modify the subscription set are valid.\nWhen the subscription set is empty, the connection is put back into regular mode.\n\nIf you need to send regular commands to Redis while in subscriber mode, just open another connection.\n\n## Handle Binary Data\nArguments can be buffers:\n```javascript\nredis.set('foo', Buffer.from('bar'));\n```\n\nAnd every command has a method that returns a Buffer (by adding a suffix of \"Buffer\" to the command name).\nTo get a buffer instead of a utf8 string:\n\n```javascript\nredis.getBuffer('foo', function (err, result) {\n  // result is a buffer.\n});\n```\n\n## Pipelining\nIf you want to send a batch of commands (e.g. > 5), you can use pipelining to queue\nthe commands in memory and then send them to Redis all at once. This way the performance improves by 50%~300% (See [benchmark section](#benchmark)).\n\n`redis.pipeline()` creates a `Pipeline` instance. You can call any Redis\ncommands on it just like the `Redis` instance. The commands are queued in memory\nand flushed to Redis by calling the `exec` method:\n\n```javascript\nvar pipeline = redis.pipeline();\npipeline.set('foo', 'bar');\npipeline.del('cc');\npipeline.exec(function (err, results) {\n  // `err` is always null, and `results` is an array of responses\n  // corresponding to the sequence of queued commands.\n  // Each response follows the format `[err, result]`.\n});\n\n// You can even chain the commands:\nredis.pipeline().set('foo', 'bar').del('cc').exec(function (err, results) {\n});\n\n// `exec` also returns a Promise:\nvar promise = redis.pipeline().set('foo', 'bar').get('foo').exec();\npromise.then(function (result) {\n  // result === [[null, 'OK'], [null, 'bar']]\n});\n```\n\nEach chained command can also have a callback, which will be invoked when the command\ngets a reply:\n\n```javascript\nredis.pipeline().set('foo', 'bar').get('foo', function (err, result) {\n  // result === 'bar'\n}).exec(function (err, result) {\n  // result[1][1] === 'bar'\n});\n```\n\nIn addition to adding commands to the `pipeline` queue individually, you can also pass an array of commands and arguments to the constructor:\n\n```javascript\nredis.pipeline([\n  ['set', 'foo', 'bar'],\n  ['get', 'foo']\n]).exec(function () { /* ... */ });\n```\n\n`#length` property shows how many commands in the pipeline:\n\n```javascript\nconst length = redis.pipeline().set('foo', 'bar').get('foo').length;\n// length === 2\n```\n\n\n## Transaction\nMost of the time, the transaction commands `multi` & `exec` are used together with pipeline.\nTherefore, when `multi` is called, a `Pipeline` instance is created automatically by default,\nso you can use `multi` just like `pipeline`:\n\n```javascript\nredis.multi().set('foo', 'bar').get('foo').exec(function (err, results) {\n  // results === [[null, 'OK'], [null, 'bar']]\n});\n```\nIf there's a syntax error in the transaction's command chain (e.g. wrong number of arguments, wrong command name, etc),\nthen none of the commands would be executed, and an error is returned:\n\n```javascript\nredis.multi().set('foo').set('foo', 'new value').exec(function (err, results) {\n  // err:\n  //  { [ReplyError: EXECABORT Transaction discarded because of previous errors.]\n  //    name: 'ReplyError',\n  //    message: 'EXECABORT Transaction discarded because of previous errors.',\n  //    command: { name: 'exec', args: [] },\n  //    previousErrors:\n  //     [ { [ReplyError: ERR wrong number of arguments for 'set' command]\n  //         name: 'ReplyError',\n  //         message: 'ERR wrong number of arguments for \\'set\\' command',\n  //         command: [Object] } ] }\n});\n```\n\nIn terms of the interface, `multi` differs from `pipeline` in that when specifying a callback\nto each chained command, the queueing state is passed to the callback instead of the result of the command:\n\n```javascript\nredis.multi().set('foo', 'bar', function (err, result) {\n  // result === 'QUEUED'\n}).exec(/* ... */);\n```\n\nIf you want to use transaction without pipeline, pass `{ pipeline: false }` to `multi`,\nand every command will be sent to Redis immediately without waiting for an `exec` invocation:\n\n```javascript\nredis.multi({ pipeline: false });\nredis.set('foo', 'bar');\nredis.get('foo');\nredis.exec(function (err, result) {\n  // result === [[null, 'OK'], [null, 'bar']]\n});\n```\n\nThe constructor of `multi` also accepts a batch of commands:\n\n```javascript\nredis.multi([\n  ['set', 'foo', 'bar'],\n  ['get', 'foo']\n]).exec(function () { /* ... */ });\n```\n\nInline transactions are supported by pipeline, which means you can group a subset of commands\nin the pipeline into a transaction:\n\n```javascript\nredis.pipeline().get('foo').multi().set('foo', 'bar').get('foo').exec().get('foo').exec();\n```\n\n## Lua Scripting\nioredis supports all of the scripting commands such as `EVAL`, `EVALSHA` and `SCRIPT`.\nHowever, it's tedious to use in real world scenarios since developers have to take\ncare of script caching and to detect when to use `EVAL` and when to use `EVALSHA`.\nioredis expose a `defineCommand` method to make scripting much easier to use:\n\n```javascript\nvar redis = new Redis();\n\n// This will define a command echo:\nredis.defineCommand('echo', {\n  numberOfKeys: 2,\n  lua: 'return {KEYS[1],KEYS[2],ARGV[1],ARGV[2]}'\n});\n\n// Now `echo` can be used just like any other ordinary command,\n// and ioredis will try to use `EVALSHA` internally when possible for better performance.\nredis.echo('k1', 'k2', 'a1', 'a2', function (err, result) {\n  // result === ['k1', 'k2', 'a1', 'a2']\n});\n\n// `echoBuffer` is also defined automatically to return buffers instead of strings:\nredis.echoBuffer('k1', 'k2', 'a1', 'a2', function (err, result) {\n  // result[0] equals to Buffer.from('k1');\n});\n\n// And of course it works with pipeline:\nredis.pipeline().set('foo', 'bar').echo('k1', 'k2', 'a1', 'a2').exec();\n```\n\nIf the number of keys can't be determined when defining a command, you can\nomit the `numberOfKeys` property and pass the number of keys as the first argument\nwhen you call the command:\n\n```javascript\nredis.defineCommand('echoDynamicKeyNumber', {\n  lua: 'return {KEYS[1],KEYS[2],ARGV[1],ARGV[2]}'\n});\n\n// Now you have to pass the number of keys as the first argument every time\n// you invoke the `echoDynamicKeyNumber` command:\nredis.echoDynamicKeyNumber(2, 'k1', 'k2', 'a1', 'a2', function (err, result) {\n  // result === ['k1', 'k2', 'a1', 'a2']\n});\n```\n\n## Transparent Key Prefixing\nThis feature allows you to specify a string that will automatically be prepended\nto all the keys in a command, which makes it easier to manage your key\nnamespaces.\n\n**Warning** This feature won't apply to commands like [KEYS](http://redis.io/commands/KEYS) and [SCAN](http://redis.io/commands/scan) that take patterns rather than actual keys([#239](https://github.com/luin/ioredis/issues/239)),\nand this feature also won't apply to the replies of commands even they are key names ([#325](https://github.com/luin/ioredis/issues/325)).\n\n```javascript\nvar fooRedis = new Redis({ keyPrefix: 'foo:' });\nfooRedis.set('bar', 'baz');  // Actually sends SET foo:bar baz\n\nfooRedis.defineCommand('echo', {\n  numberOfKeys: 2,\n  lua: 'return {KEYS[1],KEYS[2],ARGV[1],ARGV[2]}'\n});\n\n// Works well with pipelining/transaction\nfooRedis.pipeline()\n  // Sends SORT foo:list BY foo:weight_*->fieldname\n  .sort('list', 'BY', 'weight_*->fieldname')\n  // Supports custom commands\n  // Sends EVALSHA xxx foo:k1 foo:k2 a1 a2\n  .echo('k1', 'k2', 'a1', 'a2')\n  .exec()\n```\n\n## Transforming Arguments & Replies\nMost Redis commands take one or more Strings as arguments,\nand replies are sent back as a single String or an Array of Strings. However, sometimes\nyou may want something different. For instance, it would be more convenient if the `HGETALL`\ncommand returns a hash (e.g. `{ key: val1, key2: v2 }`) rather than an array of key values (e.g. `[key1, val1, key2, val2]`).\n\nioredis has a flexible system for transforming arguments and replies. There are two types\nof transformers, argument transformer and reply transformer:\n\n```javascript\nvar Redis = require('ioredis');\n\n// Here's the built-in argument transformer converting\n// hmset('key', { k1: 'v1', k2: 'v2' })\n// or\n// hmset('key', new Map([['k1', 'v1'], ['k2', 'v2']]))\n// into\n// hmset('key', 'k1', 'v1', 'k2', 'v2')\nRedis.Command.setArgumentTransformer('hmset', function (args) {\n  if (args.length === 2) {\n    if (typeof Map !== 'undefined' && args[1] instanceof Map) {\n      // utils is a internal module of ioredis\n      return [args[0]].concat(utils.convertMapToArray(args[1]));\n    }\n    if ( typeof args[1] === 'object' && args[1] !== null) {\n      return [args[0]].concat(utils.convertObjectToArray(args[1]));\n    }\n  }\n  return args;\n});\n\n// Here's the built-in reply transformer converting the HGETALL reply\n// ['k1', 'v1', 'k2', 'v2']\n// into\n// { k1: 'v1', 'k2': 'v2' }\nRedis.Command.setReplyTransformer('hgetall', function (result) {\n  if (Array.isArray(result)) {\n    var obj = {};\n    for (var i = 0; i < result.length; i += 2) {\n      obj[result[i]] = result[i + 1];\n    }\n    return obj;\n  }\n  return result;\n});\n```\n\nThere are three built-in transformers, two argument transformers for `hmset` & `mset` and\na reply transformer for `hgetall`. Transformers for `hmset` and `hgetall` were mentioned\nabove, and the transformer for `mset` is similar to the one for `hmset`:\n\n```javascript\nredis.mset({ k1: 'v1', k2: 'v2' });\nredis.get('k1', function (err, result) {\n  // result === 'v1';\n});\n\nredis.mset(new Map([['k3', 'v3'], ['k4', 'v4']]));\nredis.get('k3', function (err, result) {\n  // result === 'v3';\n});\n```\n\nAnother useful example of a reply transformer is one that changes `hgetall` to return array of arrays instead of objects which avoids a unwanted conversation of hash keys to strings when dealing with binary hash keys:\n\n```javascript\nRedis.Command.setReplyTransformer('hgetall', function (result) {\n  var arr = [];\n  for (var i = 0; i < result.length; i += 2) {\n    arr.push([result[i], result[i + 1]]);\n  }\n  return arr;\n});\nredis.hset('h1', Buffer.from([0x01]), Buffer.from([0x02]));\nredis.hset('h1', Buffer.from([0x03]), Buffer.from([0x04]));\nredis.hgetallBuffer('h1', function (err, result) {\n  // result === [ [ <Buffer 01>, <Buffer 02> ], [ <Buffer 03>, <Buffer 04> ] ];\n});\n```\n\n## Monitor\nRedis supports the MONITOR command,\nwhich lets you see all commands received by the Redis server across all client connections,\nincluding from other client libraries and other computers.\n\nThe `monitor` method returns a monitor instance.\nAfter you send the MONITOR command, no other commands are valid on that connection. ioredis will emit a monitor event for every new monitor message that comes across.\nThe callback for the monitor event takes a timestamp from the Redis server and an array of command arguments.\n\nHere is a simple example:\n\n```javascript\nredis.monitor(function (err, monitor) {\n  monitor.on('monitor', function (time, args, source, database) {\n  });\n});\n```\n\n## Streamify Scanning\nRedis 2.8 added the `SCAN` command to incrementally iterate through the keys in the database. It's different from `KEYS` in that\n`SCAN` only returns a small number of elements each call, so it can be used in production without the downside\nof blocking the server for a long time. However, it requires recording the cursor on the client side each time\nthe `SCAN` command is called in order to iterate through all the keys correctly. Since it's a relatively common use case, ioredis\nprovides a streaming interface for the `SCAN` command to make things much easier. A readable stream can be created by calling `scanStream`:\n\n```javascript\nvar redis = new Redis();\n// Create a readable stream (object mode)\nvar stream = redis.scanStream();\nstream.on('data', function (resultKeys) {\n  // `resultKeys` is an array of strings representing key names.\n  // Note that resultKeys may contain 0 keys, and that it will sometimes\n  // contain duplicates due to SCAN's implementation in Redis.\n  for (var i = 0; i < resultKeys.length; i++) {\n    console.log(resultKeys[i]);\n  }\n});\nstream.on('end', function () {\n  console.log('all keys have been visited');\n});\n```\n\n`scanStream` accepts an option, with which you can specify the `MATCH` pattern and the `COUNT` argument:\n\n```javascript\nvar stream = redis.scanStream({\n  // only returns keys following the pattern of `user:*`\n  match: 'user:*',\n  // returns approximately 100 elements per call\n  count: 100\n});\n```\n\nJust like other commands, `scanStream` has a binary version `scanBufferStream`, which returns an array of buffers. It's useful when\nthe key names are not utf8 strings.\n\nThere are also `hscanStream`, `zscanStream` and `sscanStream` to iterate through elements in a hash, zset and set. The interface of each is\nsimilar to `scanStream` except the first argument is the key name:\n\n```javascript\nvar stream = redis.hscanStream('myhash', {\n  match: 'age:??'\n});\n```\n\nYou can learn more from the [Redis documentation](http://redis.io/commands/scan).\n\n**Useful Tips**\nIt's pretty common that doing an async task in the `data` handler. We'd like the scanning process to be paused until the async task to be finished. `Stream#pause()` and `Stream.resume()` do the trick. For example if we want to migrate data in Redis to MySQL:\n\n```javascript\nvar stream = redis.scanStream();\nstream.on('data', function (resultKeys) {\n  // Pause the stream from scanning more keys until we've migrated the current keys.\n  stream.pause();\n\n  Promise.all(resultKeys.map(migrateKeyToMySQL)).then(() => {\n    // Resume the stream here.\n    stream.resume();\n  });\n});\n\nstream.on('end', function () {\n  console.log('done migration');\n});\n```\n\n## Auto-reconnect\nBy default, ioredis will try to reconnect when the connection to Redis is lost\nexcept when the connection is closed manually by `redis.disconnect()` or `redis.quit()`.\n\nIt's very flexible to control how long to wait to reconnect after disconnection\nusing the `retryStrategy` option:\n\n```javascript\nvar redis = new Redis({\n  // This is the default value of `retryStrategy`\n  retryStrategy: function (times) {\n    var delay = Math.min(times * 50, 2000);\n    return delay;\n  }\n});\n```\n\n`retryStrategy` is a function that will be called when the connection is lost.\nThe argument `times` means this is the nth reconnection being made and\nthe return value represents how long (in ms) to wait to reconnect. When the\nreturn value isn't a number, ioredis will stop trying to reconnect, and the connection\nwill be lost forever if the user doesn't call `redis.connect()` manually.\n\nWhen reconnected, the client will auto subscribe to channels that the previous connection subscribed to.\nThis behavior can be disabled by setting the `autoResubscribe` option to `false`.\n\nAnd if the previous connection has some unfulfilled commands (most likely blocking commands such as `brpop` and `blpop`),\nthe client will resend them when reconnected. This behavior can be disabled by setting the `autoResendUnfulfilledCommands` option to `false`.\n\nBy default, all pending commands will be flushed with an error every 20 retry attempts. That makes sure commands won't wait forever when the connection is down. You can change this behavior by setting `maxRetriesPerRequest`:\n\n```javascript\nvar redis = new Redis({\n  maxRetriesPerRequest: 1\n});\n```\n\nSet maxRetriesPerRequest to `null` to disable this behavior, and every command will wait forever until the connection is alive again (which is the default behavior before ioredis v4).\n\n### Reconnect on error\n\nBesides auto-reconnect when the connection is closed, ioredis supports reconnecting on the specified errors by the `reconnectOnError` option. Here's an example that will reconnect when receiving `READONLY` error:\n\n```javascript\nvar redis = new Redis({\n  reconnectOnError: function (err) {\n    var targetError = 'READONLY';\n    if (err.message.slice(0, targetError.length) === targetError) {\n      // Only reconnect when the error starts with \"READONLY\"\n      return true; // or `return 1;`\n    }\n  }\n});\n```\n\nThis feature is useful when using Amazon ElastiCache. Once failover happens, Amazon ElastiCache will switch the master we currently connected with to a slave, leading to the following writes fails with the error `READONLY`. Using `reconnectOnError`, we can force the connection to reconnect on this error in order to connect to the new master.\n\nFurthermore, if the `reconnectOnError` returns `2`, ioredis will resend the failed command after reconnecting.\n\n## Connection Events\nThe Redis instance will emit some events about the state of the connection to the Redis server.\n\nEvent    | Description\n:------------- | :-------------\nconnect  | emits when a connection is established to the Redis server.\nready    | If `enableReadyCheck` is `true`, client will emit `ready` when the server reports that it is ready to receive commands (e.g. finish loading data from disk).<br>Otherwise, `ready` will be emitted immediately right after the `connect` event.\nerror    | emits when an error occurs while connecting.<br>However, ioredis emits all `error` events silently (only emits when there's at least one listener) so that your application won't crash if you're not listening to the `error` event.\nclose    | emits when an established Redis server connection has closed.\nreconnecting | emits after `close` when a reconnection will be made. The argument of the event is the time (in ms) before reconnecting.\nend     | emits after `close` when no more reconnections will be made, or the connection is failed to establish.\n\nYou can also check out the `Redis#status` property to get the current connection status.\n\nBesides the above connection events, there are several other custom events:\n\nEvent    | Description\n:------------- | :-------------\nselect   | emits when the database changed. The argument is the new db number.\n\n## Offline Queue\nWhen a command can't be processed by Redis (being sent before the `ready` event), by default, it's added to the offline queue and will be\nexecuted when it can be processed. You can disable this feature by setting the `enableOfflineQueue`\noption to `false`:\n\n```javascript\nvar redis = new Redis({ enableOfflineQueue: false });\n```\n\n## TLS Options\nRedis doesn't support TLS natively, however if the redis server you want to connect to is hosted behind a TLS proxy (e.g. [stunnel](https://www.stunnel.org/)) or is offered by a PaaS service that supports TLS connection (e.g. [Redis Labs](https://redislabs.com/)), you can set the `tls` option:\n\n```javascript\nvar redis = new Redis({\n  host: 'localhost',\n  tls: {\n    // Refer to `tls.connect()` section in\n    // https://nodejs.org/api/tls.html\n    // for all supported options\n    ca: fs.readFileSync('cert.pem')\n  }\n});\n```\n\n<hr>\n\n## Sentinel\nioredis supports Sentinel out of the box. It works transparently as all features that work when\nyou connect to a single node also work when you connect to a sentinel group. Make sure to run Redis >= 2.8.12 if you want to use this feature. Sentinels have a default port of 26379.\n\nTo connect using Sentinel, use:\n\n```javascript\nvar redis = new Redis({\n  sentinels: [{ host: 'localhost', port: 26379 }, { host: 'localhost', port: 26380 }],\n  name: 'mymaster'\n});\n\nredis.set('foo', 'bar');\n```\n\nThe arguments passed to the constructor are different from the ones you use to connect to a single node, where:\n\n* `name` identifies a group of Redis instances composed of a master and one or more slaves (`mymaster` in the example);\n* `sentinelPassword` (optional) password for Sentinel instances.\n* `sentinels` are a list of sentinels to connect to. The list does not need to enumerate all your sentinel instances, but a few so that if one is down the client will try the next one.\n* `role` (optional) with a value of `slave` will return a random slave from the Sentinel group.\n* `preferredSlaves` (optional) can be used to prefer a particular slave or set of slaves based on priority. It accepts a function or array.\n\nioredis **guarantees** that the node you connected to is always a master even after a failover. When a failover happens, instead of trying to reconnect to the failed node (which will be demoted to slave when it's available again), ioredis will ask sentinels for the new master node and connect to it. All commands sent during the failover are queued and will be executed when the new connection is established so that none of the commands will be lost.\n\nIt's possible to connect to a slave instead of a master by specifying the option `role` with the value of `slave` and ioredis will try to connect to a random slave of the specified master, with the guarantee that the connected node is always a slave. If the current node is promoted to master due to a failover, ioredis will disconnect from it and ask the sentinels for another slave node to connect to.\n\nIf you specify the option `preferredSlaves` along with `role: 'slave'` ioredis will attempt to use this value when selecting the slave from the pool of available slaves. The value of `preferredSlaves` should either be a function that accepts an array of avaiable slaves and returns a single result, or an array of slave values priorities by the lowest `prio` value first with a default value of `1`.\n\n```javascript\n// available slaves format\nvar availableSlaves = [{ ip: '127.0.0.1', port: '31231', flags: 'slave' }];\n\n// preferredSlaves array format\nvar preferredSlaves = [\n  { ip: '127.0.0.1', port: '31231', prio: 1 },\n  { ip: '127.0.0.1', port: '31232', prio: 2 }\n];\n\n// preferredSlaves function format\npreferredSlaves = function(availableSlaves) {\n  for (var i = 0; i < availableSlaves.length; i++) {\n    var slave = availableSlaves[i];\n    if (slave.ip === '127.0.0.1') {\n      if (slave.port === '31234') {\n        return slave;\n      }\n    }\n  }\n  // if no preferred slaves are available a random one is used\n  return false;\n};\n\nvar redis = new Redis({\n  sentinels: [{ host: '127.0.0.1', port: 26379 }, { host: '127.0.0.1', port: 26380 }],\n  name: 'mymaster',\n  role: 'slave',\n  preferredSlaves: preferredSlaves\n});\n```\n\nBesides the `retryStrategy` option, there's also a `sentinelRetryStrategy` in Sentinel mode which will be invoked when all the sentinel nodes are unreachable during connecting. If `sentinelRetryStrategy` returns a valid delay time, ioredis will try to reconnect from scratch. The default value of `sentinelRetryStrategy` is:\n\n```javascript\nfunction (times) {\n  var delay = Math.min(times * 10, 1000);\n  return delay;\n}\n```\n\n## Cluster\nRedis Cluster provides a way to run a Redis installation where data is automatically sharded across multiple Redis nodes.\nYou can connect to a Redis Cluster like this:\n\n```javascript\nvar Redis = require('ioredis');\n\nvar cluster = new Redis.Cluster([{\n  port: 6380,\n  host: '127.0.0.1'\n}, {\n  port: 6381,\n  host: '127.0.0.1'\n}]);\n\ncluster.set('foo', 'bar');\ncluster.get('foo', function (err, res) {\n  // res === 'bar'\n});\n```\n\n`Cluster` constructor accepts two arguments, where:\n\n0. The first argument is a list of nodes of the cluster you want to connect to.\nJust like Sentinel, the list does not need to enumerate all your cluster nodes,\nbut a few so that if one is unreachable the client will try the next one, and the client will discover other nodes automatically when at least one node is connected.\n0. The second argument is the options, where:\n\n    * `clusterRetryStrategy`: When none of the startup nodes are reachable, `clusterRetryStrategy` will be invoked. When a number is returned,\n    ioredis will try to reconnect to the startup nodes from scratch after the specified delay (in ms). Otherwise, an error of \"None of startup nodes is available\" will be returned.\n    The default value of this option is:\n\n        ```javascript\n        function (times) {\n          var delay = Math.min(100 + times * 2, 2000);\n          return delay;\n        }\n        ```\n\n        It's possible to modify the `startupNodes` property in order to switch to another set of nodes here:\n\n        ```javascript\n        function (times) {\n          this.startupNodes = [{ port: 6790, host: '127.0.0.1' }];\n          return Math.min(100 + times * 2, 2000);\n        }\n        ```\n\n    * `enableOfflineQueue`: Similar to the `enableOfflineQueue` option of `Redis` class.\n    * `enableReadyCheck`: When enabled, \"ready\" event will only be emitted when `CLUSTER INFO` command\n    reporting the cluster is ready for handling commands. Otherwise, it will be emitted immediately after \"connect\" is emitted.\n    * `scaleReads`: Config where to send the read queries. See below for more details.\n    * `maxRedirections`: When a cluster related error (e.g. `MOVED`, `ASK` and `CLUSTERDOWN` etc.) is received, the client will redirect the\n    command to another node. This option limits the max redirections allowed when sending a command. The default value is `16`.\n    * `retryDelayOnFailover`: If the target node is disconnected when sending a command,\n    ioredis will retry after the specified delay. The default value is `100`. You should make sure `retryDelayOnFailover * maxRedirections > cluster-node-timeout`\n    to insure that no command will fail during a failover.\n    * `retryDelayOnClusterDown`: When a cluster is down, all commands will be rejected with the error of `CLUSTERDOWN`. If this option is a number (by default, it is `100`), the client\n    will resend the commands after the specified time (in ms).\n    * `retryDelayOnTryAgain`: If this option is a number (by default, it is `100`), the client\n    will resend the commands rejected with `TRYAGAIN` error after the specified time (in ms).\n    * `redisOptions`: Default options passed to the constructor of `Redis` when connecting to a node.\n    * `slotsRefreshTimeout`: Milliseconds before a timeout occurs while refreshing slots from the cluster (default `1000`)\n    * `slotsRefreshInterval`: Milliseconds between every automatic slots refresh (default `5000`)\n\n### Read-write splitting\n\nA typical redis cluster contains three or more masters and several slaves for each master. It's possible to scale out redis cluster by sending read queries to slaves and write queries to masters by setting the `scaleReads` option.\n\n`scaleReads` is \"master\" by default, which means ioredis will never send any queries to slaves. There are other three available options:\n\n1. \"all\": Send write queries to masters and read queries to masters or slaves randomly.\n2. \"slave\": Send write queries to masters and read queries to slaves.\n3. a custom `function(nodes, command): node`: Will choose the custom function to select to which node to send read queries (write queries keep being sent to master). The first node in `nodes` is always the master serving the relevant slots. If the function returns an array of nodes, a random node of that list will be selected.\n\nFor example:\n\n```javascript\nvar cluster = new Redis.Cluster([/* nodes */], {\n  scaleReads: 'slave'\n});\ncluster.set('foo', 'bar'); // This query will be sent to one of the masters.\ncluster.get('foo', function (err, res) {\n  // This query will be sent to one of the slaves.\n});\n```\n\n**NB** In the code snippet above, the `res` may not be equal to \"bar\" because of the lag of replication between the master and slaves.\n\n### Running commands to multiple nodes\n\nEvery command will be sent to exactly one node. For commands containing keys, (e.g. `GET`, `SET` and `HGETALL`), ioredis sends them to the node that serving the keys, and for other commands not containing keys, (e.g. `INFO`, `KEYS` and `FLUSHDB`), ioredis sends them to a random node.\n\nSometimes you may want to send a command to multiple nodes (masters or slaves) of the cluster, you can get the nodes via `Cluster#nodes()` method.\n\n`Cluster#nodes()` accepts a parameter role, which can be \"master\", \"slave\" and \"all\" (default), and returns an array of `Redis` instance. For example:\n\n```javascript\n// Send `FLUSHDB` command to all slaves:\nvar slaves = cluster.nodes('slave');\nPromise.all(slaves.map(function (node) {\n  return node.flushdb();\n}));\n\n// Get keys of all the masters:\nvar masters = cluster.nodes('master');\nPromise.all(masters.map(function (node) {\n  return node.keys();\n})).then(function (keys) {\n  // keys: [['key1', 'key2'], ['key3', 'key4']]\n});\n```\n\n### NAT Mapping\nSometimes the cluster is hosted within a internal network that can only be accessed via a NAT (Network Address Translation) instance. See [Accessing ElastiCache from outside AWS](https://docs.aws.amazon.com/AmazonElastiCache/latest/red-ug/accessing-elasticache.html) as an example.\n\nYou can specify nat mapping rules via `natMap` option:\n\n```javascript\nconst cluster = new Redis.Cluster([{\n  host: '203.0.113.73',\n  port: 30001\n}], {\n  natMap: {\n    '10.0.1.230:30001': {host: '203.0.113.73', port: 30001},\n    '10.0.1.231:30001': {host: '203.0.113.73', port: 30002},\n    '10.0.1.232:30001': {host: '203.0.113.73', port: 30003}\n  }\n})\n```\n\nThis option is also useful when the cluster is running inside a Docker container.\n\n### Transaction and pipeline in Cluster mode\nAlmost all features that are supported by `Redis` are also supported by `Redis.Cluster`, e.g. custom commands, transaction and pipeline.\nHowever there are some differences when using transaction and pipeline in Cluster mode:\n\n0. All keys in a pipeline should belong to the same slot since ioredis sends all commands in a pipeline to the same node.\n0. You can't use `multi` without pipeline (aka `cluster.multi({ pipeline: false })`). This is because when you call `cluster.multi({ pipeline: false })`, ioredis doesn't know which node the `multi` command should be sent to.\n0. Chaining custom commands in the pipeline is not supported in Cluster mode.\n\nWhen any commands in a pipeline receives a `MOVED` or `ASK` error, ioredis will resend the whole pipeline to the specified node automatically if all of the following conditions are satisfied:\n\n0. All errors received in the pipeline are the same. For example, we won't resend the pipeline if we got two `MOVED` errors pointing to different nodes.\n0. All commands executed successfully are readonly commands. This makes sure that resending the pipeline won't have side effects.\n\n### Pub/Sub\nPub/Sub in cluster mode works exactly as the same as in standalone mode. Internally, when a node of the cluster receives a message, it will broadcast the message to the other nodes. ioredis makes sure that each message will only be received once by strictly subscribing one node at the same time.\n\n```javascript\nvar nodes = [/* nodes */];\nvar pub = new Redis.Cluster(nodes);\nvar sub = new Redis.Cluster(nodes);\nsub.on('message', function (channel, message) {\n  console.log(channel, message);\n});\n\nsub.subscribe('news', function () {\n  pub.publish('news', 'highlights');\n});\n```\n\n### Events\n\nEvent    | Description\n:------------- | :-------------\nconnect  | emits when a connection is established to the Redis server.\nready    | emits when `CLUSTER INFO` reporting the cluster is able to receive commands (if `enableReadyCheck` is `true`) or immediately after `connect` event (if `enableReadyCheck` is false).\nerror    | emits when an error occurs while connecting with a property of `lastNodeError` representing the last node error received. This event is emitted silently (only emitting if there's at least one listener).\nclose    | emits when an established Redis server connection has closed.\nreconnecting | emits after `close` when a reconnection will be made. The argument of the event is the time (in ms) before reconnecting.\nend     | emits after `close` when no more reconnections will be made.\n+node   | emits when a new node is connected.\n-node   | emits when a node is disconnected.\nnode error | emits when an error occurs when connecting to a node. The second argument indicates the address of the node.\n\n### Password\nSetting the `password` option to access password-protected clusters:\n\n```javascript\nvar Redis = require('ioredis');\nvar cluster = new Redis.Cluster(nodes, {\n  redisOptions: {\n    password: 'your-cluster-password'\n  }\n});\n```\n\nIf some of nodes in the cluster using a different password, you should specify them in the first parameter:\n\n```javascript\nvar Redis = require('ioredis');\nvar cluster = new Redis.Cluster([\n  // Use password \"password-for-30001\" for 30001\n  { port: 30001, password: 'password-for-30001'},\n  // Don't use password when accessing 30002\n  { port: 30002, password: null }\n  // Other nodes will use \"fallback-password\"\n], {\n  redisOptions: {\n    password: 'fallback-password'\n  }\n});\n```\n\n<hr>\n\n# Error Handling\nAll the errors returned by the Redis server are instances of `ReplyError`, which can be accessed via `Redis`:\n\n```javascript\nvar Redis = require('ioredis');\nvar redis = new Redis();\n// This command causes a reply error since the SET command requires two arguments.\nredis.set('foo', function (err) {\n  err instanceof Redis.ReplyError\n});\n```\n\nThis is the error stack of the `ReplyError`:\n\n```\nReplyError: ERR wrong number of arguments for 'set' command\n    at ReplyParser._parseResult (/app/node_modules/ioredis/lib/parsers/javascript.js:60:14)\n    at ReplyParser.execute (/app/node_modules/ioredis/lib/parsers/javascript.js:178:20)\n    at Socket.<anonymous> (/app/node_modules/ioredis/lib/redis/event_handler.js:99:22)\n    at Socket.emit (events.js:97:17)\n    at readableAddChunk (_stream_readable.js:143:16)\n    at Socket.Readable.push (_stream_readable.js:106:10)\n    at TCP.onread (net.js:509:20)\n```\n\nBy default, the error stack doesn't make any sense because the whole stack happens in the ioredis\nmodule itself, not in your code. So it's not easy to find out where the error happens in your code.\nioredis provides an option `showFriendlyErrorStack` to solve the problem. When you enable\n`showFriendlyErrorStack`, ioredis will optimize the error stack for you:\n\n```javascript\nvar Redis = require('ioredis');\nvar redis = new Redis({ showFriendlyErrorStack: true });\nredis.set('foo');\n```\n\nAnd the output will be:\n\n```\nReplyError: ERR wrong number of arguments for 'set' command\n    at Object.<anonymous> (/app/index.js:3:7)\n    at Module._compile (module.js:446:26)\n    at Object.Module._extensions..js (module.js:464:10)\n    at Module.load (module.js:341:32)\n    at Function.Module._load (module.js:296:12)\n    at Function.Module.runMain (module.js:487:10)\n    at startup (node.js:111:16)\n    at node.js:799:3\n```\n\nThis time the stack tells you that the error happens on the third line in your code. Pretty sweet!\nHowever, it would decrease the performance significantly to optimize the error stack. So by\ndefault, this option is disabled and can only be used for debugging purposes. You **shouldn't** use this feature in a production environment.\n\n# Plugging in your own Promises Library\nIf you're an advanced user, you may want to plug in your own promise library like [bluebird](https://www.npmjs.com/package/bluebird). Just set Redis.Promise to your favorite ES6-style promise constructor and ioredis will use it.\n\n```javascript\nconst Redis = require('ioredis')\nRedis.Promise = require('bluebird')\n\nconst redis = new Redis()\n\n// Use bluebird\nassert.equal(redis.get().constructor, require('bluebird'))\n\n// You can change the Promise implementation at any time:\nRedis.Promise = global.Promise\nassert.equal(redis.get().constructor, global.Promise)\n```\n\n\n# Running tests\n\nStart a Redis server on 127.0.0.1:6379, and then:\n\n```shell\n$ npm test\n```\n\n`FLUSH ALL` will be invoked after each test, so make sure there's no valuable data in it before running tests.\n\nIf your testing environment does not let you spin up a Redis server [ioredis-mock](https://github.com/stipsan/ioredis-mock) is a drop-in replacement you can use in your tests. It aims to behave identically to ioredis connected to a Redis server so that your integration tests is easier to write and of better quality.\n\n# Debug\n\nYou can set the `DEBUG` env to `ioredis:*` to print debug info:\n\n```shell\n$ DEBUG=ioredis:* node app.js\n```\n\n# Consolidation: It's time for celebration\n\nRight now there are two great redis clients around and both have some advantages above each other. We speak about [node_redis](https://github.com/NodeRedis/node_redis) and ioredis. So after talking to each other about how we could improve in working together we (that is [@BridgeAR](https://github.com/BridgeAR) and [@luin](https://github.com/luin)) decided to work towards a single library on the long run. But step by step.\n\nFirst of all, we want to split small parts of our libraries into others so that we're both able to use the same code. Those libraries are going to be maintained under the NodeRedis organization. This is going to reduce the maintance overhead, allows others to use the very same code, if they need it and it's way easier for others to contribute to both libraries.\n\nWe're very happy about this step towards working together as we both want to give you the best redis experience possible.\n\nIf you want to join our cause by help maintaining something, please don't hesitate to contact either one of us.\n\n# Join in!\n\nI'm happy to receive bug reports, fixes, documentation enhancements, and any other improvements.\n\nAnd since I'm not a native English speaker, if you find any grammar mistakes in the documentation, please also let me know. :)\n\n# Contributors\n\nThis project exists thanks to all the people who contribute:\n\n<a href=\"https://github.com/luin/ioredis/graphs/contributors\"><img src=\"https://opencollective.com/ioredis/contributors.svg?width=890&showBtn=false\" /></a>\n\n# License\n\nMIT\n\n\n[![FOSSA Status](https://app.fossa.io/api/projects/git%2Bgithub.com%2Fluin%2Fioredis.svg?type=large)](https://app.fossa.io/projects/git%2Bgithub.com%2Fluin%2Fioredis?ref=badge_large)\n","readmeFilename":"README.md","bugs":{"url":"https://github.com/luin/ioredis/issues"},"homepage":"https://github.com/luin/ioredis#readme","_id":"ioredis@4.9.1","_npmVersion":"6.4.1","_nodeVersion":"10.15.3","_npmUser":{"name":"ioredis-robot","email":"ioredis-robot@zihua.li"},"dist":{"integrity":"sha512-MBEkGs0uJsm3IW2C56f4O09KreK0H7bCZ1TmSoImOCdSj9g9zoP5yzcU7LzNY/OmsVHEndqKVHMrTG1c9c7dQA==","shasum":"da1eee673231a1f1c555f532003285e3357cc7b2","tarball":"https://registry.npmjs.org/ioredis/-/ioredis-4.9.1.tgz","fileCount":35,"unpackedSize":222011,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJclPcCCRA9TVsSAnZWagAA6FQP/1nKPsKPt53KYSCaw/xg\ncwmxcJKBdt+bwMhoul5RsWR+c2wMfeRQ1CqH8g86MWpqF7cAwPjcAxtAXO3w\nBXpF6I1zgQphFP0RTmIUgN0/sQxUFZj4FDXniYx4W/T7W5lBIDWzjpKZAetw\nN+xNk+W42u/j9I+VnAPOUsv7p5U3QEL81SSwWg2nlxh9/aBShVUMY6XNx3rG\nglz+6betFc27JiNPKTh27iOF99uxCMQt2h9BAzxKb2ZeNO83Fx2OXKeqE9g9\nil3Ep1Ke7RehTXT/tGPuJiFqH7V2tZ09yOuVWXMrTLhZ2kyNQw3m40d6UFEM\nGiVPQRMbraV0nygGpovrfI+KzwK4t/GlS1ZyOIGHR1vFyiTwU8xmSBdAJwq8\nvqtdoefCDfMMNkIinW8qy1ktytwQZIBQc11PoakIsgwdeN9+sdUeGbFxM4Hb\nDT3d/v+sZd60ISGEc0OCSSHESHPoubID/6/sA9kCrc15IFCwj2gkrXM54djK\nOaIiYwv6tWTzlKXY0qCEn2uYvNeQGGN1upCQybEXrpy0Uq42IGEjwFgv4yQq\n7aUSwgGQ5ptlzHg92y+K8z3GQtb98GoOyFNONT0526MmZCprK7XcC+mKavy8\nY8xSdJ1rs/Zml9O5rFDq0MGmqav/1BJBervQ8uyY3o7IUizrGOfyrES6bDTE\n/Cb2\r\n=oRty\r\n-----END PGP SIGNATURE-----\r\n"},"maintainers":[{"email":"ioredis-robot@zihua.li","name":"ioredis-robot"},{"email":"i@zihua.li","name":"luin"}],"directories":{},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/ioredis_4.9.1_1553266433656_0.12220648556137137"},"_hasShrinkwrap":false},"4.9.2":{"name":"ioredis","version":"4.9.2","description":"A robust, performance-focused and full-featured Redis client for Node.js.","main":"built/index.js","scripts":{"test":"NODE_ENV=test mocha --timeout 8000 -r ts-node/register --exit","test:cov":"NODE_ENV=test node ./node_modules/istanbul/lib/cli.js cover --preserve-comments ./node_modules/mocha/bin/_mocha -- -r ts-node/register -R spec --exit","build":"rm -rf built && tsc","generate-docs":"jsdoc2md lib/redis.js lib/cluster/index.js lib/commander.js > API.md","prepublishOnly":"npm run build && npm test","bench":"matcha benchmarks/*.js","semantic-release":"semantic-release"},"repository":{"type":"git","url":"git://github.com/luin/ioredis.git"},"keywords":["redis","cluster","sentinel","pipelining"],"author":{"name":"luin","email":"i@zihua.li","url":"http://zihua.li"},"license":"MIT","dependencies":{"cluster-key-slot":"^1.0.6","debug":"^3.1.0","denque":"^1.1.0","lodash.defaults":"^4.2.0","lodash.flatten":"^4.4.0","redis-commands":"1.4.0","redis-errors":"^1.2.0","redis-parser":"^3.0.0","standard-as-callback":"^2.0.1"},"devDependencies":{"@semantic-release/changelog":"^3.0.0","@semantic-release/git":"^7.0.4","@types/node":"^10.11.5","@types/redis-errors":"1.2.0","bluebird":"^3.5.1","chai":"^3.5.0","cz-conventional-changelog":"^2.0.0","istanbul":"^0.4.2","jsdoc":"^3.4.0","jsdoc-to-markdown":"^4.0.1","mocha":"^5.2.0","server-destroy":"^1.0.1","sinon":"^1.17.3","ts-node":"^7.0.0","typescript":"^3.1.1"},"engines":{"node":">=6"},"config":{"commitizen":{"path":"./node_modules/cz-conventional-changelog"}},"gitHead":"115a9f419de7b34e9a771aaf1b78d5280238a352","readme":"[![ioredis](https://cdn.rawgit.com/luin/ioredis/57b5b89e3e9111ff25d8c62c0bc58ed42e5b8d1e/logo.svg)](https://github.com/luin/ioredis)\n\n[![Build Status](https://travis-ci.org/luin/ioredis.svg?branch=master)](https://travis-ci.org/luin/ioredis)\n[![Test Coverage](https://codeclimate.com/github/luin/ioredis/badges/coverage.svg)](https://codeclimate.com/github/luin/ioredis)\n[![Join the chat at https://gitter.im/luin/ioredis](https://badges.gitter.im/Join%20Chat.svg)](https://gitter.im/luin/ioredis?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge)\n[![Commitizen friendly](https://img.shields.io/badge/commitizen-friendly-brightgreen.svg)](http://commitizen.github.io/cz-cli/)\n[![semantic-release](https://img.shields.io/badge/%20%20%F0%9F%93%A6%F0%9F%9A%80-semantic--release-e10079.svg)](https://github.com/semantic-release/semantic-release)\n[![npm latest version](https://img.shields.io/npm/v/ioredis/latest.svg)](https://www.npmjs.com/package/ioredis)\n[![npm next version](https://img.shields.io/npm/v/ioredis/next.svg)](https://www.npmjs.com/package/ioredis)\n<img alt=\"\" src=\"\">\n\nA robust, performance-focused and full-featured [Redis](http://redis.io) client for [Node.js](https://nodejs.org).\n\nSupports Redis >= 2.6.12 and (Node.js >= 6).\n\n# Features\nioredis is a robust, full-featured Redis client that is\nused in the world's biggest online commerce company [Alibaba](http://www.alibaba.com/) and many other awesome companies.\n\n0. Full-featured. It supports [Cluster](http://redis.io/topics/cluster-tutorial), [Sentinel](http://redis.io/topics/sentinel), [Pipelining](http://redis.io/topics/pipelining) and of course [Lua scripting](http://redis.io/commands/eval) & [Pub/Sub](http://redis.io/topics/pubsub) (with the support of binary messages).\n0. High performance.\n0. Delightful API. It works with Node callbacks and Native promises.\n0. Transformation of command arguments and replies.\n0. Transparent key prefixing.\n0. Abstraction for Lua scripting, allowing you to define custom commands.\n0. Support for binary data.\n0. Support for TLS.\n0. Support for offline queue and ready checking.\n0. Support for ES6 types, such as `Map` and `Set`.\n0. Support for GEO commands (Redis 3.2 Unstable).\n0. Sophisticated error handling strategy.\n0. Support for NAT mapping.\n\n# Links\n* [API Documentation](API.md)\n* [Changelog](Changelog.md)\n* [Migrating from node_redis](https://github.com/luin/ioredis/wiki/Migrating-from-node_redis)\n* [Error Handling](#error-handling)\n\n## Become a Sponsor to Support ioredis's Development\nOpen source is hard and time-consuming. If you want to invest in ioredis's future you can become a sponsor and make us spend more time on this library's improvements and new features.\n\n<a href=\"https://opencollective.com/ioredis\"><img src=\"https://opencollective.com/ioredis/tiers/sponsor.svg?avatarHeight=36\"></a>\n\nThank you for using ioredis :-)\n\n<hr>\n<a href=\"https://itunes.apple.com/app/medis-gui-for-redis/id1063631769\"><img align=\"right\" src=\"medis.png\" alt=\"Download on the App Store\"></a>\n\n\n### Advertisement\n\nLooking for a Redis GUI manager for OS X, Windows and Linux? Here's [Medis](https://itunes.apple.com/us/app/medis-gui-for-redis/id1063631769)!\n\nMedis is an open-sourced, beautiful, easy-to-use Redis GUI management application.\n\nMedis starts with all the basic features you need:\n\n* Keys viewing/editing\n* SSH Tunnel for connecting with remote servers\n* Terminal for executing custom commands\n* JSON/MessagePack format viewing/editing and built-in highlighting/validator\n* And other awesome features...\n\n[Medis is open sourced on GitHub](https://github.com/luin/medis)\n\n<hr>\n\n# Quick Start\n\n## Install\n```shell\n$ npm install ioredis\n```\n\n## Basic Usage\n\n```javascript\nvar Redis = require('ioredis');\nvar redis = new Redis();\n\nredis.set('foo', 'bar');\nredis.get('foo', function (err, result) {\n  console.log(result);\n});\nredis.del('foo');\n\n// Or using a promise if the last argument isn't a function\nredis.get('foo').then(function (result) {\n  console.log(result);\n});\n\n// Arguments to commands are flattened, so the following are the same:\nredis.sadd('set', 1, 3, 5, 7);\nredis.sadd('set', [1, 3, 5, 7]);\n\n// All arguments are passed directly to the redis server:\nredis.set('key', 100, 'EX', 10);\n```\n\nSee the `examples/` folder for more examples.\n\n## Connect to Redis\nWhen a new `Redis` instance is created,\na connection to Redis will be created at the same time.\nYou can specify which Redis to connect to by:\n\n```javascript\nnew Redis()       // Connect to 127.0.0.1:6379\nnew Redis(6380)   // 127.0.0.1:6380\nnew Redis(6379, '192.168.1.1')        // 192.168.1.1:6379\nnew Redis('/tmp/redis.sock')\nnew Redis({\n  port: 6379,          // Redis port\n  host: '127.0.0.1',   // Redis host\n  family: 4,           // 4 (IPv4) or 6 (IPv6)\n  password: 'auth',\n  db: 0\n})\n```\n\nYou can also specify connection options as a [`redis://` URL](http://www.iana.org/assignments/uri-schemes/prov/redis):\n\n```javascript\n// Connect to 127.0.0.1:6380, db 4, using password \"authpassword\":\nnew Redis('redis://:authpassword@127.0.0.1:6380/4')\n```\n\nSee [API Documentation](API.md#new_Redis) for all available options.\n\n## Pub/Sub\n\nHere is a simple example of the API for publish/subscribe.\nThe following program opens two client connections.\nIt subscribes to a channel with one connection\nand publishes to that channel with the other:\n\n```javascript\nvar Redis = require('ioredis');\nvar redis = new Redis();\nvar pub = new Redis();\nredis.subscribe('news', 'music', function (err, count) {\n  // Now we are subscribed to both the 'news' and 'music' channels.\n  // `count` represents the number of channels we are currently subscribed to.\n\n  pub.publish('news', 'Hello world!');\n  pub.publish('music', 'Hello again!');\n});\n\nredis.on('message', function (channel, message) {\n  // Receive message Hello world! from channel news\n  // Receive message Hello again! from channel music\n  console.log('Receive message %s from channel %s', message, channel);\n});\n\n// There's also an event called 'messageBuffer', which is the same as 'message' except\n// it returns buffers instead of strings.\nredis.on('messageBuffer', function (channel, message) {\n  // Both `channel` and `message` are buffers.\n});\n```\n\n`PSUBSCRIBE` is also supported in a similar way:\n\n```javascript\nredis.psubscribe('pat?ern', function (err, count) {});\nredis.on('pmessage', function (pattern, channel, message) {});\nredis.on('pmessageBuffer', function (pattern, channel, message) {});\n```\n\nWhen a client issues a SUBSCRIBE or PSUBSCRIBE, that connection is put into a \"subscriber\" mode.\nAt that point, only commands that modify the subscription set are valid.\nWhen the subscription set is empty, the connection is put back into regular mode.\n\nIf you need to send regular commands to Redis while in subscriber mode, just open another connection.\n\n## Handle Binary Data\nArguments can be buffers:\n```javascript\nredis.set('foo', Buffer.from('bar'));\n```\n\nAnd every command has a method that returns a Buffer (by adding a suffix of \"Buffer\" to the command name).\nTo get a buffer instead of a utf8 string:\n\n```javascript\nredis.getBuffer('foo', function (err, result) {\n  // result is a buffer.\n});\n```\n\n## Pipelining\nIf you want to send a batch of commands (e.g. > 5), you can use pipelining to queue\nthe commands in memory and then send them to Redis all at once. This way the performance improves by 50%~300% (See [benchmark section](#benchmark)).\n\n`redis.pipeline()` creates a `Pipeline` instance. You can call any Redis\ncommands on it just like the `Redis` instance. The commands are queued in memory\nand flushed to Redis by calling the `exec` method:\n\n```javascript\nvar pipeline = redis.pipeline();\npipeline.set('foo', 'bar');\npipeline.del('cc');\npipeline.exec(function (err, results) {\n  // `err` is always null, and `results` is an array of responses\n  // corresponding to the sequence of queued commands.\n  // Each response follows the format `[err, result]`.\n});\n\n// You can even chain the commands:\nredis.pipeline().set('foo', 'bar').del('cc').exec(function (err, results) {\n});\n\n// `exec` also returns a Promise:\nvar promise = redis.pipeline().set('foo', 'bar').get('foo').exec();\npromise.then(function (result) {\n  // result === [[null, 'OK'], [null, 'bar']]\n});\n```\n\nEach chained command can also have a callback, which will be invoked when the command\ngets a reply:\n\n```javascript\nredis.pipeline().set('foo', 'bar').get('foo', function (err, result) {\n  // result === 'bar'\n}).exec(function (err, result) {\n  // result[1][1] === 'bar'\n});\n```\n\nIn addition to adding commands to the `pipeline` queue individually, you can also pass an array of commands and arguments to the constructor:\n\n```javascript\nredis.pipeline([\n  ['set', 'foo', 'bar'],\n  ['get', 'foo']\n]).exec(function () { /* ... */ });\n```\n\n`#length` property shows how many commands in the pipeline:\n\n```javascript\nconst length = redis.pipeline().set('foo', 'bar').get('foo').length;\n// length === 2\n```\n\n\n## Transaction\nMost of the time, the transaction commands `multi` & `exec` are used together with pipeline.\nTherefore, when `multi` is called, a `Pipeline` instance is created automatically by default,\nso you can use `multi` just like `pipeline`:\n\n```javascript\nredis.multi().set('foo', 'bar').get('foo').exec(function (err, results) {\n  // results === [[null, 'OK'], [null, 'bar']]\n});\n```\nIf there's a syntax error in the transaction's command chain (e.g. wrong number of arguments, wrong command name, etc),\nthen none of the commands would be executed, and an error is returned:\n\n```javascript\nredis.multi().set('foo').set('foo', 'new value').exec(function (err, results) {\n  // err:\n  //  { [ReplyError: EXECABORT Transaction discarded because of previous errors.]\n  //    name: 'ReplyError',\n  //    message: 'EXECABORT Transaction discarded because of previous errors.',\n  //    command: { name: 'exec', args: [] },\n  //    previousErrors:\n  //     [ { [ReplyError: ERR wrong number of arguments for 'set' command]\n  //         name: 'ReplyError',\n  //         message: 'ERR wrong number of arguments for \\'set\\' command',\n  //         command: [Object] } ] }\n});\n```\n\nIn terms of the interface, `multi` differs from `pipeline` in that when specifying a callback\nto each chained command, the queueing state is passed to the callback instead of the result of the command:\n\n```javascript\nredis.multi().set('foo', 'bar', function (err, result) {\n  // result === 'QUEUED'\n}).exec(/* ... */);\n```\n\nIf you want to use transaction without pipeline, pass `{ pipeline: false }` to `multi`,\nand every command will be sent to Redis immediately without waiting for an `exec` invocation:\n\n```javascript\nredis.multi({ pipeline: false });\nredis.set('foo', 'bar');\nredis.get('foo');\nredis.exec(function (err, result) {\n  // result === [[null, 'OK'], [null, 'bar']]\n});\n```\n\nThe constructor of `multi` also accepts a batch of commands:\n\n```javascript\nredis.multi([\n  ['set', 'foo', 'bar'],\n  ['get', 'foo']\n]).exec(function () { /* ... */ });\n```\n\nInline transactions are supported by pipeline, which means you can group a subset of commands\nin the pipeline into a transaction:\n\n```javascript\nredis.pipeline().get('foo').multi().set('foo', 'bar').get('foo').exec().get('foo').exec();\n```\n\n## Lua Scripting\nioredis supports all of the scripting commands such as `EVAL`, `EVALSHA` and `SCRIPT`.\nHowever, it's tedious to use in real world scenarios since developers have to take\ncare of script caching and to detect when to use `EVAL` and when to use `EVALSHA`.\nioredis expose a `defineCommand` method to make scripting much easier to use:\n\n```javascript\nvar redis = new Redis();\n\n// This will define a command echo:\nredis.defineCommand('echo', {\n  numberOfKeys: 2,\n  lua: 'return {KEYS[1],KEYS[2],ARGV[1],ARGV[2]}'\n});\n\n// Now `echo` can be used just like any other ordinary command,\n// and ioredis will try to use `EVALSHA` internally when possible for better performance.\nredis.echo('k1', 'k2', 'a1', 'a2', function (err, result) {\n  // result === ['k1', 'k2', 'a1', 'a2']\n});\n\n// `echoBuffer` is also defined automatically to return buffers instead of strings:\nredis.echoBuffer('k1', 'k2', 'a1', 'a2', function (err, result) {\n  // result[0] equals to Buffer.from('k1');\n});\n\n// And of course it works with pipeline:\nredis.pipeline().set('foo', 'bar').echo('k1', 'k2', 'a1', 'a2').exec();\n```\n\nIf the number of keys can't be determined when defining a command, you can\nomit the `numberOfKeys` property and pass the number of keys as the first argument\nwhen you call the command:\n\n```javascript\nredis.defineCommand('echoDynamicKeyNumber', {\n  lua: 'return {KEYS[1],KEYS[2],ARGV[1],ARGV[2]}'\n});\n\n// Now you have to pass the number of keys as the first argument every time\n// you invoke the `echoDynamicKeyNumber` command:\nredis.echoDynamicKeyNumber(2, 'k1', 'k2', 'a1', 'a2', function (err, result) {\n  // result === ['k1', 'k2', 'a1', 'a2']\n});\n```\n\n## Transparent Key Prefixing\nThis feature allows you to specify a string that will automatically be prepended\nto all the keys in a command, which makes it easier to manage your key\nnamespaces.\n\n**Warning** This feature won't apply to commands like [KEYS](http://redis.io/commands/KEYS) and [SCAN](http://redis.io/commands/scan) that take patterns rather than actual keys([#239](https://github.com/luin/ioredis/issues/239)),\nand this feature also won't apply to the replies of commands even they are key names ([#325](https://github.com/luin/ioredis/issues/325)).\n\n```javascript\nvar fooRedis = new Redis({ keyPrefix: 'foo:' });\nfooRedis.set('bar', 'baz');  // Actually sends SET foo:bar baz\n\nfooRedis.defineCommand('echo', {\n  numberOfKeys: 2,\n  lua: 'return {KEYS[1],KEYS[2],ARGV[1],ARGV[2]}'\n});\n\n// Works well with pipelining/transaction\nfooRedis.pipeline()\n  // Sends SORT foo:list BY foo:weight_*->fieldname\n  .sort('list', 'BY', 'weight_*->fieldname')\n  // Supports custom commands\n  // Sends EVALSHA xxx foo:k1 foo:k2 a1 a2\n  .echo('k1', 'k2', 'a1', 'a2')\n  .exec()\n```\n\n## Transforming Arguments & Replies\nMost Redis commands take one or more Strings as arguments,\nand replies are sent back as a single String or an Array of Strings. However, sometimes\nyou may want something different. For instance, it would be more convenient if the `HGETALL`\ncommand returns a hash (e.g. `{ key: val1, key2: v2 }`) rather than an array of key values (e.g. `[key1, val1, key2, val2]`).\n\nioredis has a flexible system for transforming arguments and replies. There are two types\nof transformers, argument transformer and reply transformer:\n\n```javascript\nvar Redis = require('ioredis');\n\n// Here's the built-in argument transformer converting\n// hmset('key', { k1: 'v1', k2: 'v2' })\n// or\n// hmset('key', new Map([['k1', 'v1'], ['k2', 'v2']]))\n// into\n// hmset('key', 'k1', 'v1', 'k2', 'v2')\nRedis.Command.setArgumentTransformer('hmset', function (args) {\n  if (args.length === 2) {\n    if (typeof Map !== 'undefined' && args[1] instanceof Map) {\n      // utils is a internal module of ioredis\n      return [args[0]].concat(utils.convertMapToArray(args[1]));\n    }\n    if ( typeof args[1] === 'object' && args[1] !== null) {\n      return [args[0]].concat(utils.convertObjectToArray(args[1]));\n    }\n  }\n  return args;\n});\n\n// Here's the built-in reply transformer converting the HGETALL reply\n// ['k1', 'v1', 'k2', 'v2']\n// into\n// { k1: 'v1', 'k2': 'v2' }\nRedis.Command.setReplyTransformer('hgetall', function (result) {\n  if (Array.isArray(result)) {\n    var obj = {};\n    for (var i = 0; i < result.length; i += 2) {\n      obj[result[i]] = result[i + 1];\n    }\n    return obj;\n  }\n  return result;\n});\n```\n\nThere are three built-in transformers, two argument transformers for `hmset` & `mset` and\na reply transformer for `hgetall`. Transformers for `hmset` and `hgetall` were mentioned\nabove, and the transformer for `mset` is similar to the one for `hmset`:\n\n```javascript\nredis.mset({ k1: 'v1', k2: 'v2' });\nredis.get('k1', function (err, result) {\n  // result === 'v1';\n});\n\nredis.mset(new Map([['k3', 'v3'], ['k4', 'v4']]));\nredis.get('k3', function (err, result) {\n  // result === 'v3';\n});\n```\n\nAnother useful example of a reply transformer is one that changes `hgetall` to return array of arrays instead of objects which avoids a unwanted conversation of hash keys to strings when dealing with binary hash keys:\n\n```javascript\nRedis.Command.setReplyTransformer('hgetall', function (result) {\n  var arr = [];\n  for (var i = 0; i < result.length; i += 2) {\n    arr.push([result[i], result[i + 1]]);\n  }\n  return arr;\n});\nredis.hset('h1', Buffer.from([0x01]), Buffer.from([0x02]));\nredis.hset('h1', Buffer.from([0x03]), Buffer.from([0x04]));\nredis.hgetallBuffer('h1', function (err, result) {\n  // result === [ [ <Buffer 01>, <Buffer 02> ], [ <Buffer 03>, <Buffer 04> ] ];\n});\n```\n\n## Monitor\nRedis supports the MONITOR command,\nwhich lets you see all commands received by the Redis server across all client connections,\nincluding from other client libraries and other computers.\n\nThe `monitor` method returns a monitor instance.\nAfter you send the MONITOR command, no other commands are valid on that connection. ioredis will emit a monitor event for every new monitor message that comes across.\nThe callback for the monitor event takes a timestamp from the Redis server and an array of command arguments.\n\nHere is a simple example:\n\n```javascript\nredis.monitor(function (err, monitor) {\n  monitor.on('monitor', function (time, args, source, database) {\n  });\n});\n```\n\n## Streamify Scanning\nRedis 2.8 added the `SCAN` command to incrementally iterate through the keys in the database. It's different from `KEYS` in that\n`SCAN` only returns a small number of elements each call, so it can be used in production without the downside\nof blocking the server for a long time. However, it requires recording the cursor on the client side each time\nthe `SCAN` command is called in order to iterate through all the keys correctly. Since it's a relatively common use case, ioredis\nprovides a streaming interface for the `SCAN` command to make things much easier. A readable stream can be created by calling `scanStream`:\n\n```javascript\nvar redis = new Redis();\n// Create a readable stream (object mode)\nvar stream = redis.scanStream();\nstream.on('data', function (resultKeys) {\n  // `resultKeys` is an array of strings representing key names.\n  // Note that resultKeys may contain 0 keys, and that it will sometimes\n  // contain duplicates due to SCAN's implementation in Redis.\n  for (var i = 0; i < resultKeys.length; i++) {\n    console.log(resultKeys[i]);\n  }\n});\nstream.on('end', function () {\n  console.log('all keys have been visited');\n});\n```\n\n`scanStream` accepts an option, with which you can specify the `MATCH` pattern and the `COUNT` argument:\n\n```javascript\nvar stream = redis.scanStream({\n  // only returns keys following the pattern of `user:*`\n  match: 'user:*',\n  // returns approximately 100 elements per call\n  count: 100\n});\n```\n\nJust like other commands, `scanStream` has a binary version `scanBufferStream`, which returns an array of buffers. It's useful when\nthe key names are not utf8 strings.\n\nThere are also `hscanStream`, `zscanStream` and `sscanStream` to iterate through elements in a hash, zset and set. The interface of each is\nsimilar to `scanStream` except the first argument is the key name:\n\n```javascript\nvar stream = redis.hscanStream('myhash', {\n  match: 'age:??'\n});\n```\n\nYou can learn more from the [Redis documentation](http://redis.io/commands/scan).\n\n**Useful Tips**\nIt's pretty common that doing an async task in the `data` handler. We'd like the scanning process to be paused until the async task to be finished. `Stream#pause()` and `Stream.resume()` do the trick. For example if we want to migrate data in Redis to MySQL:\n\n```javascript\nvar stream = redis.scanStream();\nstream.on('data', function (resultKeys) {\n  // Pause the stream from scanning more keys until we've migrated the current keys.\n  stream.pause();\n\n  Promise.all(resultKeys.map(migrateKeyToMySQL)).then(() => {\n    // Resume the stream here.\n    stream.resume();\n  });\n});\n\nstream.on('end', function () {\n  console.log('done migration');\n});\n```\n\n## Auto-reconnect\nBy default, ioredis will try to reconnect when the connection to Redis is lost\nexcept when the connection is closed manually by `redis.disconnect()` or `redis.quit()`.\n\nIt's very flexible to control how long to wait to reconnect after disconnection\nusing the `retryStrategy` option:\n\n```javascript\nvar redis = new Redis({\n  // This is the default value of `retryStrategy`\n  retryStrategy: function (times) {\n    var delay = Math.min(times * 50, 2000);\n    return delay;\n  }\n});\n```\n\n`retryStrategy` is a function that will be called when the connection is lost.\nThe argument `times` means this is the nth reconnection being made and\nthe return value represents how long (in ms) to wait to reconnect. When the\nreturn value isn't a number, ioredis will stop trying to reconnect, and the connection\nwill be lost forever if the user doesn't call `redis.connect()` manually.\n\nWhen reconnected, the client will auto subscribe to channels that the previous connection subscribed to.\nThis behavior can be disabled by setting the `autoResubscribe` option to `false`.\n\nAnd if the previous connection has some unfulfilled commands (most likely blocking commands such as `brpop` and `blpop`),\nthe client will resend them when reconnected. This behavior can be disabled by setting the `autoResendUnfulfilledCommands` option to `false`.\n\nBy default, all pending commands will be flushed with an error every 20 retry attempts. That makes sure commands won't wait forever when the connection is down. You can change this behavior by setting `maxRetriesPerRequest`:\n\n```javascript\nvar redis = new Redis({\n  maxRetriesPerRequest: 1\n});\n```\n\nSet maxRetriesPerRequest to `null` to disable this behavior, and every command will wait forever until the connection is alive again (which is the default behavior before ioredis v4).\n\n### Reconnect on error\n\nBesides auto-reconnect when the connection is closed, ioredis supports reconnecting on the specified errors by the `reconnectOnError` option. Here's an example that will reconnect when receiving `READONLY` error:\n\n```javascript\nvar redis = new Redis({\n  reconnectOnError: function (err) {\n    var targetError = 'READONLY';\n    if (err.message.slice(0, targetError.length) === targetError) {\n      // Only reconnect when the error starts with \"READONLY\"\n      return true; // or `return 1;`\n    }\n  }\n});\n```\n\nThis feature is useful when using Amazon ElastiCache. Once failover happens, Amazon ElastiCache will switch the master we currently connected with to a slave, leading to the following writes fails with the error `READONLY`. Using `reconnectOnError`, we can force the connection to reconnect on this error in order to connect to the new master.\n\nFurthermore, if the `reconnectOnError` returns `2`, ioredis will resend the failed command after reconnecting.\n\n## Connection Events\nThe Redis instance will emit some events about the state of the connection to the Redis server.\n\nEvent    | Description\n:------------- | :-------------\nconnect  | emits when a connection is established to the Redis server.\nready    | If `enableReadyCheck` is `true`, client will emit `ready` when the server reports that it is ready to receive commands (e.g. finish loading data from disk).<br>Otherwise, `ready` will be emitted immediately right after the `connect` event.\nerror    | emits when an error occurs while connecting.<br>However, ioredis emits all `error` events silently (only emits when there's at least one listener) so that your application won't crash if you're not listening to the `error` event.\nclose    | emits when an established Redis server connection has closed.\nreconnecting | emits after `close` when a reconnection will be made. The argument of the event is the time (in ms) before reconnecting.\nend     | emits after `close` when no more reconnections will be made, or the connection is failed to establish.\n\nYou can also check out the `Redis#status` property to get the current connection status.\n\nBesides the above connection events, there are several other custom events:\n\nEvent    | Description\n:------------- | :-------------\nselect   | emits when the database changed. The argument is the new db number.\n\n## Offline Queue\nWhen a command can't be processed by Redis (being sent before the `ready` event), by default, it's added to the offline queue and will be\nexecuted when it can be processed. You can disable this feature by setting the `enableOfflineQueue`\noption to `false`:\n\n```javascript\nvar redis = new Redis({ enableOfflineQueue: false });\n```\n\n## TLS Options\nRedis doesn't support TLS natively, however if the redis server you want to connect to is hosted behind a TLS proxy (e.g. [stunnel](https://www.stunnel.org/)) or is offered by a PaaS service that supports TLS connection (e.g. [Redis Labs](https://redislabs.com/)), you can set the `tls` option:\n\n```javascript\nvar redis = new Redis({\n  host: 'localhost',\n  tls: {\n    // Refer to `tls.connect()` section in\n    // https://nodejs.org/api/tls.html\n    // for all supported options\n    ca: fs.readFileSync('cert.pem')\n  }\n});\n```\n\n<hr>\n\n## Sentinel\nioredis supports Sentinel out of the box. It works transparently as all features that work when\nyou connect to a single node also work when you connect to a sentinel group. Make sure to run Redis >= 2.8.12 if you want to use this feature. Sentinels have a default port of 26379.\n\nTo connect using Sentinel, use:\n\n```javascript\nvar redis = new Redis({\n  sentinels: [{ host: 'localhost', port: 26379 }, { host: 'localhost', port: 26380 }],\n  name: 'mymaster'\n});\n\nredis.set('foo', 'bar');\n```\n\nThe arguments passed to the constructor are different from the ones you use to connect to a single node, where:\n\n* `name` identifies a group of Redis instances composed of a master and one or more slaves (`mymaster` in the example);\n* `sentinelPassword` (optional) password for Sentinel instances.\n* `sentinels` are a list of sentinels to connect to. The list does not need to enumerate all your sentinel instances, but a few so that if one is down the client will try the next one.\n* `role` (optional) with a value of `slave` will return a random slave from the Sentinel group.\n* `preferredSlaves` (optional) can be used to prefer a particular slave or set of slaves based on priority. It accepts a function or array.\n\nioredis **guarantees** that the node you connected to is always a master even after a failover. When a failover happens, instead of trying to reconnect to the failed node (which will be demoted to slave when it's available again), ioredis will ask sentinels for the new master node and connect to it. All commands sent during the failover are queued and will be executed when the new connection is established so that none of the commands will be lost.\n\nIt's possible to connect to a slave instead of a master by specifying the option `role` with the value of `slave` and ioredis will try to connect to a random slave of the specified master, with the guarantee that the connected node is always a slave. If the current node is promoted to master due to a failover, ioredis will disconnect from it and ask the sentinels for another slave node to connect to.\n\nIf you specify the option `preferredSlaves` along with `role: 'slave'` ioredis will attempt to use this value when selecting the slave from the pool of available slaves. The value of `preferredSlaves` should either be a function that accepts an array of avaiable slaves and returns a single result, or an array of slave values priorities by the lowest `prio` value first with a default value of `1`.\n\n```javascript\n// available slaves format\nvar availableSlaves = [{ ip: '127.0.0.1', port: '31231', flags: 'slave' }];\n\n// preferredSlaves array format\nvar preferredSlaves = [\n  { ip: '127.0.0.1', port: '31231', prio: 1 },\n  { ip: '127.0.0.1', port: '31232', prio: 2 }\n];\n\n// preferredSlaves function format\npreferredSlaves = function(availableSlaves) {\n  for (var i = 0; i < availableSlaves.length; i++) {\n    var slave = availableSlaves[i];\n    if (slave.ip === '127.0.0.1') {\n      if (slave.port === '31234') {\n        return slave;\n      }\n    }\n  }\n  // if no preferred slaves are available a random one is used\n  return false;\n};\n\nvar redis = new Redis({\n  sentinels: [{ host: '127.0.0.1', port: 26379 }, { host: '127.0.0.1', port: 26380 }],\n  name: 'mymaster',\n  role: 'slave',\n  preferredSlaves: preferredSlaves\n});\n```\n\nBesides the `retryStrategy` option, there's also a `sentinelRetryStrategy` in Sentinel mode which will be invoked when all the sentinel nodes are unreachable during connecting. If `sentinelRetryStrategy` returns a valid delay time, ioredis will try to reconnect from scratch. The default value of `sentinelRetryStrategy` is:\n\n```javascript\nfunction (times) {\n  var delay = Math.min(times * 10, 1000);\n  return delay;\n}\n```\n\n## Cluster\nRedis Cluster provides a way to run a Redis installation where data is automatically sharded across multiple Redis nodes.\nYou can connect to a Redis Cluster like this:\n\n```javascript\nvar Redis = require('ioredis');\n\nvar cluster = new Redis.Cluster([{\n  port: 6380,\n  host: '127.0.0.1'\n}, {\n  port: 6381,\n  host: '127.0.0.1'\n}]);\n\ncluster.set('foo', 'bar');\ncluster.get('foo', function (err, res) {\n  // res === 'bar'\n});\n```\n\n`Cluster` constructor accepts two arguments, where:\n\n0. The first argument is a list of nodes of the cluster you want to connect to.\nJust like Sentinel, the list does not need to enumerate all your cluster nodes,\nbut a few so that if one is unreachable the client will try the next one, and the client will discover other nodes automatically when at least one node is connected.\n0. The second argument is the options, where:\n\n    * `clusterRetryStrategy`: When none of the startup nodes are reachable, `clusterRetryStrategy` will be invoked. When a number is returned,\n    ioredis will try to reconnect to the startup nodes from scratch after the specified delay (in ms). Otherwise, an error of \"None of startup nodes is available\" will be returned.\n    The default value of this option is:\n\n        ```javascript\n        function (times) {\n          var delay = Math.min(100 + times * 2, 2000);\n          return delay;\n        }\n        ```\n\n        It's possible to modify the `startupNodes` property in order to switch to another set of nodes here:\n\n        ```javascript\n        function (times) {\n          this.startupNodes = [{ port: 6790, host: '127.0.0.1' }];\n          return Math.min(100 + times * 2, 2000);\n        }\n        ```\n\n    * `enableOfflineQueue`: Similar to the `enableOfflineQueue` option of `Redis` class.\n    * `enableReadyCheck`: When enabled, \"ready\" event will only be emitted when `CLUSTER INFO` command\n    reporting the cluster is ready for handling commands. Otherwise, it will be emitted immediately after \"connect\" is emitted.\n    * `scaleReads`: Config where to send the read queries. See below for more details.\n    * `maxRedirections`: When a cluster related error (e.g. `MOVED`, `ASK` and `CLUSTERDOWN` etc.) is received, the client will redirect the\n    command to another node. This option limits the max redirections allowed when sending a command. The default value is `16`.\n    * `retryDelayOnFailover`: If the target node is disconnected when sending a command,\n    ioredis will retry after the specified delay. The default value is `100`. You should make sure `retryDelayOnFailover * maxRedirections > cluster-node-timeout`\n    to insure that no command will fail during a failover.\n    * `retryDelayOnClusterDown`: When a cluster is down, all commands will be rejected with the error of `CLUSTERDOWN`. If this option is a number (by default, it is `100`), the client\n    will resend the commands after the specified time (in ms).\n    * `retryDelayOnTryAgain`: If this option is a number (by default, it is `100`), the client\n    will resend the commands rejected with `TRYAGAIN` error after the specified time (in ms).\n    * `redisOptions`: Default options passed to the constructor of `Redis` when connecting to a node.\n    * `slotsRefreshTimeout`: Milliseconds before a timeout occurs while refreshing slots from the cluster (default `1000`)\n    * `slotsRefreshInterval`: Milliseconds between every automatic slots refresh (default `5000`)\n\n### Read-write splitting\n\nA typical redis cluster contains three or more masters and several slaves for each master. It's possible to scale out redis cluster by sending read queries to slaves and write queries to masters by setting the `scaleReads` option.\n\n`scaleReads` is \"master\" by default, which means ioredis will never send any queries to slaves. There are other three available options:\n\n1. \"all\": Send write queries to masters and read queries to masters or slaves randomly.\n2. \"slave\": Send write queries to masters and read queries to slaves.\n3. a custom `function(nodes, command): node`: Will choose the custom function to select to which node to send read queries (write queries keep being sent to master). The first node in `nodes` is always the master serving the relevant slots. If the function returns an array of nodes, a random node of that list will be selected.\n\nFor example:\n\n```javascript\nvar cluster = new Redis.Cluster([/* nodes */], {\n  scaleReads: 'slave'\n});\ncluster.set('foo', 'bar'); // This query will be sent to one of the masters.\ncluster.get('foo', function (err, res) {\n  // This query will be sent to one of the slaves.\n});\n```\n\n**NB** In the code snippet above, the `res` may not be equal to \"bar\" because of the lag of replication between the master and slaves.\n\n### Running commands to multiple nodes\n\nEvery command will be sent to exactly one node. For commands containing keys, (e.g. `GET`, `SET` and `HGETALL`), ioredis sends them to the node that serving the keys, and for other commands not containing keys, (e.g. `INFO`, `KEYS` and `FLUSHDB`), ioredis sends them to a random node.\n\nSometimes you may want to send a command to multiple nodes (masters or slaves) of the cluster, you can get the nodes via `Cluster#nodes()` method.\n\n`Cluster#nodes()` accepts a parameter role, which can be \"master\", \"slave\" and \"all\" (default), and returns an array of `Redis` instance. For example:\n\n```javascript\n// Send `FLUSHDB` command to all slaves:\nvar slaves = cluster.nodes('slave');\nPromise.all(slaves.map(function (node) {\n  return node.flushdb();\n}));\n\n// Get keys of all the masters:\nvar masters = cluster.nodes('master');\nPromise.all(masters.map(function (node) {\n  return node.keys();\n})).then(function (keys) {\n  // keys: [['key1', 'key2'], ['key3', 'key4']]\n});\n```\n\n### NAT Mapping\nSometimes the cluster is hosted within a internal network that can only be accessed via a NAT (Network Address Translation) instance. See [Accessing ElastiCache from outside AWS](https://docs.aws.amazon.com/AmazonElastiCache/latest/red-ug/accessing-elasticache.html) as an example.\n\nYou can specify nat mapping rules via `natMap` option:\n\n```javascript\nconst cluster = new Redis.Cluster([{\n  host: '203.0.113.73',\n  port: 30001\n}], {\n  natMap: {\n    '10.0.1.230:30001': {host: '203.0.113.73', port: 30001},\n    '10.0.1.231:30001': {host: '203.0.113.73', port: 30002},\n    '10.0.1.232:30001': {host: '203.0.113.73', port: 30003}\n  }\n})\n```\n\nThis option is also useful when the cluster is running inside a Docker container.\n\n### Transaction and pipeline in Cluster mode\nAlmost all features that are supported by `Redis` are also supported by `Redis.Cluster`, e.g. custom commands, transaction and pipeline.\nHowever there are some differences when using transaction and pipeline in Cluster mode:\n\n0. All keys in a pipeline should belong to the same slot since ioredis sends all commands in a pipeline to the same node.\n0. You can't use `multi` without pipeline (aka `cluster.multi({ pipeline: false })`). This is because when you call `cluster.multi({ pipeline: false })`, ioredis doesn't know which node the `multi` command should be sent to.\n0. Chaining custom commands in the pipeline is not supported in Cluster mode.\n\nWhen any commands in a pipeline receives a `MOVED` or `ASK` error, ioredis will resend the whole pipeline to the specified node automatically if all of the following conditions are satisfied:\n\n0. All errors received in the pipeline are the same. For example, we won't resend the pipeline if we got two `MOVED` errors pointing to different nodes.\n0. All commands executed successfully are readonly commands. This makes sure that resending the pipeline won't have side effects.\n\n### Pub/Sub\nPub/Sub in cluster mode works exactly as the same as in standalone mode. Internally, when a node of the cluster receives a message, it will broadcast the message to the other nodes. ioredis makes sure that each message will only be received once by strictly subscribing one node at the same time.\n\n```javascript\nvar nodes = [/* nodes */];\nvar pub = new Redis.Cluster(nodes);\nvar sub = new Redis.Cluster(nodes);\nsub.on('message', function (channel, message) {\n  console.log(channel, message);\n});\n\nsub.subscribe('news', function () {\n  pub.publish('news', 'highlights');\n});\n```\n\n### Events\n\nEvent    | Description\n:------------- | :-------------\nconnect  | emits when a connection is established to the Redis server.\nready    | emits when `CLUSTER INFO` reporting the cluster is able to receive commands (if `enableReadyCheck` is `true`) or immediately after `connect` event (if `enableReadyCheck` is false).\nerror    | emits when an error occurs while connecting with a property of `lastNodeError` representing the last node error received. This event is emitted silently (only emitting if there's at least one listener).\nclose    | emits when an established Redis server connection has closed.\nreconnecting | emits after `close` when a reconnection will be made. The argument of the event is the time (in ms) before reconnecting.\nend     | emits after `close` when no more reconnections will be made.\n+node   | emits when a new node is connected.\n-node   | emits when a node is disconnected.\nnode error | emits when an error occurs when connecting to a node. The second argument indicates the address of the node.\n\n### Password\nSetting the `password` option to access password-protected clusters:\n\n```javascript\nvar Redis = require('ioredis');\nvar cluster = new Redis.Cluster(nodes, {\n  redisOptions: {\n    password: 'your-cluster-password'\n  }\n});\n```\n\nIf some of nodes in the cluster using a different password, you should specify them in the first parameter:\n\n```javascript\nvar Redis = require('ioredis');\nvar cluster = new Redis.Cluster([\n  // Use password \"password-for-30001\" for 30001\n  { port: 30001, password: 'password-for-30001'},\n  // Don't use password when accessing 30002\n  { port: 30002, password: null }\n  // Other nodes will use \"fallback-password\"\n], {\n  redisOptions: {\n    password: 'fallback-password'\n  }\n});\n```\n\n<hr>\n\n# Error Handling\nAll the errors returned by the Redis server are instances of `ReplyError`, which can be accessed via `Redis`:\n\n```javascript\nvar Redis = require('ioredis');\nvar redis = new Redis();\n// This command causes a reply error since the SET command requires two arguments.\nredis.set('foo', function (err) {\n  err instanceof Redis.ReplyError\n});\n```\n\nThis is the error stack of the `ReplyError`:\n\n```\nReplyError: ERR wrong number of arguments for 'set' command\n    at ReplyParser._parseResult (/app/node_modules/ioredis/lib/parsers/javascript.js:60:14)\n    at ReplyParser.execute (/app/node_modules/ioredis/lib/parsers/javascript.js:178:20)\n    at Socket.<anonymous> (/app/node_modules/ioredis/lib/redis/event_handler.js:99:22)\n    at Socket.emit (events.js:97:17)\n    at readableAddChunk (_stream_readable.js:143:16)\n    at Socket.Readable.push (_stream_readable.js:106:10)\n    at TCP.onread (net.js:509:20)\n```\n\nBy default, the error stack doesn't make any sense because the whole stack happens in the ioredis\nmodule itself, not in your code. So it's not easy to find out where the error happens in your code.\nioredis provides an option `showFriendlyErrorStack` to solve the problem. When you enable\n`showFriendlyErrorStack`, ioredis will optimize the error stack for you:\n\n```javascript\nvar Redis = require('ioredis');\nvar redis = new Redis({ showFriendlyErrorStack: true });\nredis.set('foo');\n```\n\nAnd the output will be:\n\n```\nReplyError: ERR wrong number of arguments for 'set' command\n    at Object.<anonymous> (/app/index.js:3:7)\n    at Module._compile (module.js:446:26)\n    at Object.Module._extensions..js (module.js:464:10)\n    at Module.load (module.js:341:32)\n    at Function.Module._load (module.js:296:12)\n    at Function.Module.runMain (module.js:487:10)\n    at startup (node.js:111:16)\n    at node.js:799:3\n```\n\nThis time the stack tells you that the error happens on the third line in your code. Pretty sweet!\nHowever, it would decrease the performance significantly to optimize the error stack. So by\ndefault, this option is disabled and can only be used for debugging purposes. You **shouldn't** use this feature in a production environment.\n\n# Plugging in your own Promises Library\nIf you're an advanced user, you may want to plug in your own promise library like [bluebird](https://www.npmjs.com/package/bluebird). Just set Redis.Promise to your favorite ES6-style promise constructor and ioredis will use it.\n\n```javascript\nconst Redis = require('ioredis')\nRedis.Promise = require('bluebird')\n\nconst redis = new Redis()\n\n// Use bluebird\nassert.equal(redis.get().constructor, require('bluebird'))\n\n// You can change the Promise implementation at any time:\nRedis.Promise = global.Promise\nassert.equal(redis.get().constructor, global.Promise)\n```\n\n\n# Running tests\n\nStart a Redis server on 127.0.0.1:6379, and then:\n\n```shell\n$ npm test\n```\n\n`FLUSH ALL` will be invoked after each test, so make sure there's no valuable data in it before running tests.\n\nIf your testing environment does not let you spin up a Redis server [ioredis-mock](https://github.com/stipsan/ioredis-mock) is a drop-in replacement you can use in your tests. It aims to behave identically to ioredis connected to a Redis server so that your integration tests is easier to write and of better quality.\n\n# Debug\n\nYou can set the `DEBUG` env to `ioredis:*` to print debug info:\n\n```shell\n$ DEBUG=ioredis:* node app.js\n```\n\n# Consolidation: It's time for celebration\n\nRight now there are two great redis clients around and both have some advantages above each other. We speak about [node_redis](https://github.com/NodeRedis/node_redis) and ioredis. So after talking to each other about how we could improve in working together we (that is [@BridgeAR](https://github.com/BridgeAR) and [@luin](https://github.com/luin)) decided to work towards a single library on the long run. But step by step.\n\nFirst of all, we want to split small parts of our libraries into others so that we're both able to use the same code. Those libraries are going to be maintained under the NodeRedis organization. This is going to reduce the maintance overhead, allows others to use the very same code, if they need it and it's way easier for others to contribute to both libraries.\n\nWe're very happy about this step towards working together as we both want to give you the best redis experience possible.\n\nIf you want to join our cause by help maintaining something, please don't hesitate to contact either one of us.\n\n# Join in!\n\nI'm happy to receive bug reports, fixes, documentation enhancements, and any other improvements.\n\nAnd since I'm not a native English speaker, if you find any grammar mistakes in the documentation, please also let me know. :)\n\n# Contributors\n\nThis project exists thanks to all the people who contribute:\n\n<a href=\"https://github.com/luin/ioredis/graphs/contributors\"><img src=\"https://opencollective.com/ioredis/contributors.svg?width=890&showBtn=false\" /></a>\n\n# License\n\nMIT\n\n\n[![FOSSA Status](https://app.fossa.io/api/projects/git%2Bgithub.com%2Fluin%2Fioredis.svg?type=large)](https://app.fossa.io/projects/git%2Bgithub.com%2Fluin%2Fioredis?ref=badge_large)\n","readmeFilename":"README.md","bugs":{"url":"https://github.com/luin/ioredis/issues"},"homepage":"https://github.com/luin/ioredis#readme","_id":"ioredis@4.9.2","_npmVersion":"6.4.1","_nodeVersion":"10.15.3","_npmUser":{"name":"ioredis-robot","email":"ioredis-robot@zihua.li"},"dist":{"integrity":"sha512-swF+KDN3GWI0uak2ZSGW3fiN+ri8BYpz2GIxUpDLaJRJnsJSbyKZ+FeVEWMud+F6LMwE+1nmzRM+tsW9sg6suA==","shasum":"302b031d1968959ee89a16f8423a5216a0b4e6fc","tarball":"https://registry.npmjs.org/ioredis/-/ioredis-4.9.2.tgz","fileCount":35,"unpackedSize":222480,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJczH6UCRA9TVsSAnZWagAALnAP/RkR/NASK8skkjIN7ZHp\nxZP/mKZp7y6bKqplyJPPjoiau2gVwZPHXLUQiWXyh6y9QF1ObPuI3mPxo3Ko\nZReMNJhOFHKglyug4Rp9pNprMnnCWfNMcGgQqaEjOeG2resDdifvsGg9kqAK\nPO9CEXi1SmHxZ/FX+1oReLFTgBskGGkLukG/VCC95+W4gFhDiMW6U4zHWn/C\nc3apWiQdG9/ErCZvaWCssbZR67f2d4AiDJHjjddih7O5sP9p01aYObuKlu16\nj9pw7wNpxdhNkODZoGlj49p9vEGpqPzPz98E0kEHbqqToxdiG0N7qtdDY+EY\naNV1qy50E/QWYOUxqCzNKUNPvR4cz7UwgJrRItdnQL2+KHjqEoo8aIy5POLU\nxMQps0GBpXQdW4eGmYvuvMudjAPGr89P6MiyR4meF8JveVUCR8Swrr8eXUDw\njaesX01nWTdiBcDPU89L4Kmt5SBFDiMk6oiphL1/qPnLoDQWJTCMq5AByzg6\nW0U0T+yhib2pP9Csb78yDMnQYZ51pY1Fq+TRP4Cf1ab1ZelEwx61tMuel/2+\nz69eluKQemyfVd6wt68Z3UZtR4T/XYAH1bZqG68FeYF5qgPmoQTFj/EH8DwC\nLae3O0GCgcJDjqnClEZYwtxd8MeOlEgFVpOoc7AKdTnScbBkZIhTVOrqOJGB\neFuh\r\n=9pY1\r\n-----END PGP SIGNATURE-----\r\n"},"maintainers":[{"email":"ioredis-robot@zihua.li","name":"ioredis-robot"},{"email":"i@zihua.li","name":"luin"}],"directories":{},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/ioredis_4.9.2_1556905618912_0.2862150699518211"},"_hasShrinkwrap":false},"4.9.3":{"name":"ioredis","version":"4.9.3","description":"A robust, performance-focused and full-featured Redis client for Node.js.","main":"built/index.js","scripts":{"test":"NODE_ENV=test mocha --timeout 8000 -r ts-node/register --exit","test:cov":"NODE_ENV=test node ./node_modules/istanbul/lib/cli.js cover --preserve-comments ./node_modules/mocha/bin/_mocha -- -r ts-node/register -R spec --exit","build":"rm -rf built && tsc","generate-docs":"jsdoc2md lib/redis.js lib/cluster/index.js lib/commander.js > API.md","prepublishOnly":"npm run build && npm test","bench":"matcha benchmarks/*.js","semantic-release":"semantic-release"},"repository":{"type":"git","url":"git://github.com/luin/ioredis.git"},"keywords":["redis","cluster","sentinel","pipelining"],"author":{"name":"luin","email":"i@zihua.li","url":"http://zihua.li"},"license":"MIT","dependencies":{"cluster-key-slot":"^1.0.6","debug":"^3.1.0","denque":"^1.1.0","lodash.defaults":"^4.2.0","lodash.flatten":"^4.4.0","redis-commands":"1.4.0","redis-errors":"^1.2.0","redis-parser":"^3.0.0","standard-as-callback":"^2.0.1"},"devDependencies":{"@semantic-release/changelog":"^3.0.0","@semantic-release/git":"^7.0.4","@types/node":"^10.11.5","@types/redis-errors":"1.2.0","bluebird":"^3.5.1","chai":"^3.5.0","cz-conventional-changelog":"^2.0.0","istanbul":"^0.4.2","jsdoc":"^3.4.0","jsdoc-to-markdown":"^4.0.1","mocha":"^5.2.0","server-destroy":"^1.0.1","sinon":"^1.17.3","ts-node":"^7.0.0","typescript":"^3.1.1"},"engines":{"node":">=6"},"config":{"commitizen":{"path":"./node_modules/cz-conventional-changelog"}},"gitHead":"519d481bfb9b3d7208508157e1763d9e37e9bda0","bugs":{"url":"https://github.com/luin/ioredis/issues"},"homepage":"https://github.com/luin/ioredis#readme","_id":"ioredis@4.9.3","_npmVersion":"6.4.1","_nodeVersion":"10.15.3","_npmUser":{"name":"ioredis-robot","email":"ioredis-robot@zihua.li"},"dist":{"integrity":"sha512-17BjBQ4cdUY8hxIvcpvxohH8uZ93/I2pi2CsdgbgXV1oYFiLOLpQASNmtZUsysxTwiF2Dcld7YgqJymNQsAdwA==","shasum":"5e200563390d152a788d757e303c6b0cd33c6ae5","tarball":"https://registry.npmjs.org/ioredis/-/ioredis-4.9.3.tgz","fileCount":35,"unpackedSize":222952,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJc0TvICRA9TVsSAnZWagAALf0QAJHwjqQVtyTP7fDQQYv/\nRJHmeNCmN2nx4H16d3UcoMqbafJlVB+5RzcwnlREs9SK6tTN5WIHKsonzZ81\nl+3WoyWgwwxdFOgNyDXHCYxd/LVy2k8bheUTXHXVZH+WBc1cweSoBwebahfi\nDlF9zdVCCfcdGbQdlFfBlahQilfPRgicFUIV0Xqs6Rnen9SiFipikp9f8tTw\n4SxD2t9pZvAQnBLvqf9QfBPO/1hF7LagjSK22PK8pFfRoaVXLIMTECKCh0L4\niZQU2vEnRg73ELNcimcBmof+mI2g6dUEpo2NvxLS+TCKOhAYe4nx2yzJF7pe\nsjof9ghkNSrItbzVvPydQiRnE8DAu4N4a4fI4cIvZF3w6uuZ1yHJ7RxHzuB9\nnpkj5EwbC1/XTQlLrKmeEMjA8r/0Qvgz3X1HWmAXjlmxLFJ3omnhGydWddX6\nUhVpM+YvM/OcUA/xnUfToNNw3Pk+7hQ7qaQ+4NP0YBcV0ilLATsfujBVTIAV\ne8w6e/oKFdh/E+OOCd1tHY6n2VBcfry3bvzAlIRpg3xvC/FwgyC2Lw5cUsvL\nPMUuz9TWB56u0zNEc1Ar5sCbfawhlkP7OLogofJQXjWlV4BQ/F3cOM8M+QS8\nF3fK7KkM51wZ12BwfSqlwiEoRgupRsHgjuIJ2+8llLOeeCuYCQpNhdUtwxPA\ngaD4\r\n=V3n1\r\n-----END PGP SIGNATURE-----\r\n"},"maintainers":[{"email":"ioredis-robot@zihua.li","name":"ioredis-robot"},{"email":"i@zihua.li","name":"luin"}],"directories":{},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/ioredis_4.9.3_1557216199686_0.699780425422927"},"_hasShrinkwrap":false},"4.9.4":{"name":"ioredis","version":"4.9.4","description":"A robust, performance-focused and full-featured Redis client for Node.js.","main":"built/index.js","scripts":{"test":"NODE_ENV=test mocha --timeout 8000 -r ts-node/register --exit","test:cov":"NODE_ENV=test node ./node_modules/istanbul/lib/cli.js cover --preserve-comments ./node_modules/mocha/bin/_mocha -- -r ts-node/register -R spec --exit","build":"rm -rf built && tsc","generate-docs":"jsdoc2md lib/redis.js lib/cluster/index.js lib/commander.js > API.md","prepublishOnly":"npm run build && npm test","bench":"matcha benchmarks/*.js","semantic-release":"semantic-release"},"repository":{"type":"git","url":"git://github.com/luin/ioredis.git"},"keywords":["redis","cluster","sentinel","pipelining"],"author":{"name":"luin","email":"i@zihua.li","url":"http://zihua.li"},"license":"MIT","dependencies":{"cluster-key-slot":"^1.0.6","debug":"^3.1.0","denque":"^1.1.0","lodash.defaults":"^4.2.0","lodash.flatten":"^4.4.0","redis-commands":"1.4.0","redis-errors":"^1.2.0","redis-parser":"^3.0.0","standard-as-callback":"^2.0.1"},"devDependencies":{"@semantic-release/changelog":"^3.0.0","@semantic-release/git":"^7.0.4","@types/node":"^10.11.5","@types/redis-errors":"1.2.0","bluebird":"^3.5.1","chai":"^3.5.0","cz-conventional-changelog":"^2.0.0","istanbul":"^0.4.2","jsdoc":"^3.4.0","jsdoc-to-markdown":"^4.0.1","mocha":"^5.2.0","server-destroy":"^1.0.1","sinon":"^1.17.3","ts-node":"^7.0.0","typescript":"^3.1.1"},"engines":{"node":">=6"},"config":{"commitizen":{"path":"./node_modules/cz-conventional-changelog"}},"gitHead":"b323c1cbf968a076c838a404f68b387ee82648db","readme":"[![ioredis](https://cdn.rawgit.com/luin/ioredis/57b5b89e3e9111ff25d8c62c0bc58ed42e5b8d1e/logo.svg)](https://github.com/luin/ioredis)\n\n[![Build Status](https://travis-ci.org/luin/ioredis.svg?branch=master)](https://travis-ci.org/luin/ioredis)\n[![Test Coverage](https://codeclimate.com/github/luin/ioredis/badges/coverage.svg)](https://codeclimate.com/github/luin/ioredis)\n[![Join the chat at https://gitter.im/luin/ioredis](https://badges.gitter.im/Join%20Chat.svg)](https://gitter.im/luin/ioredis?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge)\n[![Commitizen friendly](https://img.shields.io/badge/commitizen-friendly-brightgreen.svg)](http://commitizen.github.io/cz-cli/)\n[![semantic-release](https://img.shields.io/badge/%20%20%F0%9F%93%A6%F0%9F%9A%80-semantic--release-e10079.svg)](https://github.com/semantic-release/semantic-release)\n[![npm latest version](https://img.shields.io/npm/v/ioredis/latest.svg)](https://www.npmjs.com/package/ioredis)\n[![npm next version](https://img.shields.io/npm/v/ioredis/next.svg)](https://www.npmjs.com/package/ioredis)\n<img alt=\"\" src=\"\">\n\nA robust, performance-focused and full-featured [Redis](http://redis.io) client for [Node.js](https://nodejs.org).\n\nSupports Redis >= 2.6.12 and (Node.js >= 6).\n\n# Features\nioredis is a robust, full-featured Redis client that is\nused in the world's biggest online commerce company [Alibaba](http://www.alibaba.com/) and many other awesome companies.\n\n0. Full-featured. It supports [Cluster](http://redis.io/topics/cluster-tutorial), [Sentinel](http://redis.io/topics/sentinel), [Pipelining](http://redis.io/topics/pipelining) and of course [Lua scripting](http://redis.io/commands/eval) & [Pub/Sub](http://redis.io/topics/pubsub) (with the support of binary messages).\n0. High performance.\n0. Delightful API. It works with Node callbacks and Native promises.\n0. Transformation of command arguments and replies.\n0. Transparent key prefixing.\n0. Abstraction for Lua scripting, allowing you to define custom commands.\n0. Support for binary data.\n0. Support for TLS.\n0. Support for offline queue and ready checking.\n0. Support for ES6 types, such as `Map` and `Set`.\n0. Support for GEO commands (Redis 3.2 Unstable).\n0. Sophisticated error handling strategy.\n0. Support for NAT mapping.\n\n# Links\n* [API Documentation](API.md)\n* [Changelog](Changelog.md)\n* [Migrating from node_redis](https://github.com/luin/ioredis/wiki/Migrating-from-node_redis)\n* [Error Handling](#error-handling)\n\n## Become a Sponsor to Support ioredis's Development\nOpen source is hard and time-consuming. If you want to invest in ioredis's future you can become a sponsor and make us spend more time on this library's improvements and new features.\n\n<a href=\"https://opencollective.com/ioredis\"><img src=\"https://opencollective.com/ioredis/tiers/sponsor.svg?avatarHeight=36\"></a>\n\nThank you for using ioredis :-)\n\n<hr>\n<a href=\"https://itunes.apple.com/app/medis-gui-for-redis/id1063631769\"><img align=\"right\" src=\"medis.png\" alt=\"Download on the App Store\"></a>\n\n\n### Advertisement\n\nLooking for a Redis GUI manager for OS X, Windows and Linux? Here's [Medis](https://itunes.apple.com/us/app/medis-gui-for-redis/id1063631769)!\n\nMedis is an open-sourced, beautiful, easy-to-use Redis GUI management application.\n\nMedis starts with all the basic features you need:\n\n* Keys viewing/editing\n* SSH Tunnel for connecting with remote servers\n* Terminal for executing custom commands\n* JSON/MessagePack format viewing/editing and built-in highlighting/validator\n* And other awesome features...\n\n[Medis is open sourced on GitHub](https://github.com/luin/medis)\n\n<hr>\n\n# Quick Start\n\n## Install\n```shell\n$ npm install ioredis\n```\n\n## Basic Usage\n\n```javascript\nvar Redis = require('ioredis');\nvar redis = new Redis();\n\nredis.set('foo', 'bar');\nredis.get('foo', function (err, result) {\n  console.log(result);\n});\nredis.del('foo');\n\n// Or using a promise if the last argument isn't a function\nredis.get('foo').then(function (result) {\n  console.log(result);\n});\n\n// Arguments to commands are flattened, so the following are the same:\nredis.sadd('set', 1, 3, 5, 7);\nredis.sadd('set', [1, 3, 5, 7]);\n\n// All arguments are passed directly to the redis server:\nredis.set('key', 100, 'EX', 10);\n```\n\nSee the `examples/` folder for more examples.\n\n## Connect to Redis\nWhen a new `Redis` instance is created,\na connection to Redis will be created at the same time.\nYou can specify which Redis to connect to by:\n\n```javascript\nnew Redis()       // Connect to 127.0.0.1:6379\nnew Redis(6380)   // 127.0.0.1:6380\nnew Redis(6379, '192.168.1.1')        // 192.168.1.1:6379\nnew Redis('/tmp/redis.sock')\nnew Redis({\n  port: 6379,          // Redis port\n  host: '127.0.0.1',   // Redis host\n  family: 4,           // 4 (IPv4) or 6 (IPv6)\n  password: 'auth',\n  db: 0\n})\n```\n\nYou can also specify connection options as a [`redis://` URL](http://www.iana.org/assignments/uri-schemes/prov/redis):\n\n```javascript\n// Connect to 127.0.0.1:6380, db 4, using password \"authpassword\":\nnew Redis('redis://:authpassword@127.0.0.1:6380/4')\n```\n\nSee [API Documentation](API.md#new_Redis) for all available options.\n\n## Pub/Sub\n\nHere is a simple example of the API for publish/subscribe.\nThe following program opens two client connections.\nIt subscribes to a channel with one connection\nand publishes to that channel with the other:\n\n```javascript\nvar Redis = require('ioredis');\nvar redis = new Redis();\nvar pub = new Redis();\nredis.subscribe('news', 'music', function (err, count) {\n  // Now we are subscribed to both the 'news' and 'music' channels.\n  // `count` represents the number of channels we are currently subscribed to.\n\n  pub.publish('news', 'Hello world!');\n  pub.publish('music', 'Hello again!');\n});\n\nredis.on('message', function (channel, message) {\n  // Receive message Hello world! from channel news\n  // Receive message Hello again! from channel music\n  console.log('Receive message %s from channel %s', message, channel);\n});\n\n// There's also an event called 'messageBuffer', which is the same as 'message' except\n// it returns buffers instead of strings.\nredis.on('messageBuffer', function (channel, message) {\n  // Both `channel` and `message` are buffers.\n});\n```\n\n`PSUBSCRIBE` is also supported in a similar way:\n\n```javascript\nredis.psubscribe('pat?ern', function (err, count) {});\nredis.on('pmessage', function (pattern, channel, message) {});\nredis.on('pmessageBuffer', function (pattern, channel, message) {});\n```\n\nWhen a client issues a SUBSCRIBE or PSUBSCRIBE, that connection is put into a \"subscriber\" mode.\nAt that point, only commands that modify the subscription set are valid.\nWhen the subscription set is empty, the connection is put back into regular mode.\n\nIf you need to send regular commands to Redis while in subscriber mode, just open another connection.\n\n## Handle Binary Data\nArguments can be buffers:\n```javascript\nredis.set('foo', Buffer.from('bar'));\n```\n\nAnd every command has a method that returns a Buffer (by adding a suffix of \"Buffer\" to the command name).\nTo get a buffer instead of a utf8 string:\n\n```javascript\nredis.getBuffer('foo', function (err, result) {\n  // result is a buffer.\n});\n```\n\n## Pipelining\nIf you want to send a batch of commands (e.g. > 5), you can use pipelining to queue\nthe commands in memory and then send them to Redis all at once. This way the performance improves by 50%~300% (See [benchmark section](#benchmark)).\n\n`redis.pipeline()` creates a `Pipeline` instance. You can call any Redis\ncommands on it just like the `Redis` instance. The commands are queued in memory\nand flushed to Redis by calling the `exec` method:\n\n```javascript\nvar pipeline = redis.pipeline();\npipeline.set('foo', 'bar');\npipeline.del('cc');\npipeline.exec(function (err, results) {\n  // `err` is always null, and `results` is an array of responses\n  // corresponding to the sequence of queued commands.\n  // Each response follows the format `[err, result]`.\n});\n\n// You can even chain the commands:\nredis.pipeline().set('foo', 'bar').del('cc').exec(function (err, results) {\n});\n\n// `exec` also returns a Promise:\nvar promise = redis.pipeline().set('foo', 'bar').get('foo').exec();\npromise.then(function (result) {\n  // result === [[null, 'OK'], [null, 'bar']]\n});\n```\n\nEach chained command can also have a callback, which will be invoked when the command\ngets a reply:\n\n```javascript\nredis.pipeline().set('foo', 'bar').get('foo', function (err, result) {\n  // result === 'bar'\n}).exec(function (err, result) {\n  // result[1][1] === 'bar'\n});\n```\n\nIn addition to adding commands to the `pipeline` queue individually, you can also pass an array of commands and arguments to the constructor:\n\n```javascript\nredis.pipeline([\n  ['set', 'foo', 'bar'],\n  ['get', 'foo']\n]).exec(function () { /* ... */ });\n```\n\n`#length` property shows how many commands in the pipeline:\n\n```javascript\nconst length = redis.pipeline().set('foo', 'bar').get('foo').length;\n// length === 2\n```\n\n\n## Transaction\nMost of the time, the transaction commands `multi` & `exec` are used together with pipeline.\nTherefore, when `multi` is called, a `Pipeline` instance is created automatically by default,\nso you can use `multi` just like `pipeline`:\n\n```javascript\nredis.multi().set('foo', 'bar').get('foo').exec(function (err, results) {\n  // results === [[null, 'OK'], [null, 'bar']]\n});\n```\nIf there's a syntax error in the transaction's command chain (e.g. wrong number of arguments, wrong command name, etc),\nthen none of the commands would be executed, and an error is returned:\n\n```javascript\nredis.multi().set('foo').set('foo', 'new value').exec(function (err, results) {\n  // err:\n  //  { [ReplyError: EXECABORT Transaction discarded because of previous errors.]\n  //    name: 'ReplyError',\n  //    message: 'EXECABORT Transaction discarded because of previous errors.',\n  //    command: { name: 'exec', args: [] },\n  //    previousErrors:\n  //     [ { [ReplyError: ERR wrong number of arguments for 'set' command]\n  //         name: 'ReplyError',\n  //         message: 'ERR wrong number of arguments for \\'set\\' command',\n  //         command: [Object] } ] }\n});\n```\n\nIn terms of the interface, `multi` differs from `pipeline` in that when specifying a callback\nto each chained command, the queueing state is passed to the callback instead of the result of the command:\n\n```javascript\nredis.multi().set('foo', 'bar', function (err, result) {\n  // result === 'QUEUED'\n}).exec(/* ... */);\n```\n\nIf you want to use transaction without pipeline, pass `{ pipeline: false }` to `multi`,\nand every command will be sent to Redis immediately without waiting for an `exec` invocation:\n\n```javascript\nredis.multi({ pipeline: false });\nredis.set('foo', 'bar');\nredis.get('foo');\nredis.exec(function (err, result) {\n  // result === [[null, 'OK'], [null, 'bar']]\n});\n```\n\nThe constructor of `multi` also accepts a batch of commands:\n\n```javascript\nredis.multi([\n  ['set', 'foo', 'bar'],\n  ['get', 'foo']\n]).exec(function () { /* ... */ });\n```\n\nInline transactions are supported by pipeline, which means you can group a subset of commands\nin the pipeline into a transaction:\n\n```javascript\nredis.pipeline().get('foo').multi().set('foo', 'bar').get('foo').exec().get('foo').exec();\n```\n\n## Lua Scripting\nioredis supports all of the scripting commands such as `EVAL`, `EVALSHA` and `SCRIPT`.\nHowever, it's tedious to use in real world scenarios since developers have to take\ncare of script caching and to detect when to use `EVAL` and when to use `EVALSHA`.\nioredis expose a `defineCommand` method to make scripting much easier to use:\n\n```javascript\nvar redis = new Redis();\n\n// This will define a command echo:\nredis.defineCommand('echo', {\n  numberOfKeys: 2,\n  lua: 'return {KEYS[1],KEYS[2],ARGV[1],ARGV[2]}'\n});\n\n// Now `echo` can be used just like any other ordinary command,\n// and ioredis will try to use `EVALSHA` internally when possible for better performance.\nredis.echo('k1', 'k2', 'a1', 'a2', function (err, result) {\n  // result === ['k1', 'k2', 'a1', 'a2']\n});\n\n// `echoBuffer` is also defined automatically to return buffers instead of strings:\nredis.echoBuffer('k1', 'k2', 'a1', 'a2', function (err, result) {\n  // result[0] equals to Buffer.from('k1');\n});\n\n// And of course it works with pipeline:\nredis.pipeline().set('foo', 'bar').echo('k1', 'k2', 'a1', 'a2').exec();\n```\n\nIf the number of keys can't be determined when defining a command, you can\nomit the `numberOfKeys` property and pass the number of keys as the first argument\nwhen you call the command:\n\n```javascript\nredis.defineCommand('echoDynamicKeyNumber', {\n  lua: 'return {KEYS[1],KEYS[2],ARGV[1],ARGV[2]}'\n});\n\n// Now you have to pass the number of keys as the first argument every time\n// you invoke the `echoDynamicKeyNumber` command:\nredis.echoDynamicKeyNumber(2, 'k1', 'k2', 'a1', 'a2', function (err, result) {\n  // result === ['k1', 'k2', 'a1', 'a2']\n});\n```\n\n## Transparent Key Prefixing\nThis feature allows you to specify a string that will automatically be prepended\nto all the keys in a command, which makes it easier to manage your key\nnamespaces.\n\n**Warning** This feature won't apply to commands like [KEYS](http://redis.io/commands/KEYS) and [SCAN](http://redis.io/commands/scan) that take patterns rather than actual keys([#239](https://github.com/luin/ioredis/issues/239)),\nand this feature also won't apply to the replies of commands even they are key names ([#325](https://github.com/luin/ioredis/issues/325)).\n\n```javascript\nvar fooRedis = new Redis({ keyPrefix: 'foo:' });\nfooRedis.set('bar', 'baz');  // Actually sends SET foo:bar baz\n\nfooRedis.defineCommand('echo', {\n  numberOfKeys: 2,\n  lua: 'return {KEYS[1],KEYS[2],ARGV[1],ARGV[2]}'\n});\n\n// Works well with pipelining/transaction\nfooRedis.pipeline()\n  // Sends SORT foo:list BY foo:weight_*->fieldname\n  .sort('list', 'BY', 'weight_*->fieldname')\n  // Supports custom commands\n  // Sends EVALSHA xxx foo:k1 foo:k2 a1 a2\n  .echo('k1', 'k2', 'a1', 'a2')\n  .exec()\n```\n\n## Transforming Arguments & Replies\nMost Redis commands take one or more Strings as arguments,\nand replies are sent back as a single String or an Array of Strings. However, sometimes\nyou may want something different. For instance, it would be more convenient if the `HGETALL`\ncommand returns a hash (e.g. `{ key: val1, key2: v2 }`) rather than an array of key values (e.g. `[key1, val1, key2, val2]`).\n\nioredis has a flexible system for transforming arguments and replies. There are two types\nof transformers, argument transformer and reply transformer:\n\n```javascript\nvar Redis = require('ioredis');\n\n// Here's the built-in argument transformer converting\n// hmset('key', { k1: 'v1', k2: 'v2' })\n// or\n// hmset('key', new Map([['k1', 'v1'], ['k2', 'v2']]))\n// into\n// hmset('key', 'k1', 'v1', 'k2', 'v2')\nRedis.Command.setArgumentTransformer('hmset', function (args) {\n  if (args.length === 2) {\n    if (typeof Map !== 'undefined' && args[1] instanceof Map) {\n      // utils is a internal module of ioredis\n      return [args[0]].concat(utils.convertMapToArray(args[1]));\n    }\n    if ( typeof args[1] === 'object' && args[1] !== null) {\n      return [args[0]].concat(utils.convertObjectToArray(args[1]));\n    }\n  }\n  return args;\n});\n\n// Here's the built-in reply transformer converting the HGETALL reply\n// ['k1', 'v1', 'k2', 'v2']\n// into\n// { k1: 'v1', 'k2': 'v2' }\nRedis.Command.setReplyTransformer('hgetall', function (result) {\n  if (Array.isArray(result)) {\n    var obj = {};\n    for (var i = 0; i < result.length; i += 2) {\n      obj[result[i]] = result[i + 1];\n    }\n    return obj;\n  }\n  return result;\n});\n```\n\nThere are three built-in transformers, two argument transformers for `hmset` & `mset` and\na reply transformer for `hgetall`. Transformers for `hmset` and `hgetall` were mentioned\nabove, and the transformer for `mset` is similar to the one for `hmset`:\n\n```javascript\nredis.mset({ k1: 'v1', k2: 'v2' });\nredis.get('k1', function (err, result) {\n  // result === 'v1';\n});\n\nredis.mset(new Map([['k3', 'v3'], ['k4', 'v4']]));\nredis.get('k3', function (err, result) {\n  // result === 'v3';\n});\n```\n\nAnother useful example of a reply transformer is one that changes `hgetall` to return array of arrays instead of objects which avoids a unwanted conversation of hash keys to strings when dealing with binary hash keys:\n\n```javascript\nRedis.Command.setReplyTransformer('hgetall', function (result) {\n  var arr = [];\n  for (var i = 0; i < result.length; i += 2) {\n    arr.push([result[i], result[i + 1]]);\n  }\n  return arr;\n});\nredis.hset('h1', Buffer.from([0x01]), Buffer.from([0x02]));\nredis.hset('h1', Buffer.from([0x03]), Buffer.from([0x04]));\nredis.hgetallBuffer('h1', function (err, result) {\n  // result === [ [ <Buffer 01>, <Buffer 02> ], [ <Buffer 03>, <Buffer 04> ] ];\n});\n```\n\n## Monitor\nRedis supports the MONITOR command,\nwhich lets you see all commands received by the Redis server across all client connections,\nincluding from other client libraries and other computers.\n\nThe `monitor` method returns a monitor instance.\nAfter you send the MONITOR command, no other commands are valid on that connection. ioredis will emit a monitor event for every new monitor message that comes across.\nThe callback for the monitor event takes a timestamp from the Redis server and an array of command arguments.\n\nHere is a simple example:\n\n```javascript\nredis.monitor(function (err, monitor) {\n  monitor.on('monitor', function (time, args, source, database) {\n  });\n});\n```\n\n## Streamify Scanning\nRedis 2.8 added the `SCAN` command to incrementally iterate through the keys in the database. It's different from `KEYS` in that\n`SCAN` only returns a small number of elements each call, so it can be used in production without the downside\nof blocking the server for a long time. However, it requires recording the cursor on the client side each time\nthe `SCAN` command is called in order to iterate through all the keys correctly. Since it's a relatively common use case, ioredis\nprovides a streaming interface for the `SCAN` command to make things much easier. A readable stream can be created by calling `scanStream`:\n\n```javascript\nvar redis = new Redis();\n// Create a readable stream (object mode)\nvar stream = redis.scanStream();\nstream.on('data', function (resultKeys) {\n  // `resultKeys` is an array of strings representing key names.\n  // Note that resultKeys may contain 0 keys, and that it will sometimes\n  // contain duplicates due to SCAN's implementation in Redis.\n  for (var i = 0; i < resultKeys.length; i++) {\n    console.log(resultKeys[i]);\n  }\n});\nstream.on('end', function () {\n  console.log('all keys have been visited');\n});\n```\n\n`scanStream` accepts an option, with which you can specify the `MATCH` pattern and the `COUNT` argument:\n\n```javascript\nvar stream = redis.scanStream({\n  // only returns keys following the pattern of `user:*`\n  match: 'user:*',\n  // returns approximately 100 elements per call\n  count: 100\n});\n```\n\nJust like other commands, `scanStream` has a binary version `scanBufferStream`, which returns an array of buffers. It's useful when\nthe key names are not utf8 strings.\n\nThere are also `hscanStream`, `zscanStream` and `sscanStream` to iterate through elements in a hash, zset and set. The interface of each is\nsimilar to `scanStream` except the first argument is the key name:\n\n```javascript\nvar stream = redis.hscanStream('myhash', {\n  match: 'age:??'\n});\n```\n\nYou can learn more from the [Redis documentation](http://redis.io/commands/scan).\n\n**Useful Tips**\nIt's pretty common that doing an async task in the `data` handler. We'd like the scanning process to be paused until the async task to be finished. `Stream#pause()` and `Stream.resume()` do the trick. For example if we want to migrate data in Redis to MySQL:\n\n```javascript\nvar stream = redis.scanStream();\nstream.on('data', function (resultKeys) {\n  // Pause the stream from scanning more keys until we've migrated the current keys.\n  stream.pause();\n\n  Promise.all(resultKeys.map(migrateKeyToMySQL)).then(() => {\n    // Resume the stream here.\n    stream.resume();\n  });\n});\n\nstream.on('end', function () {\n  console.log('done migration');\n});\n```\n\n## Auto-reconnect\nBy default, ioredis will try to reconnect when the connection to Redis is lost\nexcept when the connection is closed manually by `redis.disconnect()` or `redis.quit()`.\n\nIt's very flexible to control how long to wait to reconnect after disconnection\nusing the `retryStrategy` option:\n\n```javascript\nvar redis = new Redis({\n  // This is the default value of `retryStrategy`\n  retryStrategy: function (times) {\n    var delay = Math.min(times * 50, 2000);\n    return delay;\n  }\n});\n```\n\n`retryStrategy` is a function that will be called when the connection is lost.\nThe argument `times` means this is the nth reconnection being made and\nthe return value represents how long (in ms) to wait to reconnect. When the\nreturn value isn't a number, ioredis will stop trying to reconnect, and the connection\nwill be lost forever if the user doesn't call `redis.connect()` manually.\n\nWhen reconnected, the client will auto subscribe to channels that the previous connection subscribed to.\nThis behavior can be disabled by setting the `autoResubscribe` option to `false`.\n\nAnd if the previous connection has some unfulfilled commands (most likely blocking commands such as `brpop` and `blpop`),\nthe client will resend them when reconnected. This behavior can be disabled by setting the `autoResendUnfulfilledCommands` option to `false`.\n\nBy default, all pending commands will be flushed with an error every 20 retry attempts. That makes sure commands won't wait forever when the connection is down. You can change this behavior by setting `maxRetriesPerRequest`:\n\n```javascript\nvar redis = new Redis({\n  maxRetriesPerRequest: 1\n});\n```\n\nSet maxRetriesPerRequest to `null` to disable this behavior, and every command will wait forever until the connection is alive again (which is the default behavior before ioredis v4).\n\n### Reconnect on error\n\nBesides auto-reconnect when the connection is closed, ioredis supports reconnecting on the specified errors by the `reconnectOnError` option. Here's an example that will reconnect when receiving `READONLY` error:\n\n```javascript\nvar redis = new Redis({\n  reconnectOnError: function (err) {\n    var targetError = 'READONLY';\n    if (err.message.slice(0, targetError.length) === targetError) {\n      // Only reconnect when the error starts with \"READONLY\"\n      return true; // or `return 1;`\n    }\n  }\n});\n```\n\nThis feature is useful when using Amazon ElastiCache. Once failover happens, Amazon ElastiCache will switch the master we currently connected with to a slave, leading to the following writes fails with the error `READONLY`. Using `reconnectOnError`, we can force the connection to reconnect on this error in order to connect to the new master.\n\nFurthermore, if the `reconnectOnError` returns `2`, ioredis will resend the failed command after reconnecting.\n\n## Connection Events\nThe Redis instance will emit some events about the state of the connection to the Redis server.\n\nEvent    | Description\n:------------- | :-------------\nconnect  | emits when a connection is established to the Redis server.\nready    | If `enableReadyCheck` is `true`, client will emit `ready` when the server reports that it is ready to receive commands (e.g. finish loading data from disk).<br>Otherwise, `ready` will be emitted immediately right after the `connect` event.\nerror    | emits when an error occurs while connecting.<br>However, ioredis emits all `error` events silently (only emits when there's at least one listener) so that your application won't crash if you're not listening to the `error` event.\nclose    | emits when an established Redis server connection has closed.\nreconnecting | emits after `close` when a reconnection will be made. The argument of the event is the time (in ms) before reconnecting.\nend     | emits after `close` when no more reconnections will be made, or the connection is failed to establish.\n\nYou can also check out the `Redis#status` property to get the current connection status.\n\nBesides the above connection events, there are several other custom events:\n\nEvent    | Description\n:------------- | :-------------\nselect   | emits when the database changed. The argument is the new db number.\n\n## Offline Queue\nWhen a command can't be processed by Redis (being sent before the `ready` event), by default, it's added to the offline queue and will be\nexecuted when it can be processed. You can disable this feature by setting the `enableOfflineQueue`\noption to `false`:\n\n```javascript\nvar redis = new Redis({ enableOfflineQueue: false });\n```\n\n## TLS Options\nRedis doesn't support TLS natively, however if the redis server you want to connect to is hosted behind a TLS proxy (e.g. [stunnel](https://www.stunnel.org/)) or is offered by a PaaS service that supports TLS connection (e.g. [Redis Labs](https://redislabs.com/)), you can set the `tls` option:\n\n```javascript\nvar redis = new Redis({\n  host: 'localhost',\n  tls: {\n    // Refer to `tls.connect()` section in\n    // https://nodejs.org/api/tls.html\n    // for all supported options\n    ca: fs.readFileSync('cert.pem')\n  }\n});\n```\n\n<hr>\n\n## Sentinel\nioredis supports Sentinel out of the box. It works transparently as all features that work when\nyou connect to a single node also work when you connect to a sentinel group. Make sure to run Redis >= 2.8.12 if you want to use this feature. Sentinels have a default port of 26379.\n\nTo connect using Sentinel, use:\n\n```javascript\nvar redis = new Redis({\n  sentinels: [{ host: 'localhost', port: 26379 }, { host: 'localhost', port: 26380 }],\n  name: 'mymaster'\n});\n\nredis.set('foo', 'bar');\n```\n\nThe arguments passed to the constructor are different from the ones you use to connect to a single node, where:\n\n* `name` identifies a group of Redis instances composed of a master and one or more slaves (`mymaster` in the example);\n* `sentinelPassword` (optional) password for Sentinel instances.\n* `sentinels` are a list of sentinels to connect to. The list does not need to enumerate all your sentinel instances, but a few so that if one is down the client will try the next one.\n* `role` (optional) with a value of `slave` will return a random slave from the Sentinel group.\n* `preferredSlaves` (optional) can be used to prefer a particular slave or set of slaves based on priority. It accepts a function or array.\n\nioredis **guarantees** that the node you connected to is always a master even after a failover. When a failover happens, instead of trying to reconnect to the failed node (which will be demoted to slave when it's available again), ioredis will ask sentinels for the new master node and connect to it. All commands sent during the failover are queued and will be executed when the new connection is established so that none of the commands will be lost.\n\nIt's possible to connect to a slave instead of a master by specifying the option `role` with the value of `slave` and ioredis will try to connect to a random slave of the specified master, with the guarantee that the connected node is always a slave. If the current node is promoted to master due to a failover, ioredis will disconnect from it and ask the sentinels for another slave node to connect to.\n\nIf you specify the option `preferredSlaves` along with `role: 'slave'` ioredis will attempt to use this value when selecting the slave from the pool of available slaves. The value of `preferredSlaves` should either be a function that accepts an array of avaiable slaves and returns a single result, or an array of slave values priorities by the lowest `prio` value first with a default value of `1`.\n\n```javascript\n// available slaves format\nvar availableSlaves = [{ ip: '127.0.0.1', port: '31231', flags: 'slave' }];\n\n// preferredSlaves array format\nvar preferredSlaves = [\n  { ip: '127.0.0.1', port: '31231', prio: 1 },\n  { ip: '127.0.0.1', port: '31232', prio: 2 }\n];\n\n// preferredSlaves function format\npreferredSlaves = function(availableSlaves) {\n  for (var i = 0; i < availableSlaves.length; i++) {\n    var slave = availableSlaves[i];\n    if (slave.ip === '127.0.0.1') {\n      if (slave.port === '31234') {\n        return slave;\n      }\n    }\n  }\n  // if no preferred slaves are available a random one is used\n  return false;\n};\n\nvar redis = new Redis({\n  sentinels: [{ host: '127.0.0.1', port: 26379 }, { host: '127.0.0.1', port: 26380 }],\n  name: 'mymaster',\n  role: 'slave',\n  preferredSlaves: preferredSlaves\n});\n```\n\nBesides the `retryStrategy` option, there's also a `sentinelRetryStrategy` in Sentinel mode which will be invoked when all the sentinel nodes are unreachable during connecting. If `sentinelRetryStrategy` returns a valid delay time, ioredis will try to reconnect from scratch. The default value of `sentinelRetryStrategy` is:\n\n```javascript\nfunction (times) {\n  var delay = Math.min(times * 10, 1000);\n  return delay;\n}\n```\n\n## Cluster\nRedis Cluster provides a way to run a Redis installation where data is automatically sharded across multiple Redis nodes.\nYou can connect to a Redis Cluster like this:\n\n```javascript\nvar Redis = require('ioredis');\n\nvar cluster = new Redis.Cluster([{\n  port: 6380,\n  host: '127.0.0.1'\n}, {\n  port: 6381,\n  host: '127.0.0.1'\n}]);\n\ncluster.set('foo', 'bar');\ncluster.get('foo', function (err, res) {\n  // res === 'bar'\n});\n```\n\n`Cluster` constructor accepts two arguments, where:\n\n0. The first argument is a list of nodes of the cluster you want to connect to.\nJust like Sentinel, the list does not need to enumerate all your cluster nodes,\nbut a few so that if one is unreachable the client will try the next one, and the client will discover other nodes automatically when at least one node is connected.\n0. The second argument is the options, where:\n\n    * `clusterRetryStrategy`: When none of the startup nodes are reachable, `clusterRetryStrategy` will be invoked. When a number is returned,\n    ioredis will try to reconnect to the startup nodes from scratch after the specified delay (in ms). Otherwise, an error of \"None of startup nodes is available\" will be returned.\n    The default value of this option is:\n\n        ```javascript\n        function (times) {\n          var delay = Math.min(100 + times * 2, 2000);\n          return delay;\n        }\n        ```\n\n        It's possible to modify the `startupNodes` property in order to switch to another set of nodes here:\n\n        ```javascript\n        function (times) {\n          this.startupNodes = [{ port: 6790, host: '127.0.0.1' }];\n          return Math.min(100 + times * 2, 2000);\n        }\n        ```\n\n    * `enableOfflineQueue`: Similar to the `enableOfflineQueue` option of `Redis` class.\n    * `enableReadyCheck`: When enabled, \"ready\" event will only be emitted when `CLUSTER INFO` command\n    reporting the cluster is ready for handling commands. Otherwise, it will be emitted immediately after \"connect\" is emitted.\n    * `scaleReads`: Config where to send the read queries. See below for more details.\n    * `maxRedirections`: When a cluster related error (e.g. `MOVED`, `ASK` and `CLUSTERDOWN` etc.) is received, the client will redirect the\n    command to another node. This option limits the max redirections allowed when sending a command. The default value is `16`.\n    * `retryDelayOnFailover`: If the target node is disconnected when sending a command,\n    ioredis will retry after the specified delay. The default value is `100`. You should make sure `retryDelayOnFailover * maxRedirections > cluster-node-timeout`\n    to insure that no command will fail during a failover.\n    * `retryDelayOnClusterDown`: When a cluster is down, all commands will be rejected with the error of `CLUSTERDOWN`. If this option is a number (by default, it is `100`), the client\n    will resend the commands after the specified time (in ms).\n    * `retryDelayOnTryAgain`: If this option is a number (by default, it is `100`), the client\n    will resend the commands rejected with `TRYAGAIN` error after the specified time (in ms).\n    * `redisOptions`: Default options passed to the constructor of `Redis` when connecting to a node.\n    * `slotsRefreshTimeout`: Milliseconds before a timeout occurs while refreshing slots from the cluster (default `1000`)\n    * `slotsRefreshInterval`: Milliseconds between every automatic slots refresh (default `5000`)\n\n### Read-write splitting\n\nA typical redis cluster contains three or more masters and several slaves for each master. It's possible to scale out redis cluster by sending read queries to slaves and write queries to masters by setting the `scaleReads` option.\n\n`scaleReads` is \"master\" by default, which means ioredis will never send any queries to slaves. There are other three available options:\n\n1. \"all\": Send write queries to masters and read queries to masters or slaves randomly.\n2. \"slave\": Send write queries to masters and read queries to slaves.\n3. a custom `function(nodes, command): node`: Will choose the custom function to select to which node to send read queries (write queries keep being sent to master). The first node in `nodes` is always the master serving the relevant slots. If the function returns an array of nodes, a random node of that list will be selected.\n\nFor example:\n\n```javascript\nvar cluster = new Redis.Cluster([/* nodes */], {\n  scaleReads: 'slave'\n});\ncluster.set('foo', 'bar'); // This query will be sent to one of the masters.\ncluster.get('foo', function (err, res) {\n  // This query will be sent to one of the slaves.\n});\n```\n\n**NB** In the code snippet above, the `res` may not be equal to \"bar\" because of the lag of replication between the master and slaves.\n\n### Running commands to multiple nodes\n\nEvery command will be sent to exactly one node. For commands containing keys, (e.g. `GET`, `SET` and `HGETALL`), ioredis sends them to the node that serving the keys, and for other commands not containing keys, (e.g. `INFO`, `KEYS` and `FLUSHDB`), ioredis sends them to a random node.\n\nSometimes you may want to send a command to multiple nodes (masters or slaves) of the cluster, you can get the nodes via `Cluster#nodes()` method.\n\n`Cluster#nodes()` accepts a parameter role, which can be \"master\", \"slave\" and \"all\" (default), and returns an array of `Redis` instance. For example:\n\n```javascript\n// Send `FLUSHDB` command to all slaves:\nvar slaves = cluster.nodes('slave');\nPromise.all(slaves.map(function (node) {\n  return node.flushdb();\n}));\n\n// Get keys of all the masters:\nvar masters = cluster.nodes('master');\nPromise.all(masters.map(function (node) {\n  return node.keys();\n})).then(function (keys) {\n  // keys: [['key1', 'key2'], ['key3', 'key4']]\n});\n```\n\n### NAT Mapping\nSometimes the cluster is hosted within a internal network that can only be accessed via a NAT (Network Address Translation) instance. See [Accessing ElastiCache from outside AWS](https://docs.aws.amazon.com/AmazonElastiCache/latest/red-ug/accessing-elasticache.html) as an example.\n\nYou can specify nat mapping rules via `natMap` option:\n\n```javascript\nconst cluster = new Redis.Cluster([{\n  host: '203.0.113.73',\n  port: 30001\n}], {\n  natMap: {\n    '10.0.1.230:30001': {host: '203.0.113.73', port: 30001},\n    '10.0.1.231:30001': {host: '203.0.113.73', port: 30002},\n    '10.0.1.232:30001': {host: '203.0.113.73', port: 30003}\n  }\n})\n```\n\nThis option is also useful when the cluster is running inside a Docker container.\n\n### Transaction and pipeline in Cluster mode\nAlmost all features that are supported by `Redis` are also supported by `Redis.Cluster`, e.g. custom commands, transaction and pipeline.\nHowever there are some differences when using transaction and pipeline in Cluster mode:\n\n0. All keys in a pipeline should belong to the same slot since ioredis sends all commands in a pipeline to the same node.\n0. You can't use `multi` without pipeline (aka `cluster.multi({ pipeline: false })`). This is because when you call `cluster.multi({ pipeline: false })`, ioredis doesn't know which node the `multi` command should be sent to.\n0. Chaining custom commands in the pipeline is not supported in Cluster mode.\n\nWhen any commands in a pipeline receives a `MOVED` or `ASK` error, ioredis will resend the whole pipeline to the specified node automatically if all of the following conditions are satisfied:\n\n0. All errors received in the pipeline are the same. For example, we won't resend the pipeline if we got two `MOVED` errors pointing to different nodes.\n0. All commands executed successfully are readonly commands. This makes sure that resending the pipeline won't have side effects.\n\n### Pub/Sub\nPub/Sub in cluster mode works exactly as the same as in standalone mode. Internally, when a node of the cluster receives a message, it will broadcast the message to the other nodes. ioredis makes sure that each message will only be received once by strictly subscribing one node at the same time.\n\n```javascript\nvar nodes = [/* nodes */];\nvar pub = new Redis.Cluster(nodes);\nvar sub = new Redis.Cluster(nodes);\nsub.on('message', function (channel, message) {\n  console.log(channel, message);\n});\n\nsub.subscribe('news', function () {\n  pub.publish('news', 'highlights');\n});\n```\n\n### Events\n\nEvent    | Description\n:------------- | :-------------\nconnect  | emits when a connection is established to the Redis server.\nready    | emits when `CLUSTER INFO` reporting the cluster is able to receive commands (if `enableReadyCheck` is `true`) or immediately after `connect` event (if `enableReadyCheck` is false).\nerror    | emits when an error occurs while connecting with a property of `lastNodeError` representing the last node error received. This event is emitted silently (only emitting if there's at least one listener).\nclose    | emits when an established Redis server connection has closed.\nreconnecting | emits after `close` when a reconnection will be made. The argument of the event is the time (in ms) before reconnecting.\nend     | emits after `close` when no more reconnections will be made.\n+node   | emits when a new node is connected.\n-node   | emits when a node is disconnected.\nnode error | emits when an error occurs when connecting to a node. The second argument indicates the address of the node.\n\n### Password\nSetting the `password` option to access password-protected clusters:\n\n```javascript\nvar Redis = require('ioredis');\nvar cluster = new Redis.Cluster(nodes, {\n  redisOptions: {\n    password: 'your-cluster-password'\n  }\n});\n```\n\nIf some of nodes in the cluster using a different password, you should specify them in the first parameter:\n\n```javascript\nvar Redis = require('ioredis');\nvar cluster = new Redis.Cluster([\n  // Use password \"password-for-30001\" for 30001\n  { port: 30001, password: 'password-for-30001'},\n  // Don't use password when accessing 30002\n  { port: 30002, password: null }\n  // Other nodes will use \"fallback-password\"\n], {\n  redisOptions: {\n    password: 'fallback-password'\n  }\n});\n```\n\n<hr>\n\n# Error Handling\nAll the errors returned by the Redis server are instances of `ReplyError`, which can be accessed via `Redis`:\n\n```javascript\nvar Redis = require('ioredis');\nvar redis = new Redis();\n// This command causes a reply error since the SET command requires two arguments.\nredis.set('foo', function (err) {\n  err instanceof Redis.ReplyError\n});\n```\n\nThis is the error stack of the `ReplyError`:\n\n```\nReplyError: ERR wrong number of arguments for 'set' command\n    at ReplyParser._parseResult (/app/node_modules/ioredis/lib/parsers/javascript.js:60:14)\n    at ReplyParser.execute (/app/node_modules/ioredis/lib/parsers/javascript.js:178:20)\n    at Socket.<anonymous> (/app/node_modules/ioredis/lib/redis/event_handler.js:99:22)\n    at Socket.emit (events.js:97:17)\n    at readableAddChunk (_stream_readable.js:143:16)\n    at Socket.Readable.push (_stream_readable.js:106:10)\n    at TCP.onread (net.js:509:20)\n```\n\nBy default, the error stack doesn't make any sense because the whole stack happens in the ioredis\nmodule itself, not in your code. So it's not easy to find out where the error happens in your code.\nioredis provides an option `showFriendlyErrorStack` to solve the problem. When you enable\n`showFriendlyErrorStack`, ioredis will optimize the error stack for you:\n\n```javascript\nvar Redis = require('ioredis');\nvar redis = new Redis({ showFriendlyErrorStack: true });\nredis.set('foo');\n```\n\nAnd the output will be:\n\n```\nReplyError: ERR wrong number of arguments for 'set' command\n    at Object.<anonymous> (/app/index.js:3:7)\n    at Module._compile (module.js:446:26)\n    at Object.Module._extensions..js (module.js:464:10)\n    at Module.load (module.js:341:32)\n    at Function.Module._load (module.js:296:12)\n    at Function.Module.runMain (module.js:487:10)\n    at startup (node.js:111:16)\n    at node.js:799:3\n```\n\nThis time the stack tells you that the error happens on the third line in your code. Pretty sweet!\nHowever, it would decrease the performance significantly to optimize the error stack. So by\ndefault, this option is disabled and can only be used for debugging purposes. You **shouldn't** use this feature in a production environment.\n\n# Plugging in your own Promises Library\nIf you're an advanced user, you may want to plug in your own promise library like [bluebird](https://www.npmjs.com/package/bluebird). Just set Redis.Promise to your favorite ES6-style promise constructor and ioredis will use it.\n\n```javascript\nconst Redis = require('ioredis')\nRedis.Promise = require('bluebird')\n\nconst redis = new Redis()\n\n// Use bluebird\nassert.equal(redis.get().constructor, require('bluebird'))\n\n// You can change the Promise implementation at any time:\nRedis.Promise = global.Promise\nassert.equal(redis.get().constructor, global.Promise)\n```\n\n\n# Running tests\n\nStart a Redis server on 127.0.0.1:6379, and then:\n\n```shell\n$ npm test\n```\n\n`FLUSH ALL` will be invoked after each test, so make sure there's no valuable data in it before running tests.\n\nIf your testing environment does not let you spin up a Redis server [ioredis-mock](https://github.com/stipsan/ioredis-mock) is a drop-in replacement you can use in your tests. It aims to behave identically to ioredis connected to a Redis server so that your integration tests is easier to write and of better quality.\n\n# Debug\n\nYou can set the `DEBUG` env to `ioredis:*` to print debug info:\n\n```shell\n$ DEBUG=ioredis:* node app.js\n```\n\n# Consolidation: It's time for celebration\n\nRight now there are two great redis clients around and both have some advantages above each other. We speak about [node_redis](https://github.com/NodeRedis/node_redis) and ioredis. So after talking to each other about how we could improve in working together we (that is [@BridgeAR](https://github.com/BridgeAR) and [@luin](https://github.com/luin)) decided to work towards a single library on the long run. But step by step.\n\nFirst of all, we want to split small parts of our libraries into others so that we're both able to use the same code. Those libraries are going to be maintained under the NodeRedis organization. This is going to reduce the maintance overhead, allows others to use the very same code, if they need it and it's way easier for others to contribute to both libraries.\n\nWe're very happy about this step towards working together as we both want to give you the best redis experience possible.\n\nIf you want to join our cause by help maintaining something, please don't hesitate to contact either one of us.\n\n# Join in!\n\nI'm happy to receive bug reports, fixes, documentation enhancements, and any other improvements.\n\nAnd since I'm not a native English speaker, if you find any grammar mistakes in the documentation, please also let me know. :)\n\n# Contributors\n\nThis project exists thanks to all the people who contribute:\n\n<a href=\"https://github.com/luin/ioredis/graphs/contributors\"><img src=\"https://opencollective.com/ioredis/contributors.svg?width=890&showBtn=false\" /></a>\n\n# License\n\nMIT\n\n\n[![FOSSA Status](https://app.fossa.io/api/projects/git%2Bgithub.com%2Fluin%2Fioredis.svg?type=large)](https://app.fossa.io/projects/git%2Bgithub.com%2Fluin%2Fioredis?ref=badge_large)\n","readmeFilename":"README.md","bugs":{"url":"https://github.com/luin/ioredis/issues"},"homepage":"https://github.com/luin/ioredis#readme","_id":"ioredis@4.9.4","_npmVersion":"6.4.1","_nodeVersion":"10.15.3","_npmUser":{"name":"ioredis-robot","email":"ioredis-robot@zihua.li"},"dist":{"integrity":"sha512-tMRAmyGCH5pAYzRtFIO5HgfVgUoSI4sqvV36bCOJzxMGVxgJjmWUTHFPH+kwqeJh9gXi63T4Xv8oYZhbno6YrQ==","shasum":"006781028a299d38c8e65ad2cd3282cd8e21ec84","tarball":"https://registry.npmjs.org/ioredis/-/ioredis-4.9.4.tgz","fileCount":35,"unpackedSize":223266,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJc2YYmCRA9TVsSAnZWagAA9AgP/j7b1zbp4YDpCmW5F/kB\n09qH1hkNFR1/eRUU479dMpk/Cs6rK0cer/jLUoUdKNb9IjBJyp+ztl1Ok/XF\naUjJexhRKndbrRAtd7gKlPWkNI59xLQ0i6ebzrt8hMvxtXrGtAA2NR7iAh0O\ng5aEAYnpxsrpDiv03zO/bRKxrKyckXYHdKfGUBhLbfPri3PJmnFS7JPpSNTE\nv1ot8SYq1xz8WsSNbJ9eWDDbsmnNd6ADrZezJlVQemPnOPJvcURnnEk0Zih2\nQul8OUhGBjYXRZCcHpKxYPLAUB228iLr1dPtDwoL3ey52TvMko12BX62pBmu\nkMlWTmbPbcJ54COzt/+SyBwZ1bRZ0qoqoe+WewAaLOS1yfygnznf+lfiphns\ncBwrkS16nJVHDfsDOby5HX92bXFJ/q0rwD4P0Wez+afdv0AxHhCNnhNrpkWE\nvqR8MovAhMGw5JlEPiv2CDNlEEni+Nn17RQ6otuYxDinldA7VVKKwSt/JmGV\nPQl4L7E2qkiWZNevNgNQSk0918Di4F38OTtOFAaXbbLfQmKzDTxiLzyi3BEm\nUDEfTR4TvFw86BYO4iyq6MC36HoXoHgJjbnCBPhXfrAu6kbtjdxR6NtJ+DFK\niddmifJ6t7oNWRBUzaIKs28HsOxoNF0H9xHm8Nxand/1n8fIPgMcic99Ty7Y\n/6NI\r\n=wsc5\r\n-----END PGP SIGNATURE-----\r\n"},"maintainers":[{"email":"ioredis-robot@zihua.li","name":"ioredis-robot"},{"email":"i@zihua.li","name":"luin"}],"directories":{},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/ioredis_4.9.4_1557759525231_0.8059909132507252"},"_hasShrinkwrap":false},"4.9.5":{"name":"ioredis","version":"4.9.5","description":"A robust, performance-focused and full-featured Redis client for Node.js.","main":"built/index.js","scripts":{"test":"NODE_ENV=test mocha --timeout 8000 -r ts-node/register --exit","test:cov":"NODE_ENV=test node ./node_modules/istanbul/lib/cli.js cover --preserve-comments ./node_modules/mocha/bin/_mocha -- -r ts-node/register -R spec --exit","build":"rm -rf built && tsc","generate-docs":"jsdoc2md lib/redis.js lib/cluster/index.js lib/commander.js > API.md","prepublishOnly":"npm run build && npm test","bench":"matcha benchmarks/*.js","semantic-release":"semantic-release"},"repository":{"type":"git","url":"git://github.com/luin/ioredis.git"},"keywords":["redis","cluster","sentinel","pipelining"],"author":{"name":"luin","email":"i@zihua.li","url":"http://zihua.li"},"license":"MIT","dependencies":{"cluster-key-slot":"^1.0.6","debug":"^3.1.0","denque":"^1.1.0","lodash.defaults":"^4.2.0","lodash.flatten":"^4.4.0","redis-commands":"1.4.0","redis-errors":"^1.2.0","redis-parser":"^3.0.0","standard-as-callback":"^2.0.1"},"devDependencies":{"@semantic-release/changelog":"^3.0.0","@semantic-release/git":"^7.0.4","@types/node":"^10.11.5","@types/redis-errors":"1.2.0","bluebird":"^3.5.1","chai":"^3.5.0","cz-conventional-changelog":"^2.0.0","istanbul":"^0.4.2","jsdoc":"^3.4.0","jsdoc-to-markdown":"^4.0.1","mocha":"^5.2.0","server-destroy":"^1.0.1","sinon":"^1.17.3","ts-node":"^7.0.0","typescript":"^3.1.1"},"engines":{"node":">=6"},"config":{"commitizen":{"path":"./node_modules/cz-conventional-changelog"}},"gitHead":"9d9c292dac60690d27362d27c8f13b9065fe3c6b","bugs":{"url":"https://github.com/luin/ioredis/issues"},"homepage":"https://github.com/luin/ioredis#readme","_id":"ioredis@4.9.5","_npmVersion":"6.4.1","_nodeVersion":"10.15.3","_npmUser":{"name":"ioredis-robot","email":"ioredis-robot@zihua.li"},"dist":{"integrity":"sha512-L9MVfvX4F3LScTMEgriCGixzqinJsYy7Mt0NPX8RyuOTmx5JW0744pM4Ze2KVQcP3J0zvKYZ1LywAB6KIq7PYg==","shasum":"0bbba0a9faae93485d3231e1b819d2d4e23271d9","tarball":"https://registry.npmjs.org/ioredis/-/ioredis-4.9.5.tgz","fileCount":35,"unpackedSize":224361,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJc25ebCRA9TVsSAnZWagAAYwoQAIFod3fwvQGkxx9ItFZo\nu1MAoPW+rHehoyfOkS2OxqqbLwp8klken3reWlhxpOJsA3bRgulq7pOpeggW\n8ki8Gw+SBCG+yOeRuVFwoqLWknZSkshcklDhkgBPxQZtsFCxaajo6vimK3Qj\n/d39xnzCsttlv2EDdvBh4BJ19FUtxDLONfOlTnnfwLgxvw/m/ZNfTvIcGPz/\nZrLQ1xA7eWulOmyIxLY0+01GFq3qO9MI98U+FwWGVoM445aaJEbtpwfw8lzQ\nOskyVDsKpXODS3MXjWpWeWDk1J6egCYRIJo/iALq+Ymr6UwgvlSA5a9kWGUl\nlsUMqLgBZBjHRER4BS0oaqaOV3fcYDMVP3xe55UOUVwGxkd6wHIM1J9fJEtd\nW8ipWTpCSexYJfiw9C519tUQHH52DUcpr2rC7IAOw+zwZobgc95j9rHCkVnQ\nDaIwk6c9nZWhzm8C7Bb+j0ejwVLwhIkIlsm41kEs7IleIFT2bLgVHgDR8ZuC\nU7MyUq4c96OoQ7rbyIt4RpLiXAURI48K+T0mDWlGiv/E923NgiKeRdk+z46D\nXvH6sJm97aZHvpR9WpTfmLNfln2aRSsTonTCS0a80/rGRvxqBIM9YmCDWjg1\nrchCLPxRp3ZiDBAHOCaFCgNtC36jwTiyLfMlmWN4lPyItYXrQMdFlPKC905k\nVEeP\r\n=eE71\r\n-----END PGP SIGNATURE-----\r\n"},"maintainers":[{"email":"ioredis-robot@zihua.li","name":"ioredis-robot"},{"email":"i@zihua.li","name":"luin"}],"directories":{},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/ioredis_4.9.5_1557895066203_0.7099298734891248"},"_hasShrinkwrap":false},"4.10.0":{"name":"ioredis","version":"4.10.0","description":"A robust, performance-focused and full-featured Redis client for Node.js.","main":"built/index.js","scripts":{"test":"NODE_ENV=test mocha --timeout 8000 -r ts-node/register --exit","test:cov":"NODE_ENV=test node ./node_modules/istanbul/lib/cli.js cover --preserve-comments ./node_modules/mocha/bin/_mocha -- -r ts-node/register -R spec --exit","build":"rm -rf built && tsc","generate-docs":"jsdoc2md lib/redis.js lib/cluster/index.js lib/commander.js > API.md","prepublishOnly":"npm run build && npm test","bench":"matcha benchmarks/*.js","semantic-release":"semantic-release"},"repository":{"type":"git","url":"git://github.com/luin/ioredis.git"},"keywords":["redis","cluster","sentinel","pipelining"],"author":{"name":"luin","email":"i@zihua.li","url":"http://zihua.li"},"license":"MIT","dependencies":{"cluster-key-slot":"^1.0.6","debug":"^3.1.0","denque":"^1.1.0","lodash.defaults":"^4.2.0","lodash.flatten":"^4.4.0","redis-commands":"1.5.0","redis-errors":"^1.2.0","redis-parser":"^3.0.0","standard-as-callback":"^2.0.1"},"devDependencies":{"@semantic-release/changelog":"^3.0.0","@semantic-release/git":"^7.0.4","@types/node":"^10.11.5","@types/redis-errors":"1.2.0","bluebird":"^3.5.1","chai":"^3.5.0","cz-conventional-changelog":"^2.0.0","istanbul":"^0.4.2","jsdoc":"^3.4.0","jsdoc-to-markdown":"^4.0.1","mocha":"^5.2.0","server-destroy":"^1.0.1","sinon":"^1.17.3","ts-node":"^7.0.0","typescript":"^3.1.1"},"engines":{"node":">=6"},"config":{"commitizen":{"path":"./node_modules/cz-conventional-changelog"}},"gitHead":"f941f629df0cd700c8a460f89ab8f762865ffdb7","bugs":{"url":"https://github.com/luin/ioredis/issues"},"homepage":"https://github.com/luin/ioredis#readme","_id":"ioredis@4.10.0","_npmVersion":"6.4.1","_nodeVersion":"10.15.3","_npmUser":{"name":"ioredis-robot","email":"ioredis-robot@zihua.li"},"dist":{"integrity":"sha512-bAdt/sKdOvUyKhjLJ8HKFmO6ZQ+OHHmfFgWn9X/ecsp1lJNnOtmh/Xl2+AdKwUdSkl/Rrw1CKOkR8+Kv8tRinQ==","shasum":"a212127473d1618af3714bd6c09fb7dcab594250","tarball":"https://registry.npmjs.org/ioredis/-/ioredis-4.10.0.tgz","fileCount":35,"unpackedSize":224606,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJc5r2VCRA9TVsSAnZWagAA4TcP/ikzkbiqjfgDBzy9zzFp\n6o3Vbu2d0oE8WU/MUUax+H/0zorExwMjVln/eCG4BZZH2t1wuajoUXeg9AkG\nfnPkCH+qYme2gyfZZFZR+Qu17npuunt9xcLf7mUTFlhcIPhGCsnYaDhq3B9T\nwPdYZGlm5G7jdGjibHeOwgBlley7SnBJF5y93aiHs/Kjia1rlS7juUsTpSnD\nuPqqw6760UqSq8pJveqgTt5AkOBDF014TQ+yIJk0y96D4EBmP+OzBg7C63rr\nB3yfyIm3Z9jlW+RqI6hQYRraesXUgz7cp4hxil0olL4pjFvaKX1MZmoBeyPf\nqdO93GH9Ix2jZQR5jebM9KisZ0RNbbfr881v+dY28Q9gnIcHN60IMa1gaic5\nXNu75JuwMzAg3ZLdLt1Iu5hetzzkq67hHGP6tI6XJs84UlF20nYorscEakGY\nZl8VpuhTGbznsefaTT4/7GvdAci59tjJ5AVGLYsbbepmthFPol65g9h/UR8V\nADFsm+Aze8R9ub5FBkHWdp4U6k0iTQVRLLGwsSWdbMuHedVyAVrQEhlehpht\nCzqwLq1C+uBvGTfD0bheclywAmb6zCsBdt/RyTYjFzvEY8X2WgKENku9bNqz\np1ul3q0CagzZ+fPlRjNr2+6z3rVscg14en/eTx6GjUSbcVMwXk5uDnwYtR72\nmiQs\r\n=I4d2\r\n-----END PGP SIGNATURE-----\r\n"},"maintainers":[{"email":"ioredis-robot@zihua.li","name":"ioredis-robot"},{"email":"i@zihua.li","name":"luin"}],"directories":{},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/ioredis_4.10.0_1558625684516_0.8468138840856769"},"_hasShrinkwrap":false},"4.10.1":{"name":"ioredis","version":"4.10.1","description":"A robust, performance-focused and full-featured Redis client for Node.js.","main":"built/index.js","scripts":{"test":"NODE_ENV=test mocha","test:cov":"NODE_ENV=test node ./node_modules/istanbul/lib/cli.js cover --preserve-comments ./node_modules/mocha/bin/_mocha -- -r ts-node/register -R spec --exit","build":"rm -rf built && tsc","prepublishOnly":"npm run build && npm test","bench":"matcha benchmarks/*.js","semantic-release":"semantic-release"},"repository":{"type":"git","url":"git://github.com/luin/ioredis.git"},"keywords":["redis","cluster","sentinel","pipelining"],"author":{"name":"luin","email":"i@zihua.li","url":"http://zihua.li"},"license":"MIT","dependencies":{"cluster-key-slot":"^1.0.6","debug":"^4.1.1","denque":"^1.1.0","lodash.defaults":"^4.2.0","lodash.flatten":"^4.4.0","redis-commands":"1.5.0","redis-errors":"^1.2.0","redis-parser":"^3.0.0","standard-as-callback":"^2.0.1"},"devDependencies":{"@semantic-release/changelog":"^3.0.4","@semantic-release/git":"^7.0.12","@types/node":"^12.0.2","@types/redis-errors":"1.2.0","bluebird":"^3.5.4","chai":"^4.2.0","cz-conventional-changelog":"^2.0.0","istanbul":"^0.4.5","mocha":"^5.0.0","server-destroy":"^1.0.1","sinon":"^7.3.2","ts-node":"^8.1.0","typescript":"^3.4.5"},"engines":{"node":">=6"},"config":{"commitizen":{"path":"./node_modules/cz-conventional-changelog"}},"gitHead":"bf92b24b43ed5184d31f791f5a7dea2b0d55eee2","readme":"[![ioredis](https://cdn.jsdelivr.net/gh/luin/ioredis@b5e8c74/logo.svg)](https://github.com/luin/ioredis)\n\n[![Build Status](https://travis-ci.org/luin/ioredis.svg?branch=master)](https://travis-ci.org/luin/ioredis)\n[![Test Coverage](https://codeclimate.com/github/luin/ioredis/badges/coverage.svg)](https://codeclimate.com/github/luin/ioredis)\n[![Join the chat at https://gitter.im/luin/ioredis](https://badges.gitter.im/Join%20Chat.svg)](https://gitter.im/luin/ioredis?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge)\n[![Commitizen friendly](https://img.shields.io/badge/commitizen-friendly-brightgreen.svg)](http://commitizen.github.io/cz-cli/)\n[![semantic-release](https://img.shields.io/badge/%20%20%F0%9F%93%A6%F0%9F%9A%80-semantic--release-e10079.svg)](https://github.com/semantic-release/semantic-release)\n[![npm latest version](https://img.shields.io/npm/v/ioredis/latest.svg)](https://www.npmjs.com/package/ioredis)\n[![npm next version](https://img.shields.io/npm/v/ioredis/next.svg)](https://www.npmjs.com/package/ioredis)\n<img alt=\"\" src=\"\">\n\nA robust, performance-focused and full-featured [Redis](http://redis.io) client for [Node.js](https://nodejs.org).\n\nSupports Redis >= 2.6.12 and (Node.js >= 6).\n\n# Features\nioredis is a robust, full-featured Redis client that is\nused in the world's biggest online commerce company [Alibaba](http://www.alibaba.com/) and many other awesome companies.\n\n0. Full-featured. It supports [Cluster](http://redis.io/topics/cluster-tutorial), [Sentinel](http://redis.io/topics/sentinel), [Pipelining](http://redis.io/topics/pipelining) and of course [Lua scripting](http://redis.io/commands/eval) & [Pub/Sub](http://redis.io/topics/pubsub) (with the support of binary messages).\n0. High performance.\n0. Delightful API. It works with Node callbacks and Native promises.\n0. Transformation of command arguments and replies.\n0. Transparent key prefixing.\n0. Abstraction for Lua scripting, allowing you to define custom commands.\n0. Support for binary data.\n0. Support for TLS.\n0. Support for offline queue and ready checking.\n0. Support for ES6 types, such as `Map` and `Set`.\n0. Support for GEO commands (Redis 3.2 Unstable).\n0. Sophisticated error handling strategy.\n0. Support for NAT mapping.\n\n# Links\n* [API Documentation](API.md)\n* [Changelog](Changelog.md)\n* [Migrating from node_redis](https://github.com/luin/ioredis/wiki/Migrating-from-node_redis)\n* [Error Handling](#error-handling)\n\n## Become a Sponsor to Support ioredis's Development\nOpen source is hard and time-consuming. If you want to invest in ioredis's future you can become a sponsor and make us spend more time on this library's improvements and new features.\n\n<a href=\"https://opencollective.com/ioredis\"><img src=\"https://opencollective.com/ioredis/tiers/sponsor.svg?avatarHeight=36\"></a>\n\nThank you for using ioredis :-)\n\n<hr>\n<a href=\"https://itunes.apple.com/app/medis-gui-for-redis/id1063631769\"><img align=\"right\" src=\"medis.png\" alt=\"Download on the App Store\"></a>\n\n\n### Advertisement\n\nLooking for a Redis GUI manager for OS X, Windows and Linux? Here's [Medis](https://itunes.apple.com/us/app/medis-gui-for-redis/id1063631769)!\n\nMedis is an open-sourced, beautiful, easy-to-use Redis GUI management application.\n\nMedis starts with all the basic features you need:\n\n* Keys viewing/editing\n* SSH Tunnel for connecting with remote servers\n* Terminal for executing custom commands\n* JSON/MessagePack format viewing/editing and built-in highlighting/validator\n* And other awesome features...\n\n[Medis is open sourced on GitHub](https://github.com/luin/medis)\n\n<hr>\n\n# Quick Start\n\n## Install\n```shell\n$ npm install ioredis\n```\n\n## Basic Usage\n\n```javascript\nvar Redis = require('ioredis');\nvar redis = new Redis();\n\nredis.set('foo', 'bar');\nredis.get('foo', function (err, result) {\n  console.log(result);\n});\nredis.del('foo');\n\n// Or using a promise if the last argument isn't a function\nredis.get('foo').then(function (result) {\n  console.log(result);\n});\n\n// Arguments to commands are flattened, so the following are the same:\nredis.sadd('set', 1, 3, 5, 7);\nredis.sadd('set', [1, 3, 5, 7]);\n\n// All arguments are passed directly to the redis server:\nredis.set('key', 100, 'EX', 10);\n```\n\nSee the `examples/` folder for more examples.\n\n## Connect to Redis\nWhen a new `Redis` instance is created,\na connection to Redis will be created at the same time.\nYou can specify which Redis to connect to by:\n\n```javascript\nnew Redis()       // Connect to 127.0.0.1:6379\nnew Redis(6380)   // 127.0.0.1:6380\nnew Redis(6379, '192.168.1.1')        // 192.168.1.1:6379\nnew Redis('/tmp/redis.sock')\nnew Redis({\n  port: 6379,          // Redis port\n  host: '127.0.0.1',   // Redis host\n  family: 4,           // 4 (IPv4) or 6 (IPv6)\n  password: 'auth',\n  db: 0\n})\n```\n\nYou can also specify connection options as a [`redis://` URL](http://www.iana.org/assignments/uri-schemes/prov/redis):\n\n```javascript\n// Connect to 127.0.0.1:6380, db 4, using password \"authpassword\":\nnew Redis('redis://:authpassword@127.0.0.1:6380/4')\n```\n\nSee [API Documentation](API.md#new_Redis) for all available options.\n\n## Pub/Sub\n\nHere is a simple example of the API for publish/subscribe.\nThe following program opens two client connections.\nIt subscribes to a channel with one connection\nand publishes to that channel with the other:\n\n```javascript\nvar Redis = require('ioredis');\nvar redis = new Redis();\nvar pub = new Redis();\nredis.subscribe('news', 'music', function (err, count) {\n  // Now we are subscribed to both the 'news' and 'music' channels.\n  // `count` represents the number of channels we are currently subscribed to.\n\n  pub.publish('news', 'Hello world!');\n  pub.publish('music', 'Hello again!');\n});\n\nredis.on('message', function (channel, message) {\n  // Receive message Hello world! from channel news\n  // Receive message Hello again! from channel music\n  console.log('Receive message %s from channel %s', message, channel);\n});\n\n// There's also an event called 'messageBuffer', which is the same as 'message' except\n// it returns buffers instead of strings.\nredis.on('messageBuffer', function (channel, message) {\n  // Both `channel` and `message` are buffers.\n});\n```\n\n`PSUBSCRIBE` is also supported in a similar way:\n\n```javascript\nredis.psubscribe('pat?ern', function (err, count) {});\nredis.on('pmessage', function (pattern, channel, message) {});\nredis.on('pmessageBuffer', function (pattern, channel, message) {});\n```\n\nWhen a client issues a SUBSCRIBE or PSUBSCRIBE, that connection is put into a \"subscriber\" mode.\nAt that point, only commands that modify the subscription set are valid.\nWhen the subscription set is empty, the connection is put back into regular mode.\n\nIf you need to send regular commands to Redis while in subscriber mode, just open another connection.\n\n## Handle Binary Data\nArguments can be buffers:\n```javascript\nredis.set('foo', Buffer.from('bar'));\n```\n\nAnd every command has a method that returns a Buffer (by adding a suffix of \"Buffer\" to the command name).\nTo get a buffer instead of a utf8 string:\n\n```javascript\nredis.getBuffer('foo', function (err, result) {\n  // result is a buffer.\n});\n```\n\n## Pipelining\nIf you want to send a batch of commands (e.g. > 5), you can use pipelining to queue\nthe commands in memory and then send them to Redis all at once. This way the performance improves by 50%~300% (See [benchmark section](#benchmark)).\n\n`redis.pipeline()` creates a `Pipeline` instance. You can call any Redis\ncommands on it just like the `Redis` instance. The commands are queued in memory\nand flushed to Redis by calling the `exec` method:\n\n```javascript\nvar pipeline = redis.pipeline();\npipeline.set('foo', 'bar');\npipeline.del('cc');\npipeline.exec(function (err, results) {\n  // `err` is always null, and `results` is an array of responses\n  // corresponding to the sequence of queued commands.\n  // Each response follows the format `[err, result]`.\n});\n\n// You can even chain the commands:\nredis.pipeline().set('foo', 'bar').del('cc').exec(function (err, results) {\n});\n\n// `exec` also returns a Promise:\nvar promise = redis.pipeline().set('foo', 'bar').get('foo').exec();\npromise.then(function (result) {\n  // result === [[null, 'OK'], [null, 'bar']]\n});\n```\n\nEach chained command can also have a callback, which will be invoked when the command\ngets a reply:\n\n```javascript\nredis.pipeline().set('foo', 'bar').get('foo', function (err, result) {\n  // result === 'bar'\n}).exec(function (err, result) {\n  // result[1][1] === 'bar'\n});\n```\n\nIn addition to adding commands to the `pipeline` queue individually, you can also pass an array of commands and arguments to the constructor:\n\n```javascript\nredis.pipeline([\n  ['set', 'foo', 'bar'],\n  ['get', 'foo']\n]).exec(function () { /* ... */ });\n```\n\n`#length` property shows how many commands in the pipeline:\n\n```javascript\nconst length = redis.pipeline().set('foo', 'bar').get('foo').length;\n// length === 2\n```\n\n\n## Transaction\nMost of the time, the transaction commands `multi` & `exec` are used together with pipeline.\nTherefore, when `multi` is called, a `Pipeline` instance is created automatically by default,\nso you can use `multi` just like `pipeline`:\n\n```javascript\nredis.multi().set('foo', 'bar').get('foo').exec(function (err, results) {\n  // results === [[null, 'OK'], [null, 'bar']]\n});\n```\nIf there's a syntax error in the transaction's command chain (e.g. wrong number of arguments, wrong command name, etc),\nthen none of the commands would be executed, and an error is returned:\n\n```javascript\nredis.multi().set('foo').set('foo', 'new value').exec(function (err, results) {\n  // err:\n  //  { [ReplyError: EXECABORT Transaction discarded because of previous errors.]\n  //    name: 'ReplyError',\n  //    message: 'EXECABORT Transaction discarded because of previous errors.',\n  //    command: { name: 'exec', args: [] },\n  //    previousErrors:\n  //     [ { [ReplyError: ERR wrong number of arguments for 'set' command]\n  //         name: 'ReplyError',\n  //         message: 'ERR wrong number of arguments for \\'set\\' command',\n  //         command: [Object] } ] }\n});\n```\n\nIn terms of the interface, `multi` differs from `pipeline` in that when specifying a callback\nto each chained command, the queueing state is passed to the callback instead of the result of the command:\n\n```javascript\nredis.multi().set('foo', 'bar', function (err, result) {\n  // result === 'QUEUED'\n}).exec(/* ... */);\n```\n\nIf you want to use transaction without pipeline, pass `{ pipeline: false }` to `multi`,\nand every command will be sent to Redis immediately without waiting for an `exec` invocation:\n\n```javascript\nredis.multi({ pipeline: false });\nredis.set('foo', 'bar');\nredis.get('foo');\nredis.exec(function (err, result) {\n  // result === [[null, 'OK'], [null, 'bar']]\n});\n```\n\nThe constructor of `multi` also accepts a batch of commands:\n\n```javascript\nredis.multi([\n  ['set', 'foo', 'bar'],\n  ['get', 'foo']\n]).exec(function () { /* ... */ });\n```\n\nInline transactions are supported by pipeline, which means you can group a subset of commands\nin the pipeline into a transaction:\n\n```javascript\nredis.pipeline().get('foo').multi().set('foo', 'bar').get('foo').exec().get('foo').exec();\n```\n\n## Lua Scripting\nioredis supports all of the scripting commands such as `EVAL`, `EVALSHA` and `SCRIPT`.\nHowever, it's tedious to use in real world scenarios since developers have to take\ncare of script caching and to detect when to use `EVAL` and when to use `EVALSHA`.\nioredis expose a `defineCommand` method to make scripting much easier to use:\n\n```javascript\nvar redis = new Redis();\n\n// This will define a command echo:\nredis.defineCommand('echo', {\n  numberOfKeys: 2,\n  lua: 'return {KEYS[1],KEYS[2],ARGV[1],ARGV[2]}'\n});\n\n// Now `echo` can be used just like any other ordinary command,\n// and ioredis will try to use `EVALSHA` internally when possible for better performance.\nredis.echo('k1', 'k2', 'a1', 'a2', function (err, result) {\n  // result === ['k1', 'k2', 'a1', 'a2']\n});\n\n// `echoBuffer` is also defined automatically to return buffers instead of strings:\nredis.echoBuffer('k1', 'k2', 'a1', 'a2', function (err, result) {\n  // result[0] equals to Buffer.from('k1');\n});\n\n// And of course it works with pipeline:\nredis.pipeline().set('foo', 'bar').echo('k1', 'k2', 'a1', 'a2').exec();\n```\n\nIf the number of keys can't be determined when defining a command, you can\nomit the `numberOfKeys` property and pass the number of keys as the first argument\nwhen you call the command:\n\n```javascript\nredis.defineCommand('echoDynamicKeyNumber', {\n  lua: 'return {KEYS[1],KEYS[2],ARGV[1],ARGV[2]}'\n});\n\n// Now you have to pass the number of keys as the first argument every time\n// you invoke the `echoDynamicKeyNumber` command:\nredis.echoDynamicKeyNumber(2, 'k1', 'k2', 'a1', 'a2', function (err, result) {\n  // result === ['k1', 'k2', 'a1', 'a2']\n});\n```\n\n## Transparent Key Prefixing\nThis feature allows you to specify a string that will automatically be prepended\nto all the keys in a command, which makes it easier to manage your key\nnamespaces.\n\n**Warning** This feature won't apply to commands like [KEYS](http://redis.io/commands/KEYS) and [SCAN](http://redis.io/commands/scan) that take patterns rather than actual keys([#239](https://github.com/luin/ioredis/issues/239)),\nand this feature also won't apply to the replies of commands even they are key names ([#325](https://github.com/luin/ioredis/issues/325)).\n\n```javascript\nvar fooRedis = new Redis({ keyPrefix: 'foo:' });\nfooRedis.set('bar', 'baz');  // Actually sends SET foo:bar baz\n\nfooRedis.defineCommand('echo', {\n  numberOfKeys: 2,\n  lua: 'return {KEYS[1],KEYS[2],ARGV[1],ARGV[2]}'\n});\n\n// Works well with pipelining/transaction\nfooRedis.pipeline()\n  // Sends SORT foo:list BY foo:weight_*->fieldname\n  .sort('list', 'BY', 'weight_*->fieldname')\n  // Supports custom commands\n  // Sends EVALSHA xxx foo:k1 foo:k2 a1 a2\n  .echo('k1', 'k2', 'a1', 'a2')\n  .exec()\n```\n\n## Transforming Arguments & Replies\nMost Redis commands take one or more Strings as arguments,\nand replies are sent back as a single String or an Array of Strings. However, sometimes\nyou may want something different. For instance, it would be more convenient if the `HGETALL`\ncommand returns a hash (e.g. `{ key: val1, key2: v2 }`) rather than an array of key values (e.g. `[key1, val1, key2, val2]`).\n\nioredis has a flexible system for transforming arguments and replies. There are two types\nof transformers, argument transformer and reply transformer:\n\n```javascript\nvar Redis = require('ioredis');\n\n// Here's the built-in argument transformer converting\n// hmset('key', { k1: 'v1', k2: 'v2' })\n// or\n// hmset('key', new Map([['k1', 'v1'], ['k2', 'v2']]))\n// into\n// hmset('key', 'k1', 'v1', 'k2', 'v2')\nRedis.Command.setArgumentTransformer('hmset', function (args) {\n  if (args.length === 2) {\n    if (typeof Map !== 'undefined' && args[1] instanceof Map) {\n      // utils is a internal module of ioredis\n      return [args[0]].concat(utils.convertMapToArray(args[1]));\n    }\n    if ( typeof args[1] === 'object' && args[1] !== null) {\n      return [args[0]].concat(utils.convertObjectToArray(args[1]));\n    }\n  }\n  return args;\n});\n\n// Here's the built-in reply transformer converting the HGETALL reply\n// ['k1', 'v1', 'k2', 'v2']\n// into\n// { k1: 'v1', 'k2': 'v2' }\nRedis.Command.setReplyTransformer('hgetall', function (result) {\n  if (Array.isArray(result)) {\n    var obj = {};\n    for (var i = 0; i < result.length; i += 2) {\n      obj[result[i]] = result[i + 1];\n    }\n    return obj;\n  }\n  return result;\n});\n```\n\nThere are three built-in transformers, two argument transformers for `hmset` & `mset` and\na reply transformer for `hgetall`. Transformers for `hmset` and `hgetall` were mentioned\nabove, and the transformer for `mset` is similar to the one for `hmset`:\n\n```javascript\nredis.mset({ k1: 'v1', k2: 'v2' });\nredis.get('k1', function (err, result) {\n  // result === 'v1';\n});\n\nredis.mset(new Map([['k3', 'v3'], ['k4', 'v4']]));\nredis.get('k3', function (err, result) {\n  // result === 'v3';\n});\n```\n\nAnother useful example of a reply transformer is one that changes `hgetall` to return array of arrays instead of objects which avoids a unwanted conversation of hash keys to strings when dealing with binary hash keys:\n\n```javascript\nRedis.Command.setReplyTransformer('hgetall', function (result) {\n  var arr = [];\n  for (var i = 0; i < result.length; i += 2) {\n    arr.push([result[i], result[i + 1]]);\n  }\n  return arr;\n});\nredis.hset('h1', Buffer.from([0x01]), Buffer.from([0x02]));\nredis.hset('h1', Buffer.from([0x03]), Buffer.from([0x04]));\nredis.hgetallBuffer('h1', function (err, result) {\n  // result === [ [ <Buffer 01>, <Buffer 02> ], [ <Buffer 03>, <Buffer 04> ] ];\n});\n```\n\n## Monitor\nRedis supports the MONITOR command,\nwhich lets you see all commands received by the Redis server across all client connections,\nincluding from other client libraries and other computers.\n\nThe `monitor` method returns a monitor instance.\nAfter you send the MONITOR command, no other commands are valid on that connection. ioredis will emit a monitor event for every new monitor message that comes across.\nThe callback for the monitor event takes a timestamp from the Redis server and an array of command arguments.\n\nHere is a simple example:\n\n```javascript\nredis.monitor(function (err, monitor) {\n  monitor.on('monitor', function (time, args, source, database) {\n  });\n});\n```\n\n## Streamify Scanning\nRedis 2.8 added the `SCAN` command to incrementally iterate through the keys in the database. It's different from `KEYS` in that\n`SCAN` only returns a small number of elements each call, so it can be used in production without the downside\nof blocking the server for a long time. However, it requires recording the cursor on the client side each time\nthe `SCAN` command is called in order to iterate through all the keys correctly. Since it's a relatively common use case, ioredis\nprovides a streaming interface for the `SCAN` command to make things much easier. A readable stream can be created by calling `scanStream`:\n\n```javascript\nvar redis = new Redis();\n// Create a readable stream (object mode)\nvar stream = redis.scanStream();\nstream.on('data', function (resultKeys) {\n  // `resultKeys` is an array of strings representing key names.\n  // Note that resultKeys may contain 0 keys, and that it will sometimes\n  // contain duplicates due to SCAN's implementation in Redis.\n  for (var i = 0; i < resultKeys.length; i++) {\n    console.log(resultKeys[i]);\n  }\n});\nstream.on('end', function () {\n  console.log('all keys have been visited');\n});\n```\n\n`scanStream` accepts an option, with which you can specify the `MATCH` pattern and the `COUNT` argument:\n\n```javascript\nvar stream = redis.scanStream({\n  // only returns keys following the pattern of `user:*`\n  match: 'user:*',\n  // returns approximately 100 elements per call\n  count: 100\n});\n```\n\nJust like other commands, `scanStream` has a binary version `scanBufferStream`, which returns an array of buffers. It's useful when\nthe key names are not utf8 strings.\n\nThere are also `hscanStream`, `zscanStream` and `sscanStream` to iterate through elements in a hash, zset and set. The interface of each is\nsimilar to `scanStream` except the first argument is the key name:\n\n```javascript\nvar stream = redis.hscanStream('myhash', {\n  match: 'age:??'\n});\n```\n\nYou can learn more from the [Redis documentation](http://redis.io/commands/scan).\n\n**Useful Tips**\nIt's pretty common that doing an async task in the `data` handler. We'd like the scanning process to be paused until the async task to be finished. `Stream#pause()` and `Stream.resume()` do the trick. For example if we want to migrate data in Redis to MySQL:\n\n```javascript\nvar stream = redis.scanStream();\nstream.on('data', function (resultKeys) {\n  // Pause the stream from scanning more keys until we've migrated the current keys.\n  stream.pause();\n\n  Promise.all(resultKeys.map(migrateKeyToMySQL)).then(() => {\n    // Resume the stream here.\n    stream.resume();\n  });\n});\n\nstream.on('end', function () {\n  console.log('done migration');\n});\n```\n\n## Auto-reconnect\nBy default, ioredis will try to reconnect when the connection to Redis is lost\nexcept when the connection is closed manually by `redis.disconnect()` or `redis.quit()`.\n\nIt's very flexible to control how long to wait to reconnect after disconnection\nusing the `retryStrategy` option:\n\n```javascript\nvar redis = new Redis({\n  // This is the default value of `retryStrategy`\n  retryStrategy: function (times) {\n    var delay = Math.min(times * 50, 2000);\n    return delay;\n  }\n});\n```\n\n`retryStrategy` is a function that will be called when the connection is lost.\nThe argument `times` means this is the nth reconnection being made and\nthe return value represents how long (in ms) to wait to reconnect. When the\nreturn value isn't a number, ioredis will stop trying to reconnect, and the connection\nwill be lost forever if the user doesn't call `redis.connect()` manually.\n\nWhen reconnected, the client will auto subscribe to channels that the previous connection subscribed to.\nThis behavior can be disabled by setting the `autoResubscribe` option to `false`.\n\nAnd if the previous connection has some unfulfilled commands (most likely blocking commands such as `brpop` and `blpop`),\nthe client will resend them when reconnected. This behavior can be disabled by setting the `autoResendUnfulfilledCommands` option to `false`.\n\nBy default, all pending commands will be flushed with an error every 20 retry attempts. That makes sure commands won't wait forever when the connection is down. You can change this behavior by setting `maxRetriesPerRequest`:\n\n```javascript\nvar redis = new Redis({\n  maxRetriesPerRequest: 1\n});\n```\n\nSet maxRetriesPerRequest to `null` to disable this behavior, and every command will wait forever until the connection is alive again (which is the default behavior before ioredis v4).\n\n### Reconnect on error\n\nBesides auto-reconnect when the connection is closed, ioredis supports reconnecting on the specified errors by the `reconnectOnError` option. Here's an example that will reconnect when receiving `READONLY` error:\n\n```javascript\nvar redis = new Redis({\n  reconnectOnError: function (err) {\n    var targetError = 'READONLY';\n    if (err.message.slice(0, targetError.length) === targetError) {\n      // Only reconnect when the error starts with \"READONLY\"\n      return true; // or `return 1;`\n    }\n  }\n});\n```\n\nThis feature is useful when using Amazon ElastiCache. Once failover happens, Amazon ElastiCache will switch the master we currently connected with to a slave, leading to the following writes fails with the error `READONLY`. Using `reconnectOnError`, we can force the connection to reconnect on this error in order to connect to the new master.\n\nFurthermore, if the `reconnectOnError` returns `2`, ioredis will resend the failed command after reconnecting.\n\n## Connection Events\nThe Redis instance will emit some events about the state of the connection to the Redis server.\n\nEvent    | Description\n:------------- | :-------------\nconnect  | emits when a connection is established to the Redis server.\nready    | If `enableReadyCheck` is `true`, client will emit `ready` when the server reports that it is ready to receive commands (e.g. finish loading data from disk).<br>Otherwise, `ready` will be emitted immediately right after the `connect` event.\nerror    | emits when an error occurs while connecting.<br>However, ioredis emits all `error` events silently (only emits when there's at least one listener) so that your application won't crash if you're not listening to the `error` event.\nclose    | emits when an established Redis server connection has closed.\nreconnecting | emits after `close` when a reconnection will be made. The argument of the event is the time (in ms) before reconnecting.\nend     | emits after `close` when no more reconnections will be made, or the connection is failed to establish.\n\nYou can also check out the `Redis#status` property to get the current connection status.\n\nBesides the above connection events, there are several other custom events:\n\nEvent    | Description\n:------------- | :-------------\nselect   | emits when the database changed. The argument is the new db number.\n\n## Offline Queue\nWhen a command can't be processed by Redis (being sent before the `ready` event), by default, it's added to the offline queue and will be\nexecuted when it can be processed. You can disable this feature by setting the `enableOfflineQueue`\noption to `false`:\n\n```javascript\nvar redis = new Redis({ enableOfflineQueue: false });\n```\n\n## TLS Options\nRedis doesn't support TLS natively, however if the redis server you want to connect to is hosted behind a TLS proxy (e.g. [stunnel](https://www.stunnel.org/)) or is offered by a PaaS service that supports TLS connection (e.g. [Redis Labs](https://redislabs.com/)), you can set the `tls` option:\n\n```javascript\nvar redis = new Redis({\n  host: 'localhost',\n  tls: {\n    // Refer to `tls.connect()` section in\n    // https://nodejs.org/api/tls.html\n    // for all supported options\n    ca: fs.readFileSync('cert.pem')\n  }\n});\n```\n\n<hr>\n\n## Sentinel\nioredis supports Sentinel out of the box. It works transparently as all features that work when\nyou connect to a single node also work when you connect to a sentinel group. Make sure to run Redis >= 2.8.12 if you want to use this feature. Sentinels have a default port of 26379.\n\nTo connect using Sentinel, use:\n\n```javascript\nvar redis = new Redis({\n  sentinels: [{ host: 'localhost', port: 26379 }, { host: 'localhost', port: 26380 }],\n  name: 'mymaster'\n});\n\nredis.set('foo', 'bar');\n```\n\nThe arguments passed to the constructor are different from the ones you use to connect to a single node, where:\n\n* `name` identifies a group of Redis instances composed of a master and one or more slaves (`mymaster` in the example);\n* `sentinelPassword` (optional) password for Sentinel instances.\n* `sentinels` are a list of sentinels to connect to. The list does not need to enumerate all your sentinel instances, but a few so that if one is down the client will try the next one.\n* `role` (optional) with a value of `slave` will return a random slave from the Sentinel group.\n* `preferredSlaves` (optional) can be used to prefer a particular slave or set of slaves based on priority. It accepts a function or array.\n\nioredis **guarantees** that the node you connected to is always a master even after a failover. When a failover happens, instead of trying to reconnect to the failed node (which will be demoted to slave when it's available again), ioredis will ask sentinels for the new master node and connect to it. All commands sent during the failover are queued and will be executed when the new connection is established so that none of the commands will be lost.\n\nIt's possible to connect to a slave instead of a master by specifying the option `role` with the value of `slave` and ioredis will try to connect to a random slave of the specified master, with the guarantee that the connected node is always a slave. If the current node is promoted to master due to a failover, ioredis will disconnect from it and ask the sentinels for another slave node to connect to.\n\nIf you specify the option `preferredSlaves` along with `role: 'slave'` ioredis will attempt to use this value when selecting the slave from the pool of available slaves. The value of `preferredSlaves` should either be a function that accepts an array of avaiable slaves and returns a single result, or an array of slave values priorities by the lowest `prio` value first with a default value of `1`.\n\n```javascript\n// available slaves format\nvar availableSlaves = [{ ip: '127.0.0.1', port: '31231', flags: 'slave' }];\n\n// preferredSlaves array format\nvar preferredSlaves = [\n  { ip: '127.0.0.1', port: '31231', prio: 1 },\n  { ip: '127.0.0.1', port: '31232', prio: 2 }\n];\n\n// preferredSlaves function format\npreferredSlaves = function(availableSlaves) {\n  for (var i = 0; i < availableSlaves.length; i++) {\n    var slave = availableSlaves[i];\n    if (slave.ip === '127.0.0.1') {\n      if (slave.port === '31234') {\n        return slave;\n      }\n    }\n  }\n  // if no preferred slaves are available a random one is used\n  return false;\n};\n\nvar redis = new Redis({\n  sentinels: [{ host: '127.0.0.1', port: 26379 }, { host: '127.0.0.1', port: 26380 }],\n  name: 'mymaster',\n  role: 'slave',\n  preferredSlaves: preferredSlaves\n});\n```\n\nBesides the `retryStrategy` option, there's also a `sentinelRetryStrategy` in Sentinel mode which will be invoked when all the sentinel nodes are unreachable during connecting. If `sentinelRetryStrategy` returns a valid delay time, ioredis will try to reconnect from scratch. The default value of `sentinelRetryStrategy` is:\n\n```javascript\nfunction (times) {\n  var delay = Math.min(times * 10, 1000);\n  return delay;\n}\n```\n\n## Cluster\nRedis Cluster provides a way to run a Redis installation where data is automatically sharded across multiple Redis nodes.\nYou can connect to a Redis Cluster like this:\n\n```javascript\nvar Redis = require('ioredis');\n\nvar cluster = new Redis.Cluster([{\n  port: 6380,\n  host: '127.0.0.1'\n}, {\n  port: 6381,\n  host: '127.0.0.1'\n}]);\n\ncluster.set('foo', 'bar');\ncluster.get('foo', function (err, res) {\n  // res === 'bar'\n});\n```\n\n`Cluster` constructor accepts two arguments, where:\n\n0. The first argument is a list of nodes of the cluster you want to connect to.\nJust like Sentinel, the list does not need to enumerate all your cluster nodes,\nbut a few so that if one is unreachable the client will try the next one, and the client will discover other nodes automatically when at least one node is connected.\n0. The second argument is the options, where:\n\n    * `clusterRetryStrategy`: When none of the startup nodes are reachable, `clusterRetryStrategy` will be invoked. When a number is returned,\n    ioredis will try to reconnect to the startup nodes from scratch after the specified delay (in ms). Otherwise, an error of \"None of startup nodes is available\" will be returned.\n    The default value of this option is:\n\n        ```javascript\n        function (times) {\n          var delay = Math.min(100 + times * 2, 2000);\n          return delay;\n        }\n        ```\n\n        It's possible to modify the `startupNodes` property in order to switch to another set of nodes here:\n\n        ```javascript\n        function (times) {\n          this.startupNodes = [{ port: 6790, host: '127.0.0.1' }];\n          return Math.min(100 + times * 2, 2000);\n        }\n        ```\n\n    * `enableOfflineQueue`: Similar to the `enableOfflineQueue` option of `Redis` class.\n    * `enableReadyCheck`: When enabled, \"ready\" event will only be emitted when `CLUSTER INFO` command\n    reporting the cluster is ready for handling commands. Otherwise, it will be emitted immediately after \"connect\" is emitted.\n    * `scaleReads`: Config where to send the read queries. See below for more details.\n    * `maxRedirections`: When a cluster related error (e.g. `MOVED`, `ASK` and `CLUSTERDOWN` etc.) is received, the client will redirect the\n    command to another node. This option limits the max redirections allowed when sending a command. The default value is `16`.\n    * `retryDelayOnFailover`: If the target node is disconnected when sending a command,\n    ioredis will retry after the specified delay. The default value is `100`. You should make sure `retryDelayOnFailover * maxRedirections > cluster-node-timeout`\n    to insure that no command will fail during a failover.\n    * `retryDelayOnClusterDown`: When a cluster is down, all commands will be rejected with the error of `CLUSTERDOWN`. If this option is a number (by default, it is `100`), the client\n    will resend the commands after the specified time (in ms).\n    * `retryDelayOnTryAgain`: If this option is a number (by default, it is `100`), the client\n    will resend the commands rejected with `TRYAGAIN` error after the specified time (in ms).\n    * `redisOptions`: Default options passed to the constructor of `Redis` when connecting to a node.\n    * `slotsRefreshTimeout`: Milliseconds before a timeout occurs while refreshing slots from the cluster (default `1000`)\n    * `slotsRefreshInterval`: Milliseconds between every automatic slots refresh (default `5000`)\n\n### Read-write splitting\n\nA typical redis cluster contains three or more masters and several slaves for each master. It's possible to scale out redis cluster by sending read queries to slaves and write queries to masters by setting the `scaleReads` option.\n\n`scaleReads` is \"master\" by default, which means ioredis will never send any queries to slaves. There are other three available options:\n\n1. \"all\": Send write queries to masters and read queries to masters or slaves randomly.\n2. \"slave\": Send write queries to masters and read queries to slaves.\n3. a custom `function(nodes, command): node`: Will choose the custom function to select to which node to send read queries (write queries keep being sent to master). The first node in `nodes` is always the master serving the relevant slots. If the function returns an array of nodes, a random node of that list will be selected.\n\nFor example:\n\n```javascript\nvar cluster = new Redis.Cluster([/* nodes */], {\n  scaleReads: 'slave'\n});\ncluster.set('foo', 'bar'); // This query will be sent to one of the masters.\ncluster.get('foo', function (err, res) {\n  // This query will be sent to one of the slaves.\n});\n```\n\n**NB** In the code snippet above, the `res` may not be equal to \"bar\" because of the lag of replication between the master and slaves.\n\n### Running commands to multiple nodes\n\nEvery command will be sent to exactly one node. For commands containing keys, (e.g. `GET`, `SET` and `HGETALL`), ioredis sends them to the node that serving the keys, and for other commands not containing keys, (e.g. `INFO`, `KEYS` and `FLUSHDB`), ioredis sends them to a random node.\n\nSometimes you may want to send a command to multiple nodes (masters or slaves) of the cluster, you can get the nodes via `Cluster#nodes()` method.\n\n`Cluster#nodes()` accepts a parameter role, which can be \"master\", \"slave\" and \"all\" (default), and returns an array of `Redis` instance. For example:\n\n```javascript\n// Send `FLUSHDB` command to all slaves:\nvar slaves = cluster.nodes('slave');\nPromise.all(slaves.map(function (node) {\n  return node.flushdb();\n}));\n\n// Get keys of all the masters:\nvar masters = cluster.nodes('master');\nPromise.all(masters.map(function (node) {\n  return node.keys();\n})).then(function (keys) {\n  // keys: [['key1', 'key2'], ['key3', 'key4']]\n});\n```\n\n### NAT Mapping\nSometimes the cluster is hosted within a internal network that can only be accessed via a NAT (Network Address Translation) instance. See [Accessing ElastiCache from outside AWS](https://docs.aws.amazon.com/AmazonElastiCache/latest/red-ug/accessing-elasticache.html) as an example.\n\nYou can specify nat mapping rules via `natMap` option:\n\n```javascript\nconst cluster = new Redis.Cluster([{\n  host: '203.0.113.73',\n  port: 30001\n}], {\n  natMap: {\n    '10.0.1.230:30001': {host: '203.0.113.73', port: 30001},\n    '10.0.1.231:30001': {host: '203.0.113.73', port: 30002},\n    '10.0.1.232:30001': {host: '203.0.113.73', port: 30003}\n  }\n})\n```\n\nThis option is also useful when the cluster is running inside a Docker container.\n\n### Transaction and pipeline in Cluster mode\nAlmost all features that are supported by `Redis` are also supported by `Redis.Cluster`, e.g. custom commands, transaction and pipeline.\nHowever there are some differences when using transaction and pipeline in Cluster mode:\n\n0. All keys in a pipeline should belong to the same slot since ioredis sends all commands in a pipeline to the same node.\n0. You can't use `multi` without pipeline (aka `cluster.multi({ pipeline: false })`). This is because when you call `cluster.multi({ pipeline: false })`, ioredis doesn't know which node the `multi` command should be sent to.\n0. Chaining custom commands in the pipeline is not supported in Cluster mode.\n\nWhen any commands in a pipeline receives a `MOVED` or `ASK` error, ioredis will resend the whole pipeline to the specified node automatically if all of the following conditions are satisfied:\n\n0. All errors received in the pipeline are the same. For example, we won't resend the pipeline if we got two `MOVED` errors pointing to different nodes.\n0. All commands executed successfully are readonly commands. This makes sure that resending the pipeline won't have side effects.\n\n### Pub/Sub\nPub/Sub in cluster mode works exactly as the same as in standalone mode. Internally, when a node of the cluster receives a message, it will broadcast the message to the other nodes. ioredis makes sure that each message will only be received once by strictly subscribing one node at the same time.\n\n```javascript\nvar nodes = [/* nodes */];\nvar pub = new Redis.Cluster(nodes);\nvar sub = new Redis.Cluster(nodes);\nsub.on('message', function (channel, message) {\n  console.log(channel, message);\n});\n\nsub.subscribe('news', function () {\n  pub.publish('news', 'highlights');\n});\n```\n\n### Events\n\nEvent    | Description\n:------------- | :-------------\nconnect  | emits when a connection is established to the Redis server.\nready    | emits when `CLUSTER INFO` reporting the cluster is able to receive commands (if `enableReadyCheck` is `true`) or immediately after `connect` event (if `enableReadyCheck` is false).\nerror    | emits when an error occurs while connecting with a property of `lastNodeError` representing the last node error received. This event is emitted silently (only emitting if there's at least one listener).\nclose    | emits when an established Redis server connection has closed.\nreconnecting | emits after `close` when a reconnection will be made. The argument of the event is the time (in ms) before reconnecting.\nend     | emits after `close` when no more reconnections will be made.\n+node   | emits when a new node is connected.\n-node   | emits when a node is disconnected.\nnode error | emits when an error occurs when connecting to a node. The second argument indicates the address of the node.\n\n### Password\nSetting the `password` option to access password-protected clusters:\n\n```javascript\nvar Redis = require('ioredis');\nvar cluster = new Redis.Cluster(nodes, {\n  redisOptions: {\n    password: 'your-cluster-password'\n  }\n});\n```\n\nIf some of nodes in the cluster using a different password, you should specify them in the first parameter:\n\n```javascript\nvar Redis = require('ioredis');\nvar cluster = new Redis.Cluster([\n  // Use password \"password-for-30001\" for 30001\n  { port: 30001, password: 'password-for-30001'},\n  // Don't use password when accessing 30002\n  { port: 30002, password: null }\n  // Other nodes will use \"fallback-password\"\n], {\n  redisOptions: {\n    password: 'fallback-password'\n  }\n});\n```\n\n<hr>\n\n# Error Handling\nAll the errors returned by the Redis server are instances of `ReplyError`, which can be accessed via `Redis`:\n\n```javascript\nvar Redis = require('ioredis');\nvar redis = new Redis();\n// This command causes a reply error since the SET command requires two arguments.\nredis.set('foo', function (err) {\n  err instanceof Redis.ReplyError\n});\n```\n\nThis is the error stack of the `ReplyError`:\n\n```\nReplyError: ERR wrong number of arguments for 'set' command\n    at ReplyParser._parseResult (/app/node_modules/ioredis/lib/parsers/javascript.js:60:14)\n    at ReplyParser.execute (/app/node_modules/ioredis/lib/parsers/javascript.js:178:20)\n    at Socket.<anonymous> (/app/node_modules/ioredis/lib/redis/event_handler.js:99:22)\n    at Socket.emit (events.js:97:17)\n    at readableAddChunk (_stream_readable.js:143:16)\n    at Socket.Readable.push (_stream_readable.js:106:10)\n    at TCP.onread (net.js:509:20)\n```\n\nBy default, the error stack doesn't make any sense because the whole stack happens in the ioredis\nmodule itself, not in your code. So it's not easy to find out where the error happens in your code.\nioredis provides an option `showFriendlyErrorStack` to solve the problem. When you enable\n`showFriendlyErrorStack`, ioredis will optimize the error stack for you:\n\n```javascript\nvar Redis = require('ioredis');\nvar redis = new Redis({ showFriendlyErrorStack: true });\nredis.set('foo');\n```\n\nAnd the output will be:\n\n```\nReplyError: ERR wrong number of arguments for 'set' command\n    at Object.<anonymous> (/app/index.js:3:7)\n    at Module._compile (module.js:446:26)\n    at Object.Module._extensions..js (module.js:464:10)\n    at Module.load (module.js:341:32)\n    at Function.Module._load (module.js:296:12)\n    at Function.Module.runMain (module.js:487:10)\n    at startup (node.js:111:16)\n    at node.js:799:3\n```\n\nThis time the stack tells you that the error happens on the third line in your code. Pretty sweet!\nHowever, it would decrease the performance significantly to optimize the error stack. So by\ndefault, this option is disabled and can only be used for debugging purposes. You **shouldn't** use this feature in a production environment.\n\n# Plugging in your own Promises Library\nIf you're an advanced user, you may want to plug in your own promise library like [bluebird](https://www.npmjs.com/package/bluebird). Just set Redis.Promise to your favorite ES6-style promise constructor and ioredis will use it.\n\n```javascript\nconst Redis = require('ioredis')\nRedis.Promise = require('bluebird')\n\nconst redis = new Redis()\n\n// Use bluebird\nassert.equal(redis.get().constructor, require('bluebird'))\n\n// You can change the Promise implementation at any time:\nRedis.Promise = global.Promise\nassert.equal(redis.get().constructor, global.Promise)\n```\n\n\n# Running tests\n\nStart a Redis server on 127.0.0.1:6379, and then:\n\n```shell\n$ npm test\n```\n\n`FLUSH ALL` will be invoked after each test, so make sure there's no valuable data in it before running tests.\n\nIf your testing environment does not let you spin up a Redis server [ioredis-mock](https://github.com/stipsan/ioredis-mock) is a drop-in replacement you can use in your tests. It aims to behave identically to ioredis connected to a Redis server so that your integration tests is easier to write and of better quality.\n\n# Debug\n\nYou can set the `DEBUG` env to `ioredis:*` to print debug info:\n\n```shell\n$ DEBUG=ioredis:* node app.js\n```\n\n# Consolidation: It's time for celebration\n\nRight now there are two great redis clients around and both have some advantages above each other. We speak about [node_redis](https://github.com/NodeRedis/node_redis) and ioredis. So after talking to each other about how we could improve in working together we (that is [@BridgeAR](https://github.com/BridgeAR) and [@luin](https://github.com/luin)) decided to work towards a single library on the long run. But step by step.\n\nFirst of all, we want to split small parts of our libraries into others so that we're both able to use the same code. Those libraries are going to be maintained under the NodeRedis organization. This is going to reduce the maintance overhead, allows others to use the very same code, if they need it and it's way easier for others to contribute to both libraries.\n\nWe're very happy about this step towards working together as we both want to give you the best redis experience possible.\n\nIf you want to join our cause by help maintaining something, please don't hesitate to contact either one of us.\n\n# Join in!\n\nI'm happy to receive bug reports, fixes, documentation enhancements, and any other improvements.\n\nAnd since I'm not a native English speaker, if you find any grammar mistakes in the documentation, please also let me know. :)\n\n# Contributors\n\nThis project exists thanks to all the people who contribute:\n\n<a href=\"https://github.com/luin/ioredis/graphs/contributors\"><img src=\"https://opencollective.com/ioredis/contributors.svg?width=890&showBtn=false\" /></a>\n\n# License\n\nMIT\n\n\n[![FOSSA Status](https://app.fossa.io/api/projects/git%2Bgithub.com%2Fluin%2Fioredis.svg?type=large)](https://app.fossa.io/projects/git%2Bgithub.com%2Fluin%2Fioredis?ref=badge_large)\n","readmeFilename":"README.md","bugs":{"url":"https://github.com/luin/ioredis/issues"},"homepage":"https://github.com/luin/ioredis#readme","_id":"ioredis@4.10.1","_nodeVersion":"10.16.0","_npmVersion":"6.9.0","dist":{"integrity":"sha512-arq8PyLhnicxEn451q63fmF6vyggjFbi1kOE7t/WeHmO/ZQJzoXiVGuQvc7NowYW9A1AV2EVRRO/sj6xuxlkbw==","shasum":"e0806d4508838108b8312720e0d1aa53545c0541","tarball":"https://registry.npmjs.org/ioredis/-/ioredis-4.10.1.tgz","fileCount":35,"unpackedSize":224687,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJc+27PCRA9TVsSAnZWagAAdvsP/1nNjM438z+WuY46SaIl\nFK0up6pwDr4mLV68pel94hZ3Ks0hCWauGsQvYaOv23Ee0yWbf6Ekr+jlDWEr\nlTsf0dfGCk+pgzJdlAJ/iOPbaVXpWSyrgA67YspdtEIMU1/IY4+jSBUuptID\nbd7VPUuMlmm+HRWOQr1Qjtm/UvCx/UYJKqQkYwNWkR9OSvfvTgwQZuLA1UXE\nD3EmSGRccpAs+HRNU5wQJRsKFevynwLtEAmNT4YkI1RFCr7F8QCvS5BhrHwj\nwvAkYPep0ZGQ3kAEX0OcQkX+N3l00bZS1R0nT60qiBLAJQxJav94gxAbWr8l\n9psSSsHs8hu5LOGY5fi2kwCu8Tw37xLOmjAvxhetO+HCIpC9869Cn4zZS9ZV\nTlIqLjmBPG8y0W2pPnYSH2AXMlaSzQOEksPwI7Dam0fNwoZc9Svt/WNfRLdM\nfkpQdurLKlrY6wth7kM5fO414q8tD8WKRFmp3VJX3yPquoNoDtQ+Rzy8Hvad\nqQhTBtVqRF1kImNFoV99GjchE2DU7QLweipUgokohqTxz3i/Vx1VGXXGjezk\nuqgvl74u9MQ70CR7QlvonOh0EX93YCct3lnTKlw7kCB/19a1/qztNezqXl1q\nskLMx78Taj42I2szQeLHQmJk2nV/axX5dXD49pYRYsiDTWIbLnq7hTlOJKFS\n/v4q\r\n=t0t7\r\n-----END PGP SIGNATURE-----\r\n"},"maintainers":[{"email":"ioredis-robot@zihua.li","name":"ioredis-robot"},{"email":"i@zihua.li","name":"luin"}],"_npmUser":{"name":"luin","email":"i@zihua.li"},"directories":{},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/ioredis_4.10.1_1559981774866_0.3343286433027941"},"_hasShrinkwrap":false},"4.10.2":{"name":"ioredis","version":"4.10.2","description":"A robust, performance-focused and full-featured Redis client for Node.js.","main":"built/index.js","scripts":{"test":"NODE_ENV=test mocha","test:cov":"NODE_ENV=test node ./node_modules/istanbul/lib/cli.js cover --preserve-comments ./node_modules/mocha/bin/_mocha -- -r ts-node/register -R spec --exit","build":"rm -rf built && tsc","prepublishOnly":"npm run build && npm test","bench":"matcha benchmarks/*.js","semantic-release":"semantic-release"},"repository":{"type":"git","url":"git://github.com/luin/ioredis.git"},"keywords":["redis","cluster","sentinel","pipelining"],"author":{"name":"luin","email":"i@zihua.li","url":"http://zihua.li"},"license":"MIT","dependencies":{"cluster-key-slot":"^1.0.6","debug":"^4.1.1","denque":"^1.1.0","lodash.defaults":"^4.2.0","lodash.flatten":"^4.4.0","redis-commands":"1.5.0","redis-errors":"^1.2.0","redis-parser":"^3.0.0","standard-as-callback":"^2.0.1"},"devDependencies":{"@semantic-release/changelog":"^3.0.4","@semantic-release/git":"^7.0.12","@types/node":"^12.0.2","@types/redis-errors":"1.2.0","bluebird":"^3.5.4","chai":"^4.2.0","cz-conventional-changelog":"^2.0.0","istanbul":"^0.4.5","mocha":"^5.0.0","server-destroy":"^1.0.1","sinon":"^7.3.2","ts-node":"^8.1.0","typescript":"^3.4.5"},"engines":{"node":">=6"},"config":{"commitizen":{"path":"./node_modules/cz-conventional-changelog"}},"gitHead":"e83226b2d43cfc610ad7ec2ff4e3a6de35b9e71c","readme":"[![ioredis](https://cdn.jsdelivr.net/gh/luin/ioredis@b5e8c74/logo.svg)](https://github.com/luin/ioredis)\n\n[![Build Status](https://travis-ci.org/luin/ioredis.svg?branch=master)](https://travis-ci.org/luin/ioredis)\n[![Test Coverage](https://codeclimate.com/github/luin/ioredis/badges/coverage.svg)](https://codeclimate.com/github/luin/ioredis)\n[![Join the chat at https://gitter.im/luin/ioredis](https://badges.gitter.im/Join%20Chat.svg)](https://gitter.im/luin/ioredis?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge)\n[![Commitizen friendly](https://img.shields.io/badge/commitizen-friendly-brightgreen.svg)](http://commitizen.github.io/cz-cli/)\n[![semantic-release](https://img.shields.io/badge/%20%20%F0%9F%93%A6%F0%9F%9A%80-semantic--release-e10079.svg)](https://github.com/semantic-release/semantic-release)\n[![npm latest version](https://img.shields.io/npm/v/ioredis/latest.svg)](https://www.npmjs.com/package/ioredis)\n[![npm next version](https://img.shields.io/npm/v/ioredis/next.svg)](https://www.npmjs.com/package/ioredis)\n<img alt=\"\" src=\"\">\n\nA robust, performance-focused and full-featured [Redis](http://redis.io) client for [Node.js](https://nodejs.org).\n\nSupports Redis >= 2.6.12 and (Node.js >= 6).\n\n# Features\nioredis is a robust, full-featured Redis client that is\nused in the world's biggest online commerce company [Alibaba](http://www.alibaba.com/) and many other awesome companies.\n\n0. Full-featured. It supports [Cluster](http://redis.io/topics/cluster-tutorial), [Sentinel](http://redis.io/topics/sentinel), [Pipelining](http://redis.io/topics/pipelining) and of course [Lua scripting](http://redis.io/commands/eval) & [Pub/Sub](http://redis.io/topics/pubsub) (with the support of binary messages).\n0. High performance.\n0. Delightful API. It works with Node callbacks and Native promises.\n0. Transformation of command arguments and replies.\n0. Transparent key prefixing.\n0. Abstraction for Lua scripting, allowing you to define custom commands.\n0. Support for binary data.\n0. Support for TLS.\n0. Support for offline queue and ready checking.\n0. Support for ES6 types, such as `Map` and `Set`.\n0. Support for GEO commands (Redis 3.2 Unstable).\n0. Sophisticated error handling strategy.\n0. Support for NAT mapping.\n\n# Links\n* [API Documentation](API.md)\n* [Changelog](Changelog.md)\n* [Migrating from node_redis](https://github.com/luin/ioredis/wiki/Migrating-from-node_redis)\n* [Error Handling](#error-handling)\n\n## Become a Sponsor to Support ioredis's Development\nOpen source is hard and time-consuming. If you want to invest in ioredis's future you can become a sponsor and make us spend more time on this library's improvements and new features.\n\n<a href=\"https://opencollective.com/ioredis\"><img src=\"https://opencollective.com/ioredis/tiers/sponsor.svg?avatarHeight=36\"></a>\n\nThank you for using ioredis :-)\n\n<hr>\n<a href=\"https://itunes.apple.com/app/medis-gui-for-redis/id1063631769\"><img align=\"right\" src=\"medis.png\" alt=\"Download on the App Store\"></a>\n\n\n### Advertisement\n\nLooking for a Redis GUI manager for OS X, Windows and Linux? Here's [Medis](https://itunes.apple.com/us/app/medis-gui-for-redis/id1063631769)!\n\nMedis is an open-sourced, beautiful, easy-to-use Redis GUI management application.\n\nMedis starts with all the basic features you need:\n\n* Keys viewing/editing\n* SSH Tunnel for connecting with remote servers\n* Terminal for executing custom commands\n* JSON/MessagePack format viewing/editing and built-in highlighting/validator\n* And other awesome features...\n\n[Medis is open sourced on GitHub](https://github.com/luin/medis)\n\n<hr>\n\n# Quick Start\n\n## Install\n```shell\n$ npm install ioredis\n```\n\n## Basic Usage\n\n```javascript\nvar Redis = require('ioredis');\nvar redis = new Redis();\n\nredis.set('foo', 'bar');\nredis.get('foo', function (err, result) {\n  console.log(result);\n});\nredis.del('foo');\n\n// Or using a promise if the last argument isn't a function\nredis.get('foo').then(function (result) {\n  console.log(result);\n});\n\n// Arguments to commands are flattened, so the following are the same:\nredis.sadd('set', 1, 3, 5, 7);\nredis.sadd('set', [1, 3, 5, 7]);\n\n// All arguments are passed directly to the redis server:\nredis.set('key', 100, 'EX', 10);\n```\n\nSee the `examples/` folder for more examples.\n\n## Connect to Redis\nWhen a new `Redis` instance is created,\na connection to Redis will be created at the same time.\nYou can specify which Redis to connect to by:\n\n```javascript\nnew Redis()       // Connect to 127.0.0.1:6379\nnew Redis(6380)   // 127.0.0.1:6380\nnew Redis(6379, '192.168.1.1')        // 192.168.1.1:6379\nnew Redis('/tmp/redis.sock')\nnew Redis({\n  port: 6379,          // Redis port\n  host: '127.0.0.1',   // Redis host\n  family: 4,           // 4 (IPv4) or 6 (IPv6)\n  password: 'auth',\n  db: 0\n})\n```\n\nYou can also specify connection options as a [`redis://` URL](http://www.iana.org/assignments/uri-schemes/prov/redis):\n\n```javascript\n// Connect to 127.0.0.1:6380, db 4, using password \"authpassword\":\nnew Redis('redis://:authpassword@127.0.0.1:6380/4')\n```\n\nSee [API Documentation](API.md#new_Redis) for all available options.\n\n## Pub/Sub\n\nHere is a simple example of the API for publish/subscribe.\nThe following program opens two client connections.\nIt subscribes to a channel with one connection\nand publishes to that channel with the other:\n\n```javascript\nvar Redis = require('ioredis');\nvar redis = new Redis();\nvar pub = new Redis();\nredis.subscribe('news', 'music', function (err, count) {\n  // Now we are subscribed to both the 'news' and 'music' channels.\n  // `count` represents the number of channels we are currently subscribed to.\n\n  pub.publish('news', 'Hello world!');\n  pub.publish('music', 'Hello again!');\n});\n\nredis.on('message', function (channel, message) {\n  // Receive message Hello world! from channel news\n  // Receive message Hello again! from channel music\n  console.log('Receive message %s from channel %s', message, channel);\n});\n\n// There's also an event called 'messageBuffer', which is the same as 'message' except\n// it returns buffers instead of strings.\nredis.on('messageBuffer', function (channel, message) {\n  // Both `channel` and `message` are buffers.\n});\n```\n\n`PSUBSCRIBE` is also supported in a similar way:\n\n```javascript\nredis.psubscribe('pat?ern', function (err, count) {});\nredis.on('pmessage', function (pattern, channel, message) {});\nredis.on('pmessageBuffer', function (pattern, channel, message) {});\n```\n\nWhen a client issues a SUBSCRIBE or PSUBSCRIBE, that connection is put into a \"subscriber\" mode.\nAt that point, only commands that modify the subscription set are valid.\nWhen the subscription set is empty, the connection is put back into regular mode.\n\nIf you need to send regular commands to Redis while in subscriber mode, just open another connection.\n\n## Handle Binary Data\nArguments can be buffers:\n```javascript\nredis.set('foo', Buffer.from('bar'));\n```\n\nAnd every command has a method that returns a Buffer (by adding a suffix of \"Buffer\" to the command name).\nTo get a buffer instead of a utf8 string:\n\n```javascript\nredis.getBuffer('foo', function (err, result) {\n  // result is a buffer.\n});\n```\n\n## Pipelining\nIf you want to send a batch of commands (e.g. > 5), you can use pipelining to queue\nthe commands in memory and then send them to Redis all at once. This way the performance improves by 50%~300% (See [benchmark section](#benchmark)).\n\n`redis.pipeline()` creates a `Pipeline` instance. You can call any Redis\ncommands on it just like the `Redis` instance. The commands are queued in memory\nand flushed to Redis by calling the `exec` method:\n\n```javascript\nvar pipeline = redis.pipeline();\npipeline.set('foo', 'bar');\npipeline.del('cc');\npipeline.exec(function (err, results) {\n  // `err` is always null, and `results` is an array of responses\n  // corresponding to the sequence of queued commands.\n  // Each response follows the format `[err, result]`.\n});\n\n// You can even chain the commands:\nredis.pipeline().set('foo', 'bar').del('cc').exec(function (err, results) {\n});\n\n// `exec` also returns a Promise:\nvar promise = redis.pipeline().set('foo', 'bar').get('foo').exec();\npromise.then(function (result) {\n  // result === [[null, 'OK'], [null, 'bar']]\n});\n```\n\nEach chained command can also have a callback, which will be invoked when the command\ngets a reply:\n\n```javascript\nredis.pipeline().set('foo', 'bar').get('foo', function (err, result) {\n  // result === 'bar'\n}).exec(function (err, result) {\n  // result[1][1] === 'bar'\n});\n```\n\nIn addition to adding commands to the `pipeline` queue individually, you can also pass an array of commands and arguments to the constructor:\n\n```javascript\nredis.pipeline([\n  ['set', 'foo', 'bar'],\n  ['get', 'foo']\n]).exec(function () { /* ... */ });\n```\n\n`#length` property shows how many commands in the pipeline:\n\n```javascript\nconst length = redis.pipeline().set('foo', 'bar').get('foo').length;\n// length === 2\n```\n\n\n## Transaction\nMost of the time, the transaction commands `multi` & `exec` are used together with pipeline.\nTherefore, when `multi` is called, a `Pipeline` instance is created automatically by default,\nso you can use `multi` just like `pipeline`:\n\n```javascript\nredis.multi().set('foo', 'bar').get('foo').exec(function (err, results) {\n  // results === [[null, 'OK'], [null, 'bar']]\n});\n```\nIf there's a syntax error in the transaction's command chain (e.g. wrong number of arguments, wrong command name, etc),\nthen none of the commands would be executed, and an error is returned:\n\n```javascript\nredis.multi().set('foo').set('foo', 'new value').exec(function (err, results) {\n  // err:\n  //  { [ReplyError: EXECABORT Transaction discarded because of previous errors.]\n  //    name: 'ReplyError',\n  //    message: 'EXECABORT Transaction discarded because of previous errors.',\n  //    command: { name: 'exec', args: [] },\n  //    previousErrors:\n  //     [ { [ReplyError: ERR wrong number of arguments for 'set' command]\n  //         name: 'ReplyError',\n  //         message: 'ERR wrong number of arguments for \\'set\\' command',\n  //         command: [Object] } ] }\n});\n```\n\nIn terms of the interface, `multi` differs from `pipeline` in that when specifying a callback\nto each chained command, the queueing state is passed to the callback instead of the result of the command:\n\n```javascript\nredis.multi().set('foo', 'bar', function (err, result) {\n  // result === 'QUEUED'\n}).exec(/* ... */);\n```\n\nIf you want to use transaction without pipeline, pass `{ pipeline: false }` to `multi`,\nand every command will be sent to Redis immediately without waiting for an `exec` invocation:\n\n```javascript\nredis.multi({ pipeline: false });\nredis.set('foo', 'bar');\nredis.get('foo');\nredis.exec(function (err, result) {\n  // result === [[null, 'OK'], [null, 'bar']]\n});\n```\n\nThe constructor of `multi` also accepts a batch of commands:\n\n```javascript\nredis.multi([\n  ['set', 'foo', 'bar'],\n  ['get', 'foo']\n]).exec(function () { /* ... */ });\n```\n\nInline transactions are supported by pipeline, which means you can group a subset of commands\nin the pipeline into a transaction:\n\n```javascript\nredis.pipeline().get('foo').multi().set('foo', 'bar').get('foo').exec().get('foo').exec();\n```\n\n## Lua Scripting\nioredis supports all of the scripting commands such as `EVAL`, `EVALSHA` and `SCRIPT`.\nHowever, it's tedious to use in real world scenarios since developers have to take\ncare of script caching and to detect when to use `EVAL` and when to use `EVALSHA`.\nioredis expose a `defineCommand` method to make scripting much easier to use:\n\n```javascript\nvar redis = new Redis();\n\n// This will define a command echo:\nredis.defineCommand('echo', {\n  numberOfKeys: 2,\n  lua: 'return {KEYS[1],KEYS[2],ARGV[1],ARGV[2]}'\n});\n\n// Now `echo` can be used just like any other ordinary command,\n// and ioredis will try to use `EVALSHA` internally when possible for better performance.\nredis.echo('k1', 'k2', 'a1', 'a2', function (err, result) {\n  // result === ['k1', 'k2', 'a1', 'a2']\n});\n\n// `echoBuffer` is also defined automatically to return buffers instead of strings:\nredis.echoBuffer('k1', 'k2', 'a1', 'a2', function (err, result) {\n  // result[0] equals to Buffer.from('k1');\n});\n\n// And of course it works with pipeline:\nredis.pipeline().set('foo', 'bar').echo('k1', 'k2', 'a1', 'a2').exec();\n```\n\nIf the number of keys can't be determined when defining a command, you can\nomit the `numberOfKeys` property and pass the number of keys as the first argument\nwhen you call the command:\n\n```javascript\nredis.defineCommand('echoDynamicKeyNumber', {\n  lua: 'return {KEYS[1],KEYS[2],ARGV[1],ARGV[2]}'\n});\n\n// Now you have to pass the number of keys as the first argument every time\n// you invoke the `echoDynamicKeyNumber` command:\nredis.echoDynamicKeyNumber(2, 'k1', 'k2', 'a1', 'a2', function (err, result) {\n  // result === ['k1', 'k2', 'a1', 'a2']\n});\n```\n\n## Transparent Key Prefixing\nThis feature allows you to specify a string that will automatically be prepended\nto all the keys in a command, which makes it easier to manage your key\nnamespaces.\n\n**Warning** This feature won't apply to commands like [KEYS](http://redis.io/commands/KEYS) and [SCAN](http://redis.io/commands/scan) that take patterns rather than actual keys([#239](https://github.com/luin/ioredis/issues/239)),\nand this feature also won't apply to the replies of commands even they are key names ([#325](https://github.com/luin/ioredis/issues/325)).\n\n```javascript\nvar fooRedis = new Redis({ keyPrefix: 'foo:' });\nfooRedis.set('bar', 'baz');  // Actually sends SET foo:bar baz\n\nfooRedis.defineCommand('echo', {\n  numberOfKeys: 2,\n  lua: 'return {KEYS[1],KEYS[2],ARGV[1],ARGV[2]}'\n});\n\n// Works well with pipelining/transaction\nfooRedis.pipeline()\n  // Sends SORT foo:list BY foo:weight_*->fieldname\n  .sort('list', 'BY', 'weight_*->fieldname')\n  // Supports custom commands\n  // Sends EVALSHA xxx foo:k1 foo:k2 a1 a2\n  .echo('k1', 'k2', 'a1', 'a2')\n  .exec()\n```\n\n## Transforming Arguments & Replies\nMost Redis commands take one or more Strings as arguments,\nand replies are sent back as a single String or an Array of Strings. However, sometimes\nyou may want something different. For instance, it would be more convenient if the `HGETALL`\ncommand returns a hash (e.g. `{ key: val1, key2: v2 }`) rather than an array of key values (e.g. `[key1, val1, key2, val2]`).\n\nioredis has a flexible system for transforming arguments and replies. There are two types\nof transformers, argument transformer and reply transformer:\n\n```javascript\nvar Redis = require('ioredis');\n\n// Here's the built-in argument transformer converting\n// hmset('key', { k1: 'v1', k2: 'v2' })\n// or\n// hmset('key', new Map([['k1', 'v1'], ['k2', 'v2']]))\n// into\n// hmset('key', 'k1', 'v1', 'k2', 'v2')\nRedis.Command.setArgumentTransformer('hmset', function (args) {\n  if (args.length === 2) {\n    if (typeof Map !== 'undefined' && args[1] instanceof Map) {\n      // utils is a internal module of ioredis\n      return [args[0]].concat(utils.convertMapToArray(args[1]));\n    }\n    if ( typeof args[1] === 'object' && args[1] !== null) {\n      return [args[0]].concat(utils.convertObjectToArray(args[1]));\n    }\n  }\n  return args;\n});\n\n// Here's the built-in reply transformer converting the HGETALL reply\n// ['k1', 'v1', 'k2', 'v2']\n// into\n// { k1: 'v1', 'k2': 'v2' }\nRedis.Command.setReplyTransformer('hgetall', function (result) {\n  if (Array.isArray(result)) {\n    var obj = {};\n    for (var i = 0; i < result.length; i += 2) {\n      obj[result[i]] = result[i + 1];\n    }\n    return obj;\n  }\n  return result;\n});\n```\n\nThere are three built-in transformers, two argument transformers for `hmset` & `mset` and\na reply transformer for `hgetall`. Transformers for `hmset` and `hgetall` were mentioned\nabove, and the transformer for `mset` is similar to the one for `hmset`:\n\n```javascript\nredis.mset({ k1: 'v1', k2: 'v2' });\nredis.get('k1', function (err, result) {\n  // result === 'v1';\n});\n\nredis.mset(new Map([['k3', 'v3'], ['k4', 'v4']]));\nredis.get('k3', function (err, result) {\n  // result === 'v3';\n});\n```\n\nAnother useful example of a reply transformer is one that changes `hgetall` to return array of arrays instead of objects which avoids a unwanted conversation of hash keys to strings when dealing with binary hash keys:\n\n```javascript\nRedis.Command.setReplyTransformer('hgetall', function (result) {\n  var arr = [];\n  for (var i = 0; i < result.length; i += 2) {\n    arr.push([result[i], result[i + 1]]);\n  }\n  return arr;\n});\nredis.hset('h1', Buffer.from([0x01]), Buffer.from([0x02]));\nredis.hset('h1', Buffer.from([0x03]), Buffer.from([0x04]));\nredis.hgetallBuffer('h1', function (err, result) {\n  // result === [ [ <Buffer 01>, <Buffer 02> ], [ <Buffer 03>, <Buffer 04> ] ];\n});\n```\n\n## Monitor\nRedis supports the MONITOR command,\nwhich lets you see all commands received by the Redis server across all client connections,\nincluding from other client libraries and other computers.\n\nThe `monitor` method returns a monitor instance.\nAfter you send the MONITOR command, no other commands are valid on that connection. ioredis will emit a monitor event for every new monitor message that comes across.\nThe callback for the monitor event takes a timestamp from the Redis server and an array of command arguments.\n\nHere is a simple example:\n\n```javascript\nredis.monitor(function (err, monitor) {\n  monitor.on('monitor', function (time, args, source, database) {\n  });\n});\n```\n\n## Streamify Scanning\nRedis 2.8 added the `SCAN` command to incrementally iterate through the keys in the database. It's different from `KEYS` in that\n`SCAN` only returns a small number of elements each call, so it can be used in production without the downside\nof blocking the server for a long time. However, it requires recording the cursor on the client side each time\nthe `SCAN` command is called in order to iterate through all the keys correctly. Since it's a relatively common use case, ioredis\nprovides a streaming interface for the `SCAN` command to make things much easier. A readable stream can be created by calling `scanStream`:\n\n```javascript\nvar redis = new Redis();\n// Create a readable stream (object mode)\nvar stream = redis.scanStream();\nstream.on('data', function (resultKeys) {\n  // `resultKeys` is an array of strings representing key names.\n  // Note that resultKeys may contain 0 keys, and that it will sometimes\n  // contain duplicates due to SCAN's implementation in Redis.\n  for (var i = 0; i < resultKeys.length; i++) {\n    console.log(resultKeys[i]);\n  }\n});\nstream.on('end', function () {\n  console.log('all keys have been visited');\n});\n```\n\n`scanStream` accepts an option, with which you can specify the `MATCH` pattern and the `COUNT` argument:\n\n```javascript\nvar stream = redis.scanStream({\n  // only returns keys following the pattern of `user:*`\n  match: 'user:*',\n  // returns approximately 100 elements per call\n  count: 100\n});\n```\n\nJust like other commands, `scanStream` has a binary version `scanBufferStream`, which returns an array of buffers. It's useful when\nthe key names are not utf8 strings.\n\nThere are also `hscanStream`, `zscanStream` and `sscanStream` to iterate through elements in a hash, zset and set. The interface of each is\nsimilar to `scanStream` except the first argument is the key name:\n\n```javascript\nvar stream = redis.hscanStream('myhash', {\n  match: 'age:??'\n});\n```\n\nYou can learn more from the [Redis documentation](http://redis.io/commands/scan).\n\n**Useful Tips**\nIt's pretty common that doing an async task in the `data` handler. We'd like the scanning process to be paused until the async task to be finished. `Stream#pause()` and `Stream.resume()` do the trick. For example if we want to migrate data in Redis to MySQL:\n\n```javascript\nvar stream = redis.scanStream();\nstream.on('data', function (resultKeys) {\n  // Pause the stream from scanning more keys until we've migrated the current keys.\n  stream.pause();\n\n  Promise.all(resultKeys.map(migrateKeyToMySQL)).then(() => {\n    // Resume the stream here.\n    stream.resume();\n  });\n});\n\nstream.on('end', function () {\n  console.log('done migration');\n});\n```\n\n## Auto-reconnect\nBy default, ioredis will try to reconnect when the connection to Redis is lost\nexcept when the connection is closed manually by `redis.disconnect()` or `redis.quit()`.\n\nIt's very flexible to control how long to wait to reconnect after disconnection\nusing the `retryStrategy` option:\n\n```javascript\nvar redis = new Redis({\n  // This is the default value of `retryStrategy`\n  retryStrategy: function (times) {\n    var delay = Math.min(times * 50, 2000);\n    return delay;\n  }\n});\n```\n\n`retryStrategy` is a function that will be called when the connection is lost.\nThe argument `times` means this is the nth reconnection being made and\nthe return value represents how long (in ms) to wait to reconnect. When the\nreturn value isn't a number, ioredis will stop trying to reconnect, and the connection\nwill be lost forever if the user doesn't call `redis.connect()` manually.\n\nWhen reconnected, the client will auto subscribe to channels that the previous connection subscribed to.\nThis behavior can be disabled by setting the `autoResubscribe` option to `false`.\n\nAnd if the previous connection has some unfulfilled commands (most likely blocking commands such as `brpop` and `blpop`),\nthe client will resend them when reconnected. This behavior can be disabled by setting the `autoResendUnfulfilledCommands` option to `false`.\n\nBy default, all pending commands will be flushed with an error every 20 retry attempts. That makes sure commands won't wait forever when the connection is down. You can change this behavior by setting `maxRetriesPerRequest`:\n\n```javascript\nvar redis = new Redis({\n  maxRetriesPerRequest: 1\n});\n```\n\nSet maxRetriesPerRequest to `null` to disable this behavior, and every command will wait forever until the connection is alive again (which is the default behavior before ioredis v4).\n\n### Reconnect on error\n\nBesides auto-reconnect when the connection is closed, ioredis supports reconnecting on the specified errors by the `reconnectOnError` option. Here's an example that will reconnect when receiving `READONLY` error:\n\n```javascript\nvar redis = new Redis({\n  reconnectOnError: function (err) {\n    var targetError = 'READONLY';\n    if (err.message.slice(0, targetError.length) === targetError) {\n      // Only reconnect when the error starts with \"READONLY\"\n      return true; // or `return 1;`\n    }\n  }\n});\n```\n\nThis feature is useful when using Amazon ElastiCache. Once failover happens, Amazon ElastiCache will switch the master we currently connected with to a slave, leading to the following writes fails with the error `READONLY`. Using `reconnectOnError`, we can force the connection to reconnect on this error in order to connect to the new master.\n\nFurthermore, if the `reconnectOnError` returns `2`, ioredis will resend the failed command after reconnecting.\n\n## Connection Events\nThe Redis instance will emit some events about the state of the connection to the Redis server.\n\nEvent    | Description\n:------------- | :-------------\nconnect  | emits when a connection is established to the Redis server.\nready    | If `enableReadyCheck` is `true`, client will emit `ready` when the server reports that it is ready to receive commands (e.g. finish loading data from disk).<br>Otherwise, `ready` will be emitted immediately right after the `connect` event.\nerror    | emits when an error occurs while connecting.<br>However, ioredis emits all `error` events silently (only emits when there's at least one listener) so that your application won't crash if you're not listening to the `error` event.\nclose    | emits when an established Redis server connection has closed.\nreconnecting | emits after `close` when a reconnection will be made. The argument of the event is the time (in ms) before reconnecting.\nend     | emits after `close` when no more reconnections will be made, or the connection is failed to establish.\n\nYou can also check out the `Redis#status` property to get the current connection status.\n\nBesides the above connection events, there are several other custom events:\n\nEvent    | Description\n:------------- | :-------------\nselect   | emits when the database changed. The argument is the new db number.\n\n## Offline Queue\nWhen a command can't be processed by Redis (being sent before the `ready` event), by default, it's added to the offline queue and will be\nexecuted when it can be processed. You can disable this feature by setting the `enableOfflineQueue`\noption to `false`:\n\n```javascript\nvar redis = new Redis({ enableOfflineQueue: false });\n```\n\n## TLS Options\nRedis doesn't support TLS natively, however if the redis server you want to connect to is hosted behind a TLS proxy (e.g. [stunnel](https://www.stunnel.org/)) or is offered by a PaaS service that supports TLS connection (e.g. [Redis Labs](https://redislabs.com/)), you can set the `tls` option:\n\n```javascript\nvar redis = new Redis({\n  host: 'localhost',\n  tls: {\n    // Refer to `tls.connect()` section in\n    // https://nodejs.org/api/tls.html\n    // for all supported options\n    ca: fs.readFileSync('cert.pem')\n  }\n});\n```\n\n<hr>\n\n## Sentinel\nioredis supports Sentinel out of the box. It works transparently as all features that work when\nyou connect to a single node also work when you connect to a sentinel group. Make sure to run Redis >= 2.8.12 if you want to use this feature. Sentinels have a default port of 26379.\n\nTo connect using Sentinel, use:\n\n```javascript\nvar redis = new Redis({\n  sentinels: [{ host: 'localhost', port: 26379 }, { host: 'localhost', port: 26380 }],\n  name: 'mymaster'\n});\n\nredis.set('foo', 'bar');\n```\n\nThe arguments passed to the constructor are different from the ones you use to connect to a single node, where:\n\n* `name` identifies a group of Redis instances composed of a master and one or more slaves (`mymaster` in the example);\n* `sentinelPassword` (optional) password for Sentinel instances.\n* `sentinels` are a list of sentinels to connect to. The list does not need to enumerate all your sentinel instances, but a few so that if one is down the client will try the next one.\n* `role` (optional) with a value of `slave` will return a random slave from the Sentinel group.\n* `preferredSlaves` (optional) can be used to prefer a particular slave or set of slaves based on priority. It accepts a function or array.\n\nioredis **guarantees** that the node you connected to is always a master even after a failover. When a failover happens, instead of trying to reconnect to the failed node (which will be demoted to slave when it's available again), ioredis will ask sentinels for the new master node and connect to it. All commands sent during the failover are queued and will be executed when the new connection is established so that none of the commands will be lost.\n\nIt's possible to connect to a slave instead of a master by specifying the option `role` with the value of `slave` and ioredis will try to connect to a random slave of the specified master, with the guarantee that the connected node is always a slave. If the current node is promoted to master due to a failover, ioredis will disconnect from it and ask the sentinels for another slave node to connect to.\n\nIf you specify the option `preferredSlaves` along with `role: 'slave'` ioredis will attempt to use this value when selecting the slave from the pool of available slaves. The value of `preferredSlaves` should either be a function that accepts an array of avaiable slaves and returns a single result, or an array of slave values priorities by the lowest `prio` value first with a default value of `1`.\n\n```javascript\n// available slaves format\nvar availableSlaves = [{ ip: '127.0.0.1', port: '31231', flags: 'slave' }];\n\n// preferredSlaves array format\nvar preferredSlaves = [\n  { ip: '127.0.0.1', port: '31231', prio: 1 },\n  { ip: '127.0.0.1', port: '31232', prio: 2 }\n];\n\n// preferredSlaves function format\npreferredSlaves = function(availableSlaves) {\n  for (var i = 0; i < availableSlaves.length; i++) {\n    var slave = availableSlaves[i];\n    if (slave.ip === '127.0.0.1') {\n      if (slave.port === '31234') {\n        return slave;\n      }\n    }\n  }\n  // if no preferred slaves are available a random one is used\n  return false;\n};\n\nvar redis = new Redis({\n  sentinels: [{ host: '127.0.0.1', port: 26379 }, { host: '127.0.0.1', port: 26380 }],\n  name: 'mymaster',\n  role: 'slave',\n  preferredSlaves: preferredSlaves\n});\n```\n\nBesides the `retryStrategy` option, there's also a `sentinelRetryStrategy` in Sentinel mode which will be invoked when all the sentinel nodes are unreachable during connecting. If `sentinelRetryStrategy` returns a valid delay time, ioredis will try to reconnect from scratch. The default value of `sentinelRetryStrategy` is:\n\n```javascript\nfunction (times) {\n  var delay = Math.min(times * 10, 1000);\n  return delay;\n}\n```\n\n## Cluster\nRedis Cluster provides a way to run a Redis installation where data is automatically sharded across multiple Redis nodes.\nYou can connect to a Redis Cluster like this:\n\n```javascript\nvar Redis = require('ioredis');\n\nvar cluster = new Redis.Cluster([{\n  port: 6380,\n  host: '127.0.0.1'\n}, {\n  port: 6381,\n  host: '127.0.0.1'\n}]);\n\ncluster.set('foo', 'bar');\ncluster.get('foo', function (err, res) {\n  // res === 'bar'\n});\n```\n\n`Cluster` constructor accepts two arguments, where:\n\n0. The first argument is a list of nodes of the cluster you want to connect to.\nJust like Sentinel, the list does not need to enumerate all your cluster nodes,\nbut a few so that if one is unreachable the client will try the next one, and the client will discover other nodes automatically when at least one node is connected.\n0. The second argument is the options, where:\n\n    * `clusterRetryStrategy`: When none of the startup nodes are reachable, `clusterRetryStrategy` will be invoked. When a number is returned,\n    ioredis will try to reconnect to the startup nodes from scratch after the specified delay (in ms). Otherwise, an error of \"None of startup nodes is available\" will be returned.\n    The default value of this option is:\n\n        ```javascript\n        function (times) {\n          var delay = Math.min(100 + times * 2, 2000);\n          return delay;\n        }\n        ```\n\n        It's possible to modify the `startupNodes` property in order to switch to another set of nodes here:\n\n        ```javascript\n        function (times) {\n          this.startupNodes = [{ port: 6790, host: '127.0.0.1' }];\n          return Math.min(100 + times * 2, 2000);\n        }\n        ```\n\n    * `enableOfflineQueue`: Similar to the `enableOfflineQueue` option of `Redis` class.\n    * `enableReadyCheck`: When enabled, \"ready\" event will only be emitted when `CLUSTER INFO` command\n    reporting the cluster is ready for handling commands. Otherwise, it will be emitted immediately after \"connect\" is emitted.\n    * `scaleReads`: Config where to send the read queries. See below for more details.\n    * `maxRedirections`: When a cluster related error (e.g. `MOVED`, `ASK` and `CLUSTERDOWN` etc.) is received, the client will redirect the\n    command to another node. This option limits the max redirections allowed when sending a command. The default value is `16`.\n    * `retryDelayOnFailover`: If the target node is disconnected when sending a command,\n    ioredis will retry after the specified delay. The default value is `100`. You should make sure `retryDelayOnFailover * maxRedirections > cluster-node-timeout`\n    to insure that no command will fail during a failover.\n    * `retryDelayOnClusterDown`: When a cluster is down, all commands will be rejected with the error of `CLUSTERDOWN`. If this option is a number (by default, it is `100`), the client\n    will resend the commands after the specified time (in ms).\n    * `retryDelayOnTryAgain`: If this option is a number (by default, it is `100`), the client\n    will resend the commands rejected with `TRYAGAIN` error after the specified time (in ms).\n    * `redisOptions`: Default options passed to the constructor of `Redis` when connecting to a node.\n    * `slotsRefreshTimeout`: Milliseconds before a timeout occurs while refreshing slots from the cluster (default `1000`)\n    * `slotsRefreshInterval`: Milliseconds between every automatic slots refresh (default `5000`)\n\n### Read-write splitting\n\nA typical redis cluster contains three or more masters and several slaves for each master. It's possible to scale out redis cluster by sending read queries to slaves and write queries to masters by setting the `scaleReads` option.\n\n`scaleReads` is \"master\" by default, which means ioredis will never send any queries to slaves. There are other three available options:\n\n1. \"all\": Send write queries to masters and read queries to masters or slaves randomly.\n2. \"slave\": Send write queries to masters and read queries to slaves.\n3. a custom `function(nodes, command): node`: Will choose the custom function to select to which node to send read queries (write queries keep being sent to master). The first node in `nodes` is always the master serving the relevant slots. If the function returns an array of nodes, a random node of that list will be selected.\n\nFor example:\n\n```javascript\nvar cluster = new Redis.Cluster([/* nodes */], {\n  scaleReads: 'slave'\n});\ncluster.set('foo', 'bar'); // This query will be sent to one of the masters.\ncluster.get('foo', function (err, res) {\n  // This query will be sent to one of the slaves.\n});\n```\n\n**NB** In the code snippet above, the `res` may not be equal to \"bar\" because of the lag of replication between the master and slaves.\n\n### Running commands to multiple nodes\n\nEvery command will be sent to exactly one node. For commands containing keys, (e.g. `GET`, `SET` and `HGETALL`), ioredis sends them to the node that serving the keys, and for other commands not containing keys, (e.g. `INFO`, `KEYS` and `FLUSHDB`), ioredis sends them to a random node.\n\nSometimes you may want to send a command to multiple nodes (masters or slaves) of the cluster, you can get the nodes via `Cluster#nodes()` method.\n\n`Cluster#nodes()` accepts a parameter role, which can be \"master\", \"slave\" and \"all\" (default), and returns an array of `Redis` instance. For example:\n\n```javascript\n// Send `FLUSHDB` command to all slaves:\nvar slaves = cluster.nodes('slave');\nPromise.all(slaves.map(function (node) {\n  return node.flushdb();\n}));\n\n// Get keys of all the masters:\nvar masters = cluster.nodes('master');\nPromise.all(masters.map(function (node) {\n  return node.keys();\n})).then(function (keys) {\n  // keys: [['key1', 'key2'], ['key3', 'key4']]\n});\n```\n\n### NAT Mapping\nSometimes the cluster is hosted within a internal network that can only be accessed via a NAT (Network Address Translation) instance. See [Accessing ElastiCache from outside AWS](https://docs.aws.amazon.com/AmazonElastiCache/latest/red-ug/accessing-elasticache.html) as an example.\n\nYou can specify nat mapping rules via `natMap` option:\n\n```javascript\nconst cluster = new Redis.Cluster([{\n  host: '203.0.113.73',\n  port: 30001\n}], {\n  natMap: {\n    '10.0.1.230:30001': {host: '203.0.113.73', port: 30001},\n    '10.0.1.231:30001': {host: '203.0.113.73', port: 30002},\n    '10.0.1.232:30001': {host: '203.0.113.73', port: 30003}\n  }\n})\n```\n\nThis option is also useful when the cluster is running inside a Docker container.\n\n### Transaction and pipeline in Cluster mode\nAlmost all features that are supported by `Redis` are also supported by `Redis.Cluster`, e.g. custom commands, transaction and pipeline.\nHowever there are some differences when using transaction and pipeline in Cluster mode:\n\n0. All keys in a pipeline should belong to the same slot since ioredis sends all commands in a pipeline to the same node.\n0. You can't use `multi` without pipeline (aka `cluster.multi({ pipeline: false })`). This is because when you call `cluster.multi({ pipeline: false })`, ioredis doesn't know which node the `multi` command should be sent to.\n0. Chaining custom commands in the pipeline is not supported in Cluster mode.\n\nWhen any commands in a pipeline receives a `MOVED` or `ASK` error, ioredis will resend the whole pipeline to the specified node automatically if all of the following conditions are satisfied:\n\n0. All errors received in the pipeline are the same. For example, we won't resend the pipeline if we got two `MOVED` errors pointing to different nodes.\n0. All commands executed successfully are readonly commands. This makes sure that resending the pipeline won't have side effects.\n\n### Pub/Sub\nPub/Sub in cluster mode works exactly as the same as in standalone mode. Internally, when a node of the cluster receives a message, it will broadcast the message to the other nodes. ioredis makes sure that each message will only be received once by strictly subscribing one node at the same time.\n\n```javascript\nvar nodes = [/* nodes */];\nvar pub = new Redis.Cluster(nodes);\nvar sub = new Redis.Cluster(nodes);\nsub.on('message', function (channel, message) {\n  console.log(channel, message);\n});\n\nsub.subscribe('news', function () {\n  pub.publish('news', 'highlights');\n});\n```\n\n### Events\n\nEvent    | Description\n:------------- | :-------------\nconnect  | emits when a connection is established to the Redis server.\nready    | emits when `CLUSTER INFO` reporting the cluster is able to receive commands (if `enableReadyCheck` is `true`) or immediately after `connect` event (if `enableReadyCheck` is false).\nerror    | emits when an error occurs while connecting with a property of `lastNodeError` representing the last node error received. This event is emitted silently (only emitting if there's at least one listener).\nclose    | emits when an established Redis server connection has closed.\nreconnecting | emits after `close` when a reconnection will be made. The argument of the event is the time (in ms) before reconnecting.\nend     | emits after `close` when no more reconnections will be made.\n+node   | emits when a new node is connected.\n-node   | emits when a node is disconnected.\nnode error | emits when an error occurs when connecting to a node. The second argument indicates the address of the node.\n\n### Password\nSetting the `password` option to access password-protected clusters:\n\n```javascript\nvar Redis = require('ioredis');\nvar cluster = new Redis.Cluster(nodes, {\n  redisOptions: {\n    password: 'your-cluster-password'\n  }\n});\n```\n\nIf some of nodes in the cluster using a different password, you should specify them in the first parameter:\n\n```javascript\nvar Redis = require('ioredis');\nvar cluster = new Redis.Cluster([\n  // Use password \"password-for-30001\" for 30001\n  { port: 30001, password: 'password-for-30001'},\n  // Don't use password when accessing 30002\n  { port: 30002, password: null }\n  // Other nodes will use \"fallback-password\"\n], {\n  redisOptions: {\n    password: 'fallback-password'\n  }\n});\n```\n\n<hr>\n\n# Error Handling\nAll the errors returned by the Redis server are instances of `ReplyError`, which can be accessed via `Redis`:\n\n```javascript\nvar Redis = require('ioredis');\nvar redis = new Redis();\n// This command causes a reply error since the SET command requires two arguments.\nredis.set('foo', function (err) {\n  err instanceof Redis.ReplyError\n});\n```\n\nThis is the error stack of the `ReplyError`:\n\n```\nReplyError: ERR wrong number of arguments for 'set' command\n    at ReplyParser._parseResult (/app/node_modules/ioredis/lib/parsers/javascript.js:60:14)\n    at ReplyParser.execute (/app/node_modules/ioredis/lib/parsers/javascript.js:178:20)\n    at Socket.<anonymous> (/app/node_modules/ioredis/lib/redis/event_handler.js:99:22)\n    at Socket.emit (events.js:97:17)\n    at readableAddChunk (_stream_readable.js:143:16)\n    at Socket.Readable.push (_stream_readable.js:106:10)\n    at TCP.onread (net.js:509:20)\n```\n\nBy default, the error stack doesn't make any sense because the whole stack happens in the ioredis\nmodule itself, not in your code. So it's not easy to find out where the error happens in your code.\nioredis provides an option `showFriendlyErrorStack` to solve the problem. When you enable\n`showFriendlyErrorStack`, ioredis will optimize the error stack for you:\n\n```javascript\nvar Redis = require('ioredis');\nvar redis = new Redis({ showFriendlyErrorStack: true });\nredis.set('foo');\n```\n\nAnd the output will be:\n\n```\nReplyError: ERR wrong number of arguments for 'set' command\n    at Object.<anonymous> (/app/index.js:3:7)\n    at Module._compile (module.js:446:26)\n    at Object.Module._extensions..js (module.js:464:10)\n    at Module.load (module.js:341:32)\n    at Function.Module._load (module.js:296:12)\n    at Function.Module.runMain (module.js:487:10)\n    at startup (node.js:111:16)\n    at node.js:799:3\n```\n\nThis time the stack tells you that the error happens on the third line in your code. Pretty sweet!\nHowever, it would decrease the performance significantly to optimize the error stack. So by\ndefault, this option is disabled and can only be used for debugging purposes. You **shouldn't** use this feature in a production environment.\n\n# Plugging in your own Promises Library\nIf you're an advanced user, you may want to plug in your own promise library like [bluebird](https://www.npmjs.com/package/bluebird). Just set Redis.Promise to your favorite ES6-style promise constructor and ioredis will use it.\n\n```javascript\nconst Redis = require('ioredis')\nRedis.Promise = require('bluebird')\n\nconst redis = new Redis()\n\n// Use bluebird\nassert.equal(redis.get().constructor, require('bluebird'))\n\n// You can change the Promise implementation at any time:\nRedis.Promise = global.Promise\nassert.equal(redis.get().constructor, global.Promise)\n```\n\n\n# Running tests\n\nStart a Redis server on 127.0.0.1:6379, and then:\n\n```shell\n$ npm test\n```\n\n`FLUSH ALL` will be invoked after each test, so make sure there's no valuable data in it before running tests.\n\nIf your testing environment does not let you spin up a Redis server [ioredis-mock](https://github.com/stipsan/ioredis-mock) is a drop-in replacement you can use in your tests. It aims to behave identically to ioredis connected to a Redis server so that your integration tests is easier to write and of better quality.\n\n# Debug\n\nYou can set the `DEBUG` env to `ioredis:*` to print debug info:\n\n```shell\n$ DEBUG=ioredis:* node app.js\n```\n\n# Consolidation: It's time for celebration\n\nRight now there are two great redis clients around and both have some advantages above each other. We speak about [node_redis](https://github.com/NodeRedis/node_redis) and ioredis. So after talking to each other about how we could improve in working together we (that is [@BridgeAR](https://github.com/BridgeAR) and [@luin](https://github.com/luin)) decided to work towards a single library on the long run. But step by step.\n\nFirst of all, we want to split small parts of our libraries into others so that we're both able to use the same code. Those libraries are going to be maintained under the NodeRedis organization. This is going to reduce the maintance overhead, allows others to use the very same code, if they need it and it's way easier for others to contribute to both libraries.\n\nWe're very happy about this step towards working together as we both want to give you the best redis experience possible.\n\nIf you want to join our cause by help maintaining something, please don't hesitate to contact either one of us.\n\n# Join in!\n\nI'm happy to receive bug reports, fixes, documentation enhancements, and any other improvements.\n\nAnd since I'm not a native English speaker, if you find any grammar mistakes in the documentation, please also let me know. :)\n\n# Contributors\n\nThis project exists thanks to all the people who contribute:\n\n<a href=\"https://github.com/luin/ioredis/graphs/contributors\"><img src=\"https://opencollective.com/ioredis/contributors.svg?width=890&showBtn=false\" /></a>\n\n# License\n\nMIT\n\n\n[![FOSSA Status](https://app.fossa.io/api/projects/git%2Bgithub.com%2Fluin%2Fioredis.svg?type=large)](https://app.fossa.io/projects/git%2Bgithub.com%2Fluin%2Fioredis?ref=badge_large)\n","readmeFilename":"README.md","bugs":{"url":"https://github.com/luin/ioredis/issues"},"homepage":"https://github.com/luin/ioredis#readme","_id":"ioredis@4.10.2","_nodeVersion":"10.16.0","_npmVersion":"6.9.0","dist":{"integrity":"sha512-4NpzKmoo6ynHfIWPBjZ7aS23u4fX7+zDkOud7x6EmVxqQH5jZDc2hf2UteuOIR7pfoW9hRHuZoM2jT/5yv+3Jg==","shasum":"e19ad148af1376e72d1d3a1c4abf12968d41b5f6","tarball":"https://registry.npmjs.org/ioredis/-/ioredis-4.10.2.tgz","fileCount":35,"unpackedSize":225222,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJc+7lMCRA9TVsSAnZWagAA/HoP/3SJPAjURvQWI8SRyfi+\nZk2bLffLD6oCMNAqZkni3e6yPNZ/1lxzlgyskVTqvBdWA0A2z6WMPBm+PbsW\nn4jpVDzEI5k0HDEgl3qcc4tDN9rXh+ntVc/u7tE7XZzWCBaztbcdONOhhD9D\nlVtmdlbJLfYHlw1UROKWiZwpnTwrZY4hT7Xz9TuN4BRTRZv0SpGXcQ2SMFuc\nX0JMaMIheM3FWUw2w2qlGCsTdKhofPEGaj50YLd2vEDNebDALqJHwS/0+cXQ\nnuslcYVH4hIPMJpbkhqPW6E+Yw70k1uDIImPINFrXi917IxsddJwQ2oDh2pF\nQq6GpOQjtud94FeUdIW8nzGt4LT4rGgF6uToctyzUWz79fR+8oj7qXuMd6VO\nMwf5qoOCyTi80kYT3FPVAEs8I6uQO4XaaxAWkhxFhSAP6UqeOFBLlIsICeX7\nSjqdWnUG6bjTNhZXr6tdFW57+PwN3hZE3PTGIrUG4zcpBOo3fplh0WCzWDlw\nSeDjmjyLmIv5i6jKSwCQQPYC2ijruBKfPnySXzIDVcKpG94cyrDM7cQ3gcwQ\n8q8/xBL0iqUeTNIYThGqOoKfcoApM2gN/AmaRks7Q+EnAhuYG1WqDqEZqX4e\n+AVH8QA1LA6aK6ht7sLQBvwiQwrH4fXV30O0LZ9bAm/E6ZmQ1ATgVB4cNew2\nFpZh\r\n=ujni\r\n-----END PGP SIGNATURE-----\r\n"},"maintainers":[{"email":"ioredis-robot@zihua.li","name":"ioredis-robot"},{"email":"i@zihua.li","name":"luin"}],"_npmUser":{"name":"luin","email":"i@zihua.li"},"directories":{},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/ioredis_4.10.2_1560000843658_0.20719253337708454"},"_hasShrinkwrap":false},"4.10.3":{"name":"ioredis","version":"4.10.3","description":"A robust, performance-focused and full-featured Redis client for Node.js.","main":"built/index.js","scripts":{"test":"NODE_ENV=test mocha","test:cov":"NODE_ENV=test node ./node_modules/istanbul/lib/cli.js cover --preserve-comments ./node_modules/mocha/bin/_mocha -- -r ts-node/register -R spec --exit","build":"rm -rf built && tsc","prepublishOnly":"npm run build && npm test","bench":"matcha benchmarks/*.js","semantic-release":"semantic-release"},"repository":{"type":"git","url":"git://github.com/luin/ioredis.git"},"keywords":["redis","cluster","sentinel","pipelining"],"author":{"name":"luin","email":"i@zihua.li","url":"http://zihua.li"},"license":"MIT","dependencies":{"cluster-key-slot":"^1.0.6","debug":"^4.1.1","denque":"^1.1.0","lodash.defaults":"^4.2.0","lodash.flatten":"^4.4.0","redis-commands":"1.5.0","redis-errors":"^1.2.0","redis-parser":"^3.0.0","standard-as-callback":"^2.0.1"},"devDependencies":{"@semantic-release/changelog":"^3.0.4","@semantic-release/git":"^7.0.12","@types/node":"^12.0.2","@types/redis-errors":"1.2.0","bluebird":"^3.5.4","chai":"^4.2.0","cz-conventional-changelog":"^2.0.0","istanbul":"^0.4.5","mocha":"^5.0.0","server-destroy":"^1.0.1","sinon":"^7.3.2","ts-node":"^8.1.0","typescript":"^3.4.5"},"engines":{"node":">=6"},"config":{"commitizen":{"path":"./node_modules/cz-conventional-changelog"}},"gitHead":"fc4d096d22af3a9e061f1dbe692660e500a73d37","readme":"[![ioredis](https://cdn.jsdelivr.net/gh/luin/ioredis@b5e8c74/logo.svg)](https://github.com/luin/ioredis)\n\n[![Build Status](https://travis-ci.org/luin/ioredis.svg?branch=master)](https://travis-ci.org/luin/ioredis)\n[![Test Coverage](https://codeclimate.com/github/luin/ioredis/badges/coverage.svg)](https://codeclimate.com/github/luin/ioredis)\n[![Join the chat at https://gitter.im/luin/ioredis](https://badges.gitter.im/Join%20Chat.svg)](https://gitter.im/luin/ioredis?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge)\n[![Commitizen friendly](https://img.shields.io/badge/commitizen-friendly-brightgreen.svg)](http://commitizen.github.io/cz-cli/)\n[![semantic-release](https://img.shields.io/badge/%20%20%F0%9F%93%A6%F0%9F%9A%80-semantic--release-e10079.svg)](https://github.com/semantic-release/semantic-release)\n[![npm latest version](https://img.shields.io/npm/v/ioredis/latest.svg)](https://www.npmjs.com/package/ioredis)\n[![npm next version](https://img.shields.io/npm/v/ioredis/next.svg)](https://www.npmjs.com/package/ioredis)\n<img alt=\"\" src=\"\">\n\nA robust, performance-focused and full-featured [Redis](http://redis.io) client for [Node.js](https://nodejs.org).\n\nSupports Redis >= 2.6.12 and (Node.js >= 6).\n\n# Features\nioredis is a robust, full-featured Redis client that is\nused in the world's biggest online commerce company [Alibaba](http://www.alibaba.com/) and many other awesome companies.\n\n0. Full-featured. It supports [Cluster](http://redis.io/topics/cluster-tutorial), [Sentinel](http://redis.io/topics/sentinel), [Pipelining](http://redis.io/topics/pipelining) and of course [Lua scripting](http://redis.io/commands/eval) & [Pub/Sub](http://redis.io/topics/pubsub) (with the support of binary messages).\n0. High performance.\n0. Delightful API. It works with Node callbacks and Native promises.\n0. Transformation of command arguments and replies.\n0. Transparent key prefixing.\n0. Abstraction for Lua scripting, allowing you to define custom commands.\n0. Support for binary data.\n0. Support for TLS.\n0. Support for offline queue and ready checking.\n0. Support for ES6 types, such as `Map` and `Set`.\n0. Support for GEO commands (Redis 3.2 Unstable).\n0. Sophisticated error handling strategy.\n0. Support for NAT mapping.\n\n# Links\n* [API Documentation](API.md)\n* [Changelog](Changelog.md)\n* [Migrating from node_redis](https://github.com/luin/ioredis/wiki/Migrating-from-node_redis)\n* [Error Handling](#error-handling)\n\n## Become a Sponsor to Support ioredis's Development\nOpen source is hard and time-consuming. If you want to invest in ioredis's future you can become a sponsor and make us spend more time on this library's improvements and new features.\n\n<a href=\"https://opencollective.com/ioredis\"><img src=\"https://opencollective.com/ioredis/tiers/sponsor.svg?avatarHeight=36\"></a>\n\nThank you for using ioredis :-)\n\n<hr>\n<a href=\"https://itunes.apple.com/app/medis-gui-for-redis/id1063631769\"><img align=\"right\" src=\"medis.png\" alt=\"Download on the App Store\"></a>\n\n\n### Advertisement\n\nLooking for a Redis GUI manager for OS X, Windows and Linux? Here's [Medis](https://itunes.apple.com/us/app/medis-gui-for-redis/id1063631769)!\n\nMedis is an open-sourced, beautiful, easy-to-use Redis GUI management application.\n\nMedis starts with all the basic features you need:\n\n* Keys viewing/editing\n* SSH Tunnel for connecting with remote servers\n* Terminal for executing custom commands\n* JSON/MessagePack format viewing/editing and built-in highlighting/validator\n* And other awesome features...\n\n[Medis is open sourced on GitHub](https://github.com/luin/medis)\n\n<hr>\n\n# Quick Start\n\n## Install\n```shell\n$ npm install ioredis\n```\n\n## Basic Usage\n\n```javascript\nvar Redis = require('ioredis');\nvar redis = new Redis();\n\nredis.set('foo', 'bar');\nredis.get('foo', function (err, result) {\n  console.log(result);\n});\nredis.del('foo');\n\n// Or using a promise if the last argument isn't a function\nredis.get('foo').then(function (result) {\n  console.log(result);\n});\n\n// Arguments to commands are flattened, so the following are the same:\nredis.sadd('set', 1, 3, 5, 7);\nredis.sadd('set', [1, 3, 5, 7]);\n\n// All arguments are passed directly to the redis server:\nredis.set('key', 100, 'EX', 10);\n```\n\nSee the `examples/` folder for more examples.\n\n## Connect to Redis\nWhen a new `Redis` instance is created,\na connection to Redis will be created at the same time.\nYou can specify which Redis to connect to by:\n\n```javascript\nnew Redis()       // Connect to 127.0.0.1:6379\nnew Redis(6380)   // 127.0.0.1:6380\nnew Redis(6379, '192.168.1.1')        // 192.168.1.1:6379\nnew Redis('/tmp/redis.sock')\nnew Redis({\n  port: 6379,          // Redis port\n  host: '127.0.0.1',   // Redis host\n  family: 4,           // 4 (IPv4) or 6 (IPv6)\n  password: 'auth',\n  db: 0\n})\n```\n\nYou can also specify connection options as a [`redis://` URL](http://www.iana.org/assignments/uri-schemes/prov/redis):\n\n```javascript\n// Connect to 127.0.0.1:6380, db 4, using password \"authpassword\":\nnew Redis('redis://:authpassword@127.0.0.1:6380/4')\n```\n\nSee [API Documentation](API.md#new_Redis) for all available options.\n\n## Pub/Sub\n\nHere is a simple example of the API for publish/subscribe.\nThe following program opens two client connections.\nIt subscribes to a channel with one connection\nand publishes to that channel with the other:\n\n```javascript\nvar Redis = require('ioredis');\nvar redis = new Redis();\nvar pub = new Redis();\nredis.subscribe('news', 'music', function (err, count) {\n  // Now we are subscribed to both the 'news' and 'music' channels.\n  // `count` represents the number of channels we are currently subscribed to.\n\n  pub.publish('news', 'Hello world!');\n  pub.publish('music', 'Hello again!');\n});\n\nredis.on('message', function (channel, message) {\n  // Receive message Hello world! from channel news\n  // Receive message Hello again! from channel music\n  console.log('Receive message %s from channel %s', message, channel);\n});\n\n// There's also an event called 'messageBuffer', which is the same as 'message' except\n// it returns buffers instead of strings.\nredis.on('messageBuffer', function (channel, message) {\n  // Both `channel` and `message` are buffers.\n});\n```\n\n`PSUBSCRIBE` is also supported in a similar way:\n\n```javascript\nredis.psubscribe('pat?ern', function (err, count) {});\nredis.on('pmessage', function (pattern, channel, message) {});\nredis.on('pmessageBuffer', function (pattern, channel, message) {});\n```\n\nWhen a client issues a SUBSCRIBE or PSUBSCRIBE, that connection is put into a \"subscriber\" mode.\nAt that point, only commands that modify the subscription set are valid.\nWhen the subscription set is empty, the connection is put back into regular mode.\n\nIf you need to send regular commands to Redis while in subscriber mode, just open another connection.\n\n## Handle Binary Data\nArguments can be buffers:\n```javascript\nredis.set('foo', Buffer.from('bar'));\n```\n\nAnd every command has a method that returns a Buffer (by adding a suffix of \"Buffer\" to the command name).\nTo get a buffer instead of a utf8 string:\n\n```javascript\nredis.getBuffer('foo', function (err, result) {\n  // result is a buffer.\n});\n```\n\n## Pipelining\nIf you want to send a batch of commands (e.g. > 5), you can use pipelining to queue\nthe commands in memory and then send them to Redis all at once. This way the performance improves by 50%~300% (See [benchmark section](#benchmark)).\n\n`redis.pipeline()` creates a `Pipeline` instance. You can call any Redis\ncommands on it just like the `Redis` instance. The commands are queued in memory\nand flushed to Redis by calling the `exec` method:\n\n```javascript\nvar pipeline = redis.pipeline();\npipeline.set('foo', 'bar');\npipeline.del('cc');\npipeline.exec(function (err, results) {\n  // `err` is always null, and `results` is an array of responses\n  // corresponding to the sequence of queued commands.\n  // Each response follows the format `[err, result]`.\n});\n\n// You can even chain the commands:\nredis.pipeline().set('foo', 'bar').del('cc').exec(function (err, results) {\n});\n\n// `exec` also returns a Promise:\nvar promise = redis.pipeline().set('foo', 'bar').get('foo').exec();\npromise.then(function (result) {\n  // result === [[null, 'OK'], [null, 'bar']]\n});\n```\n\nEach chained command can also have a callback, which will be invoked when the command\ngets a reply:\n\n```javascript\nredis.pipeline().set('foo', 'bar').get('foo', function (err, result) {\n  // result === 'bar'\n}).exec(function (err, result) {\n  // result[1][1] === 'bar'\n});\n```\n\nIn addition to adding commands to the `pipeline` queue individually, you can also pass an array of commands and arguments to the constructor:\n\n```javascript\nredis.pipeline([\n  ['set', 'foo', 'bar'],\n  ['get', 'foo']\n]).exec(function () { /* ... */ });\n```\n\n`#length` property shows how many commands in the pipeline:\n\n```javascript\nconst length = redis.pipeline().set('foo', 'bar').get('foo').length;\n// length === 2\n```\n\n\n## Transaction\nMost of the time, the transaction commands `multi` & `exec` are used together with pipeline.\nTherefore, when `multi` is called, a `Pipeline` instance is created automatically by default,\nso you can use `multi` just like `pipeline`:\n\n```javascript\nredis.multi().set('foo', 'bar').get('foo').exec(function (err, results) {\n  // results === [[null, 'OK'], [null, 'bar']]\n});\n```\nIf there's a syntax error in the transaction's command chain (e.g. wrong number of arguments, wrong command name, etc),\nthen none of the commands would be executed, and an error is returned:\n\n```javascript\nredis.multi().set('foo').set('foo', 'new value').exec(function (err, results) {\n  // err:\n  //  { [ReplyError: EXECABORT Transaction discarded because of previous errors.]\n  //    name: 'ReplyError',\n  //    message: 'EXECABORT Transaction discarded because of previous errors.',\n  //    command: { name: 'exec', args: [] },\n  //    previousErrors:\n  //     [ { [ReplyError: ERR wrong number of arguments for 'set' command]\n  //         name: 'ReplyError',\n  //         message: 'ERR wrong number of arguments for \\'set\\' command',\n  //         command: [Object] } ] }\n});\n```\n\nIn terms of the interface, `multi` differs from `pipeline` in that when specifying a callback\nto each chained command, the queueing state is passed to the callback instead of the result of the command:\n\n```javascript\nredis.multi().set('foo', 'bar', function (err, result) {\n  // result === 'QUEUED'\n}).exec(/* ... */);\n```\n\nIf you want to use transaction without pipeline, pass `{ pipeline: false }` to `multi`,\nand every command will be sent to Redis immediately without waiting for an `exec` invocation:\n\n```javascript\nredis.multi({ pipeline: false });\nredis.set('foo', 'bar');\nredis.get('foo');\nredis.exec(function (err, result) {\n  // result === [[null, 'OK'], [null, 'bar']]\n});\n```\n\nThe constructor of `multi` also accepts a batch of commands:\n\n```javascript\nredis.multi([\n  ['set', 'foo', 'bar'],\n  ['get', 'foo']\n]).exec(function () { /* ... */ });\n```\n\nInline transactions are supported by pipeline, which means you can group a subset of commands\nin the pipeline into a transaction:\n\n```javascript\nredis.pipeline().get('foo').multi().set('foo', 'bar').get('foo').exec().get('foo').exec();\n```\n\n## Lua Scripting\nioredis supports all of the scripting commands such as `EVAL`, `EVALSHA` and `SCRIPT`.\nHowever, it's tedious to use in real world scenarios since developers have to take\ncare of script caching and to detect when to use `EVAL` and when to use `EVALSHA`.\nioredis expose a `defineCommand` method to make scripting much easier to use:\n\n```javascript\nvar redis = new Redis();\n\n// This will define a command echo:\nredis.defineCommand('echo', {\n  numberOfKeys: 2,\n  lua: 'return {KEYS[1],KEYS[2],ARGV[1],ARGV[2]}'\n});\n\n// Now `echo` can be used just like any other ordinary command,\n// and ioredis will try to use `EVALSHA` internally when possible for better performance.\nredis.echo('k1', 'k2', 'a1', 'a2', function (err, result) {\n  // result === ['k1', 'k2', 'a1', 'a2']\n});\n\n// `echoBuffer` is also defined automatically to return buffers instead of strings:\nredis.echoBuffer('k1', 'k2', 'a1', 'a2', function (err, result) {\n  // result[0] equals to Buffer.from('k1');\n});\n\n// And of course it works with pipeline:\nredis.pipeline().set('foo', 'bar').echo('k1', 'k2', 'a1', 'a2').exec();\n```\n\nIf the number of keys can't be determined when defining a command, you can\nomit the `numberOfKeys` property and pass the number of keys as the first argument\nwhen you call the command:\n\n```javascript\nredis.defineCommand('echoDynamicKeyNumber', {\n  lua: 'return {KEYS[1],KEYS[2],ARGV[1],ARGV[2]}'\n});\n\n// Now you have to pass the number of keys as the first argument every time\n// you invoke the `echoDynamicKeyNumber` command:\nredis.echoDynamicKeyNumber(2, 'k1', 'k2', 'a1', 'a2', function (err, result) {\n  // result === ['k1', 'k2', 'a1', 'a2']\n});\n```\n\n## Transparent Key Prefixing\nThis feature allows you to specify a string that will automatically be prepended\nto all the keys in a command, which makes it easier to manage your key\nnamespaces.\n\n**Warning** This feature won't apply to commands like [KEYS](http://redis.io/commands/KEYS) and [SCAN](http://redis.io/commands/scan) that take patterns rather than actual keys([#239](https://github.com/luin/ioredis/issues/239)),\nand this feature also won't apply to the replies of commands even they are key names ([#325](https://github.com/luin/ioredis/issues/325)).\n\n```javascript\nvar fooRedis = new Redis({ keyPrefix: 'foo:' });\nfooRedis.set('bar', 'baz');  // Actually sends SET foo:bar baz\n\nfooRedis.defineCommand('echo', {\n  numberOfKeys: 2,\n  lua: 'return {KEYS[1],KEYS[2],ARGV[1],ARGV[2]}'\n});\n\n// Works well with pipelining/transaction\nfooRedis.pipeline()\n  // Sends SORT foo:list BY foo:weight_*->fieldname\n  .sort('list', 'BY', 'weight_*->fieldname')\n  // Supports custom commands\n  // Sends EVALSHA xxx foo:k1 foo:k2 a1 a2\n  .echo('k1', 'k2', 'a1', 'a2')\n  .exec()\n```\n\n## Transforming Arguments & Replies\nMost Redis commands take one or more Strings as arguments,\nand replies are sent back as a single String or an Array of Strings. However, sometimes\nyou may want something different. For instance, it would be more convenient if the `HGETALL`\ncommand returns a hash (e.g. `{ key: val1, key2: v2 }`) rather than an array of key values (e.g. `[key1, val1, key2, val2]`).\n\nioredis has a flexible system for transforming arguments and replies. There are two types\nof transformers, argument transformer and reply transformer:\n\n```javascript\nvar Redis = require('ioredis');\n\n// Here's the built-in argument transformer converting\n// hmset('key', { k1: 'v1', k2: 'v2' })\n// or\n// hmset('key', new Map([['k1', 'v1'], ['k2', 'v2']]))\n// into\n// hmset('key', 'k1', 'v1', 'k2', 'v2')\nRedis.Command.setArgumentTransformer('hmset', function (args) {\n  if (args.length === 2) {\n    if (typeof Map !== 'undefined' && args[1] instanceof Map) {\n      // utils is a internal module of ioredis\n      return [args[0]].concat(utils.convertMapToArray(args[1]));\n    }\n    if ( typeof args[1] === 'object' && args[1] !== null) {\n      return [args[0]].concat(utils.convertObjectToArray(args[1]));\n    }\n  }\n  return args;\n});\n\n// Here's the built-in reply transformer converting the HGETALL reply\n// ['k1', 'v1', 'k2', 'v2']\n// into\n// { k1: 'v1', 'k2': 'v2' }\nRedis.Command.setReplyTransformer('hgetall', function (result) {\n  if (Array.isArray(result)) {\n    var obj = {};\n    for (var i = 0; i < result.length; i += 2) {\n      obj[result[i]] = result[i + 1];\n    }\n    return obj;\n  }\n  return result;\n});\n```\n\nThere are three built-in transformers, two argument transformers for `hmset` & `mset` and\na reply transformer for `hgetall`. Transformers for `hmset` and `hgetall` were mentioned\nabove, and the transformer for `mset` is similar to the one for `hmset`:\n\n```javascript\nredis.mset({ k1: 'v1', k2: 'v2' });\nredis.get('k1', function (err, result) {\n  // result === 'v1';\n});\n\nredis.mset(new Map([['k3', 'v3'], ['k4', 'v4']]));\nredis.get('k3', function (err, result) {\n  // result === 'v3';\n});\n```\n\nAnother useful example of a reply transformer is one that changes `hgetall` to return array of arrays instead of objects which avoids a unwanted conversation of hash keys to strings when dealing with binary hash keys:\n\n```javascript\nRedis.Command.setReplyTransformer('hgetall', function (result) {\n  var arr = [];\n  for (var i = 0; i < result.length; i += 2) {\n    arr.push([result[i], result[i + 1]]);\n  }\n  return arr;\n});\nredis.hset('h1', Buffer.from([0x01]), Buffer.from([0x02]));\nredis.hset('h1', Buffer.from([0x03]), Buffer.from([0x04]));\nredis.hgetallBuffer('h1', function (err, result) {\n  // result === [ [ <Buffer 01>, <Buffer 02> ], [ <Buffer 03>, <Buffer 04> ] ];\n});\n```\n\n## Monitor\nRedis supports the MONITOR command,\nwhich lets you see all commands received by the Redis server across all client connections,\nincluding from other client libraries and other computers.\n\nThe `monitor` method returns a monitor instance.\nAfter you send the MONITOR command, no other commands are valid on that connection. ioredis will emit a monitor event for every new monitor message that comes across.\nThe callback for the monitor event takes a timestamp from the Redis server and an array of command arguments.\n\nHere is a simple example:\n\n```javascript\nredis.monitor(function (err, monitor) {\n  monitor.on('monitor', function (time, args, source, database) {\n  });\n});\n```\n\n## Streamify Scanning\nRedis 2.8 added the `SCAN` command to incrementally iterate through the keys in the database. It's different from `KEYS` in that\n`SCAN` only returns a small number of elements each call, so it can be used in production without the downside\nof blocking the server for a long time. However, it requires recording the cursor on the client side each time\nthe `SCAN` command is called in order to iterate through all the keys correctly. Since it's a relatively common use case, ioredis\nprovides a streaming interface for the `SCAN` command to make things much easier. A readable stream can be created by calling `scanStream`:\n\n```javascript\nvar redis = new Redis();\n// Create a readable stream (object mode)\nvar stream = redis.scanStream();\nstream.on('data', function (resultKeys) {\n  // `resultKeys` is an array of strings representing key names.\n  // Note that resultKeys may contain 0 keys, and that it will sometimes\n  // contain duplicates due to SCAN's implementation in Redis.\n  for (var i = 0; i < resultKeys.length; i++) {\n    console.log(resultKeys[i]);\n  }\n});\nstream.on('end', function () {\n  console.log('all keys have been visited');\n});\n```\n\n`scanStream` accepts an option, with which you can specify the `MATCH` pattern and the `COUNT` argument:\n\n```javascript\nvar stream = redis.scanStream({\n  // only returns keys following the pattern of `user:*`\n  match: 'user:*',\n  // returns approximately 100 elements per call\n  count: 100\n});\n```\n\nJust like other commands, `scanStream` has a binary version `scanBufferStream`, which returns an array of buffers. It's useful when\nthe key names are not utf8 strings.\n\nThere are also `hscanStream`, `zscanStream` and `sscanStream` to iterate through elements in a hash, zset and set. The interface of each is\nsimilar to `scanStream` except the first argument is the key name:\n\n```javascript\nvar stream = redis.hscanStream('myhash', {\n  match: 'age:??'\n});\n```\n\nYou can learn more from the [Redis documentation](http://redis.io/commands/scan).\n\n**Useful Tips**\nIt's pretty common that doing an async task in the `data` handler. We'd like the scanning process to be paused until the async task to be finished. `Stream#pause()` and `Stream.resume()` do the trick. For example if we want to migrate data in Redis to MySQL:\n\n```javascript\nvar stream = redis.scanStream();\nstream.on('data', function (resultKeys) {\n  // Pause the stream from scanning more keys until we've migrated the current keys.\n  stream.pause();\n\n  Promise.all(resultKeys.map(migrateKeyToMySQL)).then(() => {\n    // Resume the stream here.\n    stream.resume();\n  });\n});\n\nstream.on('end', function () {\n  console.log('done migration');\n});\n```\n\n## Auto-reconnect\nBy default, ioredis will try to reconnect when the connection to Redis is lost\nexcept when the connection is closed manually by `redis.disconnect()` or `redis.quit()`.\n\nIt's very flexible to control how long to wait to reconnect after disconnection\nusing the `retryStrategy` option:\n\n```javascript\nvar redis = new Redis({\n  // This is the default value of `retryStrategy`\n  retryStrategy: function (times) {\n    var delay = Math.min(times * 50, 2000);\n    return delay;\n  }\n});\n```\n\n`retryStrategy` is a function that will be called when the connection is lost.\nThe argument `times` means this is the nth reconnection being made and\nthe return value represents how long (in ms) to wait to reconnect. When the\nreturn value isn't a number, ioredis will stop trying to reconnect, and the connection\nwill be lost forever if the user doesn't call `redis.connect()` manually.\n\nWhen reconnected, the client will auto subscribe to channels that the previous connection subscribed to.\nThis behavior can be disabled by setting the `autoResubscribe` option to `false`.\n\nAnd if the previous connection has some unfulfilled commands (most likely blocking commands such as `brpop` and `blpop`),\nthe client will resend them when reconnected. This behavior can be disabled by setting the `autoResendUnfulfilledCommands` option to `false`.\n\nBy default, all pending commands will be flushed with an error every 20 retry attempts. That makes sure commands won't wait forever when the connection is down. You can change this behavior by setting `maxRetriesPerRequest`:\n\n```javascript\nvar redis = new Redis({\n  maxRetriesPerRequest: 1\n});\n```\n\nSet maxRetriesPerRequest to `null` to disable this behavior, and every command will wait forever until the connection is alive again (which is the default behavior before ioredis v4).\n\n### Reconnect on error\n\nBesides auto-reconnect when the connection is closed, ioredis supports reconnecting on the specified errors by the `reconnectOnError` option. Here's an example that will reconnect when receiving `READONLY` error:\n\n```javascript\nvar redis = new Redis({\n  reconnectOnError: function (err) {\n    var targetError = 'READONLY';\n    if (err.message.slice(0, targetError.length) === targetError) {\n      // Only reconnect when the error starts with \"READONLY\"\n      return true; // or `return 1;`\n    }\n  }\n});\n```\n\nThis feature is useful when using Amazon ElastiCache. Once failover happens, Amazon ElastiCache will switch the master we currently connected with to a slave, leading to the following writes fails with the error `READONLY`. Using `reconnectOnError`, we can force the connection to reconnect on this error in order to connect to the new master.\n\nFurthermore, if the `reconnectOnError` returns `2`, ioredis will resend the failed command after reconnecting.\n\n## Connection Events\nThe Redis instance will emit some events about the state of the connection to the Redis server.\n\nEvent    | Description\n:------------- | :-------------\nconnect  | emits when a connection is established to the Redis server.\nready    | If `enableReadyCheck` is `true`, client will emit `ready` when the server reports that it is ready to receive commands (e.g. finish loading data from disk).<br>Otherwise, `ready` will be emitted immediately right after the `connect` event.\nerror    | emits when an error occurs while connecting.<br>However, ioredis emits all `error` events silently (only emits when there's at least one listener) so that your application won't crash if you're not listening to the `error` event.\nclose    | emits when an established Redis server connection has closed.\nreconnecting | emits after `close` when a reconnection will be made. The argument of the event is the time (in ms) before reconnecting.\nend     | emits after `close` when no more reconnections will be made, or the connection is failed to establish.\n\nYou can also check out the `Redis#status` property to get the current connection status.\n\nBesides the above connection events, there are several other custom events:\n\nEvent    | Description\n:------------- | :-------------\nselect   | emits when the database changed. The argument is the new db number.\n\n## Offline Queue\nWhen a command can't be processed by Redis (being sent before the `ready` event), by default, it's added to the offline queue and will be\nexecuted when it can be processed. You can disable this feature by setting the `enableOfflineQueue`\noption to `false`:\n\n```javascript\nvar redis = new Redis({ enableOfflineQueue: false });\n```\n\n## TLS Options\nRedis doesn't support TLS natively, however if the redis server you want to connect to is hosted behind a TLS proxy (e.g. [stunnel](https://www.stunnel.org/)) or is offered by a PaaS service that supports TLS connection (e.g. [Redis Labs](https://redislabs.com/)), you can set the `tls` option:\n\n```javascript\nvar redis = new Redis({\n  host: 'localhost',\n  tls: {\n    // Refer to `tls.connect()` section in\n    // https://nodejs.org/api/tls.html\n    // for all supported options\n    ca: fs.readFileSync('cert.pem')\n  }\n});\n```\n\n<hr>\n\n## Sentinel\nioredis supports Sentinel out of the box. It works transparently as all features that work when\nyou connect to a single node also work when you connect to a sentinel group. Make sure to run Redis >= 2.8.12 if you want to use this feature. Sentinels have a default port of 26379.\n\nTo connect using Sentinel, use:\n\n```javascript\nvar redis = new Redis({\n  sentinels: [{ host: 'localhost', port: 26379 }, { host: 'localhost', port: 26380 }],\n  name: 'mymaster'\n});\n\nredis.set('foo', 'bar');\n```\n\nThe arguments passed to the constructor are different from the ones you use to connect to a single node, where:\n\n* `name` identifies a group of Redis instances composed of a master and one or more slaves (`mymaster` in the example);\n* `sentinelPassword` (optional) password for Sentinel instances.\n* `sentinels` are a list of sentinels to connect to. The list does not need to enumerate all your sentinel instances, but a few so that if one is down the client will try the next one.\n* `role` (optional) with a value of `slave` will return a random slave from the Sentinel group.\n* `preferredSlaves` (optional) can be used to prefer a particular slave or set of slaves based on priority. It accepts a function or array.\n\nioredis **guarantees** that the node you connected to is always a master even after a failover. When a failover happens, instead of trying to reconnect to the failed node (which will be demoted to slave when it's available again), ioredis will ask sentinels for the new master node and connect to it. All commands sent during the failover are queued and will be executed when the new connection is established so that none of the commands will be lost.\n\nIt's possible to connect to a slave instead of a master by specifying the option `role` with the value of `slave` and ioredis will try to connect to a random slave of the specified master, with the guarantee that the connected node is always a slave. If the current node is promoted to master due to a failover, ioredis will disconnect from it and ask the sentinels for another slave node to connect to.\n\nIf you specify the option `preferredSlaves` along with `role: 'slave'` ioredis will attempt to use this value when selecting the slave from the pool of available slaves. The value of `preferredSlaves` should either be a function that accepts an array of avaiable slaves and returns a single result, or an array of slave values priorities by the lowest `prio` value first with a default value of `1`.\n\n```javascript\n// available slaves format\nvar availableSlaves = [{ ip: '127.0.0.1', port: '31231', flags: 'slave' }];\n\n// preferredSlaves array format\nvar preferredSlaves = [\n  { ip: '127.0.0.1', port: '31231', prio: 1 },\n  { ip: '127.0.0.1', port: '31232', prio: 2 }\n];\n\n// preferredSlaves function format\npreferredSlaves = function(availableSlaves) {\n  for (var i = 0; i < availableSlaves.length; i++) {\n    var slave = availableSlaves[i];\n    if (slave.ip === '127.0.0.1') {\n      if (slave.port === '31234') {\n        return slave;\n      }\n    }\n  }\n  // if no preferred slaves are available a random one is used\n  return false;\n};\n\nvar redis = new Redis({\n  sentinels: [{ host: '127.0.0.1', port: 26379 }, { host: '127.0.0.1', port: 26380 }],\n  name: 'mymaster',\n  role: 'slave',\n  preferredSlaves: preferredSlaves\n});\n```\n\nBesides the `retryStrategy` option, there's also a `sentinelRetryStrategy` in Sentinel mode which will be invoked when all the sentinel nodes are unreachable during connecting. If `sentinelRetryStrategy` returns a valid delay time, ioredis will try to reconnect from scratch. The default value of `sentinelRetryStrategy` is:\n\n```javascript\nfunction (times) {\n  var delay = Math.min(times * 10, 1000);\n  return delay;\n}\n```\n\n## Cluster\nRedis Cluster provides a way to run a Redis installation where data is automatically sharded across multiple Redis nodes.\nYou can connect to a Redis Cluster like this:\n\n```javascript\nvar Redis = require('ioredis');\n\nvar cluster = new Redis.Cluster([{\n  port: 6380,\n  host: '127.0.0.1'\n}, {\n  port: 6381,\n  host: '127.0.0.1'\n}]);\n\ncluster.set('foo', 'bar');\ncluster.get('foo', function (err, res) {\n  // res === 'bar'\n});\n```\n\n`Cluster` constructor accepts two arguments, where:\n\n0. The first argument is a list of nodes of the cluster you want to connect to.\nJust like Sentinel, the list does not need to enumerate all your cluster nodes,\nbut a few so that if one is unreachable the client will try the next one, and the client will discover other nodes automatically when at least one node is connected.\n0. The second argument is the options, where:\n\n    * `clusterRetryStrategy`: When none of the startup nodes are reachable, `clusterRetryStrategy` will be invoked. When a number is returned,\n    ioredis will try to reconnect to the startup nodes from scratch after the specified delay (in ms). Otherwise, an error of \"None of startup nodes is available\" will be returned.\n    The default value of this option is:\n\n        ```javascript\n        function (times) {\n          var delay = Math.min(100 + times * 2, 2000);\n          return delay;\n        }\n        ```\n\n        It's possible to modify the `startupNodes` property in order to switch to another set of nodes here:\n\n        ```javascript\n        function (times) {\n          this.startupNodes = [{ port: 6790, host: '127.0.0.1' }];\n          return Math.min(100 + times * 2, 2000);\n        }\n        ```\n\n    * `enableOfflineQueue`: Similar to the `enableOfflineQueue` option of `Redis` class.\n    * `enableReadyCheck`: When enabled, \"ready\" event will only be emitted when `CLUSTER INFO` command\n    reporting the cluster is ready for handling commands. Otherwise, it will be emitted immediately after \"connect\" is emitted.\n    * `scaleReads`: Config where to send the read queries. See below for more details.\n    * `maxRedirections`: When a cluster related error (e.g. `MOVED`, `ASK` and `CLUSTERDOWN` etc.) is received, the client will redirect the\n    command to another node. This option limits the max redirections allowed when sending a command. The default value is `16`.\n    * `retryDelayOnFailover`: If the target node is disconnected when sending a command,\n    ioredis will retry after the specified delay. The default value is `100`. You should make sure `retryDelayOnFailover * maxRedirections > cluster-node-timeout`\n    to insure that no command will fail during a failover.\n    * `retryDelayOnClusterDown`: When a cluster is down, all commands will be rejected with the error of `CLUSTERDOWN`. If this option is a number (by default, it is `100`), the client\n    will resend the commands after the specified time (in ms).\n    * `retryDelayOnTryAgain`: If this option is a number (by default, it is `100`), the client\n    will resend the commands rejected with `TRYAGAIN` error after the specified time (in ms).\n    * `redisOptions`: Default options passed to the constructor of `Redis` when connecting to a node.\n    * `slotsRefreshTimeout`: Milliseconds before a timeout occurs while refreshing slots from the cluster (default `1000`)\n    * `slotsRefreshInterval`: Milliseconds between every automatic slots refresh (default `5000`)\n\n### Read-write splitting\n\nA typical redis cluster contains three or more masters and several slaves for each master. It's possible to scale out redis cluster by sending read queries to slaves and write queries to masters by setting the `scaleReads` option.\n\n`scaleReads` is \"master\" by default, which means ioredis will never send any queries to slaves. There are other three available options:\n\n1. \"all\": Send write queries to masters and read queries to masters or slaves randomly.\n2. \"slave\": Send write queries to masters and read queries to slaves.\n3. a custom `function(nodes, command): node`: Will choose the custom function to select to which node to send read queries (write queries keep being sent to master). The first node in `nodes` is always the master serving the relevant slots. If the function returns an array of nodes, a random node of that list will be selected.\n\nFor example:\n\n```javascript\nvar cluster = new Redis.Cluster([/* nodes */], {\n  scaleReads: 'slave'\n});\ncluster.set('foo', 'bar'); // This query will be sent to one of the masters.\ncluster.get('foo', function (err, res) {\n  // This query will be sent to one of the slaves.\n});\n```\n\n**NB** In the code snippet above, the `res` may not be equal to \"bar\" because of the lag of replication between the master and slaves.\n\n### Running commands to multiple nodes\n\nEvery command will be sent to exactly one node. For commands containing keys, (e.g. `GET`, `SET` and `HGETALL`), ioredis sends them to the node that serving the keys, and for other commands not containing keys, (e.g. `INFO`, `KEYS` and `FLUSHDB`), ioredis sends them to a random node.\n\nSometimes you may want to send a command to multiple nodes (masters or slaves) of the cluster, you can get the nodes via `Cluster#nodes()` method.\n\n`Cluster#nodes()` accepts a parameter role, which can be \"master\", \"slave\" and \"all\" (default), and returns an array of `Redis` instance. For example:\n\n```javascript\n// Send `FLUSHDB` command to all slaves:\nvar slaves = cluster.nodes('slave');\nPromise.all(slaves.map(function (node) {\n  return node.flushdb();\n}));\n\n// Get keys of all the masters:\nvar masters = cluster.nodes('master');\nPromise.all(masters.map(function (node) {\n  return node.keys();\n})).then(function (keys) {\n  // keys: [['key1', 'key2'], ['key3', 'key4']]\n});\n```\n\n### NAT Mapping\nSometimes the cluster is hosted within a internal network that can only be accessed via a NAT (Network Address Translation) instance. See [Accessing ElastiCache from outside AWS](https://docs.aws.amazon.com/AmazonElastiCache/latest/red-ug/accessing-elasticache.html) as an example.\n\nYou can specify nat mapping rules via `natMap` option:\n\n```javascript\nconst cluster = new Redis.Cluster([{\n  host: '203.0.113.73',\n  port: 30001\n}], {\n  natMap: {\n    '10.0.1.230:30001': {host: '203.0.113.73', port: 30001},\n    '10.0.1.231:30001': {host: '203.0.113.73', port: 30002},\n    '10.0.1.232:30001': {host: '203.0.113.73', port: 30003}\n  }\n})\n```\n\nThis option is also useful when the cluster is running inside a Docker container.\n\n### Transaction and pipeline in Cluster mode\nAlmost all features that are supported by `Redis` are also supported by `Redis.Cluster`, e.g. custom commands, transaction and pipeline.\nHowever there are some differences when using transaction and pipeline in Cluster mode:\n\n0. All keys in a pipeline should belong to the same slot since ioredis sends all commands in a pipeline to the same node.\n0. You can't use `multi` without pipeline (aka `cluster.multi({ pipeline: false })`). This is because when you call `cluster.multi({ pipeline: false })`, ioredis doesn't know which node the `multi` command should be sent to.\n0. Chaining custom commands in the pipeline is not supported in Cluster mode.\n\nWhen any commands in a pipeline receives a `MOVED` or `ASK` error, ioredis will resend the whole pipeline to the specified node automatically if all of the following conditions are satisfied:\n\n0. All errors received in the pipeline are the same. For example, we won't resend the pipeline if we got two `MOVED` errors pointing to different nodes.\n0. All commands executed successfully are readonly commands. This makes sure that resending the pipeline won't have side effects.\n\n### Pub/Sub\nPub/Sub in cluster mode works exactly as the same as in standalone mode. Internally, when a node of the cluster receives a message, it will broadcast the message to the other nodes. ioredis makes sure that each message will only be received once by strictly subscribing one node at the same time.\n\n```javascript\nvar nodes = [/* nodes */];\nvar pub = new Redis.Cluster(nodes);\nvar sub = new Redis.Cluster(nodes);\nsub.on('message', function (channel, message) {\n  console.log(channel, message);\n});\n\nsub.subscribe('news', function () {\n  pub.publish('news', 'highlights');\n});\n```\n\n### Events\n\nEvent    | Description\n:------------- | :-------------\nconnect  | emits when a connection is established to the Redis server.\nready    | emits when `CLUSTER INFO` reporting the cluster is able to receive commands (if `enableReadyCheck` is `true`) or immediately after `connect` event (if `enableReadyCheck` is false).\nerror    | emits when an error occurs while connecting with a property of `lastNodeError` representing the last node error received. This event is emitted silently (only emitting if there's at least one listener).\nclose    | emits when an established Redis server connection has closed.\nreconnecting | emits after `close` when a reconnection will be made. The argument of the event is the time (in ms) before reconnecting.\nend     | emits after `close` when no more reconnections will be made.\n+node   | emits when a new node is connected.\n-node   | emits when a node is disconnected.\nnode error | emits when an error occurs when connecting to a node. The second argument indicates the address of the node.\n\n### Password\nSetting the `password` option to access password-protected clusters:\n\n```javascript\nvar Redis = require('ioredis');\nvar cluster = new Redis.Cluster(nodes, {\n  redisOptions: {\n    password: 'your-cluster-password'\n  }\n});\n```\n\nIf some of nodes in the cluster using a different password, you should specify them in the first parameter:\n\n```javascript\nvar Redis = require('ioredis');\nvar cluster = new Redis.Cluster([\n  // Use password \"password-for-30001\" for 30001\n  { port: 30001, password: 'password-for-30001'},\n  // Don't use password when accessing 30002\n  { port: 30002, password: null }\n  // Other nodes will use \"fallback-password\"\n], {\n  redisOptions: {\n    password: 'fallback-password'\n  }\n});\n```\n\n<hr>\n\n# Error Handling\nAll the errors returned by the Redis server are instances of `ReplyError`, which can be accessed via `Redis`:\n\n```javascript\nvar Redis = require('ioredis');\nvar redis = new Redis();\n// This command causes a reply error since the SET command requires two arguments.\nredis.set('foo', function (err) {\n  err instanceof Redis.ReplyError\n});\n```\n\nThis is the error stack of the `ReplyError`:\n\n```\nReplyError: ERR wrong number of arguments for 'set' command\n    at ReplyParser._parseResult (/app/node_modules/ioredis/lib/parsers/javascript.js:60:14)\n    at ReplyParser.execute (/app/node_modules/ioredis/lib/parsers/javascript.js:178:20)\n    at Socket.<anonymous> (/app/node_modules/ioredis/lib/redis/event_handler.js:99:22)\n    at Socket.emit (events.js:97:17)\n    at readableAddChunk (_stream_readable.js:143:16)\n    at Socket.Readable.push (_stream_readable.js:106:10)\n    at TCP.onread (net.js:509:20)\n```\n\nBy default, the error stack doesn't make any sense because the whole stack happens in the ioredis\nmodule itself, not in your code. So it's not easy to find out where the error happens in your code.\nioredis provides an option `showFriendlyErrorStack` to solve the problem. When you enable\n`showFriendlyErrorStack`, ioredis will optimize the error stack for you:\n\n```javascript\nvar Redis = require('ioredis');\nvar redis = new Redis({ showFriendlyErrorStack: true });\nredis.set('foo');\n```\n\nAnd the output will be:\n\n```\nReplyError: ERR wrong number of arguments for 'set' command\n    at Object.<anonymous> (/app/index.js:3:7)\n    at Module._compile (module.js:446:26)\n    at Object.Module._extensions..js (module.js:464:10)\n    at Module.load (module.js:341:32)\n    at Function.Module._load (module.js:296:12)\n    at Function.Module.runMain (module.js:487:10)\n    at startup (node.js:111:16)\n    at node.js:799:3\n```\n\nThis time the stack tells you that the error happens on the third line in your code. Pretty sweet!\nHowever, it would decrease the performance significantly to optimize the error stack. So by\ndefault, this option is disabled and can only be used for debugging purposes. You **shouldn't** use this feature in a production environment.\n\n# Plugging in your own Promises Library\nIf you're an advanced user, you may want to plug in your own promise library like [bluebird](https://www.npmjs.com/package/bluebird). Just set Redis.Promise to your favorite ES6-style promise constructor and ioredis will use it.\n\n```javascript\nconst Redis = require('ioredis')\nRedis.Promise = require('bluebird')\n\nconst redis = new Redis()\n\n// Use bluebird\nassert.equal(redis.get().constructor, require('bluebird'))\n\n// You can change the Promise implementation at any time:\nRedis.Promise = global.Promise\nassert.equal(redis.get().constructor, global.Promise)\n```\n\n\n# Running tests\n\nStart a Redis server on 127.0.0.1:6379, and then:\n\n```shell\n$ npm test\n```\n\n`FLUSH ALL` will be invoked after each test, so make sure there's no valuable data in it before running tests.\n\nIf your testing environment does not let you spin up a Redis server [ioredis-mock](https://github.com/stipsan/ioredis-mock) is a drop-in replacement you can use in your tests. It aims to behave identically to ioredis connected to a Redis server so that your integration tests is easier to write and of better quality.\n\n# Debug\n\nYou can set the `DEBUG` env to `ioredis:*` to print debug info:\n\n```shell\n$ DEBUG=ioredis:* node app.js\n```\n\n# Consolidation: It's time for celebration\n\nRight now there are two great redis clients around and both have some advantages above each other. We speak about [node_redis](https://github.com/NodeRedis/node_redis) and ioredis. So after talking to each other about how we could improve in working together we (that is [@BridgeAR](https://github.com/BridgeAR) and [@luin](https://github.com/luin)) decided to work towards a single library on the long run. But step by step.\n\nFirst of all, we want to split small parts of our libraries into others so that we're both able to use the same code. Those libraries are going to be maintained under the NodeRedis organization. This is going to reduce the maintance overhead, allows others to use the very same code, if they need it and it's way easier for others to contribute to both libraries.\n\nWe're very happy about this step towards working together as we both want to give you the best redis experience possible.\n\nIf you want to join our cause by help maintaining something, please don't hesitate to contact either one of us.\n\n# Join in!\n\nI'm happy to receive bug reports, fixes, documentation enhancements, and any other improvements.\n\nAnd since I'm not a native English speaker, if you find any grammar mistakes in the documentation, please also let me know. :)\n\n# Contributors\n\nThis project exists thanks to all the people who contribute:\n\n<a href=\"https://github.com/luin/ioredis/graphs/contributors\"><img src=\"https://opencollective.com/ioredis/contributors.svg?width=890&showBtn=false\" /></a>\n\n# License\n\nMIT\n\n\n[![FOSSA Status](https://app.fossa.io/api/projects/git%2Bgithub.com%2Fluin%2Fioredis.svg?type=large)](https://app.fossa.io/projects/git%2Bgithub.com%2Fluin%2Fioredis?ref=badge_large)\n","readmeFilename":"README.md","bugs":{"url":"https://github.com/luin/ioredis/issues"},"homepage":"https://github.com/luin/ioredis#readme","_id":"ioredis@4.10.3","_nodeVersion":"10.16.0","_npmVersion":"6.9.0","dist":{"integrity":"sha512-/dWhu5epjX1hFUjjcNHnz1bOYeEVL03hqQmYaKTq22NP3Zrns1eFk27NAEUHMcl8/GbwiksnP4DJ1vBN8Cg1Yg==","shasum":"4296a6cd4384e278e17348e7f0d29b900901759b","tarball":"https://registry.npmjs.org/ioredis/-/ioredis-4.10.3.tgz","fileCount":35,"unpackedSize":225617,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJc/BmkCRA9TVsSAnZWagAAXswP/0bK3iE+5/OE9+UncOUt\nZCOW1wBqPXJwd9FmrwCx8u/Vm0QuT+SXQStaCiN/ztnwl5Ekl2Rjejfe2h4q\n3mD0FHHuhUEcmFAKbMeZd5tVkcCh+Mbosb/F4FROTX5+sG9i2wthqW43xQ8G\nmBGJQomIP5YC2z/IGbK8otdp+7yhdkG20T64XO65jeWnEj1l7DbIDDvyIo50\nbVOarvCefNzL8WYA2XBA5aNfgVRVHNtrdDmYSOT+021twSNBLe/SSQZVDODc\n5Yhg3zc0xHqZDwqa4YDx0w66MpbioC/RKjxBQtc+TETJm9NrytejhZ6elkUy\no4TpsZe56aGPAsHYZVv/gJpbAwzF9M9GO7F76sMAUgNMkr2ROvc5mbVwVt6W\nJLoSrVHG+SlUXf+M3V0UBv5A0kG+Cco3Yf+V9CsKtZgZOp73UxoijXNFKcQ4\newPDmgzqzHdXLQ4QB0TLTeWNAHoTtOhtnnj2bG3s2Q0GTG9Q0naAeYEkFbab\n/SmARJg+SzZmK9D10owF0OXA7Ts5E4I3bJaapM0MqPug7a+u+WKptxiZXC9y\nOCLWDBLd0c+yg1CUOs2RDY5kHyeubX4DBRPPCTNHcdZUeAaCcbGcI9SPrMBx\nl8KUFmWQZiAB28ebEToluYkYpbn20fGYEZ/1YVkH5WEcNVwMW4O7z8NLmtyj\nM3cW\r\n=0QOi\r\n-----END PGP SIGNATURE-----\r\n"},"maintainers":[{"email":"ioredis-robot@zihua.li","name":"ioredis-robot"},{"email":"i@zihua.li","name":"luin"}],"_npmUser":{"name":"luin","email":"i@zihua.li"},"directories":{},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/ioredis_4.10.3_1560025507821_0.623327831030148"},"_hasShrinkwrap":false},"4.10.4":{"name":"ioredis","version":"4.10.4","description":"A robust, performance-focused and full-featured Redis client for Node.js.","main":"built/index.js","scripts":{"test":"NODE_ENV=test mocha","test:cov":"NODE_ENV=test node ./node_modules/istanbul/lib/cli.js cover --preserve-comments ./node_modules/mocha/bin/_mocha -- -r ts-node/register -R spec --exit","build":"rm -rf built && tsc","prepublishOnly":"npm run build && npm test","bench":"matcha benchmarks/*.js","semantic-release":"semantic-release"},"repository":{"type":"git","url":"git://github.com/luin/ioredis.git"},"keywords":["redis","cluster","sentinel","pipelining"],"author":{"name":"luin","email":"i@zihua.li","url":"http://zihua.li"},"license":"MIT","dependencies":{"cluster-key-slot":"^1.0.6","debug":"^4.1.1","denque":"^1.1.0","lodash.defaults":"^4.2.0","lodash.flatten":"^4.4.0","redis-commands":"1.5.0","redis-errors":"^1.2.0","redis-parser":"^3.0.0","standard-as-callback":"^2.0.1"},"devDependencies":{"@semantic-release/changelog":"^3.0.4","@semantic-release/git":"^7.0.12","@types/node":"^12.0.2","@types/redis-errors":"1.2.0","bluebird":"^3.5.4","chai":"^4.2.0","cz-conventional-changelog":"^2.0.0","istanbul":"^0.4.5","mocha":"^5.0.0","server-destroy":"^1.0.1","sinon":"^7.3.2","ts-node":"^8.1.0","typescript":"^3.4.5"},"engines":{"node":">=6"},"config":{"commitizen":{"path":"./node_modules/cz-conventional-changelog"}},"gitHead":"7e656193c5b7bf3eea06492c08aa392afe900685","readme":"[![ioredis](https://cdn.jsdelivr.net/gh/luin/ioredis@b5e8c74/logo.svg)](https://github.com/luin/ioredis)\n\n[![Build Status](https://travis-ci.org/luin/ioredis.svg?branch=master)](https://travis-ci.org/luin/ioredis)\n[![Test Coverage](https://codeclimate.com/github/luin/ioredis/badges/coverage.svg)](https://codeclimate.com/github/luin/ioredis)\n[![Join the chat at https://gitter.im/luin/ioredis](https://badges.gitter.im/Join%20Chat.svg)](https://gitter.im/luin/ioredis?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge)\n[![Commitizen friendly](https://img.shields.io/badge/commitizen-friendly-brightgreen.svg)](http://commitizen.github.io/cz-cli/)\n[![semantic-release](https://img.shields.io/badge/%20%20%F0%9F%93%A6%F0%9F%9A%80-semantic--release-e10079.svg)](https://github.com/semantic-release/semantic-release)\n[![npm latest version](https://img.shields.io/npm/v/ioredis/latest.svg)](https://www.npmjs.com/package/ioredis)\n[![npm next version](https://img.shields.io/npm/v/ioredis/next.svg)](https://www.npmjs.com/package/ioredis)\n<img alt=\"\" src=\"\">\n\nA robust, performance-focused and full-featured [Redis](http://redis.io) client for [Node.js](https://nodejs.org).\n\nSupports Redis >= 2.6.12 and (Node.js >= 6).\n\n# Features\nioredis is a robust, full-featured Redis client that is\nused in the world's biggest online commerce company [Alibaba](http://www.alibaba.com/) and many other awesome companies.\n\n0. Full-featured. It supports [Cluster](http://redis.io/topics/cluster-tutorial), [Sentinel](http://redis.io/topics/sentinel), [Pipelining](http://redis.io/topics/pipelining) and of course [Lua scripting](http://redis.io/commands/eval) & [Pub/Sub](http://redis.io/topics/pubsub) (with the support of binary messages).\n0. High performance.\n0. Delightful API. It works with Node callbacks and Native promises.\n0. Transformation of command arguments and replies.\n0. Transparent key prefixing.\n0. Abstraction for Lua scripting, allowing you to define custom commands.\n0. Support for binary data.\n0. Support for TLS.\n0. Support for offline queue and ready checking.\n0. Support for ES6 types, such as `Map` and `Set`.\n0. Support for GEO commands (Redis 3.2 Unstable).\n0. Sophisticated error handling strategy.\n0. Support for NAT mapping.\n\n# Links\n* [API Documentation](API.md)\n* [Changelog](Changelog.md)\n* [Migrating from node_redis](https://github.com/luin/ioredis/wiki/Migrating-from-node_redis)\n* [Error Handling](#error-handling)\n\n## Become a Sponsor to Support ioredis's Development\nOpen source is hard and time-consuming. If you want to invest in ioredis's future you can become a sponsor and make us spend more time on this library's improvements and new features.\n\n<a href=\"https://opencollective.com/ioredis\"><img src=\"https://opencollective.com/ioredis/tiers/sponsor.svg?avatarHeight=36\"></a>\n\nThank you for using ioredis :-)\n\n<hr>\n<a href=\"https://itunes.apple.com/app/medis-gui-for-redis/id1063631769\"><img align=\"right\" src=\"medis.png\" alt=\"Download on the App Store\"></a>\n\n\n### Advertisement\n\nLooking for a Redis GUI manager for OS X, Windows and Linux? Here's [Medis](https://itunes.apple.com/us/app/medis-gui-for-redis/id1063631769)!\n\nMedis is an open-sourced, beautiful, easy-to-use Redis GUI management application.\n\nMedis starts with all the basic features you need:\n\n* Keys viewing/editing\n* SSH Tunnel for connecting with remote servers\n* Terminal for executing custom commands\n* JSON/MessagePack format viewing/editing and built-in highlighting/validator\n* And other awesome features...\n\n[Medis is open sourced on GitHub](https://github.com/luin/medis)\n\n<hr>\n\n# Quick Start\n\n## Install\n```shell\n$ npm install ioredis\n```\n\n## Basic Usage\n\n```javascript\nvar Redis = require('ioredis');\nvar redis = new Redis();\n\nredis.set('foo', 'bar');\nredis.get('foo', function (err, result) {\n  console.log(result);\n});\nredis.del('foo');\n\n// Or using a promise if the last argument isn't a function\nredis.get('foo').then(function (result) {\n  console.log(result);\n});\n\n// Arguments to commands are flattened, so the following are the same:\nredis.sadd('set', 1, 3, 5, 7);\nredis.sadd('set', [1, 3, 5, 7]);\n\n// All arguments are passed directly to the redis server:\nredis.set('key', 100, 'EX', 10);\n```\n\nSee the `examples/` folder for more examples.\n\n## Connect to Redis\nWhen a new `Redis` instance is created,\na connection to Redis will be created at the same time.\nYou can specify which Redis to connect to by:\n\n```javascript\nnew Redis()       // Connect to 127.0.0.1:6379\nnew Redis(6380)   // 127.0.0.1:6380\nnew Redis(6379, '192.168.1.1')        // 192.168.1.1:6379\nnew Redis('/tmp/redis.sock')\nnew Redis({\n  port: 6379,          // Redis port\n  host: '127.0.0.1',   // Redis host\n  family: 4,           // 4 (IPv4) or 6 (IPv6)\n  password: 'auth',\n  db: 0\n})\n```\n\nYou can also specify connection options as a [`redis://` URL](http://www.iana.org/assignments/uri-schemes/prov/redis):\n\n```javascript\n// Connect to 127.0.0.1:6380, db 4, using password \"authpassword\":\nnew Redis('redis://:authpassword@127.0.0.1:6380/4')\n```\n\nSee [API Documentation](API.md#new_Redis) for all available options.\n\n## Pub/Sub\n\nHere is a simple example of the API for publish/subscribe.\nThe following program opens two client connections.\nIt subscribes to a channel with one connection\nand publishes to that channel with the other:\n\n```javascript\nvar Redis = require('ioredis');\nvar redis = new Redis();\nvar pub = new Redis();\nredis.subscribe('news', 'music', function (err, count) {\n  // Now we are subscribed to both the 'news' and 'music' channels.\n  // `count` represents the number of channels we are currently subscribed to.\n\n  pub.publish('news', 'Hello world!');\n  pub.publish('music', 'Hello again!');\n});\n\nredis.on('message', function (channel, message) {\n  // Receive message Hello world! from channel news\n  // Receive message Hello again! from channel music\n  console.log('Receive message %s from channel %s', message, channel);\n});\n\n// There's also an event called 'messageBuffer', which is the same as 'message' except\n// it returns buffers instead of strings.\nredis.on('messageBuffer', function (channel, message) {\n  // Both `channel` and `message` are buffers.\n});\n```\n\n`PSUBSCRIBE` is also supported in a similar way:\n\n```javascript\nredis.psubscribe('pat?ern', function (err, count) {});\nredis.on('pmessage', function (pattern, channel, message) {});\nredis.on('pmessageBuffer', function (pattern, channel, message) {});\n```\n\nWhen a client issues a SUBSCRIBE or PSUBSCRIBE, that connection is put into a \"subscriber\" mode.\nAt that point, only commands that modify the subscription set are valid.\nWhen the subscription set is empty, the connection is put back into regular mode.\n\nIf you need to send regular commands to Redis while in subscriber mode, just open another connection.\n\n## Handle Binary Data\nArguments can be buffers:\n```javascript\nredis.set('foo', Buffer.from('bar'));\n```\n\nAnd every command has a method that returns a Buffer (by adding a suffix of \"Buffer\" to the command name).\nTo get a buffer instead of a utf8 string:\n\n```javascript\nredis.getBuffer('foo', function (err, result) {\n  // result is a buffer.\n});\n```\n\n## Pipelining\nIf you want to send a batch of commands (e.g. > 5), you can use pipelining to queue\nthe commands in memory and then send them to Redis all at once. This way the performance improves by 50%~300% (See [benchmark section](#benchmark)).\n\n`redis.pipeline()` creates a `Pipeline` instance. You can call any Redis\ncommands on it just like the `Redis` instance. The commands are queued in memory\nand flushed to Redis by calling the `exec` method:\n\n```javascript\nvar pipeline = redis.pipeline();\npipeline.set('foo', 'bar');\npipeline.del('cc');\npipeline.exec(function (err, results) {\n  // `err` is always null, and `results` is an array of responses\n  // corresponding to the sequence of queued commands.\n  // Each response follows the format `[err, result]`.\n});\n\n// You can even chain the commands:\nredis.pipeline().set('foo', 'bar').del('cc').exec(function (err, results) {\n});\n\n// `exec` also returns a Promise:\nvar promise = redis.pipeline().set('foo', 'bar').get('foo').exec();\npromise.then(function (result) {\n  // result === [[null, 'OK'], [null, 'bar']]\n});\n```\n\nEach chained command can also have a callback, which will be invoked when the command\ngets a reply:\n\n```javascript\nredis.pipeline().set('foo', 'bar').get('foo', function (err, result) {\n  // result === 'bar'\n}).exec(function (err, result) {\n  // result[1][1] === 'bar'\n});\n```\n\nIn addition to adding commands to the `pipeline` queue individually, you can also pass an array of commands and arguments to the constructor:\n\n```javascript\nredis.pipeline([\n  ['set', 'foo', 'bar'],\n  ['get', 'foo']\n]).exec(function () { /* ... */ });\n```\n\n`#length` property shows how many commands in the pipeline:\n\n```javascript\nconst length = redis.pipeline().set('foo', 'bar').get('foo').length;\n// length === 2\n```\n\n\n## Transaction\nMost of the time, the transaction commands `multi` & `exec` are used together with pipeline.\nTherefore, when `multi` is called, a `Pipeline` instance is created automatically by default,\nso you can use `multi` just like `pipeline`:\n\n```javascript\nredis.multi().set('foo', 'bar').get('foo').exec(function (err, results) {\n  // results === [[null, 'OK'], [null, 'bar']]\n});\n```\nIf there's a syntax error in the transaction's command chain (e.g. wrong number of arguments, wrong command name, etc),\nthen none of the commands would be executed, and an error is returned:\n\n```javascript\nredis.multi().set('foo').set('foo', 'new value').exec(function (err, results) {\n  // err:\n  //  { [ReplyError: EXECABORT Transaction discarded because of previous errors.]\n  //    name: 'ReplyError',\n  //    message: 'EXECABORT Transaction discarded because of previous errors.',\n  //    command: { name: 'exec', args: [] },\n  //    previousErrors:\n  //     [ { [ReplyError: ERR wrong number of arguments for 'set' command]\n  //         name: 'ReplyError',\n  //         message: 'ERR wrong number of arguments for \\'set\\' command',\n  //         command: [Object] } ] }\n});\n```\n\nIn terms of the interface, `multi` differs from `pipeline` in that when specifying a callback\nto each chained command, the queueing state is passed to the callback instead of the result of the command:\n\n```javascript\nredis.multi().set('foo', 'bar', function (err, result) {\n  // result === 'QUEUED'\n}).exec(/* ... */);\n```\n\nIf you want to use transaction without pipeline, pass `{ pipeline: false }` to `multi`,\nand every command will be sent to Redis immediately without waiting for an `exec` invocation:\n\n```javascript\nredis.multi({ pipeline: false });\nredis.set('foo', 'bar');\nredis.get('foo');\nredis.exec(function (err, result) {\n  // result === [[null, 'OK'], [null, 'bar']]\n});\n```\n\nThe constructor of `multi` also accepts a batch of commands:\n\n```javascript\nredis.multi([\n  ['set', 'foo', 'bar'],\n  ['get', 'foo']\n]).exec(function () { /* ... */ });\n```\n\nInline transactions are supported by pipeline, which means you can group a subset of commands\nin the pipeline into a transaction:\n\n```javascript\nredis.pipeline().get('foo').multi().set('foo', 'bar').get('foo').exec().get('foo').exec();\n```\n\n## Lua Scripting\nioredis supports all of the scripting commands such as `EVAL`, `EVALSHA` and `SCRIPT`.\nHowever, it's tedious to use in real world scenarios since developers have to take\ncare of script caching and to detect when to use `EVAL` and when to use `EVALSHA`.\nioredis expose a `defineCommand` method to make scripting much easier to use:\n\n```javascript\nvar redis = new Redis();\n\n// This will define a command echo:\nredis.defineCommand('echo', {\n  numberOfKeys: 2,\n  lua: 'return {KEYS[1],KEYS[2],ARGV[1],ARGV[2]}'\n});\n\n// Now `echo` can be used just like any other ordinary command,\n// and ioredis will try to use `EVALSHA` internally when possible for better performance.\nredis.echo('k1', 'k2', 'a1', 'a2', function (err, result) {\n  // result === ['k1', 'k2', 'a1', 'a2']\n});\n\n// `echoBuffer` is also defined automatically to return buffers instead of strings:\nredis.echoBuffer('k1', 'k2', 'a1', 'a2', function (err, result) {\n  // result[0] equals to Buffer.from('k1');\n});\n\n// And of course it works with pipeline:\nredis.pipeline().set('foo', 'bar').echo('k1', 'k2', 'a1', 'a2').exec();\n```\n\nIf the number of keys can't be determined when defining a command, you can\nomit the `numberOfKeys` property and pass the number of keys as the first argument\nwhen you call the command:\n\n```javascript\nredis.defineCommand('echoDynamicKeyNumber', {\n  lua: 'return {KEYS[1],KEYS[2],ARGV[1],ARGV[2]}'\n});\n\n// Now you have to pass the number of keys as the first argument every time\n// you invoke the `echoDynamicKeyNumber` command:\nredis.echoDynamicKeyNumber(2, 'k1', 'k2', 'a1', 'a2', function (err, result) {\n  // result === ['k1', 'k2', 'a1', 'a2']\n});\n```\n\n## Transparent Key Prefixing\nThis feature allows you to specify a string that will automatically be prepended\nto all the keys in a command, which makes it easier to manage your key\nnamespaces.\n\n**Warning** This feature won't apply to commands like [KEYS](http://redis.io/commands/KEYS) and [SCAN](http://redis.io/commands/scan) that take patterns rather than actual keys([#239](https://github.com/luin/ioredis/issues/239)),\nand this feature also won't apply to the replies of commands even they are key names ([#325](https://github.com/luin/ioredis/issues/325)).\n\n```javascript\nvar fooRedis = new Redis({ keyPrefix: 'foo:' });\nfooRedis.set('bar', 'baz');  // Actually sends SET foo:bar baz\n\nfooRedis.defineCommand('echo', {\n  numberOfKeys: 2,\n  lua: 'return {KEYS[1],KEYS[2],ARGV[1],ARGV[2]}'\n});\n\n// Works well with pipelining/transaction\nfooRedis.pipeline()\n  // Sends SORT foo:list BY foo:weight_*->fieldname\n  .sort('list', 'BY', 'weight_*->fieldname')\n  // Supports custom commands\n  // Sends EVALSHA xxx foo:k1 foo:k2 a1 a2\n  .echo('k1', 'k2', 'a1', 'a2')\n  .exec()\n```\n\n## Transforming Arguments & Replies\nMost Redis commands take one or more Strings as arguments,\nand replies are sent back as a single String or an Array of Strings. However, sometimes\nyou may want something different. For instance, it would be more convenient if the `HGETALL`\ncommand returns a hash (e.g. `{ key: val1, key2: v2 }`) rather than an array of key values (e.g. `[key1, val1, key2, val2]`).\n\nioredis has a flexible system for transforming arguments and replies. There are two types\nof transformers, argument transformer and reply transformer:\n\n```javascript\nvar Redis = require('ioredis');\n\n// Here's the built-in argument transformer converting\n// hmset('key', { k1: 'v1', k2: 'v2' })\n// or\n// hmset('key', new Map([['k1', 'v1'], ['k2', 'v2']]))\n// into\n// hmset('key', 'k1', 'v1', 'k2', 'v2')\nRedis.Command.setArgumentTransformer('hmset', function (args) {\n  if (args.length === 2) {\n    if (typeof Map !== 'undefined' && args[1] instanceof Map) {\n      // utils is a internal module of ioredis\n      return [args[0]].concat(utils.convertMapToArray(args[1]));\n    }\n    if ( typeof args[1] === 'object' && args[1] !== null) {\n      return [args[0]].concat(utils.convertObjectToArray(args[1]));\n    }\n  }\n  return args;\n});\n\n// Here's the built-in reply transformer converting the HGETALL reply\n// ['k1', 'v1', 'k2', 'v2']\n// into\n// { k1: 'v1', 'k2': 'v2' }\nRedis.Command.setReplyTransformer('hgetall', function (result) {\n  if (Array.isArray(result)) {\n    var obj = {};\n    for (var i = 0; i < result.length; i += 2) {\n      obj[result[i]] = result[i + 1];\n    }\n    return obj;\n  }\n  return result;\n});\n```\n\nThere are three built-in transformers, two argument transformers for `hmset` & `mset` and\na reply transformer for `hgetall`. Transformers for `hmset` and `hgetall` were mentioned\nabove, and the transformer for `mset` is similar to the one for `hmset`:\n\n```javascript\nredis.mset({ k1: 'v1', k2: 'v2' });\nredis.get('k1', function (err, result) {\n  // result === 'v1';\n});\n\nredis.mset(new Map([['k3', 'v3'], ['k4', 'v4']]));\nredis.get('k3', function (err, result) {\n  // result === 'v3';\n});\n```\n\nAnother useful example of a reply transformer is one that changes `hgetall` to return array of arrays instead of objects which avoids a unwanted conversation of hash keys to strings when dealing with binary hash keys:\n\n```javascript\nRedis.Command.setReplyTransformer('hgetall', function (result) {\n  var arr = [];\n  for (var i = 0; i < result.length; i += 2) {\n    arr.push([result[i], result[i + 1]]);\n  }\n  return arr;\n});\nredis.hset('h1', Buffer.from([0x01]), Buffer.from([0x02]));\nredis.hset('h1', Buffer.from([0x03]), Buffer.from([0x04]));\nredis.hgetallBuffer('h1', function (err, result) {\n  // result === [ [ <Buffer 01>, <Buffer 02> ], [ <Buffer 03>, <Buffer 04> ] ];\n});\n```\n\n## Monitor\nRedis supports the MONITOR command,\nwhich lets you see all commands received by the Redis server across all client connections,\nincluding from other client libraries and other computers.\n\nThe `monitor` method returns a monitor instance.\nAfter you send the MONITOR command, no other commands are valid on that connection. ioredis will emit a monitor event for every new monitor message that comes across.\nThe callback for the monitor event takes a timestamp from the Redis server and an array of command arguments.\n\nHere is a simple example:\n\n```javascript\nredis.monitor(function (err, monitor) {\n  monitor.on('monitor', function (time, args, source, database) {\n  });\n});\n```\n\n## Streamify Scanning\nRedis 2.8 added the `SCAN` command to incrementally iterate through the keys in the database. It's different from `KEYS` in that\n`SCAN` only returns a small number of elements each call, so it can be used in production without the downside\nof blocking the server for a long time. However, it requires recording the cursor on the client side each time\nthe `SCAN` command is called in order to iterate through all the keys correctly. Since it's a relatively common use case, ioredis\nprovides a streaming interface for the `SCAN` command to make things much easier. A readable stream can be created by calling `scanStream`:\n\n```javascript\nvar redis = new Redis();\n// Create a readable stream (object mode)\nvar stream = redis.scanStream();\nstream.on('data', function (resultKeys) {\n  // `resultKeys` is an array of strings representing key names.\n  // Note that resultKeys may contain 0 keys, and that it will sometimes\n  // contain duplicates due to SCAN's implementation in Redis.\n  for (var i = 0; i < resultKeys.length; i++) {\n    console.log(resultKeys[i]);\n  }\n});\nstream.on('end', function () {\n  console.log('all keys have been visited');\n});\n```\n\n`scanStream` accepts an option, with which you can specify the `MATCH` pattern and the `COUNT` argument:\n\n```javascript\nvar stream = redis.scanStream({\n  // only returns keys following the pattern of `user:*`\n  match: 'user:*',\n  // returns approximately 100 elements per call\n  count: 100\n});\n```\n\nJust like other commands, `scanStream` has a binary version `scanBufferStream`, which returns an array of buffers. It's useful when\nthe key names are not utf8 strings.\n\nThere are also `hscanStream`, `zscanStream` and `sscanStream` to iterate through elements in a hash, zset and set. The interface of each is\nsimilar to `scanStream` except the first argument is the key name:\n\n```javascript\nvar stream = redis.hscanStream('myhash', {\n  match: 'age:??'\n});\n```\n\nYou can learn more from the [Redis documentation](http://redis.io/commands/scan).\n\n**Useful Tips**\nIt's pretty common that doing an async task in the `data` handler. We'd like the scanning process to be paused until the async task to be finished. `Stream#pause()` and `Stream.resume()` do the trick. For example if we want to migrate data in Redis to MySQL:\n\n```javascript\nvar stream = redis.scanStream();\nstream.on('data', function (resultKeys) {\n  // Pause the stream from scanning more keys until we've migrated the current keys.\n  stream.pause();\n\n  Promise.all(resultKeys.map(migrateKeyToMySQL)).then(() => {\n    // Resume the stream here.\n    stream.resume();\n  });\n});\n\nstream.on('end', function () {\n  console.log('done migration');\n});\n```\n\n## Auto-reconnect\nBy default, ioredis will try to reconnect when the connection to Redis is lost\nexcept when the connection is closed manually by `redis.disconnect()` or `redis.quit()`.\n\nIt's very flexible to control how long to wait to reconnect after disconnection\nusing the `retryStrategy` option:\n\n```javascript\nvar redis = new Redis({\n  // This is the default value of `retryStrategy`\n  retryStrategy: function (times) {\n    var delay = Math.min(times * 50, 2000);\n    return delay;\n  }\n});\n```\n\n`retryStrategy` is a function that will be called when the connection is lost.\nThe argument `times` means this is the nth reconnection being made and\nthe return value represents how long (in ms) to wait to reconnect. When the\nreturn value isn't a number, ioredis will stop trying to reconnect, and the connection\nwill be lost forever if the user doesn't call `redis.connect()` manually.\n\nWhen reconnected, the client will auto subscribe to channels that the previous connection subscribed to.\nThis behavior can be disabled by setting the `autoResubscribe` option to `false`.\n\nAnd if the previous connection has some unfulfilled commands (most likely blocking commands such as `brpop` and `blpop`),\nthe client will resend them when reconnected. This behavior can be disabled by setting the `autoResendUnfulfilledCommands` option to `false`.\n\nBy default, all pending commands will be flushed with an error every 20 retry attempts. That makes sure commands won't wait forever when the connection is down. You can change this behavior by setting `maxRetriesPerRequest`:\n\n```javascript\nvar redis = new Redis({\n  maxRetriesPerRequest: 1\n});\n```\n\nSet maxRetriesPerRequest to `null` to disable this behavior, and every command will wait forever until the connection is alive again (which is the default behavior before ioredis v4).\n\n### Reconnect on error\n\nBesides auto-reconnect when the connection is closed, ioredis supports reconnecting on the specified errors by the `reconnectOnError` option. Here's an example that will reconnect when receiving `READONLY` error:\n\n```javascript\nvar redis = new Redis({\n  reconnectOnError: function (err) {\n    var targetError = 'READONLY';\n    if (err.message.slice(0, targetError.length) === targetError) {\n      // Only reconnect when the error starts with \"READONLY\"\n      return true; // or `return 1;`\n    }\n  }\n});\n```\n\nThis feature is useful when using Amazon ElastiCache. Once failover happens, Amazon ElastiCache will switch the master we currently connected with to a slave, leading to the following writes fails with the error `READONLY`. Using `reconnectOnError`, we can force the connection to reconnect on this error in order to connect to the new master.\n\nFurthermore, if the `reconnectOnError` returns `2`, ioredis will resend the failed command after reconnecting.\n\n## Connection Events\nThe Redis instance will emit some events about the state of the connection to the Redis server.\n\nEvent    | Description\n:------------- | :-------------\nconnect  | emits when a connection is established to the Redis server.\nready    | If `enableReadyCheck` is `true`, client will emit `ready` when the server reports that it is ready to receive commands (e.g. finish loading data from disk).<br>Otherwise, `ready` will be emitted immediately right after the `connect` event.\nerror    | emits when an error occurs while connecting.<br>However, ioredis emits all `error` events silently (only emits when there's at least one listener) so that your application won't crash if you're not listening to the `error` event.\nclose    | emits when an established Redis server connection has closed.\nreconnecting | emits after `close` when a reconnection will be made. The argument of the event is the time (in ms) before reconnecting.\nend     | emits after `close` when no more reconnections will be made, or the connection is failed to establish.\n\nYou can also check out the `Redis#status` property to get the current connection status.\n\nBesides the above connection events, there are several other custom events:\n\nEvent    | Description\n:------------- | :-------------\nselect   | emits when the database changed. The argument is the new db number.\n\n## Offline Queue\nWhen a command can't be processed by Redis (being sent before the `ready` event), by default, it's added to the offline queue and will be\nexecuted when it can be processed. You can disable this feature by setting the `enableOfflineQueue`\noption to `false`:\n\n```javascript\nvar redis = new Redis({ enableOfflineQueue: false });\n```\n\n## TLS Options\nRedis doesn't support TLS natively, however if the redis server you want to connect to is hosted behind a TLS proxy (e.g. [stunnel](https://www.stunnel.org/)) or is offered by a PaaS service that supports TLS connection (e.g. [Redis Labs](https://redislabs.com/)), you can set the `tls` option:\n\n```javascript\nvar redis = new Redis({\n  host: 'localhost',\n  tls: {\n    // Refer to `tls.connect()` section in\n    // https://nodejs.org/api/tls.html\n    // for all supported options\n    ca: fs.readFileSync('cert.pem')\n  }\n});\n```\n\n<hr>\n\n## Sentinel\nioredis supports Sentinel out of the box. It works transparently as all features that work when\nyou connect to a single node also work when you connect to a sentinel group. Make sure to run Redis >= 2.8.12 if you want to use this feature. Sentinels have a default port of 26379.\n\nTo connect using Sentinel, use:\n\n```javascript\nvar redis = new Redis({\n  sentinels: [{ host: 'localhost', port: 26379 }, { host: 'localhost', port: 26380 }],\n  name: 'mymaster'\n});\n\nredis.set('foo', 'bar');\n```\n\nThe arguments passed to the constructor are different from the ones you use to connect to a single node, where:\n\n* `name` identifies a group of Redis instances composed of a master and one or more slaves (`mymaster` in the example);\n* `sentinelPassword` (optional) password for Sentinel instances.\n* `sentinels` are a list of sentinels to connect to. The list does not need to enumerate all your sentinel instances, but a few so that if one is down the client will try the next one.\n* `role` (optional) with a value of `slave` will return a random slave from the Sentinel group.\n* `preferredSlaves` (optional) can be used to prefer a particular slave or set of slaves based on priority. It accepts a function or array.\n\nioredis **guarantees** that the node you connected to is always a master even after a failover. When a failover happens, instead of trying to reconnect to the failed node (which will be demoted to slave when it's available again), ioredis will ask sentinels for the new master node and connect to it. All commands sent during the failover are queued and will be executed when the new connection is established so that none of the commands will be lost.\n\nIt's possible to connect to a slave instead of a master by specifying the option `role` with the value of `slave` and ioredis will try to connect to a random slave of the specified master, with the guarantee that the connected node is always a slave. If the current node is promoted to master due to a failover, ioredis will disconnect from it and ask the sentinels for another slave node to connect to.\n\nIf you specify the option `preferredSlaves` along with `role: 'slave'` ioredis will attempt to use this value when selecting the slave from the pool of available slaves. The value of `preferredSlaves` should either be a function that accepts an array of avaiable slaves and returns a single result, or an array of slave values priorities by the lowest `prio` value first with a default value of `1`.\n\n```javascript\n// available slaves format\nvar availableSlaves = [{ ip: '127.0.0.1', port: '31231', flags: 'slave' }];\n\n// preferredSlaves array format\nvar preferredSlaves = [\n  { ip: '127.0.0.1', port: '31231', prio: 1 },\n  { ip: '127.0.0.1', port: '31232', prio: 2 }\n];\n\n// preferredSlaves function format\npreferredSlaves = function(availableSlaves) {\n  for (var i = 0; i < availableSlaves.length; i++) {\n    var slave = availableSlaves[i];\n    if (slave.ip === '127.0.0.1') {\n      if (slave.port === '31234') {\n        return slave;\n      }\n    }\n  }\n  // if no preferred slaves are available a random one is used\n  return false;\n};\n\nvar redis = new Redis({\n  sentinels: [{ host: '127.0.0.1', port: 26379 }, { host: '127.0.0.1', port: 26380 }],\n  name: 'mymaster',\n  role: 'slave',\n  preferredSlaves: preferredSlaves\n});\n```\n\nBesides the `retryStrategy` option, there's also a `sentinelRetryStrategy` in Sentinel mode which will be invoked when all the sentinel nodes are unreachable during connecting. If `sentinelRetryStrategy` returns a valid delay time, ioredis will try to reconnect from scratch. The default value of `sentinelRetryStrategy` is:\n\n```javascript\nfunction (times) {\n  var delay = Math.min(times * 10, 1000);\n  return delay;\n}\n```\n\n## Cluster\nRedis Cluster provides a way to run a Redis installation where data is automatically sharded across multiple Redis nodes.\nYou can connect to a Redis Cluster like this:\n\n```javascript\nvar Redis = require('ioredis');\n\nvar cluster = new Redis.Cluster([{\n  port: 6380,\n  host: '127.0.0.1'\n}, {\n  port: 6381,\n  host: '127.0.0.1'\n}]);\n\ncluster.set('foo', 'bar');\ncluster.get('foo', function (err, res) {\n  // res === 'bar'\n});\n```\n\n`Cluster` constructor accepts two arguments, where:\n\n0. The first argument is a list of nodes of the cluster you want to connect to.\nJust like Sentinel, the list does not need to enumerate all your cluster nodes,\nbut a few so that if one is unreachable the client will try the next one, and the client will discover other nodes automatically when at least one node is connected.\n0. The second argument is the options, where:\n\n    * `clusterRetryStrategy`: When none of the startup nodes are reachable, `clusterRetryStrategy` will be invoked. When a number is returned,\n    ioredis will try to reconnect to the startup nodes from scratch after the specified delay (in ms). Otherwise, an error of \"None of startup nodes is available\" will be returned.\n    The default value of this option is:\n\n        ```javascript\n        function (times) {\n          var delay = Math.min(100 + times * 2, 2000);\n          return delay;\n        }\n        ```\n\n        It's possible to modify the `startupNodes` property in order to switch to another set of nodes here:\n\n        ```javascript\n        function (times) {\n          this.startupNodes = [{ port: 6790, host: '127.0.0.1' }];\n          return Math.min(100 + times * 2, 2000);\n        }\n        ```\n\n    * `dnsLookup`: Alternative DNS lookup function (`dns.lookup()` is used by default).  It may be useful to override this in special cases, such as when AWS ElastiCache used with TLS enabled.\n    * `enableOfflineQueue`: Similar to the `enableOfflineQueue` option of `Redis` class.\n    * `enableReadyCheck`: When enabled, \"ready\" event will only be emitted when `CLUSTER INFO` command\n    reporting the cluster is ready for handling commands. Otherwise, it will be emitted immediately after \"connect\" is emitted.\n    * `scaleReads`: Config where to send the read queries. See below for more details.\n    * `maxRedirections`: When a cluster related error (e.g. `MOVED`, `ASK` and `CLUSTERDOWN` etc.) is received, the client will redirect the\n    command to another node. This option limits the max redirections allowed when sending a command. The default value is `16`.\n    * `retryDelayOnFailover`: If the target node is disconnected when sending a command,\n    ioredis will retry after the specified delay. The default value is `100`. You should make sure `retryDelayOnFailover * maxRedirections > cluster-node-timeout`\n    to insure that no command will fail during a failover.\n    * `retryDelayOnClusterDown`: When a cluster is down, all commands will be rejected with the error of `CLUSTERDOWN`. If this option is a number (by default, it is `100`), the client\n    will resend the commands after the specified time (in ms).\n    * `retryDelayOnTryAgain`: If this option is a number (by default, it is `100`), the client\n    will resend the commands rejected with `TRYAGAIN` error after the specified time (in ms).\n    * `redisOptions`: Default options passed to the constructor of `Redis` when connecting to a node.\n    * `slotsRefreshTimeout`: Milliseconds before a timeout occurs while refreshing slots from the cluster (default `1000`)\n    * `slotsRefreshInterval`: Milliseconds between every automatic slots refresh (default `5000`)\n\n### Read-write splitting\n\nA typical redis cluster contains three or more masters and several slaves for each master. It's possible to scale out redis cluster by sending read queries to slaves and write queries to masters by setting the `scaleReads` option.\n\n`scaleReads` is \"master\" by default, which means ioredis will never send any queries to slaves. There are other three available options:\n\n1. \"all\": Send write queries to masters and read queries to masters or slaves randomly.\n2. \"slave\": Send write queries to masters and read queries to slaves.\n3. a custom `function(nodes, command): node`: Will choose the custom function to select to which node to send read queries (write queries keep being sent to master). The first node in `nodes` is always the master serving the relevant slots. If the function returns an array of nodes, a random node of that list will be selected.\n\nFor example:\n\n```javascript\nvar cluster = new Redis.Cluster([/* nodes */], {\n  scaleReads: 'slave'\n});\ncluster.set('foo', 'bar'); // This query will be sent to one of the masters.\ncluster.get('foo', function (err, res) {\n  // This query will be sent to one of the slaves.\n});\n```\n\n**NB** In the code snippet above, the `res` may not be equal to \"bar\" because of the lag of replication between the master and slaves.\n\n### Running commands to multiple nodes\n\nEvery command will be sent to exactly one node. For commands containing keys, (e.g. `GET`, `SET` and `HGETALL`), ioredis sends them to the node that serving the keys, and for other commands not containing keys, (e.g. `INFO`, `KEYS` and `FLUSHDB`), ioredis sends them to a random node.\n\nSometimes you may want to send a command to multiple nodes (masters or slaves) of the cluster, you can get the nodes via `Cluster#nodes()` method.\n\n`Cluster#nodes()` accepts a parameter role, which can be \"master\", \"slave\" and \"all\" (default), and returns an array of `Redis` instance. For example:\n\n```javascript\n// Send `FLUSHDB` command to all slaves:\nvar slaves = cluster.nodes('slave');\nPromise.all(slaves.map(function (node) {\n  return node.flushdb();\n}));\n\n// Get keys of all the masters:\nvar masters = cluster.nodes('master');\nPromise.all(masters.map(function (node) {\n  return node.keys();\n})).then(function (keys) {\n  // keys: [['key1', 'key2'], ['key3', 'key4']]\n});\n```\n\n### NAT Mapping\nSometimes the cluster is hosted within a internal network that can only be accessed via a NAT (Network Address Translation) instance. See [Accessing ElastiCache from outside AWS](https://docs.aws.amazon.com/AmazonElastiCache/latest/red-ug/accessing-elasticache.html) as an example.\n\nYou can specify nat mapping rules via `natMap` option:\n\n```javascript\nconst cluster = new Redis.Cluster([{\n  host: '203.0.113.73',\n  port: 30001\n}], {\n  natMap: {\n    '10.0.1.230:30001': {host: '203.0.113.73', port: 30001},\n    '10.0.1.231:30001': {host: '203.0.113.73', port: 30002},\n    '10.0.1.232:30001': {host: '203.0.113.73', port: 30003}\n  }\n})\n```\n\nThis option is also useful when the cluster is running inside a Docker container.\n\n### Transaction and pipeline in Cluster mode\nAlmost all features that are supported by `Redis` are also supported by `Redis.Cluster`, e.g. custom commands, transaction and pipeline.\nHowever there are some differences when using transaction and pipeline in Cluster mode:\n\n0. All keys in a pipeline should belong to the same slot since ioredis sends all commands in a pipeline to the same node.\n0. You can't use `multi` without pipeline (aka `cluster.multi({ pipeline: false })`). This is because when you call `cluster.multi({ pipeline: false })`, ioredis doesn't know which node the `multi` command should be sent to.\n0. Chaining custom commands in the pipeline is not supported in Cluster mode.\n\nWhen any commands in a pipeline receives a `MOVED` or `ASK` error, ioredis will resend the whole pipeline to the specified node automatically if all of the following conditions are satisfied:\n\n0. All errors received in the pipeline are the same. For example, we won't resend the pipeline if we got two `MOVED` errors pointing to different nodes.\n0. All commands executed successfully are readonly commands. This makes sure that resending the pipeline won't have side effects.\n\n### Pub/Sub\nPub/Sub in cluster mode works exactly as the same as in standalone mode. Internally, when a node of the cluster receives a message, it will broadcast the message to the other nodes. ioredis makes sure that each message will only be received once by strictly subscribing one node at the same time.\n\n```javascript\nvar nodes = [/* nodes */];\nvar pub = new Redis.Cluster(nodes);\nvar sub = new Redis.Cluster(nodes);\nsub.on('message', function (channel, message) {\n  console.log(channel, message);\n});\n\nsub.subscribe('news', function () {\n  pub.publish('news', 'highlights');\n});\n```\n\n### Events\n\nEvent    | Description\n:------------- | :-------------\nconnect  | emits when a connection is established to the Redis server.\nready    | emits when `CLUSTER INFO` reporting the cluster is able to receive commands (if `enableReadyCheck` is `true`) or immediately after `connect` event (if `enableReadyCheck` is false).\nerror    | emits when an error occurs while connecting with a property of `lastNodeError` representing the last node error received. This event is emitted silently (only emitting if there's at least one listener).\nclose    | emits when an established Redis server connection has closed.\nreconnecting | emits after `close` when a reconnection will be made. The argument of the event is the time (in ms) before reconnecting.\nend     | emits after `close` when no more reconnections will be made.\n+node   | emits when a new node is connected.\n-node   | emits when a node is disconnected.\nnode error | emits when an error occurs when connecting to a node. The second argument indicates the address of the node.\n\n### Password\nSetting the `password` option to access password-protected clusters:\n\n```javascript\nvar Redis = require('ioredis');\nvar cluster = new Redis.Cluster(nodes, {\n  redisOptions: {\n    password: 'your-cluster-password'\n  }\n});\n```\n\nIf some of nodes in the cluster using a different password, you should specify them in the first parameter:\n\n```javascript\nvar Redis = require('ioredis');\nvar cluster = new Redis.Cluster([\n  // Use password \"password-for-30001\" for 30001\n  { port: 30001, password: 'password-for-30001'},\n  // Don't use password when accessing 30002\n  { port: 30002, password: null }\n  // Other nodes will use \"fallback-password\"\n], {\n  redisOptions: {\n    password: 'fallback-password'\n  }\n});\n```\n\n### Special note: AWS ElastiCache Clusters with TLS\n\nAWS ElastiCache for Redis (Clustered Mode) supports TLS encryption.  If you use\nthis, you may encounter errors with invalid certificates.  To resolve this\nissue, construct the `Cluster` with the `dnsLookup` option as follows:\n\n```javascript\nvar cluster = new Redis.Cluster(\n  [{\n    host: 'clustercfg.myCluster.abcdefg.xyz.cache.amazonaws.com',\n    port: 6379\n  }],\n  {\n    dnsLookup: (address, callback) => callback(null, address),\n    redisOptions: {\n      tls: {}\n    },\n  }\n};\n```\n\n<hr>\n\n# Error Handling\nAll the errors returned by the Redis server are instances of `ReplyError`, which can be accessed via `Redis`:\n\n```javascript\nvar Redis = require('ioredis');\nvar redis = new Redis();\n// This command causes a reply error since the SET command requires two arguments.\nredis.set('foo', function (err) {\n  err instanceof Redis.ReplyError\n});\n```\n\nThis is the error stack of the `ReplyError`:\n\n```\nReplyError: ERR wrong number of arguments for 'set' command\n    at ReplyParser._parseResult (/app/node_modules/ioredis/lib/parsers/javascript.js:60:14)\n    at ReplyParser.execute (/app/node_modules/ioredis/lib/parsers/javascript.js:178:20)\n    at Socket.<anonymous> (/app/node_modules/ioredis/lib/redis/event_handler.js:99:22)\n    at Socket.emit (events.js:97:17)\n    at readableAddChunk (_stream_readable.js:143:16)\n    at Socket.Readable.push (_stream_readable.js:106:10)\n    at TCP.onread (net.js:509:20)\n```\n\nBy default, the error stack doesn't make any sense because the whole stack happens in the ioredis\nmodule itself, not in your code. So it's not easy to find out where the error happens in your code.\nioredis provides an option `showFriendlyErrorStack` to solve the problem. When you enable\n`showFriendlyErrorStack`, ioredis will optimize the error stack for you:\n\n```javascript\nvar Redis = require('ioredis');\nvar redis = new Redis({ showFriendlyErrorStack: true });\nredis.set('foo');\n```\n\nAnd the output will be:\n\n```\nReplyError: ERR wrong number of arguments for 'set' command\n    at Object.<anonymous> (/app/index.js:3:7)\n    at Module._compile (module.js:446:26)\n    at Object.Module._extensions..js (module.js:464:10)\n    at Module.load (module.js:341:32)\n    at Function.Module._load (module.js:296:12)\n    at Function.Module.runMain (module.js:487:10)\n    at startup (node.js:111:16)\n    at node.js:799:3\n```\n\nThis time the stack tells you that the error happens on the third line in your code. Pretty sweet!\nHowever, it would decrease the performance significantly to optimize the error stack. So by\ndefault, this option is disabled and can only be used for debugging purposes. You **shouldn't** use this feature in a production environment.\n\n# Plugging in your own Promises Library\nIf you're an advanced user, you may want to plug in your own promise library like [bluebird](https://www.npmjs.com/package/bluebird). Just set Redis.Promise to your favorite ES6-style promise constructor and ioredis will use it.\n\n```javascript\nconst Redis = require('ioredis')\nRedis.Promise = require('bluebird')\n\nconst redis = new Redis()\n\n// Use bluebird\nassert.equal(redis.get().constructor, require('bluebird'))\n\n// You can change the Promise implementation at any time:\nRedis.Promise = global.Promise\nassert.equal(redis.get().constructor, global.Promise)\n```\n\n\n# Running tests\n\nStart a Redis server on 127.0.0.1:6379, and then:\n\n```shell\n$ npm test\n```\n\n`FLUSH ALL` will be invoked after each test, so make sure there's no valuable data in it before running tests.\n\nIf your testing environment does not let you spin up a Redis server [ioredis-mock](https://github.com/stipsan/ioredis-mock) is a drop-in replacement you can use in your tests. It aims to behave identically to ioredis connected to a Redis server so that your integration tests is easier to write and of better quality.\n\n# Debug\n\nYou can set the `DEBUG` env to `ioredis:*` to print debug info:\n\n```shell\n$ DEBUG=ioredis:* node app.js\n```\n\n# Consolidation: It's time for celebration\n\nRight now there are two great redis clients around and both have some advantages above each other. We speak about [node_redis](https://github.com/NodeRedis/node_redis) and ioredis. So after talking to each other about how we could improve in working together we (that is [@BridgeAR](https://github.com/BridgeAR) and [@luin](https://github.com/luin)) decided to work towards a single library on the long run. But step by step.\n\nFirst of all, we want to split small parts of our libraries into others so that we're both able to use the same code. Those libraries are going to be maintained under the NodeRedis organization. This is going to reduce the maintance overhead, allows others to use the very same code, if they need it and it's way easier for others to contribute to both libraries.\n\nWe're very happy about this step towards working together as we both want to give you the best redis experience possible.\n\nIf you want to join our cause by help maintaining something, please don't hesitate to contact either one of us.\n\n# Join in!\n\nI'm happy to receive bug reports, fixes, documentation enhancements, and any other improvements.\n\nAnd since I'm not a native English speaker, if you find any grammar mistakes in the documentation, please also let me know. :)\n\n# Contributors\n\nThis project exists thanks to all the people who contribute:\n\n<a href=\"https://github.com/luin/ioredis/graphs/contributors\"><img src=\"https://opencollective.com/ioredis/contributors.svg?width=890&showBtn=false\" /></a>\n\n# License\n\nMIT\n\n\n[![FOSSA Status](https://app.fossa.io/api/projects/git%2Bgithub.com%2Fluin%2Fioredis.svg?type=large)](https://app.fossa.io/projects/git%2Bgithub.com%2Fluin%2Fioredis?ref=badge_large)\n","readmeFilename":"README.md","bugs":{"url":"https://github.com/luin/ioredis/issues"},"homepage":"https://github.com/luin/ioredis#readme","_id":"ioredis@4.10.4","_nodeVersion":"10.16.0","_npmVersion":"6.9.0","dist":{"integrity":"sha512-hGH0ixXRjqTYa/UUiODfjo29phZ57n8WjFTKpsrN3dgsTCkH+WAVuGdbSoH68n+ha2ns6z8d/MRPOU0as0BtIA==","shasum":"f7ee8f59331e3fa22306114f85323c15f0cebda4","tarball":"https://registry.npmjs.org/ioredis/-/ioredis-4.10.4.tgz","fileCount":35,"unpackedSize":226539,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJc/20lCRA9TVsSAnZWagAAleoP/AwYB9znHXARQ80k0dvF\nVzsF6/sfh4DXDzbrnQhhxk0AhU2+BBrAzkp/dbgcb416OkbV8QNbYdX4WOg2\n05zKoGqLQPFpv7wkHmWq4x6HFnRdK8GzBI0uALGgLZWAnfsvEplMV+ROK1EO\nU0RNX1tR6tKdxnX4zxKo+Zhz7nQceOZuW1PNMvUpmHCopY975JskDCJU0rva\npDCypJ+gKntJ23H1kMOPEmB/fdnKZL/ImI9mpfTqWmDRffQ9Uq7C6O6bTskY\nlb5xdPYr0I7SVYvv02C9nrzQJhaFU+KwH8GgTgbH2IMzQxMotDczJV8RNNJ5\ndoJXJffVfui1h719V15yXfQIw1+OZiVgGzUz4/qW48fEEUiAs1vTepvKRt4B\nvzJ/RxNdu1xwMpXHfCF1unH0XXG7TAKKkeIeovH3NdYxlqfGliaCl6gqhwPp\n/Qf3O4cBdbAlrANMqTcOo10+6S3xJNYoR+qUKSXMGaYpKamaoxJCchjFg36W\nrXkLpZC3E0GwNRb/Vu9Tw6Ph1rBBgEDe8SqQf2Z8D2NqlYOxjBaZe1+8eP0W\n5XBFYpg6dmo/8RZpkPy9ubEBbrU0judQJZktMNEKugnCgccfakdtHzvRDiPp\nYp5OeEBYHo4CHNpX6oeKAFTt34d812tvK9+uK3o6PQjL5dbOz/tHuwZGsXFa\nJRl+\r\n=zNa6\r\n-----END PGP SIGNATURE-----\r\n"},"maintainers":[{"email":"ioredis-robot@zihua.li","name":"ioredis-robot"},{"email":"i@zihua.li","name":"luin"}],"_npmUser":{"name":"luin","email":"i@zihua.li"},"directories":{},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/ioredis_4.10.4_1560243492384_0.3296917184774122"},"_hasShrinkwrap":false},"4.11.0":{"name":"ioredis","version":"4.11.0","description":"A robust, performance-focused and full-featured Redis client for Node.js.","main":"built/index.js","scripts":{"test":"TS_NODE_LOG_ERROR=true NODE_ENV=test mocha test/**/*.ts","test:cov":"TS_NODE_LOG_ERROR=true NODE_ENV=test node ./node_modules/istanbul/lib/cli.js cover --preserve-comments ./node_modules/mocha/bin/_mocha -- -r ts-node/register -R spec --exit test/**/*.ts","build":"rm -rf built && tsc","prepublishOnly":"npm run build && npm test","bench":"matcha benchmarks/*.js","semantic-release":"semantic-release"},"repository":{"type":"git","url":"git://github.com/luin/ioredis.git"},"keywords":["redis","cluster","sentinel","pipelining"],"author":{"name":"luin","email":"i@zihua.li","url":"http://zihua.li"},"license":"MIT","dependencies":{"cluster-key-slot":"^1.0.6","debug":"^4.1.1","denque":"^1.1.0","lodash.defaults":"^4.2.0","lodash.flatten":"^4.4.0","redis-commands":"1.5.0","redis-errors":"^1.2.0","redis-parser":"^3.0.0","standard-as-callback":"^2.0.1"},"devDependencies":{"@semantic-release/changelog":"^3.0.4","@semantic-release/git":"^7.0.12","@types/bluebird":"^3.5.27","@types/debug":"^4.1.4","@types/lodash.defaults":"^4.2.6","@types/lodash.flatten":"^4.4.6","@types/mocha":"^5.2.7","@types/node":"^12.0.2","@types/redis-errors":"1.2.0","@types/sinon":"^7.0.13","bluebird":"^3.5.4","chai":"^4.2.0","cz-conventional-changelog":"^2.0.0","istanbul":"^0.4.5","mocha":"^5.0.0","server-destroy":"^1.0.1","sinon":"^7.3.2","ts-node":"^8.1.0","typescript":"^3.5.1"},"engines":{"node":">=6"},"config":{"commitizen":{"path":"./node_modules/cz-conventional-changelog"}},"gitHead":"7a62aecf6b6d5c732b86b5a21d8d50ccb8ef2be7","readme":"[![ioredis](https://cdn.jsdelivr.net/gh/luin/ioredis@b5e8c74/logo.svg)](https://github.com/luin/ioredis)\n\n[![Build Status](https://travis-ci.org/luin/ioredis.svg?branch=master)](https://travis-ci.org/luin/ioredis)\n[![Test Coverage](https://codeclimate.com/github/luin/ioredis/badges/coverage.svg)](https://codeclimate.com/github/luin/ioredis)\n[![Join the chat at https://gitter.im/luin/ioredis](https://badges.gitter.im/Join%20Chat.svg)](https://gitter.im/luin/ioredis?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge)\n[![Commitizen friendly](https://img.shields.io/badge/commitizen-friendly-brightgreen.svg)](http://commitizen.github.io/cz-cli/)\n[![semantic-release](https://img.shields.io/badge/%20%20%F0%9F%93%A6%F0%9F%9A%80-semantic--release-e10079.svg)](https://github.com/semantic-release/semantic-release)\n[![npm latest version](https://img.shields.io/npm/v/ioredis/latest.svg)](https://www.npmjs.com/package/ioredis)\n[![npm next version](https://img.shields.io/npm/v/ioredis/next.svg)](https://www.npmjs.com/package/ioredis)\n<img alt=\"\" src=\"\">\n\nA robust, performance-focused and full-featured [Redis](http://redis.io) client for [Node.js](https://nodejs.org).\n\nSupports Redis >= 2.6.12 and (Node.js >= 6).\n\n# Features\nioredis is a robust, full-featured Redis client that is\nused in the world's biggest online commerce company [Alibaba](http://www.alibaba.com/) and many other awesome companies.\n\n0. Full-featured. It supports [Cluster](http://redis.io/topics/cluster-tutorial), [Sentinel](http://redis.io/topics/sentinel), [Pipelining](http://redis.io/topics/pipelining) and of course [Lua scripting](http://redis.io/commands/eval) & [Pub/Sub](http://redis.io/topics/pubsub) (with the support of binary messages).\n0. High performance.\n0. Delightful API. It works with Node callbacks and Native promises.\n0. Transformation of command arguments and replies.\n0. Transparent key prefixing.\n0. Abstraction for Lua scripting, allowing you to define custom commands.\n0. Support for binary data.\n0. Support for TLS.\n0. Support for offline queue and ready checking.\n0. Support for ES6 types, such as `Map` and `Set`.\n0. Support for GEO commands (Redis 3.2 Unstable).\n0. Sophisticated error handling strategy.\n0. Support for NAT mapping.\n\n# Links\n* [API Documentation](API.md)\n* [Changelog](Changelog.md)\n* [Migrating from node_redis](https://github.com/luin/ioredis/wiki/Migrating-from-node_redis)\n* [Error Handling](#error-handling)\n\n<hr>\n<a href=\"http://bit.ly/medis-macos\"><img align=\"right\" src=\"resources/medis.png\" alt=\"Download on the App Store\"></a>\n\n\n### [AD] Medis: Redis GUI for OS X\n\nLooking for a Redis GUI manager for OS X, Windows and Linux? Here's [Medis](http://bit.ly/medis-macos)!\n\nMedis is an open-sourced, beautiful, easy-to-use Redis GUI management application.\n\nMedis starts with all the basic features you need:\n\n* Keys viewing/editing\n* SSH Tunnel for connecting with remote servers\n* Terminal for executing custom commands\n* JSON/MessagePack format viewing/editing and built-in highlighting/validator\n* And other awesome features...\n\n[Medis is open sourced on GitHub](https://github.com/luin/medis)\n\n### [AD] Kuber: Kubernetes Dashboard for iOS\n<a href=\"http://bit.ly/kuber-ios\"><img src=\"resources/kuber.png\" alt=\"Download on the App Store\"></a>\n\n<hr>\n\n# Quick Start\n\n## Install\n```shell\n$ npm install ioredis\n```\n\n## Basic Usage\n\n```javascript\nvar Redis = require('ioredis');\nvar redis = new Redis();\n\nredis.set('foo', 'bar');\nredis.get('foo', function (err, result) {\n  console.log(result);\n});\nredis.del('foo');\n\n// Or using a promise if the last argument isn't a function\nredis.get('foo').then(function (result) {\n  console.log(result);\n});\n\n// Arguments to commands are flattened, so the following are the same:\nredis.sadd('set', 1, 3, 5, 7);\nredis.sadd('set', [1, 3, 5, 7]);\n\n// All arguments are passed directly to the redis server:\nredis.set('key', 100, 'EX', 10);\n```\n\nSee the `examples/` folder for more examples.\n\n## Connect to Redis\nWhen a new `Redis` instance is created,\na connection to Redis will be created at the same time.\nYou can specify which Redis to connect to by:\n\n```javascript\nnew Redis()       // Connect to 127.0.0.1:6379\nnew Redis(6380)   // 127.0.0.1:6380\nnew Redis(6379, '192.168.1.1')        // 192.168.1.1:6379\nnew Redis('/tmp/redis.sock')\nnew Redis({\n  port: 6379,          // Redis port\n  host: '127.0.0.1',   // Redis host\n  family: 4,           // 4 (IPv4) or 6 (IPv6)\n  password: 'auth',\n  db: 0\n})\n```\n\nYou can also specify connection options as a [`redis://` URL](http://www.iana.org/assignments/uri-schemes/prov/redis):\n\n```javascript\n// Connect to 127.0.0.1:6380, db 4, using password \"authpassword\":\nnew Redis('redis://:authpassword@127.0.0.1:6380/4')\n```\n\nSee [API Documentation](API.md#new_Redis) for all available options.\n\n## Pub/Sub\n\nHere is a simple example of the API for publish/subscribe.\nThe following program opens two client connections.\nIt subscribes to a channel with one connection\nand publishes to that channel with the other:\n\n```javascript\nvar Redis = require('ioredis');\nvar redis = new Redis();\nvar pub = new Redis();\nredis.subscribe('news', 'music', function (err, count) {\n  // Now we are subscribed to both the 'news' and 'music' channels.\n  // `count` represents the number of channels we are currently subscribed to.\n\n  pub.publish('news', 'Hello world!');\n  pub.publish('music', 'Hello again!');\n});\n\nredis.on('message', function (channel, message) {\n  // Receive message Hello world! from channel news\n  // Receive message Hello again! from channel music\n  console.log('Receive message %s from channel %s', message, channel);\n});\n\n// There's also an event called 'messageBuffer', which is the same as 'message' except\n// it returns buffers instead of strings.\nredis.on('messageBuffer', function (channel, message) {\n  // Both `channel` and `message` are buffers.\n});\n```\n\n`PSUBSCRIBE` is also supported in a similar way:\n\n```javascript\nredis.psubscribe('pat?ern', function (err, count) {});\nredis.on('pmessage', function (pattern, channel, message) {});\nredis.on('pmessageBuffer', function (pattern, channel, message) {});\n```\n\nWhen a client issues a SUBSCRIBE or PSUBSCRIBE, that connection is put into a \"subscriber\" mode.\nAt that point, only commands that modify the subscription set are valid.\nWhen the subscription set is empty, the connection is put back into regular mode.\n\nIf you need to send regular commands to Redis while in subscriber mode, just open another connection.\n\n## Handle Binary Data\nArguments can be buffers:\n```javascript\nredis.set('foo', Buffer.from('bar'));\n```\n\nAnd every command has a method that returns a Buffer (by adding a suffix of \"Buffer\" to the command name).\nTo get a buffer instead of a utf8 string:\n\n```javascript\nredis.getBuffer('foo', function (err, result) {\n  // result is a buffer.\n});\n```\n\n## Pipelining\nIf you want to send a batch of commands (e.g. > 5), you can use pipelining to queue\nthe commands in memory and then send them to Redis all at once. This way the performance improves by 50%~300% (See [benchmark section](#benchmark)).\n\n`redis.pipeline()` creates a `Pipeline` instance. You can call any Redis\ncommands on it just like the `Redis` instance. The commands are queued in memory\nand flushed to Redis by calling the `exec` method:\n\n```javascript\nvar pipeline = redis.pipeline();\npipeline.set('foo', 'bar');\npipeline.del('cc');\npipeline.exec(function (err, results) {\n  // `err` is always null, and `results` is an array of responses\n  // corresponding to the sequence of queued commands.\n  // Each response follows the format `[err, result]`.\n});\n\n// You can even chain the commands:\nredis.pipeline().set('foo', 'bar').del('cc').exec(function (err, results) {\n});\n\n// `exec` also returns a Promise:\nvar promise = redis.pipeline().set('foo', 'bar').get('foo').exec();\npromise.then(function (result) {\n  // result === [[null, 'OK'], [null, 'bar']]\n});\n```\n\nEach chained command can also have a callback, which will be invoked when the command\ngets a reply:\n\n```javascript\nredis.pipeline().set('foo', 'bar').get('foo', function (err, result) {\n  // result === 'bar'\n}).exec(function (err, result) {\n  // result[1][1] === 'bar'\n});\n```\n\nIn addition to adding commands to the `pipeline` queue individually, you can also pass an array of commands and arguments to the constructor:\n\n```javascript\nredis.pipeline([\n  ['set', 'foo', 'bar'],\n  ['get', 'foo']\n]).exec(function () { /* ... */ });\n```\n\n`#length` property shows how many commands in the pipeline:\n\n```javascript\nconst length = redis.pipeline().set('foo', 'bar').get('foo').length;\n// length === 2\n```\n\n\n## Transaction\nMost of the time, the transaction commands `multi` & `exec` are used together with pipeline.\nTherefore, when `multi` is called, a `Pipeline` instance is created automatically by default,\nso you can use `multi` just like `pipeline`:\n\n```javascript\nredis.multi().set('foo', 'bar').get('foo').exec(function (err, results) {\n  // results === [[null, 'OK'], [null, 'bar']]\n});\n```\nIf there's a syntax error in the transaction's command chain (e.g. wrong number of arguments, wrong command name, etc),\nthen none of the commands would be executed, and an error is returned:\n\n```javascript\nredis.multi().set('foo').set('foo', 'new value').exec(function (err, results) {\n  // err:\n  //  { [ReplyError: EXECABORT Transaction discarded because of previous errors.]\n  //    name: 'ReplyError',\n  //    message: 'EXECABORT Transaction discarded because of previous errors.',\n  //    command: { name: 'exec', args: [] },\n  //    previousErrors:\n  //     [ { [ReplyError: ERR wrong number of arguments for 'set' command]\n  //         name: 'ReplyError',\n  //         message: 'ERR wrong number of arguments for \\'set\\' command',\n  //         command: [Object] } ] }\n});\n```\n\nIn terms of the interface, `multi` differs from `pipeline` in that when specifying a callback\nto each chained command, the queueing state is passed to the callback instead of the result of the command:\n\n```javascript\nredis.multi().set('foo', 'bar', function (err, result) {\n  // result === 'QUEUED'\n}).exec(/* ... */);\n```\n\nIf you want to use transaction without pipeline, pass `{ pipeline: false }` to `multi`,\nand every command will be sent to Redis immediately without waiting for an `exec` invocation:\n\n```javascript\nredis.multi({ pipeline: false });\nredis.set('foo', 'bar');\nredis.get('foo');\nredis.exec(function (err, result) {\n  // result === [[null, 'OK'], [null, 'bar']]\n});\n```\n\nThe constructor of `multi` also accepts a batch of commands:\n\n```javascript\nredis.multi([\n  ['set', 'foo', 'bar'],\n  ['get', 'foo']\n]).exec(function () { /* ... */ });\n```\n\nInline transactions are supported by pipeline, which means you can group a subset of commands\nin the pipeline into a transaction:\n\n```javascript\nredis.pipeline().get('foo').multi().set('foo', 'bar').get('foo').exec().get('foo').exec();\n```\n\n## Lua Scripting\nioredis supports all of the scripting commands such as `EVAL`, `EVALSHA` and `SCRIPT`.\nHowever, it's tedious to use in real world scenarios since developers have to take\ncare of script caching and to detect when to use `EVAL` and when to use `EVALSHA`.\nioredis expose a `defineCommand` method to make scripting much easier to use:\n\n```javascript\nvar redis = new Redis();\n\n// This will define a command echo:\nredis.defineCommand('echo', {\n  numberOfKeys: 2,\n  lua: 'return {KEYS[1],KEYS[2],ARGV[1],ARGV[2]}'\n});\n\n// Now `echo` can be used just like any other ordinary command,\n// and ioredis will try to use `EVALSHA` internally when possible for better performance.\nredis.echo('k1', 'k2', 'a1', 'a2', function (err, result) {\n  // result === ['k1', 'k2', 'a1', 'a2']\n});\n\n// `echoBuffer` is also defined automatically to return buffers instead of strings:\nredis.echoBuffer('k1', 'k2', 'a1', 'a2', function (err, result) {\n  // result[0] equals to Buffer.from('k1');\n});\n\n// And of course it works with pipeline:\nredis.pipeline().set('foo', 'bar').echo('k1', 'k2', 'a1', 'a2').exec();\n```\n\nIf the number of keys can't be determined when defining a command, you can\nomit the `numberOfKeys` property and pass the number of keys as the first argument\nwhen you call the command:\n\n```javascript\nredis.defineCommand('echoDynamicKeyNumber', {\n  lua: 'return {KEYS[1],KEYS[2],ARGV[1],ARGV[2]}'\n});\n\n// Now you have to pass the number of keys as the first argument every time\n// you invoke the `echoDynamicKeyNumber` command:\nredis.echoDynamicKeyNumber(2, 'k1', 'k2', 'a1', 'a2', function (err, result) {\n  // result === ['k1', 'k2', 'a1', 'a2']\n});\n```\n\n## Transparent Key Prefixing\nThis feature allows you to specify a string that will automatically be prepended\nto all the keys in a command, which makes it easier to manage your key\nnamespaces.\n\n**Warning** This feature won't apply to commands like [KEYS](http://redis.io/commands/KEYS) and [SCAN](http://redis.io/commands/scan) that take patterns rather than actual keys([#239](https://github.com/luin/ioredis/issues/239)),\nand this feature also won't apply to the replies of commands even they are key names ([#325](https://github.com/luin/ioredis/issues/325)).\n\n```javascript\nvar fooRedis = new Redis({ keyPrefix: 'foo:' });\nfooRedis.set('bar', 'baz');  // Actually sends SET foo:bar baz\n\nfooRedis.defineCommand('echo', {\n  numberOfKeys: 2,\n  lua: 'return {KEYS[1],KEYS[2],ARGV[1],ARGV[2]}'\n});\n\n// Works well with pipelining/transaction\nfooRedis.pipeline()\n  // Sends SORT foo:list BY foo:weight_*->fieldname\n  .sort('list', 'BY', 'weight_*->fieldname')\n  // Supports custom commands\n  // Sends EVALSHA xxx foo:k1 foo:k2 a1 a2\n  .echo('k1', 'k2', 'a1', 'a2')\n  .exec()\n```\n\n## Transforming Arguments & Replies\nMost Redis commands take one or more Strings as arguments,\nand replies are sent back as a single String or an Array of Strings. However, sometimes\nyou may want something different. For instance, it would be more convenient if the `HGETALL`\ncommand returns a hash (e.g. `{ key: val1, key2: v2 }`) rather than an array of key values (e.g. `[key1, val1, key2, val2]`).\n\nioredis has a flexible system for transforming arguments and replies. There are two types\nof transformers, argument transformer and reply transformer:\n\n```javascript\nvar Redis = require('ioredis');\n\n// Here's the built-in argument transformer converting\n// hmset('key', { k1: 'v1', k2: 'v2' })\n// or\n// hmset('key', new Map([['k1', 'v1'], ['k2', 'v2']]))\n// into\n// hmset('key', 'k1', 'v1', 'k2', 'v2')\nRedis.Command.setArgumentTransformer('hmset', function (args) {\n  if (args.length === 2) {\n    if (typeof Map !== 'undefined' && args[1] instanceof Map) {\n      // utils is a internal module of ioredis\n      return [args[0]].concat(utils.convertMapToArray(args[1]));\n    }\n    if ( typeof args[1] === 'object' && args[1] !== null) {\n      return [args[0]].concat(utils.convertObjectToArray(args[1]));\n    }\n  }\n  return args;\n});\n\n// Here's the built-in reply transformer converting the HGETALL reply\n// ['k1', 'v1', 'k2', 'v2']\n// into\n// { k1: 'v1', 'k2': 'v2' }\nRedis.Command.setReplyTransformer('hgetall', function (result) {\n  if (Array.isArray(result)) {\n    var obj = {};\n    for (var i = 0; i < result.length; i += 2) {\n      obj[result[i]] = result[i + 1];\n    }\n    return obj;\n  }\n  return result;\n});\n```\n\nThere are three built-in transformers, two argument transformers for `hmset` & `mset` and\na reply transformer for `hgetall`. Transformers for `hmset` and `hgetall` were mentioned\nabove, and the transformer for `mset` is similar to the one for `hmset`:\n\n```javascript\nredis.mset({ k1: 'v1', k2: 'v2' });\nredis.get('k1', function (err, result) {\n  // result === 'v1';\n});\n\nredis.mset(new Map([['k3', 'v3'], ['k4', 'v4']]));\nredis.get('k3', function (err, result) {\n  // result === 'v3';\n});\n```\n\nAnother useful example of a reply transformer is one that changes `hgetall` to return array of arrays instead of objects which avoids a unwanted conversation of hash keys to strings when dealing with binary hash keys:\n\n```javascript\nRedis.Command.setReplyTransformer('hgetall', function (result) {\n  var arr = [];\n  for (var i = 0; i < result.length; i += 2) {\n    arr.push([result[i], result[i + 1]]);\n  }\n  return arr;\n});\nredis.hset('h1', Buffer.from([0x01]), Buffer.from([0x02]));\nredis.hset('h1', Buffer.from([0x03]), Buffer.from([0x04]));\nredis.hgetallBuffer('h1', function (err, result) {\n  // result === [ [ <Buffer 01>, <Buffer 02> ], [ <Buffer 03>, <Buffer 04> ] ];\n});\n```\n\n## Monitor\nRedis supports the MONITOR command,\nwhich lets you see all commands received by the Redis server across all client connections,\nincluding from other client libraries and other computers.\n\nThe `monitor` method returns a monitor instance.\nAfter you send the MONITOR command, no other commands are valid on that connection. ioredis will emit a monitor event for every new monitor message that comes across.\nThe callback for the monitor event takes a timestamp from the Redis server and an array of command arguments.\n\nHere is a simple example:\n\n```javascript\nredis.monitor(function (err, monitor) {\n  monitor.on('monitor', function (time, args, source, database) {\n  });\n});\n```\n\n## Streamify Scanning\nRedis 2.8 added the `SCAN` command to incrementally iterate through the keys in the database. It's different from `KEYS` in that\n`SCAN` only returns a small number of elements each call, so it can be used in production without the downside\nof blocking the server for a long time. However, it requires recording the cursor on the client side each time\nthe `SCAN` command is called in order to iterate through all the keys correctly. Since it's a relatively common use case, ioredis\nprovides a streaming interface for the `SCAN` command to make things much easier. A readable stream can be created by calling `scanStream`:\n\n```javascript\nvar redis = new Redis();\n// Create a readable stream (object mode)\nvar stream = redis.scanStream();\nstream.on('data', function (resultKeys) {\n  // `resultKeys` is an array of strings representing key names.\n  // Note that resultKeys may contain 0 keys, and that it will sometimes\n  // contain duplicates due to SCAN's implementation in Redis.\n  for (var i = 0; i < resultKeys.length; i++) {\n    console.log(resultKeys[i]);\n  }\n});\nstream.on('end', function () {\n  console.log('all keys have been visited');\n});\n```\n\n`scanStream` accepts an option, with which you can specify the `MATCH` pattern and the `COUNT` argument:\n\n```javascript\nvar stream = redis.scanStream({\n  // only returns keys following the pattern of `user:*`\n  match: 'user:*',\n  // returns approximately 100 elements per call\n  count: 100\n});\n```\n\nJust like other commands, `scanStream` has a binary version `scanBufferStream`, which returns an array of buffers. It's useful when\nthe key names are not utf8 strings.\n\nThere are also `hscanStream`, `zscanStream` and `sscanStream` to iterate through elements in a hash, zset and set. The interface of each is\nsimilar to `scanStream` except the first argument is the key name:\n\n```javascript\nvar stream = redis.hscanStream('myhash', {\n  match: 'age:??'\n});\n```\n\nYou can learn more from the [Redis documentation](http://redis.io/commands/scan).\n\n**Useful Tips**\nIt's pretty common that doing an async task in the `data` handler. We'd like the scanning process to be paused until the async task to be finished. `Stream#pause()` and `Stream.resume()` do the trick. For example if we want to migrate data in Redis to MySQL:\n\n```javascript\nvar stream = redis.scanStream();\nstream.on('data', function (resultKeys) {\n  // Pause the stream from scanning more keys until we've migrated the current keys.\n  stream.pause();\n\n  Promise.all(resultKeys.map(migrateKeyToMySQL)).then(() => {\n    // Resume the stream here.\n    stream.resume();\n  });\n});\n\nstream.on('end', function () {\n  console.log('done migration');\n});\n```\n\n## Auto-reconnect\nBy default, ioredis will try to reconnect when the connection to Redis is lost\nexcept when the connection is closed manually by `redis.disconnect()` or `redis.quit()`.\n\nIt's very flexible to control how long to wait to reconnect after disconnection\nusing the `retryStrategy` option:\n\n```javascript\nvar redis = new Redis({\n  // This is the default value of `retryStrategy`\n  retryStrategy: function (times) {\n    var delay = Math.min(times * 50, 2000);\n    return delay;\n  }\n});\n```\n\n`retryStrategy` is a function that will be called when the connection is lost.\nThe argument `times` means this is the nth reconnection being made and\nthe return value represents how long (in ms) to wait to reconnect. When the\nreturn value isn't a number, ioredis will stop trying to reconnect, and the connection\nwill be lost forever if the user doesn't call `redis.connect()` manually.\n\nWhen reconnected, the client will auto subscribe to channels that the previous connection subscribed to.\nThis behavior can be disabled by setting the `autoResubscribe` option to `false`.\n\nAnd if the previous connection has some unfulfilled commands (most likely blocking commands such as `brpop` and `blpop`),\nthe client will resend them when reconnected. This behavior can be disabled by setting the `autoResendUnfulfilledCommands` option to `false`.\n\nBy default, all pending commands will be flushed with an error every 20 retry attempts. That makes sure commands won't wait forever when the connection is down. You can change this behavior by setting `maxRetriesPerRequest`:\n\n```javascript\nvar redis = new Redis({\n  maxRetriesPerRequest: 1\n});\n```\n\nSet maxRetriesPerRequest to `null` to disable this behavior, and every command will wait forever until the connection is alive again (which is the default behavior before ioredis v4).\n\n### Reconnect on error\n\nBesides auto-reconnect when the connection is closed, ioredis supports reconnecting on the specified errors by the `reconnectOnError` option. Here's an example that will reconnect when receiving `READONLY` error:\n\n```javascript\nvar redis = new Redis({\n  reconnectOnError: function (err) {\n    var targetError = 'READONLY';\n    if (err.message.slice(0, targetError.length) === targetError) {\n      // Only reconnect when the error starts with \"READONLY\"\n      return true; // or `return 1;`\n    }\n  }\n});\n```\n\nThis feature is useful when using Amazon ElastiCache. Once failover happens, Amazon ElastiCache will switch the master we currently connected with to a slave, leading to the following writes fails with the error `READONLY`. Using `reconnectOnError`, we can force the connection to reconnect on this error in order to connect to the new master.\n\nFurthermore, if the `reconnectOnError` returns `2`, ioredis will resend the failed command after reconnecting.\n\n## Connection Events\nThe Redis instance will emit some events about the state of the connection to the Redis server.\n\nEvent    | Description\n:------------- | :-------------\nconnect  | emits when a connection is established to the Redis server.\nready    | If `enableReadyCheck` is `true`, client will emit `ready` when the server reports that it is ready to receive commands (e.g. finish loading data from disk).<br>Otherwise, `ready` will be emitted immediately right after the `connect` event.\nerror    | emits when an error occurs while connecting.<br>However, ioredis emits all `error` events silently (only emits when there's at least one listener) so that your application won't crash if you're not listening to the `error` event.\nclose    | emits when an established Redis server connection has closed.\nreconnecting | emits after `close` when a reconnection will be made. The argument of the event is the time (in ms) before reconnecting.\nend     | emits after `close` when no more reconnections will be made, or the connection is failed to establish.\n\nYou can also check out the `Redis#status` property to get the current connection status.\n\nBesides the above connection events, there are several other custom events:\n\nEvent    | Description\n:------------- | :-------------\nselect   | emits when the database changed. The argument is the new db number.\n\n## Offline Queue\nWhen a command can't be processed by Redis (being sent before the `ready` event), by default, it's added to the offline queue and will be\nexecuted when it can be processed. You can disable this feature by setting the `enableOfflineQueue`\noption to `false`:\n\n```javascript\nvar redis = new Redis({ enableOfflineQueue: false });\n```\n\n## TLS Options\nRedis doesn't support TLS natively, however if the redis server you want to connect to is hosted behind a TLS proxy (e.g. [stunnel](https://www.stunnel.org/)) or is offered by a PaaS service that supports TLS connection (e.g. [Redis Labs](https://redislabs.com/)), you can set the `tls` option:\n\n```javascript\nvar redis = new Redis({\n  host: 'localhost',\n  tls: {\n    // Refer to `tls.connect()` section in\n    // https://nodejs.org/api/tls.html\n    // for all supported options\n    ca: fs.readFileSync('cert.pem')\n  }\n});\n```\n\n<hr>\n\n## Sentinel\nioredis supports Sentinel out of the box. It works transparently as all features that work when\nyou connect to a single node also work when you connect to a sentinel group. Make sure to run Redis >= 2.8.12 if you want to use this feature. Sentinels have a default port of 26379.\n\nTo connect using Sentinel, use:\n\n```javascript\nvar redis = new Redis({\n  sentinels: [{ host: 'localhost', port: 26379 }, { host: 'localhost', port: 26380 }],\n  name: 'mymaster'\n});\n\nredis.set('foo', 'bar');\n```\n\nThe arguments passed to the constructor are different from the ones you use to connect to a single node, where:\n\n* `name` identifies a group of Redis instances composed of a master and one or more slaves (`mymaster` in the example);\n* `sentinelPassword` (optional) password for Sentinel instances.\n* `sentinels` are a list of sentinels to connect to. The list does not need to enumerate all your sentinel instances, but a few so that if one is down the client will try the next one.\n* `role` (optional) with a value of `slave` will return a random slave from the Sentinel group.\n* `preferredSlaves` (optional) can be used to prefer a particular slave or set of slaves based on priority. It accepts a function or array.\n\nioredis **guarantees** that the node you connected to is always a master even after a failover. When a failover happens, instead of trying to reconnect to the failed node (which will be demoted to slave when it's available again), ioredis will ask sentinels for the new master node and connect to it. All commands sent during the failover are queued and will be executed when the new connection is established so that none of the commands will be lost.\n\nIt's possible to connect to a slave instead of a master by specifying the option `role` with the value of `slave` and ioredis will try to connect to a random slave of the specified master, with the guarantee that the connected node is always a slave. If the current node is promoted to master due to a failover, ioredis will disconnect from it and ask the sentinels for another slave node to connect to.\n\nIf you specify the option `preferredSlaves` along with `role: 'slave'` ioredis will attempt to use this value when selecting the slave from the pool of available slaves. The value of `preferredSlaves` should either be a function that accepts an array of avaiable slaves and returns a single result, or an array of slave values priorities by the lowest `prio` value first with a default value of `1`.\n\n```javascript\n// available slaves format\nvar availableSlaves = [{ ip: '127.0.0.1', port: '31231', flags: 'slave' }];\n\n// preferredSlaves array format\nvar preferredSlaves = [\n  { ip: '127.0.0.1', port: '31231', prio: 1 },\n  { ip: '127.0.0.1', port: '31232', prio: 2 }\n];\n\n// preferredSlaves function format\npreferredSlaves = function(availableSlaves) {\n  for (var i = 0; i < availableSlaves.length; i++) {\n    var slave = availableSlaves[i];\n    if (slave.ip === '127.0.0.1') {\n      if (slave.port === '31234') {\n        return slave;\n      }\n    }\n  }\n  // if no preferred slaves are available a random one is used\n  return false;\n};\n\nvar redis = new Redis({\n  sentinels: [{ host: '127.0.0.1', port: 26379 }, { host: '127.0.0.1', port: 26380 }],\n  name: 'mymaster',\n  role: 'slave',\n  preferredSlaves: preferredSlaves\n});\n```\n\nBesides the `retryStrategy` option, there's also a `sentinelRetryStrategy` in Sentinel mode which will be invoked when all the sentinel nodes are unreachable during connecting. If `sentinelRetryStrategy` returns a valid delay time, ioredis will try to reconnect from scratch. The default value of `sentinelRetryStrategy` is:\n\n```javascript\nfunction (times) {\n  var delay = Math.min(times * 10, 1000);\n  return delay;\n}\n```\n\n## Cluster\nRedis Cluster provides a way to run a Redis installation where data is automatically sharded across multiple Redis nodes.\nYou can connect to a Redis Cluster like this:\n\n```javascript\nvar Redis = require('ioredis');\n\nvar cluster = new Redis.Cluster([{\n  port: 6380,\n  host: '127.0.0.1'\n}, {\n  port: 6381,\n  host: '127.0.0.1'\n}]);\n\ncluster.set('foo', 'bar');\ncluster.get('foo', function (err, res) {\n  // res === 'bar'\n});\n```\n\n`Cluster` constructor accepts two arguments, where:\n\n0. The first argument is a list of nodes of the cluster you want to connect to.\nJust like Sentinel, the list does not need to enumerate all your cluster nodes,\nbut a few so that if one is unreachable the client will try the next one, and the client will discover other nodes automatically when at least one node is connected.\n0. The second argument is the options, where:\n\n    * `clusterRetryStrategy`: When none of the startup nodes are reachable, `clusterRetryStrategy` will be invoked. When a number is returned,\n    ioredis will try to reconnect to the startup nodes from scratch after the specified delay (in ms). Otherwise, an error of \"None of startup nodes is available\" will be returned.\n    The default value of this option is:\n\n        ```javascript\n        function (times) {\n          var delay = Math.min(100 + times * 2, 2000);\n          return delay;\n        }\n        ```\n\n        It's possible to modify the `startupNodes` property in order to switch to another set of nodes here:\n\n        ```javascript\n        function (times) {\n          this.startupNodes = [{ port: 6790, host: '127.0.0.1' }];\n          return Math.min(100 + times * 2, 2000);\n        }\n        ```\n\n    * `dnsLookup`: Alternative DNS lookup function (`dns.lookup()` is used by default).  It may be useful to override this in special cases, such as when AWS ElastiCache used with TLS enabled.\n    * `enableOfflineQueue`: Similar to the `enableOfflineQueue` option of `Redis` class.\n    * `enableReadyCheck`: When enabled, \"ready\" event will only be emitted when `CLUSTER INFO` command\n    reporting the cluster is ready for handling commands. Otherwise, it will be emitted immediately after \"connect\" is emitted.\n    * `scaleReads`: Config where to send the read queries. See below for more details.\n    * `maxRedirections`: When a cluster related error (e.g. `MOVED`, `ASK` and `CLUSTERDOWN` etc.) is received, the client will redirect the\n    command to another node. This option limits the max redirections allowed when sending a command. The default value is `16`.\n    * `retryDelayOnFailover`: If the target node is disconnected when sending a command,\n    ioredis will retry after the specified delay. The default value is `100`. You should make sure `retryDelayOnFailover * maxRedirections > cluster-node-timeout`\n    to insure that no command will fail during a failover.\n    * `retryDelayOnClusterDown`: When a cluster is down, all commands will be rejected with the error of `CLUSTERDOWN`. If this option is a number (by default, it is `100`), the client\n    will resend the commands after the specified time (in ms).\n    * `retryDelayOnTryAgain`: If this option is a number (by default, it is `100`), the client\n    will resend the commands rejected with `TRYAGAIN` error after the specified time (in ms).\n    * `redisOptions`: Default options passed to the constructor of `Redis` when connecting to a node.\n    * `slotsRefreshTimeout`: Milliseconds before a timeout occurs while refreshing slots from the cluster (default `1000`)\n    * `slotsRefreshInterval`: Milliseconds between every automatic slots refresh (default `5000`)\n\n### Read-write splitting\n\nA typical redis cluster contains three or more masters and several slaves for each master. It's possible to scale out redis cluster by sending read queries to slaves and write queries to masters by setting the `scaleReads` option.\n\n`scaleReads` is \"master\" by default, which means ioredis will never send any queries to slaves. There are other three available options:\n\n1. \"all\": Send write queries to masters and read queries to masters or slaves randomly.\n2. \"slave\": Send write queries to masters and read queries to slaves.\n3. a custom `function(nodes, command): node`: Will choose the custom function to select to which node to send read queries (write queries keep being sent to master). The first node in `nodes` is always the master serving the relevant slots. If the function returns an array of nodes, a random node of that list will be selected.\n\nFor example:\n\n```javascript\nvar cluster = new Redis.Cluster([/* nodes */], {\n  scaleReads: 'slave'\n});\ncluster.set('foo', 'bar'); // This query will be sent to one of the masters.\ncluster.get('foo', function (err, res) {\n  // This query will be sent to one of the slaves.\n});\n```\n\n**NB** In the code snippet above, the `res` may not be equal to \"bar\" because of the lag of replication between the master and slaves.\n\n### Running commands to multiple nodes\n\nEvery command will be sent to exactly one node. For commands containing keys, (e.g. `GET`, `SET` and `HGETALL`), ioredis sends them to the node that serving the keys, and for other commands not containing keys, (e.g. `INFO`, `KEYS` and `FLUSHDB`), ioredis sends them to a random node.\n\nSometimes you may want to send a command to multiple nodes (masters or slaves) of the cluster, you can get the nodes via `Cluster#nodes()` method.\n\n`Cluster#nodes()` accepts a parameter role, which can be \"master\", \"slave\" and \"all\" (default), and returns an array of `Redis` instance. For example:\n\n```javascript\n// Send `FLUSHDB` command to all slaves:\nvar slaves = cluster.nodes('slave');\nPromise.all(slaves.map(function (node) {\n  return node.flushdb();\n}));\n\n// Get keys of all the masters:\nvar masters = cluster.nodes('master');\nPromise.all(masters.map(function (node) {\n  return node.keys();\n})).then(function (keys) {\n  // keys: [['key1', 'key2'], ['key3', 'key4']]\n});\n```\n\n### NAT Mapping\nSometimes the cluster is hosted within a internal network that can only be accessed via a NAT (Network Address Translation) instance. See [Accessing ElastiCache from outside AWS](https://docs.aws.amazon.com/AmazonElastiCache/latest/red-ug/accessing-elasticache.html) as an example.\n\nYou can specify nat mapping rules via `natMap` option:\n\n```javascript\nconst cluster = new Redis.Cluster([{\n  host: '203.0.113.73',\n  port: 30001\n}], {\n  natMap: {\n    '10.0.1.230:30001': {host: '203.0.113.73', port: 30001},\n    '10.0.1.231:30001': {host: '203.0.113.73', port: 30002},\n    '10.0.1.232:30001': {host: '203.0.113.73', port: 30003}\n  }\n})\n```\n\nThis option is also useful when the cluster is running inside a Docker container.\n\n### Transaction and pipeline in Cluster mode\nAlmost all features that are supported by `Redis` are also supported by `Redis.Cluster`, e.g. custom commands, transaction and pipeline.\nHowever there are some differences when using transaction and pipeline in Cluster mode:\n\n0. All keys in a pipeline should belong to the same slot since ioredis sends all commands in a pipeline to the same node.\n0. You can't use `multi` without pipeline (aka `cluster.multi({ pipeline: false })`). This is because when you call `cluster.multi({ pipeline: false })`, ioredis doesn't know which node the `multi` command should be sent to.\n0. Chaining custom commands in the pipeline is not supported in Cluster mode.\n\nWhen any commands in a pipeline receives a `MOVED` or `ASK` error, ioredis will resend the whole pipeline to the specified node automatically if all of the following conditions are satisfied:\n\n0. All errors received in the pipeline are the same. For example, we won't resend the pipeline if we got two `MOVED` errors pointing to different nodes.\n0. All commands executed successfully are readonly commands. This makes sure that resending the pipeline won't have side effects.\n\n### Pub/Sub\nPub/Sub in cluster mode works exactly as the same as in standalone mode. Internally, when a node of the cluster receives a message, it will broadcast the message to the other nodes. ioredis makes sure that each message will only be received once by strictly subscribing one node at the same time.\n\n```javascript\nvar nodes = [/* nodes */];\nvar pub = new Redis.Cluster(nodes);\nvar sub = new Redis.Cluster(nodes);\nsub.on('message', function (channel, message) {\n  console.log(channel, message);\n});\n\nsub.subscribe('news', function () {\n  pub.publish('news', 'highlights');\n});\n```\n\n### Events\n\nEvent    | Description\n:------------- | :-------------\nconnect  | emits when a connection is established to the Redis server.\nready    | emits when `CLUSTER INFO` reporting the cluster is able to receive commands (if `enableReadyCheck` is `true`) or immediately after `connect` event (if `enableReadyCheck` is false).\nerror    | emits when an error occurs while connecting with a property of `lastNodeError` representing the last node error received. This event is emitted silently (only emitting if there's at least one listener).\nclose    | emits when an established Redis server connection has closed.\nreconnecting | emits after `close` when a reconnection will be made. The argument of the event is the time (in ms) before reconnecting.\nend     | emits after `close` when no more reconnections will be made.\n+node   | emits when a new node is connected.\n-node   | emits when a node is disconnected.\nnode error | emits when an error occurs when connecting to a node. The second argument indicates the address of the node.\n\n### Password\nSetting the `password` option to access password-protected clusters:\n\n```javascript\nvar Redis = require('ioredis');\nvar cluster = new Redis.Cluster(nodes, {\n  redisOptions: {\n    password: 'your-cluster-password'\n  }\n});\n```\n\nIf some of nodes in the cluster using a different password, you should specify them in the first parameter:\n\n```javascript\nvar Redis = require('ioredis');\nvar cluster = new Redis.Cluster([\n  // Use password \"password-for-30001\" for 30001\n  { port: 30001, password: 'password-for-30001'},\n  // Don't use password when accessing 30002\n  { port: 30002, password: null }\n  // Other nodes will use \"fallback-password\"\n], {\n  redisOptions: {\n    password: 'fallback-password'\n  }\n});\n```\n\n### Special note: AWS ElastiCache Clusters with TLS\n\nAWS ElastiCache for Redis (Clustered Mode) supports TLS encryption.  If you use\nthis, you may encounter errors with invalid certificates.  To resolve this\nissue, construct the `Cluster` with the `dnsLookup` option as follows:\n\n```javascript\nvar cluster = new Redis.Cluster(\n  [{\n    host: 'clustercfg.myCluster.abcdefg.xyz.cache.amazonaws.com',\n    port: 6379\n  }],\n  {\n    dnsLookup: (address, callback) => callback(null, address),\n    redisOptions: {\n      tls: {}\n    },\n  }\n};\n```\n\n<hr>\n\n# Error Handling\nAll the errors returned by the Redis server are instances of `ReplyError`, which can be accessed via `Redis`:\n\n```javascript\nvar Redis = require('ioredis');\nvar redis = new Redis();\n// This command causes a reply error since the SET command requires two arguments.\nredis.set('foo', function (err) {\n  err instanceof Redis.ReplyError\n});\n```\n\nThis is the error stack of the `ReplyError`:\n\n```\nReplyError: ERR wrong number of arguments for 'set' command\n    at ReplyParser._parseResult (/app/node_modules/ioredis/lib/parsers/javascript.js:60:14)\n    at ReplyParser.execute (/app/node_modules/ioredis/lib/parsers/javascript.js:178:20)\n    at Socket.<anonymous> (/app/node_modules/ioredis/lib/redis/event_handler.js:99:22)\n    at Socket.emit (events.js:97:17)\n    at readableAddChunk (_stream_readable.js:143:16)\n    at Socket.Readable.push (_stream_readable.js:106:10)\n    at TCP.onread (net.js:509:20)\n```\n\nBy default, the error stack doesn't make any sense because the whole stack happens in the ioredis\nmodule itself, not in your code. So it's not easy to find out where the error happens in your code.\nioredis provides an option `showFriendlyErrorStack` to solve the problem. When you enable\n`showFriendlyErrorStack`, ioredis will optimize the error stack for you:\n\n```javascript\nvar Redis = require('ioredis');\nvar redis = new Redis({ showFriendlyErrorStack: true });\nredis.set('foo');\n```\n\nAnd the output will be:\n\n```\nReplyError: ERR wrong number of arguments for 'set' command\n    at Object.<anonymous> (/app/index.js:3:7)\n    at Module._compile (module.js:446:26)\n    at Object.Module._extensions..js (module.js:464:10)\n    at Module.load (module.js:341:32)\n    at Function.Module._load (module.js:296:12)\n    at Function.Module.runMain (module.js:487:10)\n    at startup (node.js:111:16)\n    at node.js:799:3\n```\n\nThis time the stack tells you that the error happens on the third line in your code. Pretty sweet!\nHowever, it would decrease the performance significantly to optimize the error stack. So by\ndefault, this option is disabled and can only be used for debugging purposes. You **shouldn't** use this feature in a production environment.\n\n# Plugging in your own Promises Library\nIf you're an advanced user, you may want to plug in your own promise library like [bluebird](https://www.npmjs.com/package/bluebird). Just set Redis.Promise to your favorite ES6-style promise constructor and ioredis will use it.\n\n```javascript\nconst Redis = require('ioredis')\nRedis.Promise = require('bluebird')\n\nconst redis = new Redis()\n\n// Use bluebird\nassert.equal(redis.get().constructor, require('bluebird'))\n\n// You can change the Promise implementation at any time:\nRedis.Promise = global.Promise\nassert.equal(redis.get().constructor, global.Promise)\n```\n\n\n# Running tests\n\nStart a Redis server on 127.0.0.1:6379, and then:\n\n```shell\n$ npm test\n```\n\n`FLUSH ALL` will be invoked after each test, so make sure there's no valuable data in it before running tests.\n\nIf your testing environment does not let you spin up a Redis server [ioredis-mock](https://github.com/stipsan/ioredis-mock) is a drop-in replacement you can use in your tests. It aims to behave identically to ioredis connected to a Redis server so that your integration tests is easier to write and of better quality.\n\n# Debug\n\nYou can set the `DEBUG` env to `ioredis:*` to print debug info:\n\n```shell\n$ DEBUG=ioredis:* node app.js\n```\n\n# Join in!\n\nI'm happy to receive bug reports, fixes, documentation enhancements, and any other improvements.\n\nAnd since I'm not a native English speaker, if you find any grammar mistakes in the documentation, please also let me know. :)\n\n# Become a Sponsor\nOpen source is hard and time-consuming. If you want to invest in ioredis's future you can become a sponsor and make us spend more time on this library's improvements and new features.\n\n<a href=\"https://opencollective.com/ioredis\"><img src=\"https://opencollective.com/ioredis/tiers/sponsor.svg?avatarHeight=36\"></a>\n\nThank you for using ioredis :-)\n\n# Contributors\n\nThis project exists thanks to all the people who contribute:\n\n<a href=\"https://github.com/luin/ioredis/graphs/contributors\"><img src=\"https://opencollective.com/ioredis/contributors.svg?width=890&showBtn=false\" /></a>\n\n# License\n\nMIT\n\n\n[![FOSSA Status](https://app.fossa.io/api/projects/git%2Bgithub.com%2Fluin%2Fioredis.svg?type=large)](https://app.fossa.io/projects/git%2Bgithub.com%2Fluin%2Fioredis?ref=badge_large)\n","readmeFilename":"README.md","bugs":{"url":"https://github.com/luin/ioredis/issues"},"homepage":"https://github.com/luin/ioredis#readme","_id":"ioredis@4.11.0","_nodeVersion":"10.16.0","_npmVersion":"6.9.0","dist":{"integrity":"sha512-3FAz01BRVYNSdIu5YBHDM7xbL6LKApWP8j6ZhWPgN3xyC0zHA1mHdWVZ45O0K7P8GviUKcCt/odMxchLt9DWRg==","shasum":"2963471fcf883e187791162b77f7131bd10234f0","tarball":"https://registry.npmjs.org/ioredis/-/ioredis-4.11.0.tgz","fileCount":36,"unpackedSize":228651,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJdEjksCRA9TVsSAnZWagAA+JsQAImq8t+ZjLV55JOqbpRU\niU+2sQO9udLyp4/26et9U5In2bCEvul/7wMWyFFlWgdCGuFBv8SO8ejzXRew\nTC+hXOn1j0QWYVRNXyo7SF6XNgp6hmcSqpfMCgXp1AuF6VDtt85KD2p79OIJ\n2od8tA4Im+g8cL8Tn5fe/83IlMym3oiUBwt8IbMcQmFHlr9FIazbebnhvZ3M\nj0AHRT18jwx94jKN6CXtKldrOMm3mUFvGpIlErWaAzXZsM0HRVIaCJkVgRAv\nxCN6HmvxVbKGQZ6Q2f/M2aZ2I+tyOci7IIOuXmQh58XA3jwx0QysImDe08M6\nrIW173NQ8ZKqqG2tDPYECdtc48+7oUPNhxdx5R2Gn5FLOp5nQccgi5XgkZRp\nDsK/pFDFoGn9pvrmVo172jrkseD81H4RkHqvhn8LmdznII9dRESyJ4gQzChH\noPUs1A6IDkKvMk+Y8E+r49t+EZjBVRVkQl0yVHrCz7yWJcDMVT9XOZ2HunGu\nFL2jJSFygraqOhD8+rYQqe9XYLf57QbQi+WEWq+gbapg1ilsizh+tNZtxaZ+\nEEzD2PNouLde88vKdKr0Y5EUOB351FwoECvstK74BbBzGx2xJRSGR1AVRifA\np47osugfdtO/zpUwwlyoXmzl4ODWwkf+RFYvWCtKzhT3oareTjm5gMY2yA5J\np19z\r\n=BAwS\r\n-----END PGP SIGNATURE-----\r\n"},"maintainers":[{"email":"ioredis-robot@zihua.li","name":"ioredis-robot"},{"email":"i@zihua.li","name":"luin"}],"_npmUser":{"name":"luin","email":"i@zihua.li"},"directories":{},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/ioredis_4.11.0_1561475371392_0.6804043916716269"},"_hasShrinkwrap":false},"4.11.1":{"name":"ioredis","version":"4.11.1","description":"A robust, performance-focused and full-featured Redis client for Node.js.","main":"built/index.js","scripts":{"test":"TS_NODE_LOG_ERROR=true NODE_ENV=test mocha test/**/*.ts","test:cov":"TS_NODE_LOG_ERROR=true NODE_ENV=test node ./node_modules/istanbul/lib/cli.js cover --preserve-comments ./node_modules/mocha/bin/_mocha -- -r ts-node/register -R spec --exit test/**/*.ts","build":"rm -rf built && tsc","prepublishOnly":"npm run build && npm test","bench":"matcha benchmarks/*.js","semantic-release":"semantic-release"},"repository":{"type":"git","url":"git://github.com/luin/ioredis.git"},"keywords":["redis","cluster","sentinel","pipelining"],"author":{"name":"luin","email":"i@zihua.li","url":"http://zihua.li"},"license":"MIT","dependencies":{"cluster-key-slot":"^1.0.6","debug":"^4.1.1","denque":"^1.1.0","lodash.defaults":"^4.2.0","lodash.flatten":"^4.4.0","redis-commands":"1.5.0","redis-errors":"^1.2.0","redis-parser":"^3.0.0","standard-as-callback":"^2.0.1"},"devDependencies":{"@semantic-release/changelog":"^3.0.4","@semantic-release/git":"^7.0.12","@types/bluebird":"^3.5.27","@types/debug":"^4.1.4","@types/lodash.defaults":"^4.2.6","@types/lodash.flatten":"^4.4.6","@types/mocha":"^5.2.7","@types/node":"^12.0.2","@types/redis-errors":"1.2.0","@types/sinon":"^7.0.13","bluebird":"^3.5.4","chai":"^4.2.0","cz-conventional-changelog":"^2.0.0","istanbul":"^0.4.5","mocha":"^5.0.0","server-destroy":"^1.0.1","sinon":"^7.3.2","ts-node":"^8.1.0","typescript":"^3.5.1"},"engines":{"node":">=6"},"config":{"commitizen":{"path":"./node_modules/cz-conventional-changelog"}},"gitHead":"4159a0b07e85c90897c00e5f6b20b3fb8af3a6cc","bugs":{"url":"https://github.com/luin/ioredis/issues"},"homepage":"https://github.com/luin/ioredis#readme","_id":"ioredis@4.11.1","_nodeVersion":"10.16.0","_npmVersion":"6.9.0","dist":{"integrity":"sha512-Qnp7ecb3WeaL7ojeSlb0UBRXmsRMMFcjM+PaAcap8FLLf1NznRD6x96/PS2DEqoRfdM9WVffAjIIYuUp+q3zEw==","shasum":"cf14cf923b10a772d7e1eafed89f707e05760f48","tarball":"https://registry.npmjs.org/ioredis/-/ioredis-4.11.1.tgz","fileCount":36,"unpackedSize":228913,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJdEunkCRA9TVsSAnZWagAA0iYP+wWxuGDxHTcE4kAC2aCo\nzugASxEkvo4SG7ujbispUCX5T5BTVifMqDZpaEPkK8z8bQLl1FXh/Jpc6bxG\nnRaNAI4u3yACiDXgHho7cAgzaxjdNyYu+4QGCZzuaBn7cMOOuMjhxggbXVuh\n9DUJV3p4aGFc/C+IaIhTj9pk/zGPGN4DZ8Q+4nmiJ8xyt5PSkc8TkGLO1xBZ\nU3Vdp9mnrGEWUtdDFZGBpSFzmXhQMtNd6T2pd0ZqhBEZZyYnmE6PbxQ786hk\nVb7kICG8/YNLnasAueP5A5RulD/+zDRs/bXkGkbNZcZFx6lLuSb6bO1p99QY\npT5EeLeSTOWXoqAPdxXJBoziZY2ryFOG1joQWODCV4zg2DVt+kMcigF+xwRp\nvrN73NH2Wm9ElOgScGwOndkdjLP5h8yMI3h0yw2CBE9HyuCR6yLSjFnYh/Sv\nRfqPuvkXr6yJ/2nptxidiKlSUBEosuI+7jZccoptdT3uzA/bAYdAjqGPqh4x\nqbQpgzNg/zIPaKJSA89kVLsdi7hpJ12JNBJXzsjvHMDm0wTYgmnc7tAs6IEO\no8Mk9Dky6XuH8R/xa832NphVmPse01JhH2AQC6DSoT1Jsy9y3fuvYCc7OX4W\nKx7jDzCWivqmKXxN621VbZN1MV3DtjUYXE6Hdfp5rp5MeXgBiAP8NkOsrItl\nTvww\r\n=gyql\r\n-----END PGP SIGNATURE-----\r\n"},"maintainers":[{"email":"ioredis-robot@zihua.li","name":"ioredis-robot"},{"email":"i@zihua.li","name":"luin"}],"_npmUser":{"name":"luin","email":"i@zihua.li"},"directories":{},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/ioredis_4.11.1_1561520611431_0.5462590208446436"},"_hasShrinkwrap":false},"4.11.2":{"name":"ioredis","version":"4.11.2","description":"A robust, performance-focused and full-featured Redis client for Node.js.","main":"built/index.js","scripts":{"test":"TS_NODE_LOG_ERROR=true NODE_ENV=test mocha test/**/*.ts","test:cov":"TS_NODE_LOG_ERROR=true NODE_ENV=test node ./node_modules/istanbul/lib/cli.js cover --preserve-comments ./node_modules/mocha/bin/_mocha -- -r ts-node/register -R spec --exit test/**/*.ts","lint":"eslint --ext .js,.ts .","format":"prettier --write \"{,!(node_modules)/**/}*.{js,ts}\"","format-check":"prettier --check \"{,!(node_modules)/**/}*.{js,ts}\"","build":"rm -rf built && tsc","prepublishOnly":"npm run build && npm test","bench":"matcha benchmarks/*.js","semantic-release":"semantic-release"},"repository":{"type":"git","url":"git://github.com/luin/ioredis.git"},"keywords":["redis","cluster","sentinel","pipelining"],"author":{"name":"luin","email":"i@zihua.li","url":"http://zihua.li"},"license":"MIT","dependencies":{"cluster-key-slot":"^1.0.6","debug":"^4.1.1","denque":"^1.1.0","lodash.defaults":"^4.2.0","lodash.flatten":"^4.4.0","redis-commands":"1.5.0","redis-errors":"^1.2.0","redis-parser":"^3.0.0","standard-as-callback":"^2.0.1"},"devDependencies":{"@semantic-release/changelog":"^3.0.4","@semantic-release/git":"^7.0.12","@types/bluebird":"^3.5.27","@types/debug":"^4.1.4","@types/lodash.defaults":"^4.2.6","@types/lodash.flatten":"^4.4.6","@types/mocha":"^5.2.7","@types/node":"^12.0.2","@types/redis-errors":"1.2.0","@types/sinon":"^7.0.13","@typescript-eslint/eslint-plugin":"^1.11.0","@typescript-eslint/parser":"^1.11.0","bluebird":"^3.5.4","chai":"^4.2.0","cz-conventional-changelog":"^2.0.0","eslint":"^5.16.0","eslint-config-prettier":"^5.1.0","husky":"^2.5.0","istanbul":"^0.4.5","mocha":"^5.0.0","prettier":"^1.18.2","pretty-quick":"^1.11.1","server-destroy":"^1.0.1","sinon":"^7.3.2","ts-node":"^8.1.0","typescript":"^3.5.1"},"engines":{"node":">=6"},"config":{"commitizen":{"path":"./node_modules/cz-conventional-changelog"}},"husky":{"hooks":{"pre-commit":"pretty-quick --staged"}},"gitHead":"c5af1fcbf88833541bf4e6f2b768fc2fd43fff71","bugs":{"url":"https://github.com/luin/ioredis/issues"},"homepage":"https://github.com/luin/ioredis#readme","_id":"ioredis@4.11.2","_nodeVersion":"10.16.0","_npmVersion":"6.9.0","dist":{"integrity":"sha512-2lQM1jpTzoTPg9Lj+ayfcIn8rdvGwgNP/nzeJ7IW4va/ExqxttRnTlUaxa8jOsj/e4NYKtVkbuhEAvOVPwjztA==","shasum":"b76c1a8290f581ce30af3fd00f27d38a301472c6","tarball":"https://registry.npmjs.org/ioredis/-/ioredis-4.11.2.tgz","fileCount":36,"unpackedSize":234626,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJdKgu3CRA9TVsSAnZWagAAkioQAJb+x2DFHQdiSRNgiCPK\njlQCEOTRYJBrnuKiWNzD9iTlvADkAnX1aLJs6Rx/vztycbP1dF7+2167ACah\nANSECQCMPE58sBJqFXYiVmSaGY/WIPBbql8YKF6ia4knlHiqi7j7ULGg1/12\nzVQkJ+Xn4j3WR7ZhMTHEw9+Op4FiU65h07AQ9YteFiGperoYDgYOZTPaOQUX\nkPRTH+wc22/hcHEdRqtV8DfNDVwVjoyIfqze/19ZSUlmdQuatOt0inzF1Grx\nF7T6jpIccMP/qn3UtBs8fJ/LX5HsCYcIJtTEagvasdVYiz+ckqoNQ2NdXqll\nU2C6/vTa5dh1HqddE3D8EzNCOSBP7dmU0eu24Si82Anci6BPmHCW7LdtJ3PW\n37xBUJGuiFkqi4YIG4bNu6mdJcLG9+4kXHMDEPXToIp3L6L/A8jUKAVu5Rgo\nBr3Ll7K6OTCLvuqCfRJmLZR7Vm6iJZLqds8jDP+X2fpxd7FB6lW5GZq+Tqf3\nxKxhBJhO1dbb6p9RKXrDyunsXJDQ7wfciz9JmktMr7CSI6+Ffov+o5dih5e2\n0eL3ZKKpXUblzS5qTcClTXtxQcGUqw+O0PZqYkMuRwgCe3w0IfSxlufZSLr7\nqeaF4xle30NqZ2ecQZbLpmQ/YAeSti4uyRoe06CjSI64cX5UKm5ocWjdenSb\n5z3o\r\n=+JQk\r\n-----END PGP SIGNATURE-----\r\n"},"maintainers":[{"email":"ioredis-robot@zihua.li","name":"ioredis-robot"},{"email":"i@zihua.li","name":"luin"}],"_npmUser":{"name":"luin","email":"i@zihua.li"},"directories":{},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/ioredis_4.11.2_1563036598515_0.17077107273587577"},"_hasShrinkwrap":false},"4.12.0":{"name":"ioredis","version":"4.12.0","description":"A robust, performance-focused and full-featured Redis client for Node.js.","main":"built/index.js","scripts":{"test":"TS_NODE_TRANSPILE_ONLY=true TS_NODE_LOG_ERROR=true NODE_ENV=test mocha \"test/**/*.ts\"","test:cov":"TS_NODE_TRANSPILE_ONLY=true TS_NODE_LOG_ERROR=true NODE_ENV=test node ./node_modules/istanbul/lib/cli.js cover --preserve-comments ./node_modules/mocha/bin/_mocha -- -r ts-node/register -R spec --exit \"test/**/*.ts\"","lint":"eslint --ext .js,.ts .","format":"prettier --write \"{,!(node_modules)/**/}*.{js,ts}\"","format-check":"prettier --check \"{,!(node_modules)/**/}*.{js,ts}\"","build":"rm -rf built && tsc","prepublishOnly":"npm run build && npm test","bench":"matcha benchmarks/*.js","semantic-release":"semantic-release"},"repository":{"type":"git","url":"git://github.com/luin/ioredis.git"},"keywords":["redis","cluster","sentinel","pipelining"],"author":{"name":"luin","email":"i@zihua.li","url":"http://zihua.li"},"license":"MIT","dependencies":{"cluster-key-slot":"^1.0.6","debug":"^4.1.1","denque":"^1.1.0","lodash.defaults":"^4.2.0","lodash.flatten":"^4.4.0","redis-commands":"1.5.0","redis-errors":"^1.2.0","redis-parser":"^3.0.0","standard-as-callback":"^2.0.1"},"devDependencies":{"@semantic-release/changelog":"^3.0.4","@semantic-release/git":"^7.0.12","@types/bluebird":"^3.5.27","@types/chai":"^4.1.7","@types/debug":"^4.1.4","@types/lodash.defaults":"^4.2.6","@types/lodash.flatten":"^4.4.6","@types/mocha":"^5.2.7","@types/node":"^12.0.2","@types/redis-errors":"1.2.0","@types/sinon":"^7.0.13","@typescript-eslint/eslint-plugin":"^1.11.0","@typescript-eslint/parser":"^1.11.0","bluebird":"^3.5.4","chai":"^4.2.0","cz-conventional-changelog":"^2.0.0","eslint":"^5.16.0","eslint-config-prettier":"^5.1.0","husky":"^2.5.0","istanbul":"^0.4.5","mocha":"^5.0.0","prettier":"^1.18.2","pretty-quick":"^1.11.1","server-destroy":"^1.0.1","sinon":"^7.3.2","ts-node":"^8.1.0","typescript":"^3.5.1"},"engines":{"node":">=6"},"config":{"commitizen":{"path":"./node_modules/cz-conventional-changelog"}},"husky":{"hooks":{"pre-commit":"pretty-quick --staged"}},"gitHead":"7defb6bbf71c632beb03c4e8e800e3cb748fe479","readme":"[![ioredis](https://cdn.jsdelivr.net/gh/luin/ioredis@b5e8c74/logo.svg)](https://github.com/luin/ioredis)\n\n[![Build Status](https://travis-ci.org/luin/ioredis.svg?branch=master)](https://travis-ci.org/luin/ioredis)\n[![Test Coverage](https://codeclimate.com/github/luin/ioredis/badges/coverage.svg)](https://codeclimate.com/github/luin/ioredis)\n[![code style: prettier](https://img.shields.io/badge/code_style-prettier-ff69b4.svg?style=flat-square)](https://github.com/prettier/prettier)\n[![Join the chat at https://gitter.im/luin/ioredis](https://badges.gitter.im/Join%20Chat.svg)](https://gitter.im/luin/ioredis?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge)\n[![Commitizen friendly](https://img.shields.io/badge/commitizen-friendly-brightgreen.svg)](http://commitizen.github.io/cz-cli/)\n[![semantic-release](https://img.shields.io/badge/%20%20%F0%9F%93%A6%F0%9F%9A%80-semantic--release-e10079.svg)](https://github.com/semantic-release/semantic-release)\n[![npm latest version](https://img.shields.io/npm/v/ioredis/latest.svg)](https://www.npmjs.com/package/ioredis)\n[![npm next version](https://img.shields.io/npm/v/ioredis/next.svg)](https://www.npmjs.com/package/ioredis)\n<img alt=\"\" src=\"\">\n\nA robust, performance-focused and full-featured [Redis](http://redis.io) client for [Node.js](https://nodejs.org).\n\nSupports Redis >= 2.6.12 and (Node.js >= 6).\n\n# Features\n\nioredis is a robust, full-featured Redis client that is\nused in the world's biggest online commerce company [Alibaba](http://www.alibaba.com/) and many other awesome companies.\n\n0. Full-featured. It supports [Cluster](http://redis.io/topics/cluster-tutorial), [Sentinel](http://redis.io/topics/sentinel), [Pipelining](http://redis.io/topics/pipelining) and of course [Lua scripting](http://redis.io/commands/eval) & [Pub/Sub](http://redis.io/topics/pubsub) (with the support of binary messages).\n1. High performance.\n2. Delightful API. It works with Node callbacks and Native promises.\n3. Transformation of command arguments and replies.\n4. Transparent key prefixing.\n5. Abstraction for Lua scripting, allowing you to define custom commands.\n6. Support for binary data.\n7. Support for TLS.\n8. Support for offline queue and ready checking.\n9. Support for ES6 types, such as `Map` and `Set`.\n10. Support for GEO commands (Redis 3.2 Unstable).\n11. Sophisticated error handling strategy.\n12. Support for NAT mapping.\n\n# Links\n\n- [API Documentation](API.md)\n- [Changelog](Changelog.md)\n- [Migrating from node_redis](https://github.com/luin/ioredis/wiki/Migrating-from-node_redis)\n- [Error Handling](#error-handling)\n\n<hr>\n<a href=\"http://bit.ly/medis-macos\"><img align=\"right\" src=\"resources/medis.png\" alt=\"Download on the App Store\"></a>\n\n### [AD] Medis: Redis GUI for OS X\n\nLooking for a Redis GUI manager for OS X, Windows and Linux? Here's [Medis](http://bit.ly/medis-macos)!\n\nMedis is an open-sourced, beautiful, easy-to-use Redis GUI management application.\n\nMedis starts with all the basic features you need:\n\n- Keys viewing/editing\n- SSH Tunnel for connecting with remote servers\n- Terminal for executing custom commands\n- JSON/MessagePack format viewing/editing and built-in highlighting/validator\n- And other awesome features...\n\n[Medis is open sourced on GitHub](https://github.com/luin/medis)\n\n### [AD] Kuber: Kubernetes Dashboard for iOS\n\n<a href=\"http://bit.ly/kuber-ios\"><img src=\"resources/kuber.png\" alt=\"Download on the App Store\"></a>\n\n<hr>\n\n# Quick Start\n\n## Install\n\n```shell\n$ npm install ioredis\n```\n\n## Basic Usage\n\n```javascript\nvar Redis = require(\"ioredis\");\nvar redis = new Redis();\n\nredis.set(\"foo\", \"bar\");\nredis.get(\"foo\", function(err, result) {\n  console.log(result);\n});\nredis.del(\"foo\");\n\n// Or using a promise if the last argument isn't a function\nredis.get(\"foo\").then(function(result) {\n  console.log(result);\n});\n\n// Arguments to commands are flattened, so the following are the same:\nredis.sadd(\"set\", 1, 3, 5, 7);\nredis.sadd(\"set\", [1, 3, 5, 7]);\n\n// All arguments are passed directly to the redis server:\nredis.set(\"key\", 100, \"EX\", 10);\n```\n\nSee the `examples/` folder for more examples.\n\n## Connect to Redis\n\nWhen a new `Redis` instance is created,\na connection to Redis will be created at the same time.\nYou can specify which Redis to connect to by:\n\n```javascript\nnew Redis(); // Connect to 127.0.0.1:6379\nnew Redis(6380); // 127.0.0.1:6380\nnew Redis(6379, \"192.168.1.1\"); // 192.168.1.1:6379\nnew Redis(\"/tmp/redis.sock\");\nnew Redis({\n  port: 6379, // Redis port\n  host: \"127.0.0.1\", // Redis host\n  family: 4, // 4 (IPv4) or 6 (IPv6)\n  password: \"auth\",\n  db: 0\n});\n```\n\nYou can also specify connection options as a [`redis://` URL](http://www.iana.org/assignments/uri-schemes/prov/redis):\n\n```javascript\n// Connect to 127.0.0.1:6380, db 4, using password \"authpassword\":\nnew Redis(\"redis://:authpassword@127.0.0.1:6380/4\");\n```\n\nSee [API Documentation](API.md#new_Redis) for all available options.\n\n## Pub/Sub\n\nHere is a simple example of the API for publish/subscribe.\nThe following program opens two client connections.\nIt subscribes to a channel with one connection\nand publishes to that channel with the other:\n\n```javascript\nvar Redis = require(\"ioredis\");\nvar redis = new Redis();\nvar pub = new Redis();\nredis.subscribe(\"news\", \"music\", function(err, count) {\n  // Now we are subscribed to both the 'news' and 'music' channels.\n  // `count` represents the number of channels we are currently subscribed to.\n\n  pub.publish(\"news\", \"Hello world!\");\n  pub.publish(\"music\", \"Hello again!\");\n});\n\nredis.on(\"message\", function(channel, message) {\n  // Receive message Hello world! from channel news\n  // Receive message Hello again! from channel music\n  console.log(\"Receive message %s from channel %s\", message, channel);\n});\n\n// There's also an event called 'messageBuffer', which is the same as 'message' except\n// it returns buffers instead of strings.\nredis.on(\"messageBuffer\", function(channel, message) {\n  // Both `channel` and `message` are buffers.\n});\n```\n\n`PSUBSCRIBE` is also supported in a similar way:\n\n```javascript\nredis.psubscribe(\"pat?ern\", function(err, count) {});\nredis.on(\"pmessage\", function(pattern, channel, message) {});\nredis.on(\"pmessageBuffer\", function(pattern, channel, message) {});\n```\n\nWhen a client issues a SUBSCRIBE or PSUBSCRIBE, that connection is put into a \"subscriber\" mode.\nAt that point, only commands that modify the subscription set are valid.\nWhen the subscription set is empty, the connection is put back into regular mode.\n\nIf you need to send regular commands to Redis while in subscriber mode, just open another connection.\n\n## Handle Binary Data\n\nArguments can be buffers:\n\n```javascript\nredis.set(\"foo\", Buffer.from(\"bar\"));\n```\n\nAnd every command has a method that returns a Buffer (by adding a suffix of \"Buffer\" to the command name).\nTo get a buffer instead of a utf8 string:\n\n```javascript\nredis.getBuffer(\"foo\", function(err, result) {\n  // result is a buffer.\n});\n```\n\n## Pipelining\n\nIf you want to send a batch of commands (e.g. > 5), you can use pipelining to queue\nthe commands in memory and then send them to Redis all at once. This way the performance improves by 50%~300% (See [benchmark section](#benchmark)).\n\n`redis.pipeline()` creates a `Pipeline` instance. You can call any Redis\ncommands on it just like the `Redis` instance. The commands are queued in memory\nand flushed to Redis by calling the `exec` method:\n\n```javascript\nvar pipeline = redis.pipeline();\npipeline.set(\"foo\", \"bar\");\npipeline.del(\"cc\");\npipeline.exec(function(err, results) {\n  // `err` is always null, and `results` is an array of responses\n  // corresponding to the sequence of queued commands.\n  // Each response follows the format `[err, result]`.\n});\n\n// You can even chain the commands:\nredis\n  .pipeline()\n  .set(\"foo\", \"bar\")\n  .del(\"cc\")\n  .exec(function(err, results) {});\n\n// `exec` also returns a Promise:\nvar promise = redis\n  .pipeline()\n  .set(\"foo\", \"bar\")\n  .get(\"foo\")\n  .exec();\npromise.then(function(result) {\n  // result === [[null, 'OK'], [null, 'bar']]\n});\n```\n\nEach chained command can also have a callback, which will be invoked when the command\ngets a reply:\n\n```javascript\nredis\n  .pipeline()\n  .set(\"foo\", \"bar\")\n  .get(\"foo\", function(err, result) {\n    // result === 'bar'\n  })\n  .exec(function(err, result) {\n    // result[1][1] === 'bar'\n  });\n```\n\nIn addition to adding commands to the `pipeline` queue individually, you can also pass an array of commands and arguments to the constructor:\n\n```javascript\nredis.pipeline([[\"set\", \"foo\", \"bar\"], [\"get\", \"foo\"]]).exec(function() {\n  /* ... */\n});\n```\n\n`#length` property shows how many commands in the pipeline:\n\n```javascript\nconst length = redis\n  .pipeline()\n  .set(\"foo\", \"bar\")\n  .get(\"foo\").length;\n// length === 2\n```\n\n## Transaction\n\nMost of the time, the transaction commands `multi` & `exec` are used together with pipeline.\nTherefore, when `multi` is called, a `Pipeline` instance is created automatically by default,\nso you can use `multi` just like `pipeline`:\n\n```javascript\nredis\n  .multi()\n  .set(\"foo\", \"bar\")\n  .get(\"foo\")\n  .exec(function(err, results) {\n    // results === [[null, 'OK'], [null, 'bar']]\n  });\n```\n\nIf there's a syntax error in the transaction's command chain (e.g. wrong number of arguments, wrong command name, etc),\nthen none of the commands would be executed, and an error is returned:\n\n```javascript\nredis\n  .multi()\n  .set(\"foo\")\n  .set(\"foo\", \"new value\")\n  .exec(function(err, results) {\n    // err:\n    //  { [ReplyError: EXECABORT Transaction discarded because of previous errors.]\n    //    name: 'ReplyError',\n    //    message: 'EXECABORT Transaction discarded because of previous errors.',\n    //    command: { name: 'exec', args: [] },\n    //    previousErrors:\n    //     [ { [ReplyError: ERR wrong number of arguments for 'set' command]\n    //         name: 'ReplyError',\n    //         message: 'ERR wrong number of arguments for \\'set\\' command',\n    //         command: [Object] } ] }\n  });\n```\n\nIn terms of the interface, `multi` differs from `pipeline` in that when specifying a callback\nto each chained command, the queueing state is passed to the callback instead of the result of the command:\n\n```javascript\nredis\n  .multi()\n  .set(\"foo\", \"bar\", function(err, result) {\n    // result === 'QUEUED'\n  })\n  .exec(/* ... */);\n```\n\nIf you want to use transaction without pipeline, pass `{ pipeline: false }` to `multi`,\nand every command will be sent to Redis immediately without waiting for an `exec` invocation:\n\n```javascript\nredis.multi({ pipeline: false });\nredis.set(\"foo\", \"bar\");\nredis.get(\"foo\");\nredis.exec(function(err, result) {\n  // result === [[null, 'OK'], [null, 'bar']]\n});\n```\n\nThe constructor of `multi` also accepts a batch of commands:\n\n```javascript\nredis.multi([[\"set\", \"foo\", \"bar\"], [\"get\", \"foo\"]]).exec(function() {\n  /* ... */\n});\n```\n\nInline transactions are supported by pipeline, which means you can group a subset of commands\nin the pipeline into a transaction:\n\n```javascript\nredis\n  .pipeline()\n  .get(\"foo\")\n  .multi()\n  .set(\"foo\", \"bar\")\n  .get(\"foo\")\n  .exec()\n  .get(\"foo\")\n  .exec();\n```\n\n## Lua Scripting\n\nioredis supports all of the scripting commands such as `EVAL`, `EVALSHA` and `SCRIPT`.\nHowever, it's tedious to use in real world scenarios since developers have to take\ncare of script caching and to detect when to use `EVAL` and when to use `EVALSHA`.\nioredis expose a `defineCommand` method to make scripting much easier to use:\n\n```javascript\nvar redis = new Redis();\n\n// This will define a command echo:\nredis.defineCommand(\"echo\", {\n  numberOfKeys: 2,\n  lua: \"return {KEYS[1],KEYS[2],ARGV[1],ARGV[2]}\"\n});\n\n// Now `echo` can be used just like any other ordinary command,\n// and ioredis will try to use `EVALSHA` internally when possible for better performance.\nredis.echo(\"k1\", \"k2\", \"a1\", \"a2\", function(err, result) {\n  // result === ['k1', 'k2', 'a1', 'a2']\n});\n\n// `echoBuffer` is also defined automatically to return buffers instead of strings:\nredis.echoBuffer(\"k1\", \"k2\", \"a1\", \"a2\", function(err, result) {\n  // result[0] equals to Buffer.from('k1');\n});\n\n// And of course it works with pipeline:\nredis\n  .pipeline()\n  .set(\"foo\", \"bar\")\n  .echo(\"k1\", \"k2\", \"a1\", \"a2\")\n  .exec();\n```\n\nIf the number of keys can't be determined when defining a command, you can\nomit the `numberOfKeys` property and pass the number of keys as the first argument\nwhen you call the command:\n\n```javascript\nredis.defineCommand(\"echoDynamicKeyNumber\", {\n  lua: \"return {KEYS[1],KEYS[2],ARGV[1],ARGV[2]}\"\n});\n\n// Now you have to pass the number of keys as the first argument every time\n// you invoke the `echoDynamicKeyNumber` command:\nredis.echoDynamicKeyNumber(2, \"k1\", \"k2\", \"a1\", \"a2\", function(err, result) {\n  // result === ['k1', 'k2', 'a1', 'a2']\n});\n```\n\n## Transparent Key Prefixing\n\nThis feature allows you to specify a string that will automatically be prepended\nto all the keys in a command, which makes it easier to manage your key\nnamespaces.\n\n**Warning** This feature won't apply to commands like [KEYS](http://redis.io/commands/KEYS) and [SCAN](http://redis.io/commands/scan) that take patterns rather than actual keys([#239](https://github.com/luin/ioredis/issues/239)),\nand this feature also won't apply to the replies of commands even they are key names ([#325](https://github.com/luin/ioredis/issues/325)).\n\n```javascript\nvar fooRedis = new Redis({ keyPrefix: \"foo:\" });\nfooRedis.set(\"bar\", \"baz\"); // Actually sends SET foo:bar baz\n\nfooRedis.defineCommand(\"echo\", {\n  numberOfKeys: 2,\n  lua: \"return {KEYS[1],KEYS[2],ARGV[1],ARGV[2]}\"\n});\n\n// Works well with pipelining/transaction\nfooRedis\n  .pipeline()\n  // Sends SORT foo:list BY foo:weight_*->fieldname\n  .sort(\"list\", \"BY\", \"weight_*->fieldname\")\n  // Supports custom commands\n  // Sends EVALSHA xxx foo:k1 foo:k2 a1 a2\n  .echo(\"k1\", \"k2\", \"a1\", \"a2\")\n  .exec();\n```\n\n## Transforming Arguments & Replies\n\nMost Redis commands take one or more Strings as arguments,\nand replies are sent back as a single String or an Array of Strings. However, sometimes\nyou may want something different. For instance, it would be more convenient if the `HGETALL`\ncommand returns a hash (e.g. `{ key: val1, key2: v2 }`) rather than an array of key values (e.g. `[key1, val1, key2, val2]`).\n\nioredis has a flexible system for transforming arguments and replies. There are two types\nof transformers, argument transformer and reply transformer:\n\n```javascript\nvar Redis = require(\"ioredis\");\n\n// Here's the built-in argument transformer converting\n// hmset('key', { k1: 'v1', k2: 'v2' })\n// or\n// hmset('key', new Map([['k1', 'v1'], ['k2', 'v2']]))\n// into\n// hmset('key', 'k1', 'v1', 'k2', 'v2')\nRedis.Command.setArgumentTransformer(\"hmset\", function(args) {\n  if (args.length === 2) {\n    if (typeof Map !== \"undefined\" && args[1] instanceof Map) {\n      // utils is a internal module of ioredis\n      return [args[0]].concat(utils.convertMapToArray(args[1]));\n    }\n    if (typeof args[1] === \"object\" && args[1] !== null) {\n      return [args[0]].concat(utils.convertObjectToArray(args[1]));\n    }\n  }\n  return args;\n});\n\n// Here's the built-in reply transformer converting the HGETALL reply\n// ['k1', 'v1', 'k2', 'v2']\n// into\n// { k1: 'v1', 'k2': 'v2' }\nRedis.Command.setReplyTransformer(\"hgetall\", function(result) {\n  if (Array.isArray(result)) {\n    var obj = {};\n    for (var i = 0; i < result.length; i += 2) {\n      obj[result[i]] = result[i + 1];\n    }\n    return obj;\n  }\n  return result;\n});\n```\n\nThere are three built-in transformers, two argument transformers for `hmset` & `mset` and\na reply transformer for `hgetall`. Transformers for `hmset` and `hgetall` were mentioned\nabove, and the transformer for `mset` is similar to the one for `hmset`:\n\n```javascript\nredis.mset({ k1: \"v1\", k2: \"v2\" });\nredis.get(\"k1\", function(err, result) {\n  // result === 'v1';\n});\n\nredis.mset(new Map([[\"k3\", \"v3\"], [\"k4\", \"v4\"]]));\nredis.get(\"k3\", function(err, result) {\n  // result === 'v3';\n});\n```\n\nAnother useful example of a reply transformer is one that changes `hgetall` to return array of arrays instead of objects which avoids a unwanted conversation of hash keys to strings when dealing with binary hash keys:\n\n```javascript\nRedis.Command.setReplyTransformer(\"hgetall\", function(result) {\n  var arr = [];\n  for (var i = 0; i < result.length; i += 2) {\n    arr.push([result[i], result[i + 1]]);\n  }\n  return arr;\n});\nredis.hset(\"h1\", Buffer.from([0x01]), Buffer.from([0x02]));\nredis.hset(\"h1\", Buffer.from([0x03]), Buffer.from([0x04]));\nredis.hgetallBuffer(\"h1\", function(err, result) {\n  // result === [ [ <Buffer 01>, <Buffer 02> ], [ <Buffer 03>, <Buffer 04> ] ];\n});\n```\n\n## Monitor\n\nRedis supports the MONITOR command,\nwhich lets you see all commands received by the Redis server across all client connections,\nincluding from other client libraries and other computers.\n\nThe `monitor` method returns a monitor instance.\nAfter you send the MONITOR command, no other commands are valid on that connection. ioredis will emit a monitor event for every new monitor message that comes across.\nThe callback for the monitor event takes a timestamp from the Redis server and an array of command arguments.\n\nHere is a simple example:\n\n```javascript\nredis.monitor(function(err, monitor) {\n  monitor.on(\"monitor\", function(time, args, source, database) {});\n});\n```\n\n## Streamify Scanning\n\nRedis 2.8 added the `SCAN` command to incrementally iterate through the keys in the database. It's different from `KEYS` in that\n`SCAN` only returns a small number of elements each call, so it can be used in production without the downside\nof blocking the server for a long time. However, it requires recording the cursor on the client side each time\nthe `SCAN` command is called in order to iterate through all the keys correctly. Since it's a relatively common use case, ioredis\nprovides a streaming interface for the `SCAN` command to make things much easier. A readable stream can be created by calling `scanStream`:\n\n```javascript\nvar redis = new Redis();\n// Create a readable stream (object mode)\nvar stream = redis.scanStream();\nstream.on(\"data\", function(resultKeys) {\n  // `resultKeys` is an array of strings representing key names.\n  // Note that resultKeys may contain 0 keys, and that it will sometimes\n  // contain duplicates due to SCAN's implementation in Redis.\n  for (var i = 0; i < resultKeys.length; i++) {\n    console.log(resultKeys[i]);\n  }\n});\nstream.on(\"end\", function() {\n  console.log(\"all keys have been visited\");\n});\n```\n\n`scanStream` accepts an option, with which you can specify the `MATCH` pattern and the `COUNT` argument:\n\n```javascript\nvar stream = redis.scanStream({\n  // only returns keys following the pattern of `user:*`\n  match: \"user:*\",\n  // returns approximately 100 elements per call\n  count: 100\n});\n```\n\nJust like other commands, `scanStream` has a binary version `scanBufferStream`, which returns an array of buffers. It's useful when\nthe key names are not utf8 strings.\n\nThere are also `hscanStream`, `zscanStream` and `sscanStream` to iterate through elements in a hash, zset and set. The interface of each is\nsimilar to `scanStream` except the first argument is the key name:\n\n```javascript\nvar stream = redis.hscanStream(\"myhash\", {\n  match: \"age:??\"\n});\n```\n\nYou can learn more from the [Redis documentation](http://redis.io/commands/scan).\n\n**Useful Tips**\nIt's pretty common that doing an async task in the `data` handler. We'd like the scanning process to be paused until the async task to be finished. `Stream#pause()` and `Stream.resume()` do the trick. For example if we want to migrate data in Redis to MySQL:\n\n```javascript\nvar stream = redis.scanStream();\nstream.on(\"data\", function(resultKeys) {\n  // Pause the stream from scanning more keys until we've migrated the current keys.\n  stream.pause();\n\n  Promise.all(resultKeys.map(migrateKeyToMySQL)).then(() => {\n    // Resume the stream here.\n    stream.resume();\n  });\n});\n\nstream.on(\"end\", function() {\n  console.log(\"done migration\");\n});\n```\n\n## Auto-reconnect\n\nBy default, ioredis will try to reconnect when the connection to Redis is lost\nexcept when the connection is closed manually by `redis.disconnect()` or `redis.quit()`.\n\nIt's very flexible to control how long to wait to reconnect after disconnection\nusing the `retryStrategy` option:\n\n```javascript\nvar redis = new Redis({\n  // This is the default value of `retryStrategy`\n  retryStrategy: function(times) {\n    var delay = Math.min(times * 50, 2000);\n    return delay;\n  }\n});\n```\n\n`retryStrategy` is a function that will be called when the connection is lost.\nThe argument `times` means this is the nth reconnection being made and\nthe return value represents how long (in ms) to wait to reconnect. When the\nreturn value isn't a number, ioredis will stop trying to reconnect, and the connection\nwill be lost forever if the user doesn't call `redis.connect()` manually.\n\nWhen reconnected, the client will auto subscribe to channels that the previous connection subscribed to.\nThis behavior can be disabled by setting the `autoResubscribe` option to `false`.\n\nAnd if the previous connection has some unfulfilled commands (most likely blocking commands such as `brpop` and `blpop`),\nthe client will resend them when reconnected. This behavior can be disabled by setting the `autoResendUnfulfilledCommands` option to `false`.\n\nBy default, all pending commands will be flushed with an error every 20 retry attempts. That makes sure commands won't wait forever when the connection is down. You can change this behavior by setting `maxRetriesPerRequest`:\n\n```javascript\nvar redis = new Redis({\n  maxRetriesPerRequest: 1\n});\n```\n\nSet maxRetriesPerRequest to `null` to disable this behavior, and every command will wait forever until the connection is alive again (which is the default behavior before ioredis v4).\n\n### Reconnect on error\n\nBesides auto-reconnect when the connection is closed, ioredis supports reconnecting on the specified errors by the `reconnectOnError` option. Here's an example that will reconnect when receiving `READONLY` error:\n\n```javascript\nvar redis = new Redis({\n  reconnectOnError: function(err) {\n    var targetError = \"READONLY\";\n    if (err.message.slice(0, targetError.length) === targetError) {\n      // Only reconnect when the error starts with \"READONLY\"\n      return true; // or `return 1;`\n    }\n  }\n});\n```\n\nThis feature is useful when using Amazon ElastiCache. Once failover happens, Amazon ElastiCache will switch the master we currently connected with to a slave, leading to the following writes fails with the error `READONLY`. Using `reconnectOnError`, we can force the connection to reconnect on this error in order to connect to the new master.\n\nFurthermore, if the `reconnectOnError` returns `2`, ioredis will resend the failed command after reconnecting.\n\n## Connection Events\n\nThe Redis instance will emit some events about the state of the connection to the Redis server.\n\n| Event        | Description                                                                                                                                                                                                                                     |\n| :----------- | :---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| connect      | emits when a connection is established to the Redis server.                                                                                                                                                                                     |\n| ready        | If `enableReadyCheck` is `true`, client will emit `ready` when the server reports that it is ready to receive commands (e.g. finish loading data from disk).<br>Otherwise, `ready` will be emitted immediately right after the `connect` event. |\n| error        | emits when an error occurs while connecting.<br>However, ioredis emits all `error` events silently (only emits when there's at least one listener) so that your application won't crash if you're not listening to the `error` event.           |\n| close        | emits when an established Redis server connection has closed.                                                                                                                                                                                   |\n| reconnecting | emits after `close` when a reconnection will be made. The argument of the event is the time (in ms) before reconnecting.                                                                                                                        |\n| end          | emits after `close` when no more reconnections will be made, or the connection is failed to establish.                                                                                                                                          |\n\nYou can also check out the `Redis#status` property to get the current connection status.\n\nBesides the above connection events, there are several other custom events:\n\n| Event  | Description                                                         |\n| :----- | :------------------------------------------------------------------ |\n| select | emits when the database changed. The argument is the new db number. |\n\n## Offline Queue\n\nWhen a command can't be processed by Redis (being sent before the `ready` event), by default, it's added to the offline queue and will be\nexecuted when it can be processed. You can disable this feature by setting the `enableOfflineQueue`\noption to `false`:\n\n```javascript\nvar redis = new Redis({ enableOfflineQueue: false });\n```\n\n## TLS Options\n\nRedis doesn't support TLS natively, however if the redis server you want to connect to is hosted behind a TLS proxy (e.g. [stunnel](https://www.stunnel.org/)) or is offered by a PaaS service that supports TLS connection (e.g. [Redis Labs](https://redislabs.com/)), you can set the `tls` option:\n\n```javascript\nvar redis = new Redis({\n  host: \"localhost\",\n  tls: {\n    // Refer to `tls.connect()` section in\n    // https://nodejs.org/api/tls.html\n    // for all supported options\n    ca: fs.readFileSync(\"cert.pem\")\n  }\n});\n```\n\n<hr>\n\n## Sentinel\n\nioredis supports Sentinel out of the box. It works transparently as all features that work when\nyou connect to a single node also work when you connect to a sentinel group. Make sure to run Redis >= 2.8.12 if you want to use this feature. Sentinels have a default port of 26379.\n\nTo connect using Sentinel, use:\n\n```javascript\nvar redis = new Redis({\n  sentinels: [\n    { host: \"localhost\", port: 26379 },\n    { host: \"localhost\", port: 26380 }\n  ],\n  name: \"mymaster\"\n});\n\nredis.set(\"foo\", \"bar\");\n```\n\nThe arguments passed to the constructor are different from the ones you use to connect to a single node, where:\n\n- `name` identifies a group of Redis instances composed of a master and one or more slaves (`mymaster` in the example);\n- `sentinelPassword` (optional) password for Sentinel instances.\n- `sentinels` are a list of sentinels to connect to. The list does not need to enumerate all your sentinel instances, but a few so that if one is down the client will try the next one.\n- `role` (optional) with a value of `slave` will return a random slave from the Sentinel group.\n- `preferredSlaves` (optional) can be used to prefer a particular slave or set of slaves based on priority. It accepts a function or array.\n\nioredis **guarantees** that the node you connected to is always a master even after a failover. When a failover happens, instead of trying to reconnect to the failed node (which will be demoted to slave when it's available again), ioredis will ask sentinels for the new master node and connect to it. All commands sent during the failover are queued and will be executed when the new connection is established so that none of the commands will be lost.\n\nIt's possible to connect to a slave instead of a master by specifying the option `role` with the value of `slave` and ioredis will try to connect to a random slave of the specified master, with the guarantee that the connected node is always a slave. If the current node is promoted to master due to a failover, ioredis will disconnect from it and ask the sentinels for another slave node to connect to.\n\nIf you specify the option `preferredSlaves` along with `role: 'slave'` ioredis will attempt to use this value when selecting the slave from the pool of available slaves. The value of `preferredSlaves` should either be a function that accepts an array of avaiable slaves and returns a single result, or an array of slave values priorities by the lowest `prio` value first with a default value of `1`.\n\n```javascript\n// available slaves format\nvar availableSlaves = [{ ip: \"127.0.0.1\", port: \"31231\", flags: \"slave\" }];\n\n// preferredSlaves array format\nvar preferredSlaves = [\n  { ip: \"127.0.0.1\", port: \"31231\", prio: 1 },\n  { ip: \"127.0.0.1\", port: \"31232\", prio: 2 }\n];\n\n// preferredSlaves function format\npreferredSlaves = function(availableSlaves) {\n  for (var i = 0; i < availableSlaves.length; i++) {\n    var slave = availableSlaves[i];\n    if (slave.ip === \"127.0.0.1\") {\n      if (slave.port === \"31234\") {\n        return slave;\n      }\n    }\n  }\n  // if no preferred slaves are available a random one is used\n  return false;\n};\n\nvar redis = new Redis({\n  sentinels: [\n    { host: \"127.0.0.1\", port: 26379 },\n    { host: \"127.0.0.1\", port: 26380 }\n  ],\n  name: \"mymaster\",\n  role: \"slave\",\n  preferredSlaves: preferredSlaves\n});\n```\n\nBesides the `retryStrategy` option, there's also a `sentinelRetryStrategy` in Sentinel mode which will be invoked when all the sentinel nodes are unreachable during connecting. If `sentinelRetryStrategy` returns a valid delay time, ioredis will try to reconnect from scratch. The default value of `sentinelRetryStrategy` is:\n\n```javascript\nfunction (times) {\n  var delay = Math.min(times * 10, 1000);\n  return delay;\n}\n```\n\n## Cluster\n\nRedis Cluster provides a way to run a Redis installation where data is automatically sharded across multiple Redis nodes.\nYou can connect to a Redis Cluster like this:\n\n```javascript\nvar Redis = require(\"ioredis\");\n\nvar cluster = new Redis.Cluster([\n  {\n    port: 6380,\n    host: \"127.0.0.1\"\n  },\n  {\n    port: 6381,\n    host: \"127.0.0.1\"\n  }\n]);\n\ncluster.set(\"foo\", \"bar\");\ncluster.get(\"foo\", function(err, res) {\n  // res === 'bar'\n});\n```\n\n`Cluster` constructor accepts two arguments, where:\n\n0.  The first argument is a list of nodes of the cluster you want to connect to.\n    Just like Sentinel, the list does not need to enumerate all your cluster nodes,\n    but a few so that if one is unreachable the client will try the next one, and the client will discover other nodes automatically when at least one node is connected.\n1.  The second argument is the options, where:\n\n    - `clusterRetryStrategy`: When none of the startup nodes are reachable, `clusterRetryStrategy` will be invoked. When a number is returned,\n      ioredis will try to reconnect to the startup nodes from scratch after the specified delay (in ms). Otherwise, an error of \"None of startup nodes is available\" will be returned.\n      The default value of this option is:\n\n          ```javascript\n          function (times) {\n            var delay = Math.min(100 + times * 2, 2000);\n            return delay;\n          }\n          ```\n\n          It's possible to modify the `startupNodes` property in order to switch to another set of nodes here:\n\n          ```javascript\n          function (times) {\n            this.startupNodes = [{ port: 6790, host: '127.0.0.1' }];\n            return Math.min(100 + times * 2, 2000);\n          }\n          ```\n\n    - `dnsLookup`: Alternative DNS lookup function (`dns.lookup()` is used by default). It may be useful to override this in special cases, such as when AWS ElastiCache used with TLS enabled.\n    - `enableOfflineQueue`: Similar to the `enableOfflineQueue` option of `Redis` class.\n    - `enableReadyCheck`: When enabled, \"ready\" event will only be emitted when `CLUSTER INFO` command\n      reporting the cluster is ready for handling commands. Otherwise, it will be emitted immediately after \"connect\" is emitted.\n    - `scaleReads`: Config where to send the read queries. See below for more details.\n    - `maxRedirections`: When a cluster related error (e.g. `MOVED`, `ASK` and `CLUSTERDOWN` etc.) is received, the client will redirect the\n      command to another node. This option limits the max redirections allowed when sending a command. The default value is `16`.\n    - `retryDelayOnFailover`: If the target node is disconnected when sending a command,\n      ioredis will retry after the specified delay. The default value is `100`. You should make sure `retryDelayOnFailover * maxRedirections > cluster-node-timeout`\n      to insure that no command will fail during a failover.\n    - `retryDelayOnClusterDown`: When a cluster is down, all commands will be rejected with the error of `CLUSTERDOWN`. If this option is a number (by default, it is `100`), the client\n      will resend the commands after the specified time (in ms).\n    - `retryDelayOnTryAgain`: If this option is a number (by default, it is `100`), the client\n      will resend the commands rejected with `TRYAGAIN` error after the specified time (in ms).\n    - `redisOptions`: Default options passed to the constructor of `Redis` when connecting to a node.\n    - `slotsRefreshTimeout`: Milliseconds before a timeout occurs while refreshing slots from the cluster (default `1000`)\n    - `slotsRefreshInterval`: Milliseconds between every automatic slots refresh (default `5000`)\n\n### Read-write splitting\n\nA typical redis cluster contains three or more masters and several slaves for each master. It's possible to scale out redis cluster by sending read queries to slaves and write queries to masters by setting the `scaleReads` option.\n\n`scaleReads` is \"master\" by default, which means ioredis will never send any queries to slaves. There are other three available options:\n\n1. \"all\": Send write queries to masters and read queries to masters or slaves randomly.\n2. \"slave\": Send write queries to masters and read queries to slaves.\n3. a custom `function(nodes, command): node`: Will choose the custom function to select to which node to send read queries (write queries keep being sent to master). The first node in `nodes` is always the master serving the relevant slots. If the function returns an array of nodes, a random node of that list will be selected.\n\nFor example:\n\n```javascript\nvar cluster = new Redis.Cluster(\n  [\n    /* nodes */\n  ],\n  {\n    scaleReads: \"slave\"\n  }\n);\ncluster.set(\"foo\", \"bar\"); // This query will be sent to one of the masters.\ncluster.get(\"foo\", function(err, res) {\n  // This query will be sent to one of the slaves.\n});\n```\n\n**NB** In the code snippet above, the `res` may not be equal to \"bar\" because of the lag of replication between the master and slaves.\n\n### Running commands to multiple nodes\n\nEvery command will be sent to exactly one node. For commands containing keys, (e.g. `GET`, `SET` and `HGETALL`), ioredis sends them to the node that serving the keys, and for other commands not containing keys, (e.g. `INFO`, `KEYS` and `FLUSHDB`), ioredis sends them to a random node.\n\nSometimes you may want to send a command to multiple nodes (masters or slaves) of the cluster, you can get the nodes via `Cluster#nodes()` method.\n\n`Cluster#nodes()` accepts a parameter role, which can be \"master\", \"slave\" and \"all\" (default), and returns an array of `Redis` instance. For example:\n\n```javascript\n// Send `FLUSHDB` command to all slaves:\nvar slaves = cluster.nodes(\"slave\");\nPromise.all(\n  slaves.map(function(node) {\n    return node.flushdb();\n  })\n);\n\n// Get keys of all the masters:\nvar masters = cluster.nodes(\"master\");\nPromise.all(\n  masters.map(function(node) {\n    return node.keys();\n  })\n).then(function(keys) {\n  // keys: [['key1', 'key2'], ['key3', 'key4']]\n});\n```\n\n### NAT Mapping\n\nSometimes the cluster is hosted within a internal network that can only be accessed via a NAT (Network Address Translation) instance. See [Accessing ElastiCache from outside AWS](https://docs.aws.amazon.com/AmazonElastiCache/latest/red-ug/accessing-elasticache.html) as an example.\n\nYou can specify nat mapping rules via `natMap` option:\n\n```javascript\nconst cluster = new Redis.Cluster(\n  [\n    {\n      host: \"203.0.113.73\",\n      port: 30001\n    }\n  ],\n  {\n    natMap: {\n      \"10.0.1.230:30001\": { host: \"203.0.113.73\", port: 30001 },\n      \"10.0.1.231:30001\": { host: \"203.0.113.73\", port: 30002 },\n      \"10.0.1.232:30001\": { host: \"203.0.113.73\", port: 30003 }\n    }\n  }\n);\n```\n\nThis option is also useful when the cluster is running inside a Docker container.\n\n### Transaction and pipeline in Cluster mode\n\nAlmost all features that are supported by `Redis` are also supported by `Redis.Cluster`, e.g. custom commands, transaction and pipeline.\nHowever there are some differences when using transaction and pipeline in Cluster mode:\n\n0. All keys in a pipeline should belong to the same slot since ioredis sends all commands in a pipeline to the same node.\n1. You can't use `multi` without pipeline (aka `cluster.multi({ pipeline: false })`). This is because when you call `cluster.multi({ pipeline: false })`, ioredis doesn't know which node the `multi` command should be sent to.\n2. Chaining custom commands in the pipeline is not supported in Cluster mode.\n\nWhen any commands in a pipeline receives a `MOVED` or `ASK` error, ioredis will resend the whole pipeline to the specified node automatically if all of the following conditions are satisfied:\n\n0. All errors received in the pipeline are the same. For example, we won't resend the pipeline if we got two `MOVED` errors pointing to different nodes.\n1. All commands executed successfully are readonly commands. This makes sure that resending the pipeline won't have side effects.\n\n### Pub/Sub\n\nPub/Sub in cluster mode works exactly as the same as in standalone mode. Internally, when a node of the cluster receives a message, it will broadcast the message to the other nodes. ioredis makes sure that each message will only be received once by strictly subscribing one node at the same time.\n\n```javascript\nvar nodes = [\n  /* nodes */\n];\nvar pub = new Redis.Cluster(nodes);\nvar sub = new Redis.Cluster(nodes);\nsub.on(\"message\", function(channel, message) {\n  console.log(channel, message);\n});\n\nsub.subscribe(\"news\", function() {\n  pub.publish(\"news\", \"highlights\");\n});\n```\n\n### Events\n\n| Event        | Description                                                                                                                                                                                                |\n| :----------- | :--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| connect      | emits when a connection is established to the Redis server.                                                                                                                                                |\n| ready        | emits when `CLUSTER INFO` reporting the cluster is able to receive commands (if `enableReadyCheck` is `true`) or immediately after `connect` event (if `enableReadyCheck` is false).                       |\n| error        | emits when an error occurs while connecting with a property of `lastNodeError` representing the last node error received. This event is emitted silently (only emitting if there's at least one listener). |\n| close        | emits when an established Redis server connection has closed.                                                                                                                                              |\n| reconnecting | emits after `close` when a reconnection will be made. The argument of the event is the time (in ms) before reconnecting.                                                                                   |\n| end          | emits after `close` when no more reconnections will be made.                                                                                                                                               |\n| +node        | emits when a new node is connected.                                                                                                                                                                        |\n| -node        | emits when a node is disconnected.                                                                                                                                                                         |\n| node error   | emits when an error occurs when connecting to a node. The second argument indicates the address of the node.                                                                                               |\n\n### Password\n\nSetting the `password` option to access password-protected clusters:\n\n```javascript\nvar Redis = require(\"ioredis\");\nvar cluster = new Redis.Cluster(nodes, {\n  redisOptions: {\n    password: \"your-cluster-password\"\n  }\n});\n```\n\nIf some of nodes in the cluster using a different password, you should specify them in the first parameter:\n\n```javascript\nvar Redis = require(\"ioredis\");\nvar cluster = new Redis.Cluster(\n  [\n    // Use password \"password-for-30001\" for 30001\n    { port: 30001, password: \"password-for-30001\" },\n    // Don't use password when accessing 30002\n    { port: 30002, password: null }\n    // Other nodes will use \"fallback-password\"\n  ],\n  {\n    redisOptions: {\n      password: \"fallback-password\"\n    }\n  }\n);\n```\n\n### Special note: AWS ElastiCache Clusters with TLS\n\nAWS ElastiCache for Redis (Clustered Mode) supports TLS encryption. If you use\nthis, you may encounter errors with invalid certificates. To resolve this\nissue, construct the `Cluster` with the `dnsLookup` option as follows:\n\n```javascript\nvar cluster = new Redis.Cluster(\n  [{\n    host: 'clustercfg.myCluster.abcdefg.xyz.cache.amazonaws.com',\n    port: 6379\n  }],\n  {\n    dnsLookup: (address, callback) => callback(null, address),\n    redisOptions: {\n      tls: {}\n    },\n  }\n};\n```\n\n<hr>\n\n# Error Handling\n\nAll the errors returned by the Redis server are instances of `ReplyError`, which can be accessed via `Redis`:\n\n```javascript\nvar Redis = require(\"ioredis\");\nvar redis = new Redis();\n// This command causes a reply error since the SET command requires two arguments.\nredis.set(\"foo\", function(err) {\n  err instanceof Redis.ReplyError;\n});\n```\n\nThis is the error stack of the `ReplyError`:\n\n```\nReplyError: ERR wrong number of arguments for 'set' command\n    at ReplyParser._parseResult (/app/node_modules/ioredis/lib/parsers/javascript.js:60:14)\n    at ReplyParser.execute (/app/node_modules/ioredis/lib/parsers/javascript.js:178:20)\n    at Socket.<anonymous> (/app/node_modules/ioredis/lib/redis/event_handler.js:99:22)\n    at Socket.emit (events.js:97:17)\n    at readableAddChunk (_stream_readable.js:143:16)\n    at Socket.Readable.push (_stream_readable.js:106:10)\n    at TCP.onread (net.js:509:20)\n```\n\nBy default, the error stack doesn't make any sense because the whole stack happens in the ioredis\nmodule itself, not in your code. So it's not easy to find out where the error happens in your code.\nioredis provides an option `showFriendlyErrorStack` to solve the problem. When you enable\n`showFriendlyErrorStack`, ioredis will optimize the error stack for you:\n\n```javascript\nvar Redis = require(\"ioredis\");\nvar redis = new Redis({ showFriendlyErrorStack: true });\nredis.set(\"foo\");\n```\n\nAnd the output will be:\n\n```\nReplyError: ERR wrong number of arguments for 'set' command\n    at Object.<anonymous> (/app/index.js:3:7)\n    at Module._compile (module.js:446:26)\n    at Object.Module._extensions..js (module.js:464:10)\n    at Module.load (module.js:341:32)\n    at Function.Module._load (module.js:296:12)\n    at Function.Module.runMain (module.js:487:10)\n    at startup (node.js:111:16)\n    at node.js:799:3\n```\n\nThis time the stack tells you that the error happens on the third line in your code. Pretty sweet!\nHowever, it would decrease the performance significantly to optimize the error stack. So by\ndefault, this option is disabled and can only be used for debugging purposes. You **shouldn't** use this feature in a production environment.\n\n# Plugging in your own Promises Library\n\nIf you're an advanced user, you may want to plug in your own promise library like [bluebird](https://www.npmjs.com/package/bluebird). Just set Redis.Promise to your favorite ES6-style promise constructor and ioredis will use it.\n\n```javascript\nconst Redis = require(\"ioredis\");\nRedis.Promise = require(\"bluebird\");\n\nconst redis = new Redis();\n\n// Use bluebird\nassert.equal(redis.get().constructor, require(\"bluebird\"));\n\n// You can change the Promise implementation at any time:\nRedis.Promise = global.Promise;\nassert.equal(redis.get().constructor, global.Promise);\n```\n\n# Running tests\n\nStart a Redis server on 127.0.0.1:6379, and then:\n\n```shell\n$ npm test\n```\n\n`FLUSH ALL` will be invoked after each test, so make sure there's no valuable data in it before running tests.\n\nIf your testing environment does not let you spin up a Redis server [ioredis-mock](https://github.com/stipsan/ioredis-mock) is a drop-in replacement you can use in your tests. It aims to behave identically to ioredis connected to a Redis server so that your integration tests is easier to write and of better quality.\n\n# Debug\n\nYou can set the `DEBUG` env to `ioredis:*` to print debug info:\n\n```shell\n$ DEBUG=ioredis:* node app.js\n```\n\n# Join in!\n\nI'm happy to receive bug reports, fixes, documentation enhancements, and any other improvements.\n\nAnd since I'm not a native English speaker, if you find any grammar mistakes in the documentation, please also let me know. :)\n\n# Become a Sponsor\n\nOpen source is hard and time-consuming. If you want to invest in ioredis's future you can become a sponsor and make us spend more time on this library's improvements and new features.\n\n<a href=\"https://opencollective.com/ioredis\"><img src=\"https://opencollective.com/ioredis/tiers/sponsor.svg?avatarHeight=36\"></a>\n\nThank you for using ioredis :-)\n\n# Contributors\n\nThis project exists thanks to all the people who contribute:\n\n<a href=\"https://github.com/luin/ioredis/graphs/contributors\"><img src=\"https://opencollective.com/ioredis/contributors.svg?width=890&showBtn=false\" /></a>\n\n# License\n\nMIT\n\n[![FOSSA Status](https://app.fossa.io/api/projects/git%2Bgithub.com%2Fluin%2Fioredis.svg?type=large)](https://app.fossa.io/projects/git%2Bgithub.com%2Fluin%2Fioredis?ref=badge_large)\n","readmeFilename":"README.md","bugs":{"url":"https://github.com/luin/ioredis/issues"},"homepage":"https://github.com/luin/ioredis#readme","_id":"ioredis@4.12.0","_nodeVersion":"10.16.0","_npmVersion":"6.9.0","dist":{"integrity":"sha512-c6l+jJL+zn+b5jJMD21pCsmEtf0SCOmGJ71QBR70cBQnOP0Jnn0tZFSwQtzb3pyQqcOiIykUfVLzP3LuuW8gmA==","shasum":"fd5cce7cabaf4e613de9300c76b5f57a9e854461","tarball":"https://registry.npmjs.org/ioredis/-/ioredis-4.12.0.tgz","fileCount":36,"unpackedSize":235762,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJdK4H6CRA9TVsSAnZWagAABzsP/2Rc7GcuznC5xOjtxIQd\nwsNTx/sX4EwSjchTc0QKPueCTVFfyHjd1a+UR92lzBuz1/VhhnmsFMbfspAT\nf2AiFnPEN7e2gi1zLWo80nwi65MOe6LDiExrhAo8+BTylVXcwN9NKE0ytbq7\nnD/OYGYo0OHu814mnY5w3i11eprdtaeyjTfhKqIXifbSVUa6Qr0gJk4A/mQD\nR+JxikXz3h9k/B+4bs5N+6iMDoR21XmWHmuKmokqg30ZBA3txFYu62ozxSUY\nqN7nMfi4+QMPh7tahXxdMpN/SlOc4Dx5WDXN6mnAGtARlMVA8XBIMME2YOiV\n/ez08Tu3HZbDXxu14yjcFzXiUbXwGTPOtL9AegZJh+W4VFphiqeAlNlosXdw\nus5UpEJT55ddh6BPMAFTNSmJ5Ean7PH0IrtNzvbWLKPFIhoRJhOAH7XXPIms\n/696Tpo/MbrjVFf+9I0FMkf2ECdpZdpUITZJZSfqs1SG5aUwoAgxYHKdbkYs\nTo8Maj2j2PwdCVd43cG0F0WuuXst67bxOe8fD7iDtZs+2YjTUcpjyHkYstLv\nLYCjNV8MJRMtpeE9QwVMI5+Yhqx5csuoiUR/raWAbEDaQvUqj742biLHeuId\nzhc6C2xxtLzbdOHxARjy1rVY5BNgX2LqzIQtmp4X+PmBLs9XH1wKgue8TdKP\n409+\r\n=ytvC\r\n-----END PGP SIGNATURE-----\r\n"},"maintainers":[{"email":"ioredis-robot@zihua.li","name":"ioredis-robot"},{"email":"i@zihua.li","name":"luin"}],"_npmUser":{"name":"luin","email":"i@zihua.li"},"directories":{},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/ioredis_4.12.0_1563132408806_0.45261819114932655"},"_hasShrinkwrap":false},"4.12.1":{"name":"ioredis","version":"4.12.1","description":"A robust, performance-focused and full-featured Redis client for Node.js.","main":"built/index.js","scripts":{"test":"TS_NODE_TRANSPILE_ONLY=true TS_NODE_LOG_ERROR=true NODE_ENV=test mocha \"test/**/*.ts\"","test:cov":"TS_NODE_TRANSPILE_ONLY=true TS_NODE_LOG_ERROR=true NODE_ENV=test node ./node_modules/istanbul/lib/cli.js cover --preserve-comments ./node_modules/mocha/bin/_mocha -- -r ts-node/register -R spec --exit \"test/**/*.ts\"","lint":"eslint --ext .js,.ts .","format":"prettier --write \"{,!(node_modules)/**/}*.{js,ts}\"","format-check":"prettier --check \"{,!(node_modules)/**/}*.{js,ts}\"","build":"rm -rf built && tsc","prepublishOnly":"npm run build && npm test","bench":"matcha benchmarks/*.js","semantic-release":"semantic-release"},"repository":{"type":"git","url":"git://github.com/luin/ioredis.git"},"keywords":["redis","cluster","sentinel","pipelining"],"author":{"name":"luin","email":"i@zihua.li","url":"http://zihua.li"},"license":"MIT","dependencies":{"cluster-key-slot":"^1.0.6","debug":"^4.1.1","denque":"^1.1.0","lodash.defaults":"^4.2.0","lodash.flatten":"^4.4.0","redis-commands":"1.5.0","redis-errors":"^1.2.0","redis-parser":"^3.0.0","standard-as-callback":"^2.0.1"},"devDependencies":{"@semantic-release/changelog":"^3.0.4","@semantic-release/git":"^7.0.12","@types/bluebird":"^3.5.27","@types/chai":"^4.1.7","@types/debug":"^4.1.4","@types/lodash.defaults":"^4.2.6","@types/lodash.flatten":"^4.4.6","@types/mocha":"^5.2.7","@types/node":"^12.0.2","@types/redis-errors":"1.2.0","@types/sinon":"^7.0.13","@typescript-eslint/eslint-plugin":"^1.11.0","@typescript-eslint/parser":"^1.11.0","bluebird":"^3.5.4","chai":"^4.2.0","cz-conventional-changelog":"^2.0.0","eslint":"^5.16.0","eslint-config-prettier":"^5.1.0","husky":"^2.5.0","istanbul":"^0.4.5","mocha":"^5.0.0","prettier":"^1.18.2","pretty-quick":"^1.11.1","server-destroy":"^1.0.1","sinon":"^7.3.2","ts-node":"^8.1.0","typescript":"^3.5.1"},"engines":{"node":">=6"},"config":{"commitizen":{"path":"./node_modules/cz-conventional-changelog"}},"husky":{"hooks":{"pre-commit":"pretty-quick --staged"}},"gitHead":"6b67c3f7d9f1bd98b51afb9a5cfb4a2131fdddd6","readme":"[![ioredis](https://cdn.jsdelivr.net/gh/luin/ioredis@b5e8c74/logo.svg)](https://github.com/luin/ioredis)\n\n[![Build Status](https://travis-ci.org/luin/ioredis.svg?branch=master)](https://travis-ci.org/luin/ioredis)\n[![Test Coverage](https://codeclimate.com/github/luin/ioredis/badges/coverage.svg)](https://codeclimate.com/github/luin/ioredis)\n[![code style: prettier](https://img.shields.io/badge/code_style-prettier-ff69b4.svg?style=flat-square)](https://github.com/prettier/prettier)\n[![Join the chat at https://gitter.im/luin/ioredis](https://badges.gitter.im/Join%20Chat.svg)](https://gitter.im/luin/ioredis?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge)\n[![Commitizen friendly](https://img.shields.io/badge/commitizen-friendly-brightgreen.svg)](http://commitizen.github.io/cz-cli/)\n[![semantic-release](https://img.shields.io/badge/%20%20%F0%9F%93%A6%F0%9F%9A%80-semantic--release-e10079.svg)](https://github.com/semantic-release/semantic-release)\n[![npm latest version](https://img.shields.io/npm/v/ioredis/latest.svg)](https://www.npmjs.com/package/ioredis)\n[![npm next version](https://img.shields.io/npm/v/ioredis/next.svg)](https://www.npmjs.com/package/ioredis)\n<img alt=\"\" src=\"\">\n\nA robust, performance-focused and full-featured [Redis](http://redis.io) client for [Node.js](https://nodejs.org).\n\nSupports Redis >= 2.6.12 and (Node.js >= 6).\n\n# Features\n\nioredis is a robust, full-featured Redis client that is\nused in the world's biggest online commerce company [Alibaba](http://www.alibaba.com/) and many other awesome companies.\n\n0. Full-featured. It supports [Cluster](http://redis.io/topics/cluster-tutorial), [Sentinel](http://redis.io/topics/sentinel), [Pipelining](http://redis.io/topics/pipelining) and of course [Lua scripting](http://redis.io/commands/eval) & [Pub/Sub](http://redis.io/topics/pubsub) (with the support of binary messages).\n1. High performance.\n2. Delightful API. It works with Node callbacks and Native promises.\n3. Transformation of command arguments and replies.\n4. Transparent key prefixing.\n5. Abstraction for Lua scripting, allowing you to define custom commands.\n6. Support for binary data.\n7. Support for TLS.\n8. Support for offline queue and ready checking.\n9. Support for ES6 types, such as `Map` and `Set`.\n10. Support for GEO commands (Redis 3.2 Unstable).\n11. Sophisticated error handling strategy.\n12. Support for NAT mapping.\n\n# Links\n\n- [API Documentation](API.md)\n- [Changelog](Changelog.md)\n- [Migrating from node_redis](https://github.com/luin/ioredis/wiki/Migrating-from-node_redis)\n- [Error Handling](#error-handling)\n\n<hr>\n<a href=\"http://bit.ly/medis-macos\"><img align=\"right\" src=\"resources/medis.png\" alt=\"Download on the App Store\"></a>\n\n### [AD] Medis: Redis GUI for OS X\n\nLooking for a Redis GUI manager for OS X, Windows and Linux? Here's [Medis](http://bit.ly/medis-macos)!\n\nMedis is an open-sourced, beautiful, easy-to-use Redis GUI management application.\n\nMedis starts with all the basic features you need:\n\n- Keys viewing/editing\n- SSH Tunnel for connecting with remote servers\n- Terminal for executing custom commands\n- JSON/MessagePack format viewing/editing and built-in highlighting/validator\n- And other awesome features...\n\n[Medis is open sourced on GitHub](https://github.com/luin/medis)\n\n### [AD] Kuber: Kubernetes Dashboard for iOS\n\n<a href=\"http://bit.ly/kuber-ios\"><img src=\"resources/kuber.png\" alt=\"Download on the App Store\"></a>\n\n<hr>\n\n# Quick Start\n\n## Install\n\n```shell\n$ npm install ioredis\n```\n\n## Basic Usage\n\n```javascript\nvar Redis = require(\"ioredis\");\nvar redis = new Redis();\n\nredis.set(\"foo\", \"bar\");\nredis.get(\"foo\", function(err, result) {\n  console.log(result);\n});\nredis.del(\"foo\");\n\n// Or using a promise if the last argument isn't a function\nredis.get(\"foo\").then(function(result) {\n  console.log(result);\n});\n\n// Arguments to commands are flattened, so the following are the same:\nredis.sadd(\"set\", 1, 3, 5, 7);\nredis.sadd(\"set\", [1, 3, 5, 7]);\n\n// All arguments are passed directly to the redis server:\nredis.set(\"key\", 100, \"EX\", 10);\n```\n\nSee the `examples/` folder for more examples.\n\n## Connect to Redis\n\nWhen a new `Redis` instance is created,\na connection to Redis will be created at the same time.\nYou can specify which Redis to connect to by:\n\n```javascript\nnew Redis(); // Connect to 127.0.0.1:6379\nnew Redis(6380); // 127.0.0.1:6380\nnew Redis(6379, \"192.168.1.1\"); // 192.168.1.1:6379\nnew Redis(\"/tmp/redis.sock\");\nnew Redis({\n  port: 6379, // Redis port\n  host: \"127.0.0.1\", // Redis host\n  family: 4, // 4 (IPv4) or 6 (IPv6)\n  password: \"auth\",\n  db: 0\n});\n```\n\nYou can also specify connection options as a [`redis://` URL](http://www.iana.org/assignments/uri-schemes/prov/redis):\n\n```javascript\n// Connect to 127.0.0.1:6380, db 4, using password \"authpassword\":\nnew Redis(\"redis://:authpassword@127.0.0.1:6380/4\");\n```\n\nSee [API Documentation](API.md#new_Redis) for all available options.\n\n## Pub/Sub\n\nHere is a simple example of the API for publish/subscribe.\nThe following program opens two client connections.\nIt subscribes to a channel with one connection\nand publishes to that channel with the other:\n\n```javascript\nvar Redis = require(\"ioredis\");\nvar redis = new Redis();\nvar pub = new Redis();\nredis.subscribe(\"news\", \"music\", function(err, count) {\n  // Now we are subscribed to both the 'news' and 'music' channels.\n  // `count` represents the number of channels we are currently subscribed to.\n\n  pub.publish(\"news\", \"Hello world!\");\n  pub.publish(\"music\", \"Hello again!\");\n});\n\nredis.on(\"message\", function(channel, message) {\n  // Receive message Hello world! from channel news\n  // Receive message Hello again! from channel music\n  console.log(\"Receive message %s from channel %s\", message, channel);\n});\n\n// There's also an event called 'messageBuffer', which is the same as 'message' except\n// it returns buffers instead of strings.\nredis.on(\"messageBuffer\", function(channel, message) {\n  // Both `channel` and `message` are buffers.\n});\n```\n\n`PSUBSCRIBE` is also supported in a similar way:\n\n```javascript\nredis.psubscribe(\"pat?ern\", function(err, count) {});\nredis.on(\"pmessage\", function(pattern, channel, message) {});\nredis.on(\"pmessageBuffer\", function(pattern, channel, message) {});\n```\n\nWhen a client issues a SUBSCRIBE or PSUBSCRIBE, that connection is put into a \"subscriber\" mode.\nAt that point, only commands that modify the subscription set are valid.\nWhen the subscription set is empty, the connection is put back into regular mode.\n\nIf you need to send regular commands to Redis while in subscriber mode, just open another connection.\n\n## Handle Binary Data\n\nArguments can be buffers:\n\n```javascript\nredis.set(\"foo\", Buffer.from(\"bar\"));\n```\n\nAnd every command has a method that returns a Buffer (by adding a suffix of \"Buffer\" to the command name).\nTo get a buffer instead of a utf8 string:\n\n```javascript\nredis.getBuffer(\"foo\", function(err, result) {\n  // result is a buffer.\n});\n```\n\n## Pipelining\n\nIf you want to send a batch of commands (e.g. > 5), you can use pipelining to queue\nthe commands in memory and then send them to Redis all at once. This way the performance improves by 50%~300% (See [benchmark section](#benchmark)).\n\n`redis.pipeline()` creates a `Pipeline` instance. You can call any Redis\ncommands on it just like the `Redis` instance. The commands are queued in memory\nand flushed to Redis by calling the `exec` method:\n\n```javascript\nvar pipeline = redis.pipeline();\npipeline.set(\"foo\", \"bar\");\npipeline.del(\"cc\");\npipeline.exec(function(err, results) {\n  // `err` is always null, and `results` is an array of responses\n  // corresponding to the sequence of queued commands.\n  // Each response follows the format `[err, result]`.\n});\n\n// You can even chain the commands:\nredis\n  .pipeline()\n  .set(\"foo\", \"bar\")\n  .del(\"cc\")\n  .exec(function(err, results) {});\n\n// `exec` also returns a Promise:\nvar promise = redis\n  .pipeline()\n  .set(\"foo\", \"bar\")\n  .get(\"foo\")\n  .exec();\npromise.then(function(result) {\n  // result === [[null, 'OK'], [null, 'bar']]\n});\n```\n\nEach chained command can also have a callback, which will be invoked when the command\ngets a reply:\n\n```javascript\nredis\n  .pipeline()\n  .set(\"foo\", \"bar\")\n  .get(\"foo\", function(err, result) {\n    // result === 'bar'\n  })\n  .exec(function(err, result) {\n    // result[1][1] === 'bar'\n  });\n```\n\nIn addition to adding commands to the `pipeline` queue individually, you can also pass an array of commands and arguments to the constructor:\n\n```javascript\nredis.pipeline([[\"set\", \"foo\", \"bar\"], [\"get\", \"foo\"]]).exec(function() {\n  /* ... */\n});\n```\n\n`#length` property shows how many commands in the pipeline:\n\n```javascript\nconst length = redis\n  .pipeline()\n  .set(\"foo\", \"bar\")\n  .get(\"foo\").length;\n// length === 2\n```\n\n## Transaction\n\nMost of the time, the transaction commands `multi` & `exec` are used together with pipeline.\nTherefore, when `multi` is called, a `Pipeline` instance is created automatically by default,\nso you can use `multi` just like `pipeline`:\n\n```javascript\nredis\n  .multi()\n  .set(\"foo\", \"bar\")\n  .get(\"foo\")\n  .exec(function(err, results) {\n    // results === [[null, 'OK'], [null, 'bar']]\n  });\n```\n\nIf there's a syntax error in the transaction's command chain (e.g. wrong number of arguments, wrong command name, etc),\nthen none of the commands would be executed, and an error is returned:\n\n```javascript\nredis\n  .multi()\n  .set(\"foo\")\n  .set(\"foo\", \"new value\")\n  .exec(function(err, results) {\n    // err:\n    //  { [ReplyError: EXECABORT Transaction discarded because of previous errors.]\n    //    name: 'ReplyError',\n    //    message: 'EXECABORT Transaction discarded because of previous errors.',\n    //    command: { name: 'exec', args: [] },\n    //    previousErrors:\n    //     [ { [ReplyError: ERR wrong number of arguments for 'set' command]\n    //         name: 'ReplyError',\n    //         message: 'ERR wrong number of arguments for \\'set\\' command',\n    //         command: [Object] } ] }\n  });\n```\n\nIn terms of the interface, `multi` differs from `pipeline` in that when specifying a callback\nto each chained command, the queueing state is passed to the callback instead of the result of the command:\n\n```javascript\nredis\n  .multi()\n  .set(\"foo\", \"bar\", function(err, result) {\n    // result === 'QUEUED'\n  })\n  .exec(/* ... */);\n```\n\nIf you want to use transaction without pipeline, pass `{ pipeline: false }` to `multi`,\nand every command will be sent to Redis immediately without waiting for an `exec` invocation:\n\n```javascript\nredis.multi({ pipeline: false });\nredis.set(\"foo\", \"bar\");\nredis.get(\"foo\");\nredis.exec(function(err, result) {\n  // result === [[null, 'OK'], [null, 'bar']]\n});\n```\n\nThe constructor of `multi` also accepts a batch of commands:\n\n```javascript\nredis.multi([[\"set\", \"foo\", \"bar\"], [\"get\", \"foo\"]]).exec(function() {\n  /* ... */\n});\n```\n\nInline transactions are supported by pipeline, which means you can group a subset of commands\nin the pipeline into a transaction:\n\n```javascript\nredis\n  .pipeline()\n  .get(\"foo\")\n  .multi()\n  .set(\"foo\", \"bar\")\n  .get(\"foo\")\n  .exec()\n  .get(\"foo\")\n  .exec();\n```\n\n## Lua Scripting\n\nioredis supports all of the scripting commands such as `EVAL`, `EVALSHA` and `SCRIPT`.\nHowever, it's tedious to use in real world scenarios since developers have to take\ncare of script caching and to detect when to use `EVAL` and when to use `EVALSHA`.\nioredis expose a `defineCommand` method to make scripting much easier to use:\n\n```javascript\nvar redis = new Redis();\n\n// This will define a command echo:\nredis.defineCommand(\"echo\", {\n  numberOfKeys: 2,\n  lua: \"return {KEYS[1],KEYS[2],ARGV[1],ARGV[2]}\"\n});\n\n// Now `echo` can be used just like any other ordinary command,\n// and ioredis will try to use `EVALSHA` internally when possible for better performance.\nredis.echo(\"k1\", \"k2\", \"a1\", \"a2\", function(err, result) {\n  // result === ['k1', 'k2', 'a1', 'a2']\n});\n\n// `echoBuffer` is also defined automatically to return buffers instead of strings:\nredis.echoBuffer(\"k1\", \"k2\", \"a1\", \"a2\", function(err, result) {\n  // result[0] equals to Buffer.from('k1');\n});\n\n// And of course it works with pipeline:\nredis\n  .pipeline()\n  .set(\"foo\", \"bar\")\n  .echo(\"k1\", \"k2\", \"a1\", \"a2\")\n  .exec();\n```\n\nIf the number of keys can't be determined when defining a command, you can\nomit the `numberOfKeys` property and pass the number of keys as the first argument\nwhen you call the command:\n\n```javascript\nredis.defineCommand(\"echoDynamicKeyNumber\", {\n  lua: \"return {KEYS[1],KEYS[2],ARGV[1],ARGV[2]}\"\n});\n\n// Now you have to pass the number of keys as the first argument every time\n// you invoke the `echoDynamicKeyNumber` command:\nredis.echoDynamicKeyNumber(2, \"k1\", \"k2\", \"a1\", \"a2\", function(err, result) {\n  // result === ['k1', 'k2', 'a1', 'a2']\n});\n```\n\n## Transparent Key Prefixing\n\nThis feature allows you to specify a string that will automatically be prepended\nto all the keys in a command, which makes it easier to manage your key\nnamespaces.\n\n**Warning** This feature won't apply to commands like [KEYS](http://redis.io/commands/KEYS) and [SCAN](http://redis.io/commands/scan) that take patterns rather than actual keys([#239](https://github.com/luin/ioredis/issues/239)),\nand this feature also won't apply to the replies of commands even they are key names ([#325](https://github.com/luin/ioredis/issues/325)).\n\n```javascript\nvar fooRedis = new Redis({ keyPrefix: \"foo:\" });\nfooRedis.set(\"bar\", \"baz\"); // Actually sends SET foo:bar baz\n\nfooRedis.defineCommand(\"echo\", {\n  numberOfKeys: 2,\n  lua: \"return {KEYS[1],KEYS[2],ARGV[1],ARGV[2]}\"\n});\n\n// Works well with pipelining/transaction\nfooRedis\n  .pipeline()\n  // Sends SORT foo:list BY foo:weight_*->fieldname\n  .sort(\"list\", \"BY\", \"weight_*->fieldname\")\n  // Supports custom commands\n  // Sends EVALSHA xxx foo:k1 foo:k2 a1 a2\n  .echo(\"k1\", \"k2\", \"a1\", \"a2\")\n  .exec();\n```\n\n## Transforming Arguments & Replies\n\nMost Redis commands take one or more Strings as arguments,\nand replies are sent back as a single String or an Array of Strings. However, sometimes\nyou may want something different. For instance, it would be more convenient if the `HGETALL`\ncommand returns a hash (e.g. `{ key: val1, key2: v2 }`) rather than an array of key values (e.g. `[key1, val1, key2, val2]`).\n\nioredis has a flexible system for transforming arguments and replies. There are two types\nof transformers, argument transformer and reply transformer:\n\n```javascript\nvar Redis = require(\"ioredis\");\n\n// Here's the built-in argument transformer converting\n// hmset('key', { k1: 'v1', k2: 'v2' })\n// or\n// hmset('key', new Map([['k1', 'v1'], ['k2', 'v2']]))\n// into\n// hmset('key', 'k1', 'v1', 'k2', 'v2')\nRedis.Command.setArgumentTransformer(\"hmset\", function(args) {\n  if (args.length === 2) {\n    if (typeof Map !== \"undefined\" && args[1] instanceof Map) {\n      // utils is a internal module of ioredis\n      return [args[0]].concat(utils.convertMapToArray(args[1]));\n    }\n    if (typeof args[1] === \"object\" && args[1] !== null) {\n      return [args[0]].concat(utils.convertObjectToArray(args[1]));\n    }\n  }\n  return args;\n});\n\n// Here's the built-in reply transformer converting the HGETALL reply\n// ['k1', 'v1', 'k2', 'v2']\n// into\n// { k1: 'v1', 'k2': 'v2' }\nRedis.Command.setReplyTransformer(\"hgetall\", function(result) {\n  if (Array.isArray(result)) {\n    var obj = {};\n    for (var i = 0; i < result.length; i += 2) {\n      obj[result[i]] = result[i + 1];\n    }\n    return obj;\n  }\n  return result;\n});\n```\n\nThere are three built-in transformers, two argument transformers for `hmset` & `mset` and\na reply transformer for `hgetall`. Transformers for `hmset` and `hgetall` were mentioned\nabove, and the transformer for `mset` is similar to the one for `hmset`:\n\n```javascript\nredis.mset({ k1: \"v1\", k2: \"v2\" });\nredis.get(\"k1\", function(err, result) {\n  // result === 'v1';\n});\n\nredis.mset(new Map([[\"k3\", \"v3\"], [\"k4\", \"v4\"]]));\nredis.get(\"k3\", function(err, result) {\n  // result === 'v3';\n});\n```\n\nAnother useful example of a reply transformer is one that changes `hgetall` to return array of arrays instead of objects which avoids a unwanted conversation of hash keys to strings when dealing with binary hash keys:\n\n```javascript\nRedis.Command.setReplyTransformer(\"hgetall\", function(result) {\n  var arr = [];\n  for (var i = 0; i < result.length; i += 2) {\n    arr.push([result[i], result[i + 1]]);\n  }\n  return arr;\n});\nredis.hset(\"h1\", Buffer.from([0x01]), Buffer.from([0x02]));\nredis.hset(\"h1\", Buffer.from([0x03]), Buffer.from([0x04]));\nredis.hgetallBuffer(\"h1\", function(err, result) {\n  // result === [ [ <Buffer 01>, <Buffer 02> ], [ <Buffer 03>, <Buffer 04> ] ];\n});\n```\n\n## Monitor\n\nRedis supports the MONITOR command,\nwhich lets you see all commands received by the Redis server across all client connections,\nincluding from other client libraries and other computers.\n\nThe `monitor` method returns a monitor instance.\nAfter you send the MONITOR command, no other commands are valid on that connection. ioredis will emit a monitor event for every new monitor message that comes across.\nThe callback for the monitor event takes a timestamp from the Redis server and an array of command arguments.\n\nHere is a simple example:\n\n```javascript\nredis.monitor(function(err, monitor) {\n  monitor.on(\"monitor\", function(time, args, source, database) {});\n});\n```\n\n## Streamify Scanning\n\nRedis 2.8 added the `SCAN` command to incrementally iterate through the keys in the database. It's different from `KEYS` in that\n`SCAN` only returns a small number of elements each call, so it can be used in production without the downside\nof blocking the server for a long time. However, it requires recording the cursor on the client side each time\nthe `SCAN` command is called in order to iterate through all the keys correctly. Since it's a relatively common use case, ioredis\nprovides a streaming interface for the `SCAN` command to make things much easier. A readable stream can be created by calling `scanStream`:\n\n```javascript\nvar redis = new Redis();\n// Create a readable stream (object mode)\nvar stream = redis.scanStream();\nstream.on(\"data\", function(resultKeys) {\n  // `resultKeys` is an array of strings representing key names.\n  // Note that resultKeys may contain 0 keys, and that it will sometimes\n  // contain duplicates due to SCAN's implementation in Redis.\n  for (var i = 0; i < resultKeys.length; i++) {\n    console.log(resultKeys[i]);\n  }\n});\nstream.on(\"end\", function() {\n  console.log(\"all keys have been visited\");\n});\n```\n\n`scanStream` accepts an option, with which you can specify the `MATCH` pattern and the `COUNT` argument:\n\n```javascript\nvar stream = redis.scanStream({\n  // only returns keys following the pattern of `user:*`\n  match: \"user:*\",\n  // returns approximately 100 elements per call\n  count: 100\n});\n```\n\nJust like other commands, `scanStream` has a binary version `scanBufferStream`, which returns an array of buffers. It's useful when\nthe key names are not utf8 strings.\n\nThere are also `hscanStream`, `zscanStream` and `sscanStream` to iterate through elements in a hash, zset and set. The interface of each is\nsimilar to `scanStream` except the first argument is the key name:\n\n```javascript\nvar stream = redis.hscanStream(\"myhash\", {\n  match: \"age:??\"\n});\n```\n\nYou can learn more from the [Redis documentation](http://redis.io/commands/scan).\n\n**Useful Tips**\nIt's pretty common that doing an async task in the `data` handler. We'd like the scanning process to be paused until the async task to be finished. `Stream#pause()` and `Stream.resume()` do the trick. For example if we want to migrate data in Redis to MySQL:\n\n```javascript\nvar stream = redis.scanStream();\nstream.on(\"data\", function(resultKeys) {\n  // Pause the stream from scanning more keys until we've migrated the current keys.\n  stream.pause();\n\n  Promise.all(resultKeys.map(migrateKeyToMySQL)).then(() => {\n    // Resume the stream here.\n    stream.resume();\n  });\n});\n\nstream.on(\"end\", function() {\n  console.log(\"done migration\");\n});\n```\n\n## Auto-reconnect\n\nBy default, ioredis will try to reconnect when the connection to Redis is lost\nexcept when the connection is closed manually by `redis.disconnect()` or `redis.quit()`.\n\nIt's very flexible to control how long to wait to reconnect after disconnection\nusing the `retryStrategy` option:\n\n```javascript\nvar redis = new Redis({\n  // This is the default value of `retryStrategy`\n  retryStrategy: function(times) {\n    var delay = Math.min(times * 50, 2000);\n    return delay;\n  }\n});\n```\n\n`retryStrategy` is a function that will be called when the connection is lost.\nThe argument `times` means this is the nth reconnection being made and\nthe return value represents how long (in ms) to wait to reconnect. When the\nreturn value isn't a number, ioredis will stop trying to reconnect, and the connection\nwill be lost forever if the user doesn't call `redis.connect()` manually.\n\nWhen reconnected, the client will auto subscribe to channels that the previous connection subscribed to.\nThis behavior can be disabled by setting the `autoResubscribe` option to `false`.\n\nAnd if the previous connection has some unfulfilled commands (most likely blocking commands such as `brpop` and `blpop`),\nthe client will resend them when reconnected. This behavior can be disabled by setting the `autoResendUnfulfilledCommands` option to `false`.\n\nBy default, all pending commands will be flushed with an error every 20 retry attempts. That makes sure commands won't wait forever when the connection is down. You can change this behavior by setting `maxRetriesPerRequest`:\n\n```javascript\nvar redis = new Redis({\n  maxRetriesPerRequest: 1\n});\n```\n\nSet maxRetriesPerRequest to `null` to disable this behavior, and every command will wait forever until the connection is alive again (which is the default behavior before ioredis v4).\n\n### Reconnect on error\n\nBesides auto-reconnect when the connection is closed, ioredis supports reconnecting on the specified errors by the `reconnectOnError` option. Here's an example that will reconnect when receiving `READONLY` error:\n\n```javascript\nvar redis = new Redis({\n  reconnectOnError: function(err) {\n    var targetError = \"READONLY\";\n    if (err.message.slice(0, targetError.length) === targetError) {\n      // Only reconnect when the error starts with \"READONLY\"\n      return true; // or `return 1;`\n    }\n  }\n});\n```\n\nThis feature is useful when using Amazon ElastiCache. Once failover happens, Amazon ElastiCache will switch the master we currently connected with to a slave, leading to the following writes fails with the error `READONLY`. Using `reconnectOnError`, we can force the connection to reconnect on this error in order to connect to the new master.\n\nFurthermore, if the `reconnectOnError` returns `2`, ioredis will resend the failed command after reconnecting.\n\n## Connection Events\n\nThe Redis instance will emit some events about the state of the connection to the Redis server.\n\n| Event        | Description                                                                                                                                                                                                                                     |\n| :----------- | :---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| connect      | emits when a connection is established to the Redis server.                                                                                                                                                                                     |\n| ready        | If `enableReadyCheck` is `true`, client will emit `ready` when the server reports that it is ready to receive commands (e.g. finish loading data from disk).<br>Otherwise, `ready` will be emitted immediately right after the `connect` event. |\n| error        | emits when an error occurs while connecting.<br>However, ioredis emits all `error` events silently (only emits when there's at least one listener) so that your application won't crash if you're not listening to the `error` event.           |\n| close        | emits when an established Redis server connection has closed.                                                                                                                                                                                   |\n| reconnecting | emits after `close` when a reconnection will be made. The argument of the event is the time (in ms) before reconnecting.                                                                                                                        |\n| end          | emits after `close` when no more reconnections will be made, or the connection is failed to establish.                                                                                                                                          |\n\nYou can also check out the `Redis#status` property to get the current connection status.\n\nBesides the above connection events, there are several other custom events:\n\n| Event  | Description                                                         |\n| :----- | :------------------------------------------------------------------ |\n| select | emits when the database changed. The argument is the new db number. |\n\n## Offline Queue\n\nWhen a command can't be processed by Redis (being sent before the `ready` event), by default, it's added to the offline queue and will be\nexecuted when it can be processed. You can disable this feature by setting the `enableOfflineQueue`\noption to `false`:\n\n```javascript\nvar redis = new Redis({ enableOfflineQueue: false });\n```\n\n## TLS Options\n\nRedis doesn't support TLS natively, however if the redis server you want to connect to is hosted behind a TLS proxy (e.g. [stunnel](https://www.stunnel.org/)) or is offered by a PaaS service that supports TLS connection (e.g. [Redis Labs](https://redislabs.com/)), you can set the `tls` option:\n\n```javascript\nvar redis = new Redis({\n  host: \"localhost\",\n  tls: {\n    // Refer to `tls.connect()` section in\n    // https://nodejs.org/api/tls.html\n    // for all supported options\n    ca: fs.readFileSync(\"cert.pem\")\n  }\n});\n```\n\n<hr>\n\n## Sentinel\n\nioredis supports Sentinel out of the box. It works transparently as all features that work when\nyou connect to a single node also work when you connect to a sentinel group. Make sure to run Redis >= 2.8.12 if you want to use this feature. Sentinels have a default port of 26379.\n\nTo connect using Sentinel, use:\n\n```javascript\nvar redis = new Redis({\n  sentinels: [\n    { host: \"localhost\", port: 26379 },\n    { host: \"localhost\", port: 26380 }\n  ],\n  name: \"mymaster\"\n});\n\nredis.set(\"foo\", \"bar\");\n```\n\nThe arguments passed to the constructor are different from the ones you use to connect to a single node, where:\n\n- `name` identifies a group of Redis instances composed of a master and one or more slaves (`mymaster` in the example);\n- `sentinelPassword` (optional) password for Sentinel instances.\n- `sentinels` are a list of sentinels to connect to. The list does not need to enumerate all your sentinel instances, but a few so that if one is down the client will try the next one.\n- `role` (optional) with a value of `slave` will return a random slave from the Sentinel group.\n- `preferredSlaves` (optional) can be used to prefer a particular slave or set of slaves based on priority. It accepts a function or array.\n\nioredis **guarantees** that the node you connected to is always a master even after a failover. When a failover happens, instead of trying to reconnect to the failed node (which will be demoted to slave when it's available again), ioredis will ask sentinels for the new master node and connect to it. All commands sent during the failover are queued and will be executed when the new connection is established so that none of the commands will be lost.\n\nIt's possible to connect to a slave instead of a master by specifying the option `role` with the value of `slave` and ioredis will try to connect to a random slave of the specified master, with the guarantee that the connected node is always a slave. If the current node is promoted to master due to a failover, ioredis will disconnect from it and ask the sentinels for another slave node to connect to.\n\nIf you specify the option `preferredSlaves` along with `role: 'slave'` ioredis will attempt to use this value when selecting the slave from the pool of available slaves. The value of `preferredSlaves` should either be a function that accepts an array of avaiable slaves and returns a single result, or an array of slave values priorities by the lowest `prio` value first with a default value of `1`.\n\n```javascript\n// available slaves format\nvar availableSlaves = [{ ip: \"127.0.0.1\", port: \"31231\", flags: \"slave\" }];\n\n// preferredSlaves array format\nvar preferredSlaves = [\n  { ip: \"127.0.0.1\", port: \"31231\", prio: 1 },\n  { ip: \"127.0.0.1\", port: \"31232\", prio: 2 }\n];\n\n// preferredSlaves function format\npreferredSlaves = function(availableSlaves) {\n  for (var i = 0; i < availableSlaves.length; i++) {\n    var slave = availableSlaves[i];\n    if (slave.ip === \"127.0.0.1\") {\n      if (slave.port === \"31234\") {\n        return slave;\n      }\n    }\n  }\n  // if no preferred slaves are available a random one is used\n  return false;\n};\n\nvar redis = new Redis({\n  sentinels: [\n    { host: \"127.0.0.1\", port: 26379 },\n    { host: \"127.0.0.1\", port: 26380 }\n  ],\n  name: \"mymaster\",\n  role: \"slave\",\n  preferredSlaves: preferredSlaves\n});\n```\n\nBesides the `retryStrategy` option, there's also a `sentinelRetryStrategy` in Sentinel mode which will be invoked when all the sentinel nodes are unreachable during connecting. If `sentinelRetryStrategy` returns a valid delay time, ioredis will try to reconnect from scratch. The default value of `sentinelRetryStrategy` is:\n\n```javascript\nfunction (times) {\n  var delay = Math.min(times * 10, 1000);\n  return delay;\n}\n```\n\n## Cluster\n\nRedis Cluster provides a way to run a Redis installation where data is automatically sharded across multiple Redis nodes.\nYou can connect to a Redis Cluster like this:\n\n```javascript\nvar Redis = require(\"ioredis\");\n\nvar cluster = new Redis.Cluster([\n  {\n    port: 6380,\n    host: \"127.0.0.1\"\n  },\n  {\n    port: 6381,\n    host: \"127.0.0.1\"\n  }\n]);\n\ncluster.set(\"foo\", \"bar\");\ncluster.get(\"foo\", function(err, res) {\n  // res === 'bar'\n});\n```\n\n`Cluster` constructor accepts two arguments, where:\n\n0.  The first argument is a list of nodes of the cluster you want to connect to.\n    Just like Sentinel, the list does not need to enumerate all your cluster nodes,\n    but a few so that if one is unreachable the client will try the next one, and the client will discover other nodes automatically when at least one node is connected.\n1.  The second argument is the options, where:\n\n    - `clusterRetryStrategy`: When none of the startup nodes are reachable, `clusterRetryStrategy` will be invoked. When a number is returned,\n      ioredis will try to reconnect to the startup nodes from scratch after the specified delay (in ms). Otherwise, an error of \"None of startup nodes is available\" will be returned.\n      The default value of this option is:\n\n          ```javascript\n          function (times) {\n            var delay = Math.min(100 + times * 2, 2000);\n            return delay;\n          }\n          ```\n\n          It's possible to modify the `startupNodes` property in order to switch to another set of nodes here:\n\n          ```javascript\n          function (times) {\n            this.startupNodes = [{ port: 6790, host: '127.0.0.1' }];\n            return Math.min(100 + times * 2, 2000);\n          }\n          ```\n\n    - `dnsLookup`: Alternative DNS lookup function (`dns.lookup()` is used by default). It may be useful to override this in special cases, such as when AWS ElastiCache used with TLS enabled.\n    - `enableOfflineQueue`: Similar to the `enableOfflineQueue` option of `Redis` class.\n    - `enableReadyCheck`: When enabled, \"ready\" event will only be emitted when `CLUSTER INFO` command\n      reporting the cluster is ready for handling commands. Otherwise, it will be emitted immediately after \"connect\" is emitted.\n    - `scaleReads`: Config where to send the read queries. See below for more details.\n    - `maxRedirections`: When a cluster related error (e.g. `MOVED`, `ASK` and `CLUSTERDOWN` etc.) is received, the client will redirect the\n      command to another node. This option limits the max redirections allowed when sending a command. The default value is `16`.\n    - `retryDelayOnFailover`: If the target node is disconnected when sending a command,\n      ioredis will retry after the specified delay. The default value is `100`. You should make sure `retryDelayOnFailover * maxRedirections > cluster-node-timeout`\n      to insure that no command will fail during a failover.\n    - `retryDelayOnClusterDown`: When a cluster is down, all commands will be rejected with the error of `CLUSTERDOWN`. If this option is a number (by default, it is `100`), the client\n      will resend the commands after the specified time (in ms).\n    - `retryDelayOnTryAgain`: If this option is a number (by default, it is `100`), the client\n      will resend the commands rejected with `TRYAGAIN` error after the specified time (in ms).\n    - `redisOptions`: Default options passed to the constructor of `Redis` when connecting to a node.\n    - `slotsRefreshTimeout`: Milliseconds before a timeout occurs while refreshing slots from the cluster (default `1000`)\n    - `slotsRefreshInterval`: Milliseconds between every automatic slots refresh (default `5000`)\n\n### Read-write splitting\n\nA typical redis cluster contains three or more masters and several slaves for each master. It's possible to scale out redis cluster by sending read queries to slaves and write queries to masters by setting the `scaleReads` option.\n\n`scaleReads` is \"master\" by default, which means ioredis will never send any queries to slaves. There are other three available options:\n\n1. \"all\": Send write queries to masters and read queries to masters or slaves randomly.\n2. \"slave\": Send write queries to masters and read queries to slaves.\n3. a custom `function(nodes, command): node`: Will choose the custom function to select to which node to send read queries (write queries keep being sent to master). The first node in `nodes` is always the master serving the relevant slots. If the function returns an array of nodes, a random node of that list will be selected.\n\nFor example:\n\n```javascript\nvar cluster = new Redis.Cluster(\n  [\n    /* nodes */\n  ],\n  {\n    scaleReads: \"slave\"\n  }\n);\ncluster.set(\"foo\", \"bar\"); // This query will be sent to one of the masters.\ncluster.get(\"foo\", function(err, res) {\n  // This query will be sent to one of the slaves.\n});\n```\n\n**NB** In the code snippet above, the `res` may not be equal to \"bar\" because of the lag of replication between the master and slaves.\n\n### Running commands to multiple nodes\n\nEvery command will be sent to exactly one node. For commands containing keys, (e.g. `GET`, `SET` and `HGETALL`), ioredis sends them to the node that serving the keys, and for other commands not containing keys, (e.g. `INFO`, `KEYS` and `FLUSHDB`), ioredis sends them to a random node.\n\nSometimes you may want to send a command to multiple nodes (masters or slaves) of the cluster, you can get the nodes via `Cluster#nodes()` method.\n\n`Cluster#nodes()` accepts a parameter role, which can be \"master\", \"slave\" and \"all\" (default), and returns an array of `Redis` instance. For example:\n\n```javascript\n// Send `FLUSHDB` command to all slaves:\nvar slaves = cluster.nodes(\"slave\");\nPromise.all(\n  slaves.map(function(node) {\n    return node.flushdb();\n  })\n);\n\n// Get keys of all the masters:\nvar masters = cluster.nodes(\"master\");\nPromise.all(\n  masters.map(function(node) {\n    return node.keys();\n  })\n).then(function(keys) {\n  // keys: [['key1', 'key2'], ['key3', 'key4']]\n});\n```\n\n### NAT Mapping\n\nSometimes the cluster is hosted within a internal network that can only be accessed via a NAT (Network Address Translation) instance. See [Accessing ElastiCache from outside AWS](https://docs.aws.amazon.com/AmazonElastiCache/latest/red-ug/accessing-elasticache.html) as an example.\n\nYou can specify nat mapping rules via `natMap` option:\n\n```javascript\nconst cluster = new Redis.Cluster(\n  [\n    {\n      host: \"203.0.113.73\",\n      port: 30001\n    }\n  ],\n  {\n    natMap: {\n      \"10.0.1.230:30001\": { host: \"203.0.113.73\", port: 30001 },\n      \"10.0.1.231:30001\": { host: \"203.0.113.73\", port: 30002 },\n      \"10.0.1.232:30001\": { host: \"203.0.113.73\", port: 30003 }\n    }\n  }\n);\n```\n\nThis option is also useful when the cluster is running inside a Docker container.\n\n### Transaction and pipeline in Cluster mode\n\nAlmost all features that are supported by `Redis` are also supported by `Redis.Cluster`, e.g. custom commands, transaction and pipeline.\nHowever there are some differences when using transaction and pipeline in Cluster mode:\n\n0. All keys in a pipeline should belong to the same slot since ioredis sends all commands in a pipeline to the same node.\n1. You can't use `multi` without pipeline (aka `cluster.multi({ pipeline: false })`). This is because when you call `cluster.multi({ pipeline: false })`, ioredis doesn't know which node the `multi` command should be sent to.\n2. Chaining custom commands in the pipeline is not supported in Cluster mode.\n\nWhen any commands in a pipeline receives a `MOVED` or `ASK` error, ioredis will resend the whole pipeline to the specified node automatically if all of the following conditions are satisfied:\n\n0. All errors received in the pipeline are the same. For example, we won't resend the pipeline if we got two `MOVED` errors pointing to different nodes.\n1. All commands executed successfully are readonly commands. This makes sure that resending the pipeline won't have side effects.\n\n### Pub/Sub\n\nPub/Sub in cluster mode works exactly as the same as in standalone mode. Internally, when a node of the cluster receives a message, it will broadcast the message to the other nodes. ioredis makes sure that each message will only be received once by strictly subscribing one node at the same time.\n\n```javascript\nvar nodes = [\n  /* nodes */\n];\nvar pub = new Redis.Cluster(nodes);\nvar sub = new Redis.Cluster(nodes);\nsub.on(\"message\", function(channel, message) {\n  console.log(channel, message);\n});\n\nsub.subscribe(\"news\", function() {\n  pub.publish(\"news\", \"highlights\");\n});\n```\n\n### Events\n\n| Event        | Description                                                                                                                                                                                                |\n| :----------- | :--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| connect      | emits when a connection is established to the Redis server.                                                                                                                                                |\n| ready        | emits when `CLUSTER INFO` reporting the cluster is able to receive commands (if `enableReadyCheck` is `true`) or immediately after `connect` event (if `enableReadyCheck` is false).                       |\n| error        | emits when an error occurs while connecting with a property of `lastNodeError` representing the last node error received. This event is emitted silently (only emitting if there's at least one listener). |\n| close        | emits when an established Redis server connection has closed.                                                                                                                                              |\n| reconnecting | emits after `close` when a reconnection will be made. The argument of the event is the time (in ms) before reconnecting.                                                                                   |\n| end          | emits after `close` when no more reconnections will be made.                                                                                                                                               |\n| +node        | emits when a new node is connected.                                                                                                                                                                        |\n| -node        | emits when a node is disconnected.                                                                                                                                                                         |\n| node error   | emits when an error occurs when connecting to a node. The second argument indicates the address of the node.                                                                                               |\n\n### Password\n\nSetting the `password` option to access password-protected clusters:\n\n```javascript\nvar Redis = require(\"ioredis\");\nvar cluster = new Redis.Cluster(nodes, {\n  redisOptions: {\n    password: \"your-cluster-password\"\n  }\n});\n```\n\nIf some of nodes in the cluster using a different password, you should specify them in the first parameter:\n\n```javascript\nvar Redis = require(\"ioredis\");\nvar cluster = new Redis.Cluster(\n  [\n    // Use password \"password-for-30001\" for 30001\n    { port: 30001, password: \"password-for-30001\" },\n    // Don't use password when accessing 30002\n    { port: 30002, password: null }\n    // Other nodes will use \"fallback-password\"\n  ],\n  {\n    redisOptions: {\n      password: \"fallback-password\"\n    }\n  }\n);\n```\n\n### Special note: AWS ElastiCache Clusters with TLS\n\nAWS ElastiCache for Redis (Clustered Mode) supports TLS encryption. If you use\nthis, you may encounter errors with invalid certificates. To resolve this\nissue, construct the `Cluster` with the `dnsLookup` option as follows:\n\n```javascript\nvar cluster = new Redis.Cluster(\n  [{\n    host: 'clustercfg.myCluster.abcdefg.xyz.cache.amazonaws.com',\n    port: 6379\n  }],\n  {\n    dnsLookup: (address, callback) => callback(null, address),\n    redisOptions: {\n      tls: {}\n    },\n  }\n};\n```\n\n<hr>\n\n# Error Handling\n\nAll the errors returned by the Redis server are instances of `ReplyError`, which can be accessed via `Redis`:\n\n```javascript\nvar Redis = require(\"ioredis\");\nvar redis = new Redis();\n// This command causes a reply error since the SET command requires two arguments.\nredis.set(\"foo\", function(err) {\n  err instanceof Redis.ReplyError;\n});\n```\n\nThis is the error stack of the `ReplyError`:\n\n```\nReplyError: ERR wrong number of arguments for 'set' command\n    at ReplyParser._parseResult (/app/node_modules/ioredis/lib/parsers/javascript.js:60:14)\n    at ReplyParser.execute (/app/node_modules/ioredis/lib/parsers/javascript.js:178:20)\n    at Socket.<anonymous> (/app/node_modules/ioredis/lib/redis/event_handler.js:99:22)\n    at Socket.emit (events.js:97:17)\n    at readableAddChunk (_stream_readable.js:143:16)\n    at Socket.Readable.push (_stream_readable.js:106:10)\n    at TCP.onread (net.js:509:20)\n```\n\nBy default, the error stack doesn't make any sense because the whole stack happens in the ioredis\nmodule itself, not in your code. So it's not easy to find out where the error happens in your code.\nioredis provides an option `showFriendlyErrorStack` to solve the problem. When you enable\n`showFriendlyErrorStack`, ioredis will optimize the error stack for you:\n\n```javascript\nvar Redis = require(\"ioredis\");\nvar redis = new Redis({ showFriendlyErrorStack: true });\nredis.set(\"foo\");\n```\n\nAnd the output will be:\n\n```\nReplyError: ERR wrong number of arguments for 'set' command\n    at Object.<anonymous> (/app/index.js:3:7)\n    at Module._compile (module.js:446:26)\n    at Object.Module._extensions..js (module.js:464:10)\n    at Module.load (module.js:341:32)\n    at Function.Module._load (module.js:296:12)\n    at Function.Module.runMain (module.js:487:10)\n    at startup (node.js:111:16)\n    at node.js:799:3\n```\n\nThis time the stack tells you that the error happens on the third line in your code. Pretty sweet!\nHowever, it would decrease the performance significantly to optimize the error stack. So by\ndefault, this option is disabled and can only be used for debugging purposes. You **shouldn't** use this feature in a production environment.\n\n# Plugging in your own Promises Library\n\nIf you're an advanced user, you may want to plug in your own promise library like [bluebird](https://www.npmjs.com/package/bluebird). Just set Redis.Promise to your favorite ES6-style promise constructor and ioredis will use it.\n\n```javascript\nconst Redis = require(\"ioredis\");\nRedis.Promise = require(\"bluebird\");\n\nconst redis = new Redis();\n\n// Use bluebird\nassert.equal(redis.get().constructor, require(\"bluebird\"));\n\n// You can change the Promise implementation at any time:\nRedis.Promise = global.Promise;\nassert.equal(redis.get().constructor, global.Promise);\n```\n\n# Running tests\n\nStart a Redis server on 127.0.0.1:6379, and then:\n\n```shell\n$ npm test\n```\n\n`FLUSH ALL` will be invoked after each test, so make sure there's no valuable data in it before running tests.\n\nIf your testing environment does not let you spin up a Redis server [ioredis-mock](https://github.com/stipsan/ioredis-mock) is a drop-in replacement you can use in your tests. It aims to behave identically to ioredis connected to a Redis server so that your integration tests is easier to write and of better quality.\n\n# Debug\n\nYou can set the `DEBUG` env to `ioredis:*` to print debug info:\n\n```shell\n$ DEBUG=ioredis:* node app.js\n```\n\n# Join in!\n\nI'm happy to receive bug reports, fixes, documentation enhancements, and any other improvements.\n\nAnd since I'm not a native English speaker, if you find any grammar mistakes in the documentation, please also let me know. :)\n\n# Become a Sponsor\n\nOpen source is hard and time-consuming. If you want to invest in ioredis's future you can become a sponsor and make us spend more time on this library's improvements and new features.\n\n<a href=\"https://opencollective.com/ioredis\"><img src=\"https://opencollective.com/ioredis/tiers/sponsor.svg?avatarHeight=36\"></a>\n\nThank you for using ioredis :-)\n\n# Contributors\n\nThis project exists thanks to all the people who contribute:\n\n<a href=\"https://github.com/luin/ioredis/graphs/contributors\"><img src=\"https://opencollective.com/ioredis/contributors.svg?width=890&showBtn=false\" /></a>\n\n# License\n\nMIT\n\n[![FOSSA Status](https://app.fossa.io/api/projects/git%2Bgithub.com%2Fluin%2Fioredis.svg?type=large)](https://app.fossa.io/projects/git%2Bgithub.com%2Fluin%2Fioredis?ref=badge_large)\n","readmeFilename":"README.md","bugs":{"url":"https://github.com/luin/ioredis/issues"},"homepage":"https://github.com/luin/ioredis#readme","_id":"ioredis@4.12.1","_nodeVersion":"10.16.0","_npmVersion":"6.9.0","dist":{"integrity":"sha512-GIgrwkIJP0U79/r21YYGHNPQYI54Ct5aI04wfODcF8HArm1tQURUviiRKlENWvAcr1Hd0uArDW99AfdrdxjtEw==","shasum":"4ccaa371362f50fa4a1efb37836ebbae3a7285c6","tarball":"https://registry.npmjs.org/ioredis/-/ioredis-4.12.1.tgz","fileCount":36,"unpackedSize":236534,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJdLCjSCRA9TVsSAnZWagAAUHUP/jENJ2VU1ttkyKpMXx32\nnUI9/KIwG2/UiQnwx55Kd3TAmiFhyZVG+OGZ/J7ipLUhBRd2KtuqM/K2DTpM\nWibfAo875RzMBndq76s8b0mbmA8gcuSX3xMaJOJp6kc1jZXMbypHuZ1Xp7N/\npE19xYivBLBcabQG6t34T8mgi3FR5iNNAIabKso2si3/F7ARqhLtNZMaG0dW\nfFQeKCqPOKG8cS2hu4XO1dZ2XOTEdp/HAGjp3aQm6pqlhdQ+scqMmdP5Cdtp\n8iYw5PT861vXSzcaV9cb1/XIXvWUWmyCnsb4k6+HTTGnB3OxGYiojp2NCMh9\n2cD9thSh1Qqzx3NL4AcNI5fY+t0AiJBsFf5z09DlDvs6t5LHBEy+8RCRd6zy\nDKhTJNx8pZOtzhfOcoVFYYZ3IJ/6oM8L2buTHgkwKc3KF12QDf7BZ7NIwF5U\nbJDAQKhh3gXPRSYYFVNVJo3NnuLJkknuivU3PxR1mxoTYaP/wexbWg3fLtL2\nqOGRGZvDco+9uWKAESpmNP93WuQhFum9bOo43pPq9SkO+ZGrTTvrc0URLeJj\n1DP/QWywC8MCdpODwYBpjf8BTP32eddR47TzLnbtEI4YTqumn+nYpLAx8fAv\nzZaoY5a/+Fw2Es63HdNLIS9sZ/8ZpneNNlVy4NFfQDYOeGRR2AqqyoMe2z6W\ntABq\r\n=nFJH\r\n-----END PGP SIGNATURE-----\r\n"},"maintainers":[{"email":"ioredis-robot@zihua.li","name":"ioredis-robot"},{"email":"i@zihua.li","name":"luin"}],"_npmUser":{"name":"luin","email":"i@zihua.li"},"directories":{},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/ioredis_4.12.1_1563175121277_0.2715884002430613"},"_hasShrinkwrap":false},"4.12.2":{"name":"ioredis","version":"4.12.2","description":"A robust, performance-focused and full-featured Redis client for Node.js.","main":"built/index.js","scripts":{"test":"TS_NODE_TRANSPILE_ONLY=true TS_NODE_LOG_ERROR=true NODE_ENV=test mocha \"test/**/*.ts\"","test:cov":"TS_NODE_TRANSPILE_ONLY=true TS_NODE_LOG_ERROR=true NODE_ENV=test node ./node_modules/istanbul/lib/cli.js cover --preserve-comments ./node_modules/mocha/bin/_mocha -- -r ts-node/register -R spec --exit \"test/**/*.ts\"","lint":"eslint --ext .js,.ts .","format":"prettier --write \"{,!(node_modules)/**/}*.{js,ts}\"","format-check":"prettier --check \"{,!(node_modules)/**/}*.{js,ts}\"","build":"rm -rf built && tsc","prepublishOnly":"npm run build && npm test","bench":"matcha benchmarks/*.js","semantic-release":"semantic-release"},"repository":{"type":"git","url":"git://github.com/luin/ioredis.git"},"keywords":["redis","cluster","sentinel","pipelining"],"author":{"name":"luin","email":"i@zihua.li","url":"http://zihua.li"},"license":"MIT","dependencies":{"cluster-key-slot":"^1.0.6","debug":"^4.1.1","denque":"^1.1.0","lodash.defaults":"^4.2.0","lodash.flatten":"^4.4.0","redis-commands":"1.5.0","redis-errors":"^1.2.0","redis-parser":"^3.0.0","standard-as-callback":"^2.0.1"},"devDependencies":{"@semantic-release/changelog":"^3.0.4","@semantic-release/git":"^7.0.12","@types/bluebird":"^3.5.27","@types/chai":"^4.1.7","@types/debug":"^4.1.4","@types/lodash.defaults":"^4.2.6","@types/lodash.flatten":"^4.4.6","@types/mocha":"^5.2.7","@types/node":"^12.0.2","@types/redis-errors":"1.2.0","@types/sinon":"^7.0.13","@typescript-eslint/eslint-plugin":"^1.11.0","@typescript-eslint/parser":"^1.11.0","bluebird":"^3.5.4","chai":"^4.2.0","cz-conventional-changelog":"^2.0.0","eslint":"^5.16.0","eslint-config-prettier":"^5.1.0","husky":"^2.5.0","istanbul":"^0.4.5","mocha":"^5.0.0","prettier":"^1.18.2","pretty-quick":"^1.11.1","server-destroy":"^1.0.1","sinon":"^7.3.2","ts-node":"^8.1.0","typescript":"^3.5.1"},"engines":{"node":">=6"},"config":{"commitizen":{"path":"./node_modules/cz-conventional-changelog"}},"husky":{"hooks":{"pre-commit":"pretty-quick --staged"}},"gitHead":"717fe4db139c7b45096bcdd80704b9297fce30c8","readme":"[![ioredis](https://cdn.jsdelivr.net/gh/luin/ioredis@b5e8c74/logo.svg)](https://github.com/luin/ioredis)\n\n[![Build Status](https://travis-ci.org/luin/ioredis.svg?branch=master)](https://travis-ci.org/luin/ioredis)\n[![Test Coverage](https://codeclimate.com/github/luin/ioredis/badges/coverage.svg)](https://codeclimate.com/github/luin/ioredis)\n[![code style: prettier](https://img.shields.io/badge/code_style-prettier-ff69b4.svg?style=flat-square)](https://github.com/prettier/prettier)\n[![Join the chat at https://gitter.im/luin/ioredis](https://badges.gitter.im/Join%20Chat.svg)](https://gitter.im/luin/ioredis?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge)\n[![Commitizen friendly](https://img.shields.io/badge/commitizen-friendly-brightgreen.svg)](http://commitizen.github.io/cz-cli/)\n[![semantic-release](https://img.shields.io/badge/%20%20%F0%9F%93%A6%F0%9F%9A%80-semantic--release-e10079.svg)](https://github.com/semantic-release/semantic-release)\n[![npm latest version](https://img.shields.io/npm/v/ioredis/latest.svg)](https://www.npmjs.com/package/ioredis)\n[![npm next version](https://img.shields.io/npm/v/ioredis/next.svg)](https://www.npmjs.com/package/ioredis)\n<img alt=\"\" src=\"\">\n\nA robust, performance-focused and full-featured [Redis](http://redis.io) client for [Node.js](https://nodejs.org).\n\nSupports Redis >= 2.6.12 and (Node.js >= 6).\n\n# Features\n\nioredis is a robust, full-featured Redis client that is\nused in the world's biggest online commerce company [Alibaba](http://www.alibaba.com/) and many other awesome companies.\n\n0. Full-featured. It supports [Cluster](http://redis.io/topics/cluster-tutorial), [Sentinel](http://redis.io/topics/sentinel), [Pipelining](http://redis.io/topics/pipelining) and of course [Lua scripting](http://redis.io/commands/eval) & [Pub/Sub](http://redis.io/topics/pubsub) (with the support of binary messages).\n1. High performance.\n2. Delightful API. It works with Node callbacks and Native promises.\n3. Transformation of command arguments and replies.\n4. Transparent key prefixing.\n5. Abstraction for Lua scripting, allowing you to define custom commands.\n6. Support for binary data.\n7. Support for TLS.\n8. Support for offline queue and ready checking.\n9. Support for ES6 types, such as `Map` and `Set`.\n10. Support for GEO commands (Redis 3.2 Unstable).\n11. Sophisticated error handling strategy.\n12. Support for NAT mapping.\n\n# Links\n\n- [API Documentation](API.md)\n- [Changelog](Changelog.md)\n- [Migrating from node_redis](https://github.com/luin/ioredis/wiki/Migrating-from-node_redis)\n- [Error Handling](#error-handling)\n\n<hr>\n<a href=\"http://bit.ly/medis-macos\"><img align=\"right\" src=\"resources/medis.png\" alt=\"Download on the App Store\"></a>\n\n### [AD] Medis: Redis GUI for OS X\n\nLooking for a Redis GUI manager for OS X, Windows and Linux? Here's [Medis](http://bit.ly/medis-macos)!\n\nMedis is an open-sourced, beautiful, easy-to-use Redis GUI management application.\n\nMedis starts with all the basic features you need:\n\n- Keys viewing/editing\n- SSH Tunnel for connecting with remote servers\n- Terminal for executing custom commands\n- JSON/MessagePack format viewing/editing and built-in highlighting/validator\n- And other awesome features...\n\n[Medis is open sourced on GitHub](https://github.com/luin/medis)\n\n### [AD] Kuber: Kubernetes Dashboard for iOS\n\n<a href=\"http://bit.ly/kuber-ios\"><img src=\"resources/kuber.png\" alt=\"Download on the App Store\"></a>\n\n<hr>\n\n# Quick Start\n\n## Install\n\n```shell\n$ npm install ioredis\n```\n\n## Basic Usage\n\n```javascript\nvar Redis = require(\"ioredis\");\nvar redis = new Redis();\n\nredis.set(\"foo\", \"bar\");\nredis.get(\"foo\", function(err, result) {\n  console.log(result);\n});\nredis.del(\"foo\");\n\n// Or using a promise if the last argument isn't a function\nredis.get(\"foo\").then(function(result) {\n  console.log(result);\n});\n\n// Arguments to commands are flattened, so the following are the same:\nredis.sadd(\"set\", 1, 3, 5, 7);\nredis.sadd(\"set\", [1, 3, 5, 7]);\n\n// All arguments are passed directly to the redis server:\nredis.set(\"key\", 100, \"EX\", 10);\n```\n\nSee the `examples/` folder for more examples.\n\n## Connect to Redis\n\nWhen a new `Redis` instance is created,\na connection to Redis will be created at the same time.\nYou can specify which Redis to connect to by:\n\n```javascript\nnew Redis(); // Connect to 127.0.0.1:6379\nnew Redis(6380); // 127.0.0.1:6380\nnew Redis(6379, \"192.168.1.1\"); // 192.168.1.1:6379\nnew Redis(\"/tmp/redis.sock\");\nnew Redis({\n  port: 6379, // Redis port\n  host: \"127.0.0.1\", // Redis host\n  family: 4, // 4 (IPv4) or 6 (IPv6)\n  password: \"auth\",\n  db: 0\n});\n```\n\nYou can also specify connection options as a [`redis://` URL](http://www.iana.org/assignments/uri-schemes/prov/redis):\n\n```javascript\n// Connect to 127.0.0.1:6380, db 4, using password \"authpassword\":\nnew Redis(\"redis://:authpassword@127.0.0.1:6380/4\");\n```\n\nSee [API Documentation](API.md#new_Redis) for all available options.\n\n## Pub/Sub\n\nHere is a simple example of the API for publish/subscribe.\nThe following program opens two client connections.\nIt subscribes to a channel with one connection\nand publishes to that channel with the other:\n\n```javascript\nvar Redis = require(\"ioredis\");\nvar redis = new Redis();\nvar pub = new Redis();\nredis.subscribe(\"news\", \"music\", function(err, count) {\n  // Now we are subscribed to both the 'news' and 'music' channels.\n  // `count` represents the number of channels we are currently subscribed to.\n\n  pub.publish(\"news\", \"Hello world!\");\n  pub.publish(\"music\", \"Hello again!\");\n});\n\nredis.on(\"message\", function(channel, message) {\n  // Receive message Hello world! from channel news\n  // Receive message Hello again! from channel music\n  console.log(\"Receive message %s from channel %s\", message, channel);\n});\n\n// There's also an event called 'messageBuffer', which is the same as 'message' except\n// it returns buffers instead of strings.\nredis.on(\"messageBuffer\", function(channel, message) {\n  // Both `channel` and `message` are buffers.\n});\n```\n\n`PSUBSCRIBE` is also supported in a similar way:\n\n```javascript\nredis.psubscribe(\"pat?ern\", function(err, count) {});\nredis.on(\"pmessage\", function(pattern, channel, message) {});\nredis.on(\"pmessageBuffer\", function(pattern, channel, message) {});\n```\n\nWhen a client issues a SUBSCRIBE or PSUBSCRIBE, that connection is put into a \"subscriber\" mode.\nAt that point, only commands that modify the subscription set are valid.\nWhen the subscription set is empty, the connection is put back into regular mode.\n\nIf you need to send regular commands to Redis while in subscriber mode, just open another connection.\n\n## Handle Binary Data\n\nArguments can be buffers:\n\n```javascript\nredis.set(\"foo\", Buffer.from(\"bar\"));\n```\n\nAnd every command has a method that returns a Buffer (by adding a suffix of \"Buffer\" to the command name).\nTo get a buffer instead of a utf8 string:\n\n```javascript\nredis.getBuffer(\"foo\", function(err, result) {\n  // result is a buffer.\n});\n```\n\n## Pipelining\n\nIf you want to send a batch of commands (e.g. > 5), you can use pipelining to queue\nthe commands in memory and then send them to Redis all at once. This way the performance improves by 50%~300% (See [benchmark section](#benchmark)).\n\n`redis.pipeline()` creates a `Pipeline` instance. You can call any Redis\ncommands on it just like the `Redis` instance. The commands are queued in memory\nand flushed to Redis by calling the `exec` method:\n\n```javascript\nvar pipeline = redis.pipeline();\npipeline.set(\"foo\", \"bar\");\npipeline.del(\"cc\");\npipeline.exec(function(err, results) {\n  // `err` is always null, and `results` is an array of responses\n  // corresponding to the sequence of queued commands.\n  // Each response follows the format `[err, result]`.\n});\n\n// You can even chain the commands:\nredis\n  .pipeline()\n  .set(\"foo\", \"bar\")\n  .del(\"cc\")\n  .exec(function(err, results) {});\n\n// `exec` also returns a Promise:\nvar promise = redis\n  .pipeline()\n  .set(\"foo\", \"bar\")\n  .get(\"foo\")\n  .exec();\npromise.then(function(result) {\n  // result === [[null, 'OK'], [null, 'bar']]\n});\n```\n\nEach chained command can also have a callback, which will be invoked when the command\ngets a reply:\n\n```javascript\nredis\n  .pipeline()\n  .set(\"foo\", \"bar\")\n  .get(\"foo\", function(err, result) {\n    // result === 'bar'\n  })\n  .exec(function(err, result) {\n    // result[1][1] === 'bar'\n  });\n```\n\nIn addition to adding commands to the `pipeline` queue individually, you can also pass an array of commands and arguments to the constructor:\n\n```javascript\nredis.pipeline([[\"set\", \"foo\", \"bar\"], [\"get\", \"foo\"]]).exec(function() {\n  /* ... */\n});\n```\n\n`#length` property shows how many commands in the pipeline:\n\n```javascript\nconst length = redis\n  .pipeline()\n  .set(\"foo\", \"bar\")\n  .get(\"foo\").length;\n// length === 2\n```\n\n## Transaction\n\nMost of the time, the transaction commands `multi` & `exec` are used together with pipeline.\nTherefore, when `multi` is called, a `Pipeline` instance is created automatically by default,\nso you can use `multi` just like `pipeline`:\n\n```javascript\nredis\n  .multi()\n  .set(\"foo\", \"bar\")\n  .get(\"foo\")\n  .exec(function(err, results) {\n    // results === [[null, 'OK'], [null, 'bar']]\n  });\n```\n\nIf there's a syntax error in the transaction's command chain (e.g. wrong number of arguments, wrong command name, etc),\nthen none of the commands would be executed, and an error is returned:\n\n```javascript\nredis\n  .multi()\n  .set(\"foo\")\n  .set(\"foo\", \"new value\")\n  .exec(function(err, results) {\n    // err:\n    //  { [ReplyError: EXECABORT Transaction discarded because of previous errors.]\n    //    name: 'ReplyError',\n    //    message: 'EXECABORT Transaction discarded because of previous errors.',\n    //    command: { name: 'exec', args: [] },\n    //    previousErrors:\n    //     [ { [ReplyError: ERR wrong number of arguments for 'set' command]\n    //         name: 'ReplyError',\n    //         message: 'ERR wrong number of arguments for \\'set\\' command',\n    //         command: [Object] } ] }\n  });\n```\n\nIn terms of the interface, `multi` differs from `pipeline` in that when specifying a callback\nto each chained command, the queueing state is passed to the callback instead of the result of the command:\n\n```javascript\nredis\n  .multi()\n  .set(\"foo\", \"bar\", function(err, result) {\n    // result === 'QUEUED'\n  })\n  .exec(/* ... */);\n```\n\nIf you want to use transaction without pipeline, pass `{ pipeline: false }` to `multi`,\nand every command will be sent to Redis immediately without waiting for an `exec` invocation:\n\n```javascript\nredis.multi({ pipeline: false });\nredis.set(\"foo\", \"bar\");\nredis.get(\"foo\");\nredis.exec(function(err, result) {\n  // result === [[null, 'OK'], [null, 'bar']]\n});\n```\n\nThe constructor of `multi` also accepts a batch of commands:\n\n```javascript\nredis.multi([[\"set\", \"foo\", \"bar\"], [\"get\", \"foo\"]]).exec(function() {\n  /* ... */\n});\n```\n\nInline transactions are supported by pipeline, which means you can group a subset of commands\nin the pipeline into a transaction:\n\n```javascript\nredis\n  .pipeline()\n  .get(\"foo\")\n  .multi()\n  .set(\"foo\", \"bar\")\n  .get(\"foo\")\n  .exec()\n  .get(\"foo\")\n  .exec();\n```\n\n## Lua Scripting\n\nioredis supports all of the scripting commands such as `EVAL`, `EVALSHA` and `SCRIPT`.\nHowever, it's tedious to use in real world scenarios since developers have to take\ncare of script caching and to detect when to use `EVAL` and when to use `EVALSHA`.\nioredis expose a `defineCommand` method to make scripting much easier to use:\n\n```javascript\nvar redis = new Redis();\n\n// This will define a command echo:\nredis.defineCommand(\"echo\", {\n  numberOfKeys: 2,\n  lua: \"return {KEYS[1],KEYS[2],ARGV[1],ARGV[2]}\"\n});\n\n// Now `echo` can be used just like any other ordinary command,\n// and ioredis will try to use `EVALSHA` internally when possible for better performance.\nredis.echo(\"k1\", \"k2\", \"a1\", \"a2\", function(err, result) {\n  // result === ['k1', 'k2', 'a1', 'a2']\n});\n\n// `echoBuffer` is also defined automatically to return buffers instead of strings:\nredis.echoBuffer(\"k1\", \"k2\", \"a1\", \"a2\", function(err, result) {\n  // result[0] equals to Buffer.from('k1');\n});\n\n// And of course it works with pipeline:\nredis\n  .pipeline()\n  .set(\"foo\", \"bar\")\n  .echo(\"k1\", \"k2\", \"a1\", \"a2\")\n  .exec();\n```\n\nIf the number of keys can't be determined when defining a command, you can\nomit the `numberOfKeys` property and pass the number of keys as the first argument\nwhen you call the command:\n\n```javascript\nredis.defineCommand(\"echoDynamicKeyNumber\", {\n  lua: \"return {KEYS[1],KEYS[2],ARGV[1],ARGV[2]}\"\n});\n\n// Now you have to pass the number of keys as the first argument every time\n// you invoke the `echoDynamicKeyNumber` command:\nredis.echoDynamicKeyNumber(2, \"k1\", \"k2\", \"a1\", \"a2\", function(err, result) {\n  // result === ['k1', 'k2', 'a1', 'a2']\n});\n```\n\n## Transparent Key Prefixing\n\nThis feature allows you to specify a string that will automatically be prepended\nto all the keys in a command, which makes it easier to manage your key\nnamespaces.\n\n**Warning** This feature won't apply to commands like [KEYS](http://redis.io/commands/KEYS) and [SCAN](http://redis.io/commands/scan) that take patterns rather than actual keys([#239](https://github.com/luin/ioredis/issues/239)),\nand this feature also won't apply to the replies of commands even they are key names ([#325](https://github.com/luin/ioredis/issues/325)).\n\n```javascript\nvar fooRedis = new Redis({ keyPrefix: \"foo:\" });\nfooRedis.set(\"bar\", \"baz\"); // Actually sends SET foo:bar baz\n\nfooRedis.defineCommand(\"echo\", {\n  numberOfKeys: 2,\n  lua: \"return {KEYS[1],KEYS[2],ARGV[1],ARGV[2]}\"\n});\n\n// Works well with pipelining/transaction\nfooRedis\n  .pipeline()\n  // Sends SORT foo:list BY foo:weight_*->fieldname\n  .sort(\"list\", \"BY\", \"weight_*->fieldname\")\n  // Supports custom commands\n  // Sends EVALSHA xxx foo:k1 foo:k2 a1 a2\n  .echo(\"k1\", \"k2\", \"a1\", \"a2\")\n  .exec();\n```\n\n## Transforming Arguments & Replies\n\nMost Redis commands take one or more Strings as arguments,\nand replies are sent back as a single String or an Array of Strings. However, sometimes\nyou may want something different. For instance, it would be more convenient if the `HGETALL`\ncommand returns a hash (e.g. `{ key: val1, key2: v2 }`) rather than an array of key values (e.g. `[key1, val1, key2, val2]`).\n\nioredis has a flexible system for transforming arguments and replies. There are two types\nof transformers, argument transformer and reply transformer:\n\n```javascript\nvar Redis = require(\"ioredis\");\n\n// Here's the built-in argument transformer converting\n// hmset('key', { k1: 'v1', k2: 'v2' })\n// or\n// hmset('key', new Map([['k1', 'v1'], ['k2', 'v2']]))\n// into\n// hmset('key', 'k1', 'v1', 'k2', 'v2')\nRedis.Command.setArgumentTransformer(\"hmset\", function(args) {\n  if (args.length === 2) {\n    if (typeof Map !== \"undefined\" && args[1] instanceof Map) {\n      // utils is a internal module of ioredis\n      return [args[0]].concat(utils.convertMapToArray(args[1]));\n    }\n    if (typeof args[1] === \"object\" && args[1] !== null) {\n      return [args[0]].concat(utils.convertObjectToArray(args[1]));\n    }\n  }\n  return args;\n});\n\n// Here's the built-in reply transformer converting the HGETALL reply\n// ['k1', 'v1', 'k2', 'v2']\n// into\n// { k1: 'v1', 'k2': 'v2' }\nRedis.Command.setReplyTransformer(\"hgetall\", function(result) {\n  if (Array.isArray(result)) {\n    var obj = {};\n    for (var i = 0; i < result.length; i += 2) {\n      obj[result[i]] = result[i + 1];\n    }\n    return obj;\n  }\n  return result;\n});\n```\n\nThere are three built-in transformers, two argument transformers for `hmset` & `mset` and\na reply transformer for `hgetall`. Transformers for `hmset` and `hgetall` were mentioned\nabove, and the transformer for `mset` is similar to the one for `hmset`:\n\n```javascript\nredis.mset({ k1: \"v1\", k2: \"v2\" });\nredis.get(\"k1\", function(err, result) {\n  // result === 'v1';\n});\n\nredis.mset(new Map([[\"k3\", \"v3\"], [\"k4\", \"v4\"]]));\nredis.get(\"k3\", function(err, result) {\n  // result === 'v3';\n});\n```\n\nAnother useful example of a reply transformer is one that changes `hgetall` to return array of arrays instead of objects which avoids a unwanted conversation of hash keys to strings when dealing with binary hash keys:\n\n```javascript\nRedis.Command.setReplyTransformer(\"hgetall\", function(result) {\n  var arr = [];\n  for (var i = 0; i < result.length; i += 2) {\n    arr.push([result[i], result[i + 1]]);\n  }\n  return arr;\n});\nredis.hset(\"h1\", Buffer.from([0x01]), Buffer.from([0x02]));\nredis.hset(\"h1\", Buffer.from([0x03]), Buffer.from([0x04]));\nredis.hgetallBuffer(\"h1\", function(err, result) {\n  // result === [ [ <Buffer 01>, <Buffer 02> ], [ <Buffer 03>, <Buffer 04> ] ];\n});\n```\n\n## Monitor\n\nRedis supports the MONITOR command,\nwhich lets you see all commands received by the Redis server across all client connections,\nincluding from other client libraries and other computers.\n\nThe `monitor` method returns a monitor instance.\nAfter you send the MONITOR command, no other commands are valid on that connection. ioredis will emit a monitor event for every new monitor message that comes across.\nThe callback for the monitor event takes a timestamp from the Redis server and an array of command arguments.\n\nHere is a simple example:\n\n```javascript\nredis.monitor(function(err, monitor) {\n  monitor.on(\"monitor\", function(time, args, source, database) {});\n});\n```\n\n## Streamify Scanning\n\nRedis 2.8 added the `SCAN` command to incrementally iterate through the keys in the database. It's different from `KEYS` in that\n`SCAN` only returns a small number of elements each call, so it can be used in production without the downside\nof blocking the server for a long time. However, it requires recording the cursor on the client side each time\nthe `SCAN` command is called in order to iterate through all the keys correctly. Since it's a relatively common use case, ioredis\nprovides a streaming interface for the `SCAN` command to make things much easier. A readable stream can be created by calling `scanStream`:\n\n```javascript\nvar redis = new Redis();\n// Create a readable stream (object mode)\nvar stream = redis.scanStream();\nstream.on(\"data\", function(resultKeys) {\n  // `resultKeys` is an array of strings representing key names.\n  // Note that resultKeys may contain 0 keys, and that it will sometimes\n  // contain duplicates due to SCAN's implementation in Redis.\n  for (var i = 0; i < resultKeys.length; i++) {\n    console.log(resultKeys[i]);\n  }\n});\nstream.on(\"end\", function() {\n  console.log(\"all keys have been visited\");\n});\n```\n\n`scanStream` accepts an option, with which you can specify the `MATCH` pattern and the `COUNT` argument:\n\n```javascript\nvar stream = redis.scanStream({\n  // only returns keys following the pattern of `user:*`\n  match: \"user:*\",\n  // returns approximately 100 elements per call\n  count: 100\n});\n```\n\nJust like other commands, `scanStream` has a binary version `scanBufferStream`, which returns an array of buffers. It's useful when\nthe key names are not utf8 strings.\n\nThere are also `hscanStream`, `zscanStream` and `sscanStream` to iterate through elements in a hash, zset and set. The interface of each is\nsimilar to `scanStream` except the first argument is the key name:\n\n```javascript\nvar stream = redis.hscanStream(\"myhash\", {\n  match: \"age:??\"\n});\n```\n\nYou can learn more from the [Redis documentation](http://redis.io/commands/scan).\n\n**Useful Tips**\nIt's pretty common that doing an async task in the `data` handler. We'd like the scanning process to be paused until the async task to be finished. `Stream#pause()` and `Stream.resume()` do the trick. For example if we want to migrate data in Redis to MySQL:\n\n```javascript\nvar stream = redis.scanStream();\nstream.on(\"data\", function(resultKeys) {\n  // Pause the stream from scanning more keys until we've migrated the current keys.\n  stream.pause();\n\n  Promise.all(resultKeys.map(migrateKeyToMySQL)).then(() => {\n    // Resume the stream here.\n    stream.resume();\n  });\n});\n\nstream.on(\"end\", function() {\n  console.log(\"done migration\");\n});\n```\n\n## Auto-reconnect\n\nBy default, ioredis will try to reconnect when the connection to Redis is lost\nexcept when the connection is closed manually by `redis.disconnect()` or `redis.quit()`.\n\nIt's very flexible to control how long to wait to reconnect after disconnection\nusing the `retryStrategy` option:\n\n```javascript\nvar redis = new Redis({\n  // This is the default value of `retryStrategy`\n  retryStrategy: function(times) {\n    var delay = Math.min(times * 50, 2000);\n    return delay;\n  }\n});\n```\n\n`retryStrategy` is a function that will be called when the connection is lost.\nThe argument `times` means this is the nth reconnection being made and\nthe return value represents how long (in ms) to wait to reconnect. When the\nreturn value isn't a number, ioredis will stop trying to reconnect, and the connection\nwill be lost forever if the user doesn't call `redis.connect()` manually.\n\nWhen reconnected, the client will auto subscribe to channels that the previous connection subscribed to.\nThis behavior can be disabled by setting the `autoResubscribe` option to `false`.\n\nAnd if the previous connection has some unfulfilled commands (most likely blocking commands such as `brpop` and `blpop`),\nthe client will resend them when reconnected. This behavior can be disabled by setting the `autoResendUnfulfilledCommands` option to `false`.\n\nBy default, all pending commands will be flushed with an error every 20 retry attempts. That makes sure commands won't wait forever when the connection is down. You can change this behavior by setting `maxRetriesPerRequest`:\n\n```javascript\nvar redis = new Redis({\n  maxRetriesPerRequest: 1\n});\n```\n\nSet maxRetriesPerRequest to `null` to disable this behavior, and every command will wait forever until the connection is alive again (which is the default behavior before ioredis v4).\n\n### Reconnect on error\n\nBesides auto-reconnect when the connection is closed, ioredis supports reconnecting on the specified errors by the `reconnectOnError` option. Here's an example that will reconnect when receiving `READONLY` error:\n\n```javascript\nvar redis = new Redis({\n  reconnectOnError: function(err) {\n    var targetError = \"READONLY\";\n    if (err.message.slice(0, targetError.length) === targetError) {\n      // Only reconnect when the error starts with \"READONLY\"\n      return true; // or `return 1;`\n    }\n  }\n});\n```\n\nThis feature is useful when using Amazon ElastiCache. Once failover happens, Amazon ElastiCache will switch the master we currently connected with to a slave, leading to the following writes fails with the error `READONLY`. Using `reconnectOnError`, we can force the connection to reconnect on this error in order to connect to the new master.\n\nFurthermore, if the `reconnectOnError` returns `2`, ioredis will resend the failed command after reconnecting.\n\n## Connection Events\n\nThe Redis instance will emit some events about the state of the connection to the Redis server.\n\n| Event        | Description                                                                                                                                                                                                                                     |\n| :----------- | :---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| connect      | emits when a connection is established to the Redis server.                                                                                                                                                                                     |\n| ready        | If `enableReadyCheck` is `true`, client will emit `ready` when the server reports that it is ready to receive commands (e.g. finish loading data from disk).<br>Otherwise, `ready` will be emitted immediately right after the `connect` event. |\n| error        | emits when an error occurs while connecting.<br>However, ioredis emits all `error` events silently (only emits when there's at least one listener) so that your application won't crash if you're not listening to the `error` event.           |\n| close        | emits when an established Redis server connection has closed.                                                                                                                                                                                   |\n| reconnecting | emits after `close` when a reconnection will be made. The argument of the event is the time (in ms) before reconnecting.                                                                                                                        |\n| end          | emits after `close` when no more reconnections will be made, or the connection is failed to establish.                                                                                                                                          |\n\nYou can also check out the `Redis#status` property to get the current connection status.\n\nBesides the above connection events, there are several other custom events:\n\n| Event  | Description                                                         |\n| :----- | :------------------------------------------------------------------ |\n| select | emits when the database changed. The argument is the new db number. |\n\n## Offline Queue\n\nWhen a command can't be processed by Redis (being sent before the `ready` event), by default, it's added to the offline queue and will be\nexecuted when it can be processed. You can disable this feature by setting the `enableOfflineQueue`\noption to `false`:\n\n```javascript\nvar redis = new Redis({ enableOfflineQueue: false });\n```\n\n## TLS Options\n\nRedis doesn't support TLS natively, however if the redis server you want to connect to is hosted behind a TLS proxy (e.g. [stunnel](https://www.stunnel.org/)) or is offered by a PaaS service that supports TLS connection (e.g. [Redis Labs](https://redislabs.com/)), you can set the `tls` option:\n\n```javascript\nvar redis = new Redis({\n  host: \"localhost\",\n  tls: {\n    // Refer to `tls.connect()` section in\n    // https://nodejs.org/api/tls.html\n    // for all supported options\n    ca: fs.readFileSync(\"cert.pem\")\n  }\n});\n```\n\n<hr>\n\n## Sentinel\n\nioredis supports Sentinel out of the box. It works transparently as all features that work when\nyou connect to a single node also work when you connect to a sentinel group. Make sure to run Redis >= 2.8.12 if you want to use this feature. Sentinels have a default port of 26379.\n\nTo connect using Sentinel, use:\n\n```javascript\nvar redis = new Redis({\n  sentinels: [\n    { host: \"localhost\", port: 26379 },\n    { host: \"localhost\", port: 26380 }\n  ],\n  name: \"mymaster\"\n});\n\nredis.set(\"foo\", \"bar\");\n```\n\nThe arguments passed to the constructor are different from the ones you use to connect to a single node, where:\n\n- `name` identifies a group of Redis instances composed of a master and one or more slaves (`mymaster` in the example);\n- `sentinelPassword` (optional) password for Sentinel instances.\n- `sentinels` are a list of sentinels to connect to. The list does not need to enumerate all your sentinel instances, but a few so that if one is down the client will try the next one.\n- `role` (optional) with a value of `slave` will return a random slave from the Sentinel group.\n- `preferredSlaves` (optional) can be used to prefer a particular slave or set of slaves based on priority. It accepts a function or array.\n\nioredis **guarantees** that the node you connected to is always a master even after a failover. When a failover happens, instead of trying to reconnect to the failed node (which will be demoted to slave when it's available again), ioredis will ask sentinels for the new master node and connect to it. All commands sent during the failover are queued and will be executed when the new connection is established so that none of the commands will be lost.\n\nIt's possible to connect to a slave instead of a master by specifying the option `role` with the value of `slave` and ioredis will try to connect to a random slave of the specified master, with the guarantee that the connected node is always a slave. If the current node is promoted to master due to a failover, ioredis will disconnect from it and ask the sentinels for another slave node to connect to.\n\nIf you specify the option `preferredSlaves` along with `role: 'slave'` ioredis will attempt to use this value when selecting the slave from the pool of available slaves. The value of `preferredSlaves` should either be a function that accepts an array of avaiable slaves and returns a single result, or an array of slave values priorities by the lowest `prio` value first with a default value of `1`.\n\n```javascript\n// available slaves format\nvar availableSlaves = [{ ip: \"127.0.0.1\", port: \"31231\", flags: \"slave\" }];\n\n// preferredSlaves array format\nvar preferredSlaves = [\n  { ip: \"127.0.0.1\", port: \"31231\", prio: 1 },\n  { ip: \"127.0.0.1\", port: \"31232\", prio: 2 }\n];\n\n// preferredSlaves function format\npreferredSlaves = function(availableSlaves) {\n  for (var i = 0; i < availableSlaves.length; i++) {\n    var slave = availableSlaves[i];\n    if (slave.ip === \"127.0.0.1\") {\n      if (slave.port === \"31234\") {\n        return slave;\n      }\n    }\n  }\n  // if no preferred slaves are available a random one is used\n  return false;\n};\n\nvar redis = new Redis({\n  sentinels: [\n    { host: \"127.0.0.1\", port: 26379 },\n    { host: \"127.0.0.1\", port: 26380 }\n  ],\n  name: \"mymaster\",\n  role: \"slave\",\n  preferredSlaves: preferredSlaves\n});\n```\n\nBesides the `retryStrategy` option, there's also a `sentinelRetryStrategy` in Sentinel mode which will be invoked when all the sentinel nodes are unreachable during connecting. If `sentinelRetryStrategy` returns a valid delay time, ioredis will try to reconnect from scratch. The default value of `sentinelRetryStrategy` is:\n\n```javascript\nfunction (times) {\n  var delay = Math.min(times * 10, 1000);\n  return delay;\n}\n```\n\n## Cluster\n\nRedis Cluster provides a way to run a Redis installation where data is automatically sharded across multiple Redis nodes.\nYou can connect to a Redis Cluster like this:\n\n```javascript\nvar Redis = require(\"ioredis\");\n\nvar cluster = new Redis.Cluster([\n  {\n    port: 6380,\n    host: \"127.0.0.1\"\n  },\n  {\n    port: 6381,\n    host: \"127.0.0.1\"\n  }\n]);\n\ncluster.set(\"foo\", \"bar\");\ncluster.get(\"foo\", function(err, res) {\n  // res === 'bar'\n});\n```\n\n`Cluster` constructor accepts two arguments, where:\n\n0.  The first argument is a list of nodes of the cluster you want to connect to.\n    Just like Sentinel, the list does not need to enumerate all your cluster nodes,\n    but a few so that if one is unreachable the client will try the next one, and the client will discover other nodes automatically when at least one node is connected.\n1.  The second argument is the options, where:\n\n    - `clusterRetryStrategy`: When none of the startup nodes are reachable, `clusterRetryStrategy` will be invoked. When a number is returned,\n      ioredis will try to reconnect to the startup nodes from scratch after the specified delay (in ms). Otherwise, an error of \"None of startup nodes is available\" will be returned.\n      The default value of this option is:\n\n          ```javascript\n          function (times) {\n            var delay = Math.min(100 + times * 2, 2000);\n            return delay;\n          }\n          ```\n\n          It's possible to modify the `startupNodes` property in order to switch to another set of nodes here:\n\n          ```javascript\n          function (times) {\n            this.startupNodes = [{ port: 6790, host: '127.0.0.1' }];\n            return Math.min(100 + times * 2, 2000);\n          }\n          ```\n\n    - `dnsLookup`: Alternative DNS lookup function (`dns.lookup()` is used by default). It may be useful to override this in special cases, such as when AWS ElastiCache used with TLS enabled.\n    - `enableOfflineQueue`: Similar to the `enableOfflineQueue` option of `Redis` class.\n    - `enableReadyCheck`: When enabled, \"ready\" event will only be emitted when `CLUSTER INFO` command\n      reporting the cluster is ready for handling commands. Otherwise, it will be emitted immediately after \"connect\" is emitted.\n    - `scaleReads`: Config where to send the read queries. See below for more details.\n    - `maxRedirections`: When a cluster related error (e.g. `MOVED`, `ASK` and `CLUSTERDOWN` etc.) is received, the client will redirect the\n      command to another node. This option limits the max redirections allowed when sending a command. The default value is `16`.\n    - `retryDelayOnFailover`: If the target node is disconnected when sending a command,\n      ioredis will retry after the specified delay. The default value is `100`. You should make sure `retryDelayOnFailover * maxRedirections > cluster-node-timeout`\n      to insure that no command will fail during a failover.\n    - `retryDelayOnClusterDown`: When a cluster is down, all commands will be rejected with the error of `CLUSTERDOWN`. If this option is a number (by default, it is `100`), the client\n      will resend the commands after the specified time (in ms).\n    - `retryDelayOnTryAgain`: If this option is a number (by default, it is `100`), the client\n      will resend the commands rejected with `TRYAGAIN` error after the specified time (in ms).\n    - `redisOptions`: Default options passed to the constructor of `Redis` when connecting to a node.\n    - `slotsRefreshTimeout`: Milliseconds before a timeout occurs while refreshing slots from the cluster (default `1000`)\n    - `slotsRefreshInterval`: Milliseconds between every automatic slots refresh (default `5000`)\n\n### Read-write splitting\n\nA typical redis cluster contains three or more masters and several slaves for each master. It's possible to scale out redis cluster by sending read queries to slaves and write queries to masters by setting the `scaleReads` option.\n\n`scaleReads` is \"master\" by default, which means ioredis will never send any queries to slaves. There are other three available options:\n\n1. \"all\": Send write queries to masters and read queries to masters or slaves randomly.\n2. \"slave\": Send write queries to masters and read queries to slaves.\n3. a custom `function(nodes, command): node`: Will choose the custom function to select to which node to send read queries (write queries keep being sent to master). The first node in `nodes` is always the master serving the relevant slots. If the function returns an array of nodes, a random node of that list will be selected.\n\nFor example:\n\n```javascript\nvar cluster = new Redis.Cluster(\n  [\n    /* nodes */\n  ],\n  {\n    scaleReads: \"slave\"\n  }\n);\ncluster.set(\"foo\", \"bar\"); // This query will be sent to one of the masters.\ncluster.get(\"foo\", function(err, res) {\n  // This query will be sent to one of the slaves.\n});\n```\n\n**NB** In the code snippet above, the `res` may not be equal to \"bar\" because of the lag of replication between the master and slaves.\n\n### Running commands to multiple nodes\n\nEvery command will be sent to exactly one node. For commands containing keys, (e.g. `GET`, `SET` and `HGETALL`), ioredis sends them to the node that serving the keys, and for other commands not containing keys, (e.g. `INFO`, `KEYS` and `FLUSHDB`), ioredis sends them to a random node.\n\nSometimes you may want to send a command to multiple nodes (masters or slaves) of the cluster, you can get the nodes via `Cluster#nodes()` method.\n\n`Cluster#nodes()` accepts a parameter role, which can be \"master\", \"slave\" and \"all\" (default), and returns an array of `Redis` instance. For example:\n\n```javascript\n// Send `FLUSHDB` command to all slaves:\nvar slaves = cluster.nodes(\"slave\");\nPromise.all(\n  slaves.map(function(node) {\n    return node.flushdb();\n  })\n);\n\n// Get keys of all the masters:\nvar masters = cluster.nodes(\"master\");\nPromise.all(\n  masters.map(function(node) {\n    return node.keys();\n  })\n).then(function(keys) {\n  // keys: [['key1', 'key2'], ['key3', 'key4']]\n});\n```\n\n### NAT Mapping\n\nSometimes the cluster is hosted within a internal network that can only be accessed via a NAT (Network Address Translation) instance. See [Accessing ElastiCache from outside AWS](https://docs.aws.amazon.com/AmazonElastiCache/latest/red-ug/accessing-elasticache.html) as an example.\n\nYou can specify nat mapping rules via `natMap` option:\n\n```javascript\nconst cluster = new Redis.Cluster(\n  [\n    {\n      host: \"203.0.113.73\",\n      port: 30001\n    }\n  ],\n  {\n    natMap: {\n      \"10.0.1.230:30001\": { host: \"203.0.113.73\", port: 30001 },\n      \"10.0.1.231:30001\": { host: \"203.0.113.73\", port: 30002 },\n      \"10.0.1.232:30001\": { host: \"203.0.113.73\", port: 30003 }\n    }\n  }\n);\n```\n\nThis option is also useful when the cluster is running inside a Docker container.\n\n### Transaction and pipeline in Cluster mode\n\nAlmost all features that are supported by `Redis` are also supported by `Redis.Cluster`, e.g. custom commands, transaction and pipeline.\nHowever there are some differences when using transaction and pipeline in Cluster mode:\n\n0. All keys in a pipeline should belong to the same slot since ioredis sends all commands in a pipeline to the same node.\n1. You can't use `multi` without pipeline (aka `cluster.multi({ pipeline: false })`). This is because when you call `cluster.multi({ pipeline: false })`, ioredis doesn't know which node the `multi` command should be sent to.\n2. Chaining custom commands in the pipeline is not supported in Cluster mode.\n\nWhen any commands in a pipeline receives a `MOVED` or `ASK` error, ioredis will resend the whole pipeline to the specified node automatically if all of the following conditions are satisfied:\n\n0. All errors received in the pipeline are the same. For example, we won't resend the pipeline if we got two `MOVED` errors pointing to different nodes.\n1. All commands executed successfully are readonly commands. This makes sure that resending the pipeline won't have side effects.\n\n### Pub/Sub\n\nPub/Sub in cluster mode works exactly as the same as in standalone mode. Internally, when a node of the cluster receives a message, it will broadcast the message to the other nodes. ioredis makes sure that each message will only be received once by strictly subscribing one node at the same time.\n\n```javascript\nvar nodes = [\n  /* nodes */\n];\nvar pub = new Redis.Cluster(nodes);\nvar sub = new Redis.Cluster(nodes);\nsub.on(\"message\", function(channel, message) {\n  console.log(channel, message);\n});\n\nsub.subscribe(\"news\", function() {\n  pub.publish(\"news\", \"highlights\");\n});\n```\n\n### Events\n\n| Event        | Description                                                                                                                                                                                                |\n| :----------- | :--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| connect      | emits when a connection is established to the Redis server.                                                                                                                                                |\n| ready        | emits when `CLUSTER INFO` reporting the cluster is able to receive commands (if `enableReadyCheck` is `true`) or immediately after `connect` event (if `enableReadyCheck` is false).                       |\n| error        | emits when an error occurs while connecting with a property of `lastNodeError` representing the last node error received. This event is emitted silently (only emitting if there's at least one listener). |\n| close        | emits when an established Redis server connection has closed.                                                                                                                                              |\n| reconnecting | emits after `close` when a reconnection will be made. The argument of the event is the time (in ms) before reconnecting.                                                                                   |\n| end          | emits after `close` when no more reconnections will be made.                                                                                                                                               |\n| +node        | emits when a new node is connected.                                                                                                                                                                        |\n| -node        | emits when a node is disconnected.                                                                                                                                                                         |\n| node error   | emits when an error occurs when connecting to a node. The second argument indicates the address of the node.                                                                                               |\n\n### Password\n\nSetting the `password` option to access password-protected clusters:\n\n```javascript\nvar Redis = require(\"ioredis\");\nvar cluster = new Redis.Cluster(nodes, {\n  redisOptions: {\n    password: \"your-cluster-password\"\n  }\n});\n```\n\nIf some of nodes in the cluster using a different password, you should specify them in the first parameter:\n\n```javascript\nvar Redis = require(\"ioredis\");\nvar cluster = new Redis.Cluster(\n  [\n    // Use password \"password-for-30001\" for 30001\n    { port: 30001, password: \"password-for-30001\" },\n    // Don't use password when accessing 30002\n    { port: 30002, password: null }\n    // Other nodes will use \"fallback-password\"\n  ],\n  {\n    redisOptions: {\n      password: \"fallback-password\"\n    }\n  }\n);\n```\n\n### Special note: AWS ElastiCache Clusters with TLS\n\nAWS ElastiCache for Redis (Clustered Mode) supports TLS encryption. If you use\nthis, you may encounter errors with invalid certificates. To resolve this\nissue, construct the `Cluster` with the `dnsLookup` option as follows:\n\n```javascript\nvar cluster = new Redis.Cluster(\n  [{\n    host: 'clustercfg.myCluster.abcdefg.xyz.cache.amazonaws.com',\n    port: 6379\n  }],\n  {\n    dnsLookup: (address, callback) => callback(null, address),\n    redisOptions: {\n      tls: {}\n    },\n  }\n};\n```\n\n<hr>\n\n# Error Handling\n\nAll the errors returned by the Redis server are instances of `ReplyError`, which can be accessed via `Redis`:\n\n```javascript\nvar Redis = require(\"ioredis\");\nvar redis = new Redis();\n// This command causes a reply error since the SET command requires two arguments.\nredis.set(\"foo\", function(err) {\n  err instanceof Redis.ReplyError;\n});\n```\n\nThis is the error stack of the `ReplyError`:\n\n```\nReplyError: ERR wrong number of arguments for 'set' command\n    at ReplyParser._parseResult (/app/node_modules/ioredis/lib/parsers/javascript.js:60:14)\n    at ReplyParser.execute (/app/node_modules/ioredis/lib/parsers/javascript.js:178:20)\n    at Socket.<anonymous> (/app/node_modules/ioredis/lib/redis/event_handler.js:99:22)\n    at Socket.emit (events.js:97:17)\n    at readableAddChunk (_stream_readable.js:143:16)\n    at Socket.Readable.push (_stream_readable.js:106:10)\n    at TCP.onread (net.js:509:20)\n```\n\nBy default, the error stack doesn't make any sense because the whole stack happens in the ioredis\nmodule itself, not in your code. So it's not easy to find out where the error happens in your code.\nioredis provides an option `showFriendlyErrorStack` to solve the problem. When you enable\n`showFriendlyErrorStack`, ioredis will optimize the error stack for you:\n\n```javascript\nvar Redis = require(\"ioredis\");\nvar redis = new Redis({ showFriendlyErrorStack: true });\nredis.set(\"foo\");\n```\n\nAnd the output will be:\n\n```\nReplyError: ERR wrong number of arguments for 'set' command\n    at Object.<anonymous> (/app/index.js:3:7)\n    at Module._compile (module.js:446:26)\n    at Object.Module._extensions..js (module.js:464:10)\n    at Module.load (module.js:341:32)\n    at Function.Module._load (module.js:296:12)\n    at Function.Module.runMain (module.js:487:10)\n    at startup (node.js:111:16)\n    at node.js:799:3\n```\n\nThis time the stack tells you that the error happens on the third line in your code. Pretty sweet!\nHowever, it would decrease the performance significantly to optimize the error stack. So by\ndefault, this option is disabled and can only be used for debugging purposes. You **shouldn't** use this feature in a production environment.\n\n# Plugging in your own Promises Library\n\nIf you're an advanced user, you may want to plug in your own promise library like [bluebird](https://www.npmjs.com/package/bluebird). Just set Redis.Promise to your favorite ES6-style promise constructor and ioredis will use it.\n\n```javascript\nconst Redis = require(\"ioredis\");\nRedis.Promise = require(\"bluebird\");\n\nconst redis = new Redis();\n\n// Use bluebird\nassert.equal(redis.get().constructor, require(\"bluebird\"));\n\n// You can change the Promise implementation at any time:\nRedis.Promise = global.Promise;\nassert.equal(redis.get().constructor, global.Promise);\n```\n\n# Running tests\n\nStart a Redis server on 127.0.0.1:6379, and then:\n\n```shell\n$ npm test\n```\n\n`FLUSH ALL` will be invoked after each test, so make sure there's no valuable data in it before running tests.\n\nIf your testing environment does not let you spin up a Redis server [ioredis-mock](https://github.com/stipsan/ioredis-mock) is a drop-in replacement you can use in your tests. It aims to behave identically to ioredis connected to a Redis server so that your integration tests is easier to write and of better quality.\n\n# Debug\n\nYou can set the `DEBUG` env to `ioredis:*` to print debug info:\n\n```shell\n$ DEBUG=ioredis:* node app.js\n```\n\n# Join in!\n\nI'm happy to receive bug reports, fixes, documentation enhancements, and any other improvements.\n\nAnd since I'm not a native English speaker, if you find any grammar mistakes in the documentation, please also let me know. :)\n\n# Become a Sponsor\n\nOpen source is hard and time-consuming. If you want to invest in ioredis's future you can become a sponsor and make us spend more time on this library's improvements and new features.\n\n<a href=\"https://opencollective.com/ioredis\"><img src=\"https://opencollective.com/ioredis/tiers/sponsor.svg?avatarHeight=36\"></a>\n\nThank you for using ioredis :-)\n\n# Contributors\n\nThis project exists thanks to all the people who contribute:\n\n<a href=\"https://github.com/luin/ioredis/graphs/contributors\"><img src=\"https://opencollective.com/ioredis/contributors.svg?width=890&showBtn=false\" /></a>\n\n# License\n\nMIT\n\n[![FOSSA Status](https://app.fossa.io/api/projects/git%2Bgithub.com%2Fluin%2Fioredis.svg?type=large)](https://app.fossa.io/projects/git%2Bgithub.com%2Fluin%2Fioredis?ref=badge_large)\n","readmeFilename":"README.md","bugs":{"url":"https://github.com/luin/ioredis/issues"},"homepage":"https://github.com/luin/ioredis#readme","_id":"ioredis@4.12.2","_nodeVersion":"10.16.0","_npmVersion":"6.9.0","dist":{"integrity":"sha512-IO/+znENEGhz8FrQ8tj3oOeQ6k7VNaJnouk48oKHzCnNTnJLmeqIKH4ByK2uw7Q+CFgngiiR1M27zdrFaE0vJA==","shasum":"ea79ee33dfa75af61d856939cf5c21ef159e5e2e","tarball":"https://registry.npmjs.org/ioredis/-/ioredis-4.12.2.tgz","fileCount":36,"unpackedSize":237398,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJdLepWCRA9TVsSAnZWagAAiKwP/3yaKT+/aHmH9V4hJZxQ\nJYs6oKJyMnRk7aGIwfm4vaKp33gg12w41HK0HBihAA7/0rOP4/yg8/JDAjpA\n+aDHU3HZJWXWghZXHL3XJJNkC+FUXf8pnGNfHwvEgtYQWK8vnU18W+BLzTeg\nwf90+zN4zK6UN+IGXhH9bONcPd1am5DYnyS3LLL3IxWKzWaNXyIexSw2wEYI\nVuy+qKblVUCdhdBdzqPhSpfOrrfH6dSFAURC4sB5HnmhCb7h2e2TDYSUV0Su\nFf3G8HYTijvMyaC5GeENOfDHvbSIBU9NGY2qzubuIntsqevtOKpfLfsMV0lp\ndDpoNT+OuMxkSB3zqVSNSa9H4Ekzt32CtZAQpWsff4w7OOr22WRAPJ87WLSC\n4xnj1BAfmKiRPk2CguQUSq8YVQ++/q8X07dP7xEm//B9twq8wzRwheXAbtfE\nE9ZcSlAz/qk1mvqjQzNw/WHbpqWqrjF78sOZU6h+HLi1n4E9bjyp8tMS/TLb\nGVm5So5BSraR9lp6or09osoQtk+sY3v+Sy1wJQ/id8xb9RjA/3pwH0YbMHCc\n06JB9vDNFisDa1DBKe0a61GNmqLnQp9SmGau7Nn/jkuEoUf/p/nMf9aL1Glc\nkG2pTp3QkWkJD+ZQaEy0HbhCP6MXnVDPgoSVzEKxjVCuTBgT7lzCv817LF2O\nzZN6\r\n=FgDa\r\n-----END PGP SIGNATURE-----\r\n"},"maintainers":[{"email":"ioredis-robot@zihua.li","name":"ioredis-robot"},{"email":"i@zihua.li","name":"luin"}],"_npmUser":{"name":"luin","email":"i@zihua.li"},"directories":{},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/ioredis_4.12.2_1563290197611_0.6575951685431272"},"_hasShrinkwrap":false},"4.13.0":{"name":"ioredis","version":"4.13.0","description":"A robust, performance-focused and full-featured Redis client for Node.js.","main":"built/index.js","scripts":{"test":"TS_NODE_TRANSPILE_ONLY=true TS_NODE_LOG_ERROR=true NODE_ENV=test mocha \"test/**/*.ts\"","test:cov":"TS_NODE_TRANSPILE_ONLY=true TS_NODE_LOG_ERROR=true NODE_ENV=test node ./node_modules/istanbul/lib/cli.js cover --preserve-comments ./node_modules/mocha/bin/_mocha -- -r ts-node/register -R spec --exit \"test/**/*.ts\"","lint":"eslint --ext .js,.ts .","format":"prettier --write \"{,!(node_modules)/**/}*.{js,ts}\"","format-check":"prettier --check \"{,!(node_modules)/**/}*.{js,ts}\"","build":"rm -rf built && tsc","prepublishOnly":"npm run build && npm test","bench":"matcha benchmarks/*.js","semantic-release":"semantic-release"},"repository":{"type":"git","url":"git://github.com/luin/ioredis.git"},"keywords":["redis","cluster","sentinel","pipelining"],"author":{"name":"luin","email":"i@zihua.li","url":"http://zihua.li"},"license":"MIT","dependencies":{"cluster-key-slot":"^1.1.0","debug":"^4.1.1","denque":"^1.1.0","lodash.defaults":"^4.2.0","lodash.flatten":"^4.4.0","redis-commands":"1.5.0","redis-errors":"^1.2.0","redis-parser":"^3.0.0","standard-as-callback":"^2.0.1"},"devDependencies":{"@semantic-release/changelog":"^3.0.4","@semantic-release/git":"^7.0.12","@types/bluebird":"^3.5.27","@types/chai":"^4.1.7","@types/debug":"^4.1.4","@types/lodash.defaults":"^4.2.6","@types/lodash.flatten":"^4.4.6","@types/mocha":"^5.2.7","@types/node":"^12.0.2","@types/redis-errors":"1.2.0","@types/sinon":"^7.0.13","@typescript-eslint/eslint-plugin":"^1.11.0","@typescript-eslint/parser":"^1.11.0","bluebird":"^3.5.4","chai":"^4.2.0","cz-conventional-changelog":"^2.0.0","eslint":"^5.16.0","eslint-config-prettier":"^5.1.0","husky":"^2.5.0","istanbul":"^0.4.5","mocha":"^5.0.0","prettier":"^1.18.2","pretty-quick":"^1.11.1","server-destroy":"^1.0.1","sinon":"^7.3.2","ts-node":"^8.1.0","typescript":"^3.5.1"},"engines":{"node":">=6"},"config":{"commitizen":{"path":"./node_modules/cz-conventional-changelog"}},"husky":{"hooks":{"pre-commit":"pretty-quick --staged"}},"gitHead":"e593e349fd2811eed2f1a369ffb3a06205909482","readme":"[![ioredis](https://cdn.jsdelivr.net/gh/luin/ioredis@b5e8c74/logo.svg)](https://github.com/luin/ioredis)\n\n[![Build Status](https://travis-ci.org/luin/ioredis.svg?branch=master)](https://travis-ci.org/luin/ioredis)\n[![Test Coverage](https://codeclimate.com/github/luin/ioredis/badges/coverage.svg)](https://codeclimate.com/github/luin/ioredis)\n[![code style: prettier](https://img.shields.io/badge/code_style-prettier-ff69b4.svg?style=flat-square)](https://github.com/prettier/prettier)\n[![Join the chat at https://gitter.im/luin/ioredis](https://badges.gitter.im/Join%20Chat.svg)](https://gitter.im/luin/ioredis?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge)\n[![Commitizen friendly](https://img.shields.io/badge/commitizen-friendly-brightgreen.svg)](http://commitizen.github.io/cz-cli/)\n[![semantic-release](https://img.shields.io/badge/%20%20%F0%9F%93%A6%F0%9F%9A%80-semantic--release-e10079.svg)](https://github.com/semantic-release/semantic-release)\n[![npm latest version](https://img.shields.io/npm/v/ioredis/latest.svg)](https://www.npmjs.com/package/ioredis)\n[![npm next version](https://img.shields.io/npm/v/ioredis/next.svg)](https://www.npmjs.com/package/ioredis)\n<img alt=\"\" src=\"\">\n\nA robust, performance-focused and full-featured [Redis](http://redis.io) client for [Node.js](https://nodejs.org).\n\nSupports Redis >= 2.6.12 and (Node.js >= 6).\n\n# Features\n\nioredis is a robust, full-featured Redis client that is\nused in the world's biggest online commerce company [Alibaba](http://www.alibaba.com/) and many other awesome companies.\n\n0. Full-featured. It supports [Cluster](http://redis.io/topics/cluster-tutorial), [Sentinel](http://redis.io/topics/sentinel), [Pipelining](http://redis.io/topics/pipelining) and of course [Lua scripting](http://redis.io/commands/eval) & [Pub/Sub](http://redis.io/topics/pubsub) (with the support of binary messages).\n1. High performance.\n2. Delightful API. It works with Node callbacks and Native promises.\n3. Transformation of command arguments and replies.\n4. Transparent key prefixing.\n5. Abstraction for Lua scripting, allowing you to define custom commands.\n6. Support for binary data.\n7. Support for TLS.\n8. Support for offline queue and ready checking.\n9. Support for ES6 types, such as `Map` and `Set`.\n10. Support for GEO commands (Redis 3.2 Unstable).\n11. Sophisticated error handling strategy.\n12. Support for NAT mapping.\n\n# Links\n\n- [API Documentation](API.md)\n- [Changelog](Changelog.md)\n- [Migrating from node_redis](https://github.com/luin/ioredis/wiki/Migrating-from-node_redis)\n- [Error Handling](#error-handling)\n\n<hr>\n<a href=\"http://bit.ly/medis-macos\"><img align=\"right\" src=\"resources/medis.png\" alt=\"Download on the App Store\"></a>\n\n### [AD] Medis: Redis GUI for OS X\n\nLooking for a Redis GUI manager for OS X, Windows and Linux? Here's [Medis](http://bit.ly/medis-macos)!\n\nMedis is an open-sourced, beautiful, easy-to-use Redis GUI management application.\n\nMedis starts with all the basic features you need:\n\n- Keys viewing/editing\n- SSH Tunnel for connecting with remote servers\n- Terminal for executing custom commands\n- JSON/MessagePack format viewing/editing and built-in highlighting/validator\n- And other awesome features...\n\n[Medis is open sourced on GitHub](https://github.com/luin/medis)\n\n### [AD] Kuber: Kubernetes Dashboard for iOS\n\n<a href=\"http://bit.ly/kuber-ios\"><img src=\"resources/kuber.png\" alt=\"Download on the App Store\"></a>\n\n<hr>\n\n# Quick Start\n\n## Install\n\n```shell\n$ npm install ioredis\n```\n\n## Basic Usage\n\n```javascript\nvar Redis = require(\"ioredis\");\nvar redis = new Redis();\n\nredis.set(\"foo\", \"bar\");\nredis.get(\"foo\", function(err, result) {\n  console.log(result);\n});\nredis.del(\"foo\");\n\n// Or using a promise if the last argument isn't a function\nredis.get(\"foo\").then(function(result) {\n  console.log(result);\n});\n\n// Arguments to commands are flattened, so the following are the same:\nredis.sadd(\"set\", 1, 3, 5, 7);\nredis.sadd(\"set\", [1, 3, 5, 7]);\n\n// All arguments are passed directly to the redis server:\nredis.set(\"key\", 100, \"EX\", 10);\n```\n\nSee the `examples/` folder for more examples.\n\n## Connect to Redis\n\nWhen a new `Redis` instance is created,\na connection to Redis will be created at the same time.\nYou can specify which Redis to connect to by:\n\n```javascript\nnew Redis(); // Connect to 127.0.0.1:6379\nnew Redis(6380); // 127.0.0.1:6380\nnew Redis(6379, \"192.168.1.1\"); // 192.168.1.1:6379\nnew Redis(\"/tmp/redis.sock\");\nnew Redis({\n  port: 6379, // Redis port\n  host: \"127.0.0.1\", // Redis host\n  family: 4, // 4 (IPv4) or 6 (IPv6)\n  password: \"auth\",\n  db: 0\n});\n```\n\nYou can also specify connection options as a [`redis://` URL](http://www.iana.org/assignments/uri-schemes/prov/redis):\n\n```javascript\n// Connect to 127.0.0.1:6380, db 4, using password \"authpassword\":\nnew Redis(\"redis://:authpassword@127.0.0.1:6380/4\");\n```\n\nSee [API Documentation](API.md#new_Redis) for all available options.\n\n## Pub/Sub\n\nHere is a simple example of the API for publish/subscribe.\nThe following program opens two client connections.\nIt subscribes to a channel with one connection\nand publishes to that channel with the other:\n\n```javascript\nvar Redis = require(\"ioredis\");\nvar redis = new Redis();\nvar pub = new Redis();\nredis.subscribe(\"news\", \"music\", function(err, count) {\n  // Now we are subscribed to both the 'news' and 'music' channels.\n  // `count` represents the number of channels we are currently subscribed to.\n\n  pub.publish(\"news\", \"Hello world!\");\n  pub.publish(\"music\", \"Hello again!\");\n});\n\nredis.on(\"message\", function(channel, message) {\n  // Receive message Hello world! from channel news\n  // Receive message Hello again! from channel music\n  console.log(\"Receive message %s from channel %s\", message, channel);\n});\n\n// There's also an event called 'messageBuffer', which is the same as 'message' except\n// it returns buffers instead of strings.\nredis.on(\"messageBuffer\", function(channel, message) {\n  // Both `channel` and `message` are buffers.\n});\n```\n\n`PSUBSCRIBE` is also supported in a similar way:\n\n```javascript\nredis.psubscribe(\"pat?ern\", function(err, count) {});\nredis.on(\"pmessage\", function(pattern, channel, message) {});\nredis.on(\"pmessageBuffer\", function(pattern, channel, message) {});\n```\n\nWhen a client issues a SUBSCRIBE or PSUBSCRIBE, that connection is put into a \"subscriber\" mode.\nAt that point, only commands that modify the subscription set are valid.\nWhen the subscription set is empty, the connection is put back into regular mode.\n\nIf you need to send regular commands to Redis while in subscriber mode, just open another connection.\n\n## Handle Binary Data\n\nArguments can be buffers:\n\n```javascript\nredis.set(\"foo\", Buffer.from(\"bar\"));\n```\n\nAnd every command has a method that returns a Buffer (by adding a suffix of \"Buffer\" to the command name).\nTo get a buffer instead of a utf8 string:\n\n```javascript\nredis.getBuffer(\"foo\", function(err, result) {\n  // result is a buffer.\n});\n```\n\n## Pipelining\n\nIf you want to send a batch of commands (e.g. > 5), you can use pipelining to queue\nthe commands in memory and then send them to Redis all at once. This way the performance improves by 50%~300% (See [benchmark section](#benchmark)).\n\n`redis.pipeline()` creates a `Pipeline` instance. You can call any Redis\ncommands on it just like the `Redis` instance. The commands are queued in memory\nand flushed to Redis by calling the `exec` method:\n\n```javascript\nvar pipeline = redis.pipeline();\npipeline.set(\"foo\", \"bar\");\npipeline.del(\"cc\");\npipeline.exec(function(err, results) {\n  // `err` is always null, and `results` is an array of responses\n  // corresponding to the sequence of queued commands.\n  // Each response follows the format `[err, result]`.\n});\n\n// You can even chain the commands:\nredis\n  .pipeline()\n  .set(\"foo\", \"bar\")\n  .del(\"cc\")\n  .exec(function(err, results) {});\n\n// `exec` also returns a Promise:\nvar promise = redis\n  .pipeline()\n  .set(\"foo\", \"bar\")\n  .get(\"foo\")\n  .exec();\npromise.then(function(result) {\n  // result === [[null, 'OK'], [null, 'bar']]\n});\n```\n\nEach chained command can also have a callback, which will be invoked when the command\ngets a reply:\n\n```javascript\nredis\n  .pipeline()\n  .set(\"foo\", \"bar\")\n  .get(\"foo\", function(err, result) {\n    // result === 'bar'\n  })\n  .exec(function(err, result) {\n    // result[1][1] === 'bar'\n  });\n```\n\nIn addition to adding commands to the `pipeline` queue individually, you can also pass an array of commands and arguments to the constructor:\n\n```javascript\nredis.pipeline([[\"set\", \"foo\", \"bar\"], [\"get\", \"foo\"]]).exec(function() {\n  /* ... */\n});\n```\n\n`#length` property shows how many commands in the pipeline:\n\n```javascript\nconst length = redis\n  .pipeline()\n  .set(\"foo\", \"bar\")\n  .get(\"foo\").length;\n// length === 2\n```\n\n## Transaction\n\nMost of the time, the transaction commands `multi` & `exec` are used together with pipeline.\nTherefore, when `multi` is called, a `Pipeline` instance is created automatically by default,\nso you can use `multi` just like `pipeline`:\n\n```javascript\nredis\n  .multi()\n  .set(\"foo\", \"bar\")\n  .get(\"foo\")\n  .exec(function(err, results) {\n    // results === [[null, 'OK'], [null, 'bar']]\n  });\n```\n\nIf there's a syntax error in the transaction's command chain (e.g. wrong number of arguments, wrong command name, etc),\nthen none of the commands would be executed, and an error is returned:\n\n```javascript\nredis\n  .multi()\n  .set(\"foo\")\n  .set(\"foo\", \"new value\")\n  .exec(function(err, results) {\n    // err:\n    //  { [ReplyError: EXECABORT Transaction discarded because of previous errors.]\n    //    name: 'ReplyError',\n    //    message: 'EXECABORT Transaction discarded because of previous errors.',\n    //    command: { name: 'exec', args: [] },\n    //    previousErrors:\n    //     [ { [ReplyError: ERR wrong number of arguments for 'set' command]\n    //         name: 'ReplyError',\n    //         message: 'ERR wrong number of arguments for \\'set\\' command',\n    //         command: [Object] } ] }\n  });\n```\n\nIn terms of the interface, `multi` differs from `pipeline` in that when specifying a callback\nto each chained command, the queueing state is passed to the callback instead of the result of the command:\n\n```javascript\nredis\n  .multi()\n  .set(\"foo\", \"bar\", function(err, result) {\n    // result === 'QUEUED'\n  })\n  .exec(/* ... */);\n```\n\nIf you want to use transaction without pipeline, pass `{ pipeline: false }` to `multi`,\nand every command will be sent to Redis immediately without waiting for an `exec` invocation:\n\n```javascript\nredis.multi({ pipeline: false });\nredis.set(\"foo\", \"bar\");\nredis.get(\"foo\");\nredis.exec(function(err, result) {\n  // result === [[null, 'OK'], [null, 'bar']]\n});\n```\n\nThe constructor of `multi` also accepts a batch of commands:\n\n```javascript\nredis.multi([[\"set\", \"foo\", \"bar\"], [\"get\", \"foo\"]]).exec(function() {\n  /* ... */\n});\n```\n\nInline transactions are supported by pipeline, which means you can group a subset of commands\nin the pipeline into a transaction:\n\n```javascript\nredis\n  .pipeline()\n  .get(\"foo\")\n  .multi()\n  .set(\"foo\", \"bar\")\n  .get(\"foo\")\n  .exec()\n  .get(\"foo\")\n  .exec();\n```\n\n## Lua Scripting\n\nioredis supports all of the scripting commands such as `EVAL`, `EVALSHA` and `SCRIPT`.\nHowever, it's tedious to use in real world scenarios since developers have to take\ncare of script caching and to detect when to use `EVAL` and when to use `EVALSHA`.\nioredis expose a `defineCommand` method to make scripting much easier to use:\n\n```javascript\nvar redis = new Redis();\n\n// This will define a command echo:\nredis.defineCommand(\"echo\", {\n  numberOfKeys: 2,\n  lua: \"return {KEYS[1],KEYS[2],ARGV[1],ARGV[2]}\"\n});\n\n// Now `echo` can be used just like any other ordinary command,\n// and ioredis will try to use `EVALSHA` internally when possible for better performance.\nredis.echo(\"k1\", \"k2\", \"a1\", \"a2\", function(err, result) {\n  // result === ['k1', 'k2', 'a1', 'a2']\n});\n\n// `echoBuffer` is also defined automatically to return buffers instead of strings:\nredis.echoBuffer(\"k1\", \"k2\", \"a1\", \"a2\", function(err, result) {\n  // result[0] equals to Buffer.from('k1');\n});\n\n// And of course it works with pipeline:\nredis\n  .pipeline()\n  .set(\"foo\", \"bar\")\n  .echo(\"k1\", \"k2\", \"a1\", \"a2\")\n  .exec();\n```\n\nIf the number of keys can't be determined when defining a command, you can\nomit the `numberOfKeys` property and pass the number of keys as the first argument\nwhen you call the command:\n\n```javascript\nredis.defineCommand(\"echoDynamicKeyNumber\", {\n  lua: \"return {KEYS[1],KEYS[2],ARGV[1],ARGV[2]}\"\n});\n\n// Now you have to pass the number of keys as the first argument every time\n// you invoke the `echoDynamicKeyNumber` command:\nredis.echoDynamicKeyNumber(2, \"k1\", \"k2\", \"a1\", \"a2\", function(err, result) {\n  // result === ['k1', 'k2', 'a1', 'a2']\n});\n```\n\n## Transparent Key Prefixing\n\nThis feature allows you to specify a string that will automatically be prepended\nto all the keys in a command, which makes it easier to manage your key\nnamespaces.\n\n**Warning** This feature won't apply to commands like [KEYS](http://redis.io/commands/KEYS) and [SCAN](http://redis.io/commands/scan) that take patterns rather than actual keys([#239](https://github.com/luin/ioredis/issues/239)),\nand this feature also won't apply to the replies of commands even they are key names ([#325](https://github.com/luin/ioredis/issues/325)).\n\n```javascript\nvar fooRedis = new Redis({ keyPrefix: \"foo:\" });\nfooRedis.set(\"bar\", \"baz\"); // Actually sends SET foo:bar baz\n\nfooRedis.defineCommand(\"echo\", {\n  numberOfKeys: 2,\n  lua: \"return {KEYS[1],KEYS[2],ARGV[1],ARGV[2]}\"\n});\n\n// Works well with pipelining/transaction\nfooRedis\n  .pipeline()\n  // Sends SORT foo:list BY foo:weight_*->fieldname\n  .sort(\"list\", \"BY\", \"weight_*->fieldname\")\n  // Supports custom commands\n  // Sends EVALSHA xxx foo:k1 foo:k2 a1 a2\n  .echo(\"k1\", \"k2\", \"a1\", \"a2\")\n  .exec();\n```\n\n## Transforming Arguments & Replies\n\nMost Redis commands take one or more Strings as arguments,\nand replies are sent back as a single String or an Array of Strings. However, sometimes\nyou may want something different. For instance, it would be more convenient if the `HGETALL`\ncommand returns a hash (e.g. `{ key: val1, key2: v2 }`) rather than an array of key values (e.g. `[key1, val1, key2, val2]`).\n\nioredis has a flexible system for transforming arguments and replies. There are two types\nof transformers, argument transformer and reply transformer:\n\n```javascript\nvar Redis = require(\"ioredis\");\n\n// Here's the built-in argument transformer converting\n// hmset('key', { k1: 'v1', k2: 'v2' })\n// or\n// hmset('key', new Map([['k1', 'v1'], ['k2', 'v2']]))\n// into\n// hmset('key', 'k1', 'v1', 'k2', 'v2')\nRedis.Command.setArgumentTransformer(\"hmset\", function(args) {\n  if (args.length === 2) {\n    if (typeof Map !== \"undefined\" && args[1] instanceof Map) {\n      // utils is a internal module of ioredis\n      return [args[0]].concat(utils.convertMapToArray(args[1]));\n    }\n    if (typeof args[1] === \"object\" && args[1] !== null) {\n      return [args[0]].concat(utils.convertObjectToArray(args[1]));\n    }\n  }\n  return args;\n});\n\n// Here's the built-in reply transformer converting the HGETALL reply\n// ['k1', 'v1', 'k2', 'v2']\n// into\n// { k1: 'v1', 'k2': 'v2' }\nRedis.Command.setReplyTransformer(\"hgetall\", function(result) {\n  if (Array.isArray(result)) {\n    var obj = {};\n    for (var i = 0; i < result.length; i += 2) {\n      obj[result[i]] = result[i + 1];\n    }\n    return obj;\n  }\n  return result;\n});\n```\n\nThere are three built-in transformers, two argument transformers for `hmset` & `mset` and\na reply transformer for `hgetall`. Transformers for `hmset` and `hgetall` were mentioned\nabove, and the transformer for `mset` is similar to the one for `hmset`:\n\n```javascript\nredis.mset({ k1: \"v1\", k2: \"v2\" });\nredis.get(\"k1\", function(err, result) {\n  // result === 'v1';\n});\n\nredis.mset(new Map([[\"k3\", \"v3\"], [\"k4\", \"v4\"]]));\nredis.get(\"k3\", function(err, result) {\n  // result === 'v3';\n});\n```\n\nAnother useful example of a reply transformer is one that changes `hgetall` to return array of arrays instead of objects which avoids a unwanted conversation of hash keys to strings when dealing with binary hash keys:\n\n```javascript\nRedis.Command.setReplyTransformer(\"hgetall\", function(result) {\n  var arr = [];\n  for (var i = 0; i < result.length; i += 2) {\n    arr.push([result[i], result[i + 1]]);\n  }\n  return arr;\n});\nredis.hset(\"h1\", Buffer.from([0x01]), Buffer.from([0x02]));\nredis.hset(\"h1\", Buffer.from([0x03]), Buffer.from([0x04]));\nredis.hgetallBuffer(\"h1\", function(err, result) {\n  // result === [ [ <Buffer 01>, <Buffer 02> ], [ <Buffer 03>, <Buffer 04> ] ];\n});\n```\n\n## Monitor\n\nRedis supports the MONITOR command,\nwhich lets you see all commands received by the Redis server across all client connections,\nincluding from other client libraries and other computers.\n\nThe `monitor` method returns a monitor instance.\nAfter you send the MONITOR command, no other commands are valid on that connection. ioredis will emit a monitor event for every new monitor message that comes across.\nThe callback for the monitor event takes a timestamp from the Redis server and an array of command arguments.\n\nHere is a simple example:\n\n```javascript\nredis.monitor(function(err, monitor) {\n  monitor.on(\"monitor\", function(time, args, source, database) {});\n});\n```\n\n## Streamify Scanning\n\nRedis 2.8 added the `SCAN` command to incrementally iterate through the keys in the database. It's different from `KEYS` in that\n`SCAN` only returns a small number of elements each call, so it can be used in production without the downside\nof blocking the server for a long time. However, it requires recording the cursor on the client side each time\nthe `SCAN` command is called in order to iterate through all the keys correctly. Since it's a relatively common use case, ioredis\nprovides a streaming interface for the `SCAN` command to make things much easier. A readable stream can be created by calling `scanStream`:\n\n```javascript\nvar redis = new Redis();\n// Create a readable stream (object mode)\nvar stream = redis.scanStream();\nstream.on(\"data\", function(resultKeys) {\n  // `resultKeys` is an array of strings representing key names.\n  // Note that resultKeys may contain 0 keys, and that it will sometimes\n  // contain duplicates due to SCAN's implementation in Redis.\n  for (var i = 0; i < resultKeys.length; i++) {\n    console.log(resultKeys[i]);\n  }\n});\nstream.on(\"end\", function() {\n  console.log(\"all keys have been visited\");\n});\n```\n\n`scanStream` accepts an option, with which you can specify the `MATCH` pattern and the `COUNT` argument:\n\n```javascript\nvar stream = redis.scanStream({\n  // only returns keys following the pattern of `user:*`\n  match: \"user:*\",\n  // returns approximately 100 elements per call\n  count: 100\n});\n```\n\nJust like other commands, `scanStream` has a binary version `scanBufferStream`, which returns an array of buffers. It's useful when\nthe key names are not utf8 strings.\n\nThere are also `hscanStream`, `zscanStream` and `sscanStream` to iterate through elements in a hash, zset and set. The interface of each is\nsimilar to `scanStream` except the first argument is the key name:\n\n```javascript\nvar stream = redis.hscanStream(\"myhash\", {\n  match: \"age:??\"\n});\n```\n\nYou can learn more from the [Redis documentation](http://redis.io/commands/scan).\n\n**Useful Tips**\nIt's pretty common that doing an async task in the `data` handler. We'd like the scanning process to be paused until the async task to be finished. `Stream#pause()` and `Stream.resume()` do the trick. For example if we want to migrate data in Redis to MySQL:\n\n```javascript\nvar stream = redis.scanStream();\nstream.on(\"data\", function(resultKeys) {\n  // Pause the stream from scanning more keys until we've migrated the current keys.\n  stream.pause();\n\n  Promise.all(resultKeys.map(migrateKeyToMySQL)).then(() => {\n    // Resume the stream here.\n    stream.resume();\n  });\n});\n\nstream.on(\"end\", function() {\n  console.log(\"done migration\");\n});\n```\n\n## Auto-reconnect\n\nBy default, ioredis will try to reconnect when the connection to Redis is lost\nexcept when the connection is closed manually by `redis.disconnect()` or `redis.quit()`.\n\nIt's very flexible to control how long to wait to reconnect after disconnection\nusing the `retryStrategy` option:\n\n```javascript\nvar redis = new Redis({\n  // This is the default value of `retryStrategy`\n  retryStrategy: function(times) {\n    var delay = Math.min(times * 50, 2000);\n    return delay;\n  }\n});\n```\n\n`retryStrategy` is a function that will be called when the connection is lost.\nThe argument `times` means this is the nth reconnection being made and\nthe return value represents how long (in ms) to wait to reconnect. When the\nreturn value isn't a number, ioredis will stop trying to reconnect, and the connection\nwill be lost forever if the user doesn't call `redis.connect()` manually.\n\nWhen reconnected, the client will auto subscribe to channels that the previous connection subscribed to.\nThis behavior can be disabled by setting the `autoResubscribe` option to `false`.\n\nAnd if the previous connection has some unfulfilled commands (most likely blocking commands such as `brpop` and `blpop`),\nthe client will resend them when reconnected. This behavior can be disabled by setting the `autoResendUnfulfilledCommands` option to `false`.\n\nBy default, all pending commands will be flushed with an error every 20 retry attempts. That makes sure commands won't wait forever when the connection is down. You can change this behavior by setting `maxRetriesPerRequest`:\n\n```javascript\nvar redis = new Redis({\n  maxRetriesPerRequest: 1\n});\n```\n\nSet maxRetriesPerRequest to `null` to disable this behavior, and every command will wait forever until the connection is alive again (which is the default behavior before ioredis v4).\n\n### Reconnect on error\n\nBesides auto-reconnect when the connection is closed, ioredis supports reconnecting on the specified errors by the `reconnectOnError` option. Here's an example that will reconnect when receiving `READONLY` error:\n\n```javascript\nvar redis = new Redis({\n  reconnectOnError: function(err) {\n    var targetError = \"READONLY\";\n    if (err.message.slice(0, targetError.length) === targetError) {\n      // Only reconnect when the error starts with \"READONLY\"\n      return true; // or `return 1;`\n    }\n  }\n});\n```\n\nThis feature is useful when using Amazon ElastiCache. Once failover happens, Amazon ElastiCache will switch the master we currently connected with to a slave, leading to the following writes fails with the error `READONLY`. Using `reconnectOnError`, we can force the connection to reconnect on this error in order to connect to the new master.\n\nFurthermore, if the `reconnectOnError` returns `2`, ioredis will resend the failed command after reconnecting.\n\n## Connection Events\n\nThe Redis instance will emit some events about the state of the connection to the Redis server.\n\n| Event        | Description                                                                                                                                                                                                                                     |\n| :----------- | :---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| connect      | emits when a connection is established to the Redis server.                                                                                                                                                                                     |\n| ready        | If `enableReadyCheck` is `true`, client will emit `ready` when the server reports that it is ready to receive commands (e.g. finish loading data from disk).<br>Otherwise, `ready` will be emitted immediately right after the `connect` event. |\n| error        | emits when an error occurs while connecting.<br>However, ioredis emits all `error` events silently (only emits when there's at least one listener) so that your application won't crash if you're not listening to the `error` event.           |\n| close        | emits when an established Redis server connection has closed.                                                                                                                                                                                   |\n| reconnecting | emits after `close` when a reconnection will be made. The argument of the event is the time (in ms) before reconnecting.                                                                                                                        |\n| end          | emits after `close` when no more reconnections will be made, or the connection is failed to establish.                                                                                                                                          |\n\nYou can also check out the `Redis#status` property to get the current connection status.\n\nBesides the above connection events, there are several other custom events:\n\n| Event  | Description                                                         |\n| :----- | :------------------------------------------------------------------ |\n| select | emits when the database changed. The argument is the new db number. |\n\n## Offline Queue\n\nWhen a command can't be processed by Redis (being sent before the `ready` event), by default, it's added to the offline queue and will be\nexecuted when it can be processed. You can disable this feature by setting the `enableOfflineQueue`\noption to `false`:\n\n```javascript\nvar redis = new Redis({ enableOfflineQueue: false });\n```\n\n## TLS Options\n\nRedis doesn't support TLS natively, however if the redis server you want to connect to is hosted behind a TLS proxy (e.g. [stunnel](https://www.stunnel.org/)) or is offered by a PaaS service that supports TLS connection (e.g. [Redis Labs](https://redislabs.com/)), you can set the `tls` option:\n\n```javascript\nvar redis = new Redis({\n  host: \"localhost\",\n  tls: {\n    // Refer to `tls.connect()` section in\n    // https://nodejs.org/api/tls.html\n    // for all supported options\n    ca: fs.readFileSync(\"cert.pem\")\n  }\n});\n```\n\n<hr>\n\n## Sentinel\n\nioredis supports Sentinel out of the box. It works transparently as all features that work when\nyou connect to a single node also work when you connect to a sentinel group. Make sure to run Redis >= 2.8.12 if you want to use this feature. Sentinels have a default port of 26379.\n\nTo connect using Sentinel, use:\n\n```javascript\nvar redis = new Redis({\n  sentinels: [\n    { host: \"localhost\", port: 26379 },\n    { host: \"localhost\", port: 26380 }\n  ],\n  name: \"mymaster\"\n});\n\nredis.set(\"foo\", \"bar\");\n```\n\nThe arguments passed to the constructor are different from the ones you use to connect to a single node, where:\n\n- `name` identifies a group of Redis instances composed of a master and one or more slaves (`mymaster` in the example);\n- `sentinelPassword` (optional) password for Sentinel instances.\n- `sentinels` are a list of sentinels to connect to. The list does not need to enumerate all your sentinel instances, but a few so that if one is down the client will try the next one.\n- `role` (optional) with a value of `slave` will return a random slave from the Sentinel group.\n- `preferredSlaves` (optional) can be used to prefer a particular slave or set of slaves based on priority. It accepts a function or array.\n\nioredis **guarantees** that the node you connected to is always a master even after a failover. When a failover happens, instead of trying to reconnect to the failed node (which will be demoted to slave when it's available again), ioredis will ask sentinels for the new master node and connect to it. All commands sent during the failover are queued and will be executed when the new connection is established so that none of the commands will be lost.\n\nIt's possible to connect to a slave instead of a master by specifying the option `role` with the value of `slave` and ioredis will try to connect to a random slave of the specified master, with the guarantee that the connected node is always a slave. If the current node is promoted to master due to a failover, ioredis will disconnect from it and ask the sentinels for another slave node to connect to.\n\nIf you specify the option `preferredSlaves` along with `role: 'slave'` ioredis will attempt to use this value when selecting the slave from the pool of available slaves. The value of `preferredSlaves` should either be a function that accepts an array of avaiable slaves and returns a single result, or an array of slave values priorities by the lowest `prio` value first with a default value of `1`.\n\n```javascript\n// available slaves format\nvar availableSlaves = [{ ip: \"127.0.0.1\", port: \"31231\", flags: \"slave\" }];\n\n// preferredSlaves array format\nvar preferredSlaves = [\n  { ip: \"127.0.0.1\", port: \"31231\", prio: 1 },\n  { ip: \"127.0.0.1\", port: \"31232\", prio: 2 }\n];\n\n// preferredSlaves function format\npreferredSlaves = function(availableSlaves) {\n  for (var i = 0; i < availableSlaves.length; i++) {\n    var slave = availableSlaves[i];\n    if (slave.ip === \"127.0.0.1\") {\n      if (slave.port === \"31234\") {\n        return slave;\n      }\n    }\n  }\n  // if no preferred slaves are available a random one is used\n  return false;\n};\n\nvar redis = new Redis({\n  sentinels: [\n    { host: \"127.0.0.1\", port: 26379 },\n    { host: \"127.0.0.1\", port: 26380 }\n  ],\n  name: \"mymaster\",\n  role: \"slave\",\n  preferredSlaves: preferredSlaves\n});\n```\n\nBesides the `retryStrategy` option, there's also a `sentinelRetryStrategy` in Sentinel mode which will be invoked when all the sentinel nodes are unreachable during connecting. If `sentinelRetryStrategy` returns a valid delay time, ioredis will try to reconnect from scratch. The default value of `sentinelRetryStrategy` is:\n\n```javascript\nfunction (times) {\n  var delay = Math.min(times * 10, 1000);\n  return delay;\n}\n```\n\n## Cluster\n\nRedis Cluster provides a way to run a Redis installation where data is automatically sharded across multiple Redis nodes.\nYou can connect to a Redis Cluster like this:\n\n```javascript\nvar Redis = require(\"ioredis\");\n\nvar cluster = new Redis.Cluster([\n  {\n    port: 6380,\n    host: \"127.0.0.1\"\n  },\n  {\n    port: 6381,\n    host: \"127.0.0.1\"\n  }\n]);\n\ncluster.set(\"foo\", \"bar\");\ncluster.get(\"foo\", function(err, res) {\n  // res === 'bar'\n});\n```\n\n`Cluster` constructor accepts two arguments, where:\n\n0.  The first argument is a list of nodes of the cluster you want to connect to.\n    Just like Sentinel, the list does not need to enumerate all your cluster nodes,\n    but a few so that if one is unreachable the client will try the next one, and the client will discover other nodes automatically when at least one node is connected.\n1.  The second argument is the options, where:\n\n    - `clusterRetryStrategy`: When none of the startup nodes are reachable, `clusterRetryStrategy` will be invoked. When a number is returned,\n      ioredis will try to reconnect to the startup nodes from scratch after the specified delay (in ms). Otherwise, an error of \"None of startup nodes is available\" will be returned.\n      The default value of this option is:\n\n          ```javascript\n          function (times) {\n            var delay = Math.min(100 + times * 2, 2000);\n            return delay;\n          }\n          ```\n\n          It's possible to modify the `startupNodes` property in order to switch to another set of nodes here:\n\n          ```javascript\n          function (times) {\n            this.startupNodes = [{ port: 6790, host: '127.0.0.1' }];\n            return Math.min(100 + times * 2, 2000);\n          }\n          ```\n\n    - `dnsLookup`: Alternative DNS lookup function (`dns.lookup()` is used by default). It may be useful to override this in special cases, such as when AWS ElastiCache used with TLS enabled.\n    - `enableOfflineQueue`: Similar to the `enableOfflineQueue` option of `Redis` class.\n    - `enableReadyCheck`: When enabled, \"ready\" event will only be emitted when `CLUSTER INFO` command\n      reporting the cluster is ready for handling commands. Otherwise, it will be emitted immediately after \"connect\" is emitted.\n    - `scaleReads`: Config where to send the read queries. See below for more details.\n    - `maxRedirections`: When a cluster related error (e.g. `MOVED`, `ASK` and `CLUSTERDOWN` etc.) is received, the client will redirect the\n      command to another node. This option limits the max redirections allowed when sending a command. The default value is `16`.\n    - `retryDelayOnFailover`: If the target node is disconnected when sending a command,\n      ioredis will retry after the specified delay. The default value is `100`. You should make sure `retryDelayOnFailover * maxRedirections > cluster-node-timeout`\n      to insure that no command will fail during a failover.\n    - `retryDelayOnClusterDown`: When a cluster is down, all commands will be rejected with the error of `CLUSTERDOWN`. If this option is a number (by default, it is `100`), the client\n      will resend the commands after the specified time (in ms).\n    - `retryDelayOnTryAgain`: If this option is a number (by default, it is `100`), the client\n      will resend the commands rejected with `TRYAGAIN` error after the specified time (in ms).\n    - `redisOptions`: Default options passed to the constructor of `Redis` when connecting to a node.\n    - `slotsRefreshTimeout`: Milliseconds before a timeout occurs while refreshing slots from the cluster (default `1000`)\n    - `slotsRefreshInterval`: Milliseconds between every automatic slots refresh (default `5000`)\n\n### Read-write splitting\n\nA typical redis cluster contains three or more masters and several slaves for each master. It's possible to scale out redis cluster by sending read queries to slaves and write queries to masters by setting the `scaleReads` option.\n\n`scaleReads` is \"master\" by default, which means ioredis will never send any queries to slaves. There are other three available options:\n\n1. \"all\": Send write queries to masters and read queries to masters or slaves randomly.\n2. \"slave\": Send write queries to masters and read queries to slaves.\n3. a custom `function(nodes, command): node`: Will choose the custom function to select to which node to send read queries (write queries keep being sent to master). The first node in `nodes` is always the master serving the relevant slots. If the function returns an array of nodes, a random node of that list will be selected.\n\nFor example:\n\n```javascript\nvar cluster = new Redis.Cluster(\n  [\n    /* nodes */\n  ],\n  {\n    scaleReads: \"slave\"\n  }\n);\ncluster.set(\"foo\", \"bar\"); // This query will be sent to one of the masters.\ncluster.get(\"foo\", function(err, res) {\n  // This query will be sent to one of the slaves.\n});\n```\n\n**NB** In the code snippet above, the `res` may not be equal to \"bar\" because of the lag of replication between the master and slaves.\n\n### Running commands to multiple nodes\n\nEvery command will be sent to exactly one node. For commands containing keys, (e.g. `GET`, `SET` and `HGETALL`), ioredis sends them to the node that serving the keys, and for other commands not containing keys, (e.g. `INFO`, `KEYS` and `FLUSHDB`), ioredis sends them to a random node.\n\nSometimes you may want to send a command to multiple nodes (masters or slaves) of the cluster, you can get the nodes via `Cluster#nodes()` method.\n\n`Cluster#nodes()` accepts a parameter role, which can be \"master\", \"slave\" and \"all\" (default), and returns an array of `Redis` instance. For example:\n\n```javascript\n// Send `FLUSHDB` command to all slaves:\nvar slaves = cluster.nodes(\"slave\");\nPromise.all(\n  slaves.map(function(node) {\n    return node.flushdb();\n  })\n);\n\n// Get keys of all the masters:\nvar masters = cluster.nodes(\"master\");\nPromise.all(\n  masters.map(function(node) {\n    return node.keys();\n  })\n).then(function(keys) {\n  // keys: [['key1', 'key2'], ['key3', 'key4']]\n});\n```\n\n### NAT Mapping\n\nSometimes the cluster is hosted within a internal network that can only be accessed via a NAT (Network Address Translation) instance. See [Accessing ElastiCache from outside AWS](https://docs.aws.amazon.com/AmazonElastiCache/latest/red-ug/accessing-elasticache.html) as an example.\n\nYou can specify nat mapping rules via `natMap` option:\n\n```javascript\nconst cluster = new Redis.Cluster(\n  [\n    {\n      host: \"203.0.113.73\",\n      port: 30001\n    }\n  ],\n  {\n    natMap: {\n      \"10.0.1.230:30001\": { host: \"203.0.113.73\", port: 30001 },\n      \"10.0.1.231:30001\": { host: \"203.0.113.73\", port: 30002 },\n      \"10.0.1.232:30001\": { host: \"203.0.113.73\", port: 30003 }\n    }\n  }\n);\n```\n\nThis option is also useful when the cluster is running inside a Docker container.\n\n### Transaction and pipeline in Cluster mode\n\nAlmost all features that are supported by `Redis` are also supported by `Redis.Cluster`, e.g. custom commands, transaction and pipeline.\nHowever there are some differences when using transaction and pipeline in Cluster mode:\n\n0. All keys in a pipeline should belong to the same slot since ioredis sends all commands in a pipeline to the same node.\n1. You can't use `multi` without pipeline (aka `cluster.multi({ pipeline: false })`). This is because when you call `cluster.multi({ pipeline: false })`, ioredis doesn't know which node the `multi` command should be sent to.\n2. Chaining custom commands in the pipeline is not supported in Cluster mode.\n\nWhen any commands in a pipeline receives a `MOVED` or `ASK` error, ioredis will resend the whole pipeline to the specified node automatically if all of the following conditions are satisfied:\n\n0. All errors received in the pipeline are the same. For example, we won't resend the pipeline if we got two `MOVED` errors pointing to different nodes.\n1. All commands executed successfully are readonly commands. This makes sure that resending the pipeline won't have side effects.\n\n### Pub/Sub\n\nPub/Sub in cluster mode works exactly as the same as in standalone mode. Internally, when a node of the cluster receives a message, it will broadcast the message to the other nodes. ioredis makes sure that each message will only be received once by strictly subscribing one node at the same time.\n\n```javascript\nvar nodes = [\n  /* nodes */\n];\nvar pub = new Redis.Cluster(nodes);\nvar sub = new Redis.Cluster(nodes);\nsub.on(\"message\", function(channel, message) {\n  console.log(channel, message);\n});\n\nsub.subscribe(\"news\", function() {\n  pub.publish(\"news\", \"highlights\");\n});\n```\n\n### Events\n\n| Event        | Description                                                                                                                                                                                                |\n| :----------- | :--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| connect      | emits when a connection is established to the Redis server.                                                                                                                                                |\n| ready        | emits when `CLUSTER INFO` reporting the cluster is able to receive commands (if `enableReadyCheck` is `true`) or immediately after `connect` event (if `enableReadyCheck` is false).                       |\n| error        | emits when an error occurs while connecting with a property of `lastNodeError` representing the last node error received. This event is emitted silently (only emitting if there's at least one listener). |\n| close        | emits when an established Redis server connection has closed.                                                                                                                                              |\n| reconnecting | emits after `close` when a reconnection will be made. The argument of the event is the time (in ms) before reconnecting.                                                                                   |\n| end          | emits after `close` when no more reconnections will be made.                                                                                                                                               |\n| +node        | emits when a new node is connected.                                                                                                                                                                        |\n| -node        | emits when a node is disconnected.                                                                                                                                                                         |\n| node error   | emits when an error occurs when connecting to a node. The second argument indicates the address of the node.                                                                                               |\n\n### Password\n\nSetting the `password` option to access password-protected clusters:\n\n```javascript\nvar Redis = require(\"ioredis\");\nvar cluster = new Redis.Cluster(nodes, {\n  redisOptions: {\n    password: \"your-cluster-password\"\n  }\n});\n```\n\nIf some of nodes in the cluster using a different password, you should specify them in the first parameter:\n\n```javascript\nvar Redis = require(\"ioredis\");\nvar cluster = new Redis.Cluster(\n  [\n    // Use password \"password-for-30001\" for 30001\n    { port: 30001, password: \"password-for-30001\" },\n    // Don't use password when accessing 30002\n    { port: 30002, password: null }\n    // Other nodes will use \"fallback-password\"\n  ],\n  {\n    redisOptions: {\n      password: \"fallback-password\"\n    }\n  }\n);\n```\n\n### Special note: AWS ElastiCache Clusters with TLS\n\nAWS ElastiCache for Redis (Clustered Mode) supports TLS encryption. If you use\nthis, you may encounter errors with invalid certificates. To resolve this\nissue, construct the `Cluster` with the `dnsLookup` option as follows:\n\n```javascript\nvar cluster = new Redis.Cluster(\n  [{\n    host: 'clustercfg.myCluster.abcdefg.xyz.cache.amazonaws.com',\n    port: 6379\n  }],\n  {\n    dnsLookup: (address, callback) => callback(null, address),\n    redisOptions: {\n      tls: {}\n    },\n  }\n};\n```\n\n<hr>\n\n# Error Handling\n\nAll the errors returned by the Redis server are instances of `ReplyError`, which can be accessed via `Redis`:\n\n```javascript\nvar Redis = require(\"ioredis\");\nvar redis = new Redis();\n// This command causes a reply error since the SET command requires two arguments.\nredis.set(\"foo\", function(err) {\n  err instanceof Redis.ReplyError;\n});\n```\n\nThis is the error stack of the `ReplyError`:\n\n```\nReplyError: ERR wrong number of arguments for 'set' command\n    at ReplyParser._parseResult (/app/node_modules/ioredis/lib/parsers/javascript.js:60:14)\n    at ReplyParser.execute (/app/node_modules/ioredis/lib/parsers/javascript.js:178:20)\n    at Socket.<anonymous> (/app/node_modules/ioredis/lib/redis/event_handler.js:99:22)\n    at Socket.emit (events.js:97:17)\n    at readableAddChunk (_stream_readable.js:143:16)\n    at Socket.Readable.push (_stream_readable.js:106:10)\n    at TCP.onread (net.js:509:20)\n```\n\nBy default, the error stack doesn't make any sense because the whole stack happens in the ioredis\nmodule itself, not in your code. So it's not easy to find out where the error happens in your code.\nioredis provides an option `showFriendlyErrorStack` to solve the problem. When you enable\n`showFriendlyErrorStack`, ioredis will optimize the error stack for you:\n\n```javascript\nvar Redis = require(\"ioredis\");\nvar redis = new Redis({ showFriendlyErrorStack: true });\nredis.set(\"foo\");\n```\n\nAnd the output will be:\n\n```\nReplyError: ERR wrong number of arguments for 'set' command\n    at Object.<anonymous> (/app/index.js:3:7)\n    at Module._compile (module.js:446:26)\n    at Object.Module._extensions..js (module.js:464:10)\n    at Module.load (module.js:341:32)\n    at Function.Module._load (module.js:296:12)\n    at Function.Module.runMain (module.js:487:10)\n    at startup (node.js:111:16)\n    at node.js:799:3\n```\n\nThis time the stack tells you that the error happens on the third line in your code. Pretty sweet!\nHowever, it would decrease the performance significantly to optimize the error stack. So by\ndefault, this option is disabled and can only be used for debugging purposes. You **shouldn't** use this feature in a production environment.\n\n# Plugging in your own Promises Library\n\nIf you're an advanced user, you may want to plug in your own promise library like [bluebird](https://www.npmjs.com/package/bluebird). Just set Redis.Promise to your favorite ES6-style promise constructor and ioredis will use it.\n\n```javascript\nconst Redis = require(\"ioredis\");\nRedis.Promise = require(\"bluebird\");\n\nconst redis = new Redis();\n\n// Use bluebird\nassert.equal(redis.get().constructor, require(\"bluebird\"));\n\n// You can change the Promise implementation at any time:\nRedis.Promise = global.Promise;\nassert.equal(redis.get().constructor, global.Promise);\n```\n\n# Running tests\n\nStart a Redis server on 127.0.0.1:6379, and then:\n\n```shell\n$ npm test\n```\n\n`FLUSH ALL` will be invoked after each test, so make sure there's no valuable data in it before running tests.\n\nIf your testing environment does not let you spin up a Redis server [ioredis-mock](https://github.com/stipsan/ioredis-mock) is a drop-in replacement you can use in your tests. It aims to behave identically to ioredis connected to a Redis server so that your integration tests is easier to write and of better quality.\n\n# Debug\n\nYou can set the `DEBUG` env to `ioredis:*` to print debug info:\n\n```shell\n$ DEBUG=ioredis:* node app.js\n```\n\n# Join in!\n\nI'm happy to receive bug reports, fixes, documentation enhancements, and any other improvements.\n\nAnd since I'm not a native English speaker, if you find any grammar mistakes in the documentation, please also let me know. :)\n\n# Become a Sponsor\n\nOpen source is hard and time-consuming. If you want to invest in ioredis's future you can become a sponsor and make us spend more time on this library's improvements and new features.\n\n<a href=\"https://opencollective.com/ioredis\"><img src=\"https://opencollective.com/ioredis/tiers/sponsor.svg?avatarHeight=36\"></a>\n\nThank you for using ioredis :-)\n\n# Contributors\n\nThis project exists thanks to all the people who contribute:\n\n<a href=\"https://github.com/luin/ioredis/graphs/contributors\"><img src=\"https://opencollective.com/ioredis/contributors.svg?width=890&showBtn=false\" /></a>\n\n# License\n\nMIT\n\n[![FOSSA Status](https://app.fossa.io/api/projects/git%2Bgithub.com%2Fluin%2Fioredis.svg?type=large)](https://app.fossa.io/projects/git%2Bgithub.com%2Fluin%2Fioredis?ref=badge_large)\n","readmeFilename":"README.md","bugs":{"url":"https://github.com/luin/ioredis/issues"},"homepage":"https://github.com/luin/ioredis#readme","_id":"ioredis@4.13.0","_nodeVersion":"10.16.0","_npmVersion":"6.9.0","dist":{"integrity":"sha512-zZFiRwCXm42OQ7QR5ebLGB3udSToXu5puFhYCBtXa5P/B0b7z6jlpo8gTaMCdahfc8mgyQCK/U9NXlszpIRmvQ==","shasum":"b13d390b9e3e894b5e2a081e5ba94d51da29bfc2","tarball":"https://registry.npmjs.org/ioredis/-/ioredis-4.13.0.tgz","fileCount":36,"unpackedSize":238061,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJdMWQFCRA9TVsSAnZWagAAcwIP/35Aq2TZzBzlweepOir+\nA+n1ag7ExJDMFtggjBY411dB03yilcrsneB+ZtgCdp7xf489R/PKqHI8PuOI\nJkSRNVoAYU3Eo5Zd9VxBWNnFZAey7g9BnSGPbFsKO4uPs1pEqgXF6ZDM0ELD\nV4MC6q/FIyLrulgHz0oJ5dqYchQd/j37+5s4uhTBKImHLC9nANUWdlNxr+QU\ntnPWa46nKB1uw+mm2nCNfQGLdRYYopRdqRLZkf7A0agXwSacAcD/Gxl/p2WL\nswV4TUjDoYd7F6vEaQ7Nha8RIMVE/IfIbwACV3lgNvLvWVVBt4nxqfIlUiz9\noIEGeYlAIx9MN8AVYDSmSnui/XqTXYBORwJkfCIp3ydyJ1fch+IC19QHpf+w\nA9Qg22J+1ZHMJ/SvTQUnfSGXaitp95qhdxAncoQCubfEfa9HmsaU+q9dTZKI\ni0VqqR4b2USOUTF5Vif9M/65NWRcwM1jHyFtLKL7D/TD0aUiiYdG0JRVTugW\nIugWm1pc7e/n29UXdSC9gvadkGuQjNaPN5X0rvJhXTA/QPkT6F7OY5igpgxi\nuj5tLMAgaghnUdFb6JbORTDwOeoyZA0babKRzF6gU1BPWxRW1DnOv1HVPfdm\nZtGCD9pFG2V5jiQhtTQlZmA1u9QhNHqqn5/X9hZNzsSr6eYbA5fzEb9f3XoJ\n/0nE\r\n=UmXe\r\n-----END PGP SIGNATURE-----\r\n"},"maintainers":[{"email":"ioredis-robot@zihua.li","name":"ioredis-robot"},{"email":"i@zihua.li","name":"luin"}],"_npmUser":{"name":"luin","email":"i@zihua.li"},"directories":{},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/ioredis_4.13.0_1563517957268_0.5920748023260072"},"_hasShrinkwrap":false},"4.13.1":{"name":"ioredis","version":"4.13.1","description":"A robust, performance-focused and full-featured Redis client for Node.js.","main":"built/index.js","scripts":{"test":"TS_NODE_TRANSPILE_ONLY=true TS_NODE_LOG_ERROR=true NODE_ENV=test mocha \"test/**/*.ts\"","test:cov":"TS_NODE_TRANSPILE_ONLY=true TS_NODE_LOG_ERROR=true NODE_ENV=test node ./node_modules/istanbul/lib/cli.js cover --preserve-comments ./node_modules/mocha/bin/_mocha -- -r ts-node/register -R spec --exit \"test/**/*.ts\"","lint":"eslint --ext .js,.ts .","format":"prettier --write \"{,!(node_modules)/**/}*.{js,ts}\"","format-check":"prettier --check \"{,!(node_modules)/**/}*.{js,ts}\"","build":"rm -rf built && tsc","prepublishOnly":"npm run build && npm test","bench":"matcha benchmarks/*.js","semantic-release":"semantic-release"},"repository":{"type":"git","url":"git://github.com/luin/ioredis.git"},"keywords":["redis","cluster","sentinel","pipelining"],"author":{"name":"luin","email":"i@zihua.li","url":"http://zihua.li"},"license":"MIT","dependencies":{"cluster-key-slot":"^1.1.0","debug":"^4.1.1","denque":"^1.1.0","lodash.defaults":"^4.2.0","lodash.flatten":"^4.4.0","redis-commands":"1.5.0","redis-errors":"^1.2.0","redis-parser":"^3.0.0","standard-as-callback":"^2.0.1"},"devDependencies":{"@semantic-release/changelog":"^3.0.4","@semantic-release/git":"^7.0.12","@types/bluebird":"^3.5.27","@types/chai":"^4.1.7","@types/debug":"^4.1.4","@types/lodash.defaults":"^4.2.6","@types/lodash.flatten":"^4.4.6","@types/mocha":"^5.2.7","@types/node":"^12.0.2","@types/redis-errors":"1.2.0","@types/sinon":"^7.0.13","@typescript-eslint/eslint-plugin":"^1.11.0","@typescript-eslint/parser":"^1.11.0","bluebird":"^3.5.4","chai":"^4.2.0","cz-conventional-changelog":"^2.0.0","eslint":"^5.16.0","eslint-config-prettier":"^5.1.0","husky":"^2.5.0","istanbul":"^0.4.5","mocha":"^5.0.0","prettier":"^1.18.2","pretty-quick":"^1.11.1","server-destroy":"^1.0.1","sinon":"^7.3.2","ts-node":"^8.1.0","typescript":"^3.5.1"},"engines":{"node":">=6"},"config":{"commitizen":{"path":"./node_modules/cz-conventional-changelog"}},"husky":{"hooks":{"pre-commit":"pretty-quick --staged"}},"gitHead":"fd25e89706badbfb28cd927ee887a59f3c7307f1","readme":"[![ioredis](https://cdn.jsdelivr.net/gh/luin/ioredis@b5e8c74/logo.svg)](https://github.com/luin/ioredis)\n\n[![Build Status](https://travis-ci.org/luin/ioredis.svg?branch=master)](https://travis-ci.org/luin/ioredis)\n[![Test Coverage](https://codeclimate.com/github/luin/ioredis/badges/coverage.svg)](https://codeclimate.com/github/luin/ioredis)\n[![code style: prettier](https://img.shields.io/badge/code_style-prettier-ff69b4.svg?style=flat-square)](https://github.com/prettier/prettier)\n[![Join the chat at https://gitter.im/luin/ioredis](https://badges.gitter.im/Join%20Chat.svg)](https://gitter.im/luin/ioredis?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge)\n[![Commitizen friendly](https://img.shields.io/badge/commitizen-friendly-brightgreen.svg)](http://commitizen.github.io/cz-cli/)\n[![semantic-release](https://img.shields.io/badge/%20%20%F0%9F%93%A6%F0%9F%9A%80-semantic--release-e10079.svg)](https://github.com/semantic-release/semantic-release)\n[![npm latest version](https://img.shields.io/npm/v/ioredis/latest.svg)](https://www.npmjs.com/package/ioredis)\n[![npm next version](https://img.shields.io/npm/v/ioredis/next.svg)](https://www.npmjs.com/package/ioredis)\n<img alt=\"\" src=\"\">\n\nA robust, performance-focused and full-featured [Redis](http://redis.io) client for [Node.js](https://nodejs.org).\n\nSupports Redis >= 2.6.12 and (Node.js >= 6).\n\n# Features\n\nioredis is a robust, full-featured Redis client that is\nused in the world's biggest online commerce company [Alibaba](http://www.alibaba.com/) and many other awesome companies.\n\n0. Full-featured. It supports [Cluster](http://redis.io/topics/cluster-tutorial), [Sentinel](http://redis.io/topics/sentinel), [Pipelining](http://redis.io/topics/pipelining) and of course [Lua scripting](http://redis.io/commands/eval) & [Pub/Sub](http://redis.io/topics/pubsub) (with the support of binary messages).\n1. High performance.\n2. Delightful API. It works with Node callbacks and Native promises.\n3. Transformation of command arguments and replies.\n4. Transparent key prefixing.\n5. Abstraction for Lua scripting, allowing you to define custom commands.\n6. Support for binary data.\n7. Support for TLS.\n8. Support for offline queue and ready checking.\n9. Support for ES6 types, such as `Map` and `Set`.\n10. Support for GEO commands (Redis 3.2 Unstable).\n11. Sophisticated error handling strategy.\n12. Support for NAT mapping.\n\n# Links\n\n- [API Documentation](API.md)\n- [Changelog](Changelog.md)\n- [Migrating from node_redis](https://github.com/luin/ioredis/wiki/Migrating-from-node_redis)\n- [Error Handling](#error-handling)\n\n<hr>\n<a href=\"http://bit.ly/medis-macos\"><img align=\"right\" src=\"resources/medis.png\" alt=\"Download on the App Store\"></a>\n\n### [AD] Medis: Redis GUI for OS X\n\nLooking for a Redis GUI manager for OS X, Windows and Linux? Here's [Medis](http://bit.ly/medis-macos)!\n\nMedis is an open-sourced, beautiful, easy-to-use Redis GUI management application.\n\nMedis starts with all the basic features you need:\n\n- Keys viewing/editing\n- SSH Tunnel for connecting with remote servers\n- Terminal for executing custom commands\n- JSON/MessagePack format viewing/editing and built-in highlighting/validator\n- And other awesome features...\n\n[Medis is open sourced on GitHub](https://github.com/luin/medis)\n\n### [AD] Kuber: Kubernetes Dashboard for iOS\n\n<a href=\"http://bit.ly/kuber-ios\"><img src=\"resources/kuber.png\" alt=\"Download on the App Store\"></a>\n\n<hr>\n\n# Quick Start\n\n## Install\n\n```shell\n$ npm install ioredis\n```\n\n## Basic Usage\n\n```javascript\nvar Redis = require(\"ioredis\");\nvar redis = new Redis();\n\nredis.set(\"foo\", \"bar\");\nredis.get(\"foo\", function(err, result) {\n  console.log(result);\n});\nredis.del(\"foo\");\n\n// Or using a promise if the last argument isn't a function\nredis.get(\"foo\").then(function(result) {\n  console.log(result);\n});\n\n// Arguments to commands are flattened, so the following are the same:\nredis.sadd(\"set\", 1, 3, 5, 7);\nredis.sadd(\"set\", [1, 3, 5, 7]);\n\n// All arguments are passed directly to the redis server:\nredis.set(\"key\", 100, \"EX\", 10);\n```\n\nSee the `examples/` folder for more examples.\n\n## Connect to Redis\n\nWhen a new `Redis` instance is created,\na connection to Redis will be created at the same time.\nYou can specify which Redis to connect to by:\n\n```javascript\nnew Redis(); // Connect to 127.0.0.1:6379\nnew Redis(6380); // 127.0.0.1:6380\nnew Redis(6379, \"192.168.1.1\"); // 192.168.1.1:6379\nnew Redis(\"/tmp/redis.sock\");\nnew Redis({\n  port: 6379, // Redis port\n  host: \"127.0.0.1\", // Redis host\n  family: 4, // 4 (IPv4) or 6 (IPv6)\n  password: \"auth\",\n  db: 0\n});\n```\n\nYou can also specify connection options as a [`redis://` URL](http://www.iana.org/assignments/uri-schemes/prov/redis):\n\n```javascript\n// Connect to 127.0.0.1:6380, db 4, using password \"authpassword\":\nnew Redis(\"redis://:authpassword@127.0.0.1:6380/4\");\n```\n\nSee [API Documentation](API.md#new_Redis) for all available options.\n\n## Pub/Sub\n\nHere is a simple example of the API for publish/subscribe.\nThe following program opens two client connections.\nIt subscribes to a channel with one connection\nand publishes to that channel with the other:\n\n```javascript\nvar Redis = require(\"ioredis\");\nvar redis = new Redis();\nvar pub = new Redis();\nredis.subscribe(\"news\", \"music\", function(err, count) {\n  // Now we are subscribed to both the 'news' and 'music' channels.\n  // `count` represents the number of channels we are currently subscribed to.\n\n  pub.publish(\"news\", \"Hello world!\");\n  pub.publish(\"music\", \"Hello again!\");\n});\n\nredis.on(\"message\", function(channel, message) {\n  // Receive message Hello world! from channel news\n  // Receive message Hello again! from channel music\n  console.log(\"Receive message %s from channel %s\", message, channel);\n});\n\n// There's also an event called 'messageBuffer', which is the same as 'message' except\n// it returns buffers instead of strings.\nredis.on(\"messageBuffer\", function(channel, message) {\n  // Both `channel` and `message` are buffers.\n});\n```\n\n`PSUBSCRIBE` is also supported in a similar way:\n\n```javascript\nredis.psubscribe(\"pat?ern\", function(err, count) {});\nredis.on(\"pmessage\", function(pattern, channel, message) {});\nredis.on(\"pmessageBuffer\", function(pattern, channel, message) {});\n```\n\nWhen a client issues a SUBSCRIBE or PSUBSCRIBE, that connection is put into a \"subscriber\" mode.\nAt that point, only commands that modify the subscription set are valid.\nWhen the subscription set is empty, the connection is put back into regular mode.\n\nIf you need to send regular commands to Redis while in subscriber mode, just open another connection.\n\n## Handle Binary Data\n\nArguments can be buffers:\n\n```javascript\nredis.set(\"foo\", Buffer.from(\"bar\"));\n```\n\nAnd every command has a method that returns a Buffer (by adding a suffix of \"Buffer\" to the command name).\nTo get a buffer instead of a utf8 string:\n\n```javascript\nredis.getBuffer(\"foo\", function(err, result) {\n  // result is a buffer.\n});\n```\n\n## Pipelining\n\nIf you want to send a batch of commands (e.g. > 5), you can use pipelining to queue\nthe commands in memory and then send them to Redis all at once. This way the performance improves by 50%~300% (See [benchmark section](#benchmark)).\n\n`redis.pipeline()` creates a `Pipeline` instance. You can call any Redis\ncommands on it just like the `Redis` instance. The commands are queued in memory\nand flushed to Redis by calling the `exec` method:\n\n```javascript\nvar pipeline = redis.pipeline();\npipeline.set(\"foo\", \"bar\");\npipeline.del(\"cc\");\npipeline.exec(function(err, results) {\n  // `err` is always null, and `results` is an array of responses\n  // corresponding to the sequence of queued commands.\n  // Each response follows the format `[err, result]`.\n});\n\n// You can even chain the commands:\nredis\n  .pipeline()\n  .set(\"foo\", \"bar\")\n  .del(\"cc\")\n  .exec(function(err, results) {});\n\n// `exec` also returns a Promise:\nvar promise = redis\n  .pipeline()\n  .set(\"foo\", \"bar\")\n  .get(\"foo\")\n  .exec();\npromise.then(function(result) {\n  // result === [[null, 'OK'], [null, 'bar']]\n});\n```\n\nEach chained command can also have a callback, which will be invoked when the command\ngets a reply:\n\n```javascript\nredis\n  .pipeline()\n  .set(\"foo\", \"bar\")\n  .get(\"foo\", function(err, result) {\n    // result === 'bar'\n  })\n  .exec(function(err, result) {\n    // result[1][1] === 'bar'\n  });\n```\n\nIn addition to adding commands to the `pipeline` queue individually, you can also pass an array of commands and arguments to the constructor:\n\n```javascript\nredis.pipeline([[\"set\", \"foo\", \"bar\"], [\"get\", \"foo\"]]).exec(function() {\n  /* ... */\n});\n```\n\n`#length` property shows how many commands in the pipeline:\n\n```javascript\nconst length = redis\n  .pipeline()\n  .set(\"foo\", \"bar\")\n  .get(\"foo\").length;\n// length === 2\n```\n\n## Transaction\n\nMost of the time, the transaction commands `multi` & `exec` are used together with pipeline.\nTherefore, when `multi` is called, a `Pipeline` instance is created automatically by default,\nso you can use `multi` just like `pipeline`:\n\n```javascript\nredis\n  .multi()\n  .set(\"foo\", \"bar\")\n  .get(\"foo\")\n  .exec(function(err, results) {\n    // results === [[null, 'OK'], [null, 'bar']]\n  });\n```\n\nIf there's a syntax error in the transaction's command chain (e.g. wrong number of arguments, wrong command name, etc),\nthen none of the commands would be executed, and an error is returned:\n\n```javascript\nredis\n  .multi()\n  .set(\"foo\")\n  .set(\"foo\", \"new value\")\n  .exec(function(err, results) {\n    // err:\n    //  { [ReplyError: EXECABORT Transaction discarded because of previous errors.]\n    //    name: 'ReplyError',\n    //    message: 'EXECABORT Transaction discarded because of previous errors.',\n    //    command: { name: 'exec', args: [] },\n    //    previousErrors:\n    //     [ { [ReplyError: ERR wrong number of arguments for 'set' command]\n    //         name: 'ReplyError',\n    //         message: 'ERR wrong number of arguments for \\'set\\' command',\n    //         command: [Object] } ] }\n  });\n```\n\nIn terms of the interface, `multi` differs from `pipeline` in that when specifying a callback\nto each chained command, the queueing state is passed to the callback instead of the result of the command:\n\n```javascript\nredis\n  .multi()\n  .set(\"foo\", \"bar\", function(err, result) {\n    // result === 'QUEUED'\n  })\n  .exec(/* ... */);\n```\n\nIf you want to use transaction without pipeline, pass `{ pipeline: false }` to `multi`,\nand every command will be sent to Redis immediately without waiting for an `exec` invocation:\n\n```javascript\nredis.multi({ pipeline: false });\nredis.set(\"foo\", \"bar\");\nredis.get(\"foo\");\nredis.exec(function(err, result) {\n  // result === [[null, 'OK'], [null, 'bar']]\n});\n```\n\nThe constructor of `multi` also accepts a batch of commands:\n\n```javascript\nredis.multi([[\"set\", \"foo\", \"bar\"], [\"get\", \"foo\"]]).exec(function() {\n  /* ... */\n});\n```\n\nInline transactions are supported by pipeline, which means you can group a subset of commands\nin the pipeline into a transaction:\n\n```javascript\nredis\n  .pipeline()\n  .get(\"foo\")\n  .multi()\n  .set(\"foo\", \"bar\")\n  .get(\"foo\")\n  .exec()\n  .get(\"foo\")\n  .exec();\n```\n\n## Lua Scripting\n\nioredis supports all of the scripting commands such as `EVAL`, `EVALSHA` and `SCRIPT`.\nHowever, it's tedious to use in real world scenarios since developers have to take\ncare of script caching and to detect when to use `EVAL` and when to use `EVALSHA`.\nioredis expose a `defineCommand` method to make scripting much easier to use:\n\n```javascript\nvar redis = new Redis();\n\n// This will define a command echo:\nredis.defineCommand(\"echo\", {\n  numberOfKeys: 2,\n  lua: \"return {KEYS[1],KEYS[2],ARGV[1],ARGV[2]}\"\n});\n\n// Now `echo` can be used just like any other ordinary command,\n// and ioredis will try to use `EVALSHA` internally when possible for better performance.\nredis.echo(\"k1\", \"k2\", \"a1\", \"a2\", function(err, result) {\n  // result === ['k1', 'k2', 'a1', 'a2']\n});\n\n// `echoBuffer` is also defined automatically to return buffers instead of strings:\nredis.echoBuffer(\"k1\", \"k2\", \"a1\", \"a2\", function(err, result) {\n  // result[0] equals to Buffer.from('k1');\n});\n\n// And of course it works with pipeline:\nredis\n  .pipeline()\n  .set(\"foo\", \"bar\")\n  .echo(\"k1\", \"k2\", \"a1\", \"a2\")\n  .exec();\n```\n\nIf the number of keys can't be determined when defining a command, you can\nomit the `numberOfKeys` property and pass the number of keys as the first argument\nwhen you call the command:\n\n```javascript\nredis.defineCommand(\"echoDynamicKeyNumber\", {\n  lua: \"return {KEYS[1],KEYS[2],ARGV[1],ARGV[2]}\"\n});\n\n// Now you have to pass the number of keys as the first argument every time\n// you invoke the `echoDynamicKeyNumber` command:\nredis.echoDynamicKeyNumber(2, \"k1\", \"k2\", \"a1\", \"a2\", function(err, result) {\n  // result === ['k1', 'k2', 'a1', 'a2']\n});\n```\n\n## Transparent Key Prefixing\n\nThis feature allows you to specify a string that will automatically be prepended\nto all the keys in a command, which makes it easier to manage your key\nnamespaces.\n\n**Warning** This feature won't apply to commands like [KEYS](http://redis.io/commands/KEYS) and [SCAN](http://redis.io/commands/scan) that take patterns rather than actual keys([#239](https://github.com/luin/ioredis/issues/239)),\nand this feature also won't apply to the replies of commands even they are key names ([#325](https://github.com/luin/ioredis/issues/325)).\n\n```javascript\nvar fooRedis = new Redis({ keyPrefix: \"foo:\" });\nfooRedis.set(\"bar\", \"baz\"); // Actually sends SET foo:bar baz\n\nfooRedis.defineCommand(\"echo\", {\n  numberOfKeys: 2,\n  lua: \"return {KEYS[1],KEYS[2],ARGV[1],ARGV[2]}\"\n});\n\n// Works well with pipelining/transaction\nfooRedis\n  .pipeline()\n  // Sends SORT foo:list BY foo:weight_*->fieldname\n  .sort(\"list\", \"BY\", \"weight_*->fieldname\")\n  // Supports custom commands\n  // Sends EVALSHA xxx foo:k1 foo:k2 a1 a2\n  .echo(\"k1\", \"k2\", \"a1\", \"a2\")\n  .exec();\n```\n\n## Transforming Arguments & Replies\n\nMost Redis commands take one or more Strings as arguments,\nand replies are sent back as a single String or an Array of Strings. However, sometimes\nyou may want something different. For instance, it would be more convenient if the `HGETALL`\ncommand returns a hash (e.g. `{ key: val1, key2: v2 }`) rather than an array of key values (e.g. `[key1, val1, key2, val2]`).\n\nioredis has a flexible system for transforming arguments and replies. There are two types\nof transformers, argument transformer and reply transformer:\n\n```javascript\nvar Redis = require(\"ioredis\");\n\n// Here's the built-in argument transformer converting\n// hmset('key', { k1: 'v1', k2: 'v2' })\n// or\n// hmset('key', new Map([['k1', 'v1'], ['k2', 'v2']]))\n// into\n// hmset('key', 'k1', 'v1', 'k2', 'v2')\nRedis.Command.setArgumentTransformer(\"hmset\", function(args) {\n  if (args.length === 2) {\n    if (typeof Map !== \"undefined\" && args[1] instanceof Map) {\n      // utils is a internal module of ioredis\n      return [args[0]].concat(utils.convertMapToArray(args[1]));\n    }\n    if (typeof args[1] === \"object\" && args[1] !== null) {\n      return [args[0]].concat(utils.convertObjectToArray(args[1]));\n    }\n  }\n  return args;\n});\n\n// Here's the built-in reply transformer converting the HGETALL reply\n// ['k1', 'v1', 'k2', 'v2']\n// into\n// { k1: 'v1', 'k2': 'v2' }\nRedis.Command.setReplyTransformer(\"hgetall\", function(result) {\n  if (Array.isArray(result)) {\n    var obj = {};\n    for (var i = 0; i < result.length; i += 2) {\n      obj[result[i]] = result[i + 1];\n    }\n    return obj;\n  }\n  return result;\n});\n```\n\nThere are three built-in transformers, two argument transformers for `hmset` & `mset` and\na reply transformer for `hgetall`. Transformers for `hmset` and `hgetall` were mentioned\nabove, and the transformer for `mset` is similar to the one for `hmset`:\n\n```javascript\nredis.mset({ k1: \"v1\", k2: \"v2\" });\nredis.get(\"k1\", function(err, result) {\n  // result === 'v1';\n});\n\nredis.mset(new Map([[\"k3\", \"v3\"], [\"k4\", \"v4\"]]));\nredis.get(\"k3\", function(err, result) {\n  // result === 'v3';\n});\n```\n\nAnother useful example of a reply transformer is one that changes `hgetall` to return array of arrays instead of objects which avoids a unwanted conversation of hash keys to strings when dealing with binary hash keys:\n\n```javascript\nRedis.Command.setReplyTransformer(\"hgetall\", function(result) {\n  var arr = [];\n  for (var i = 0; i < result.length; i += 2) {\n    arr.push([result[i], result[i + 1]]);\n  }\n  return arr;\n});\nredis.hset(\"h1\", Buffer.from([0x01]), Buffer.from([0x02]));\nredis.hset(\"h1\", Buffer.from([0x03]), Buffer.from([0x04]));\nredis.hgetallBuffer(\"h1\", function(err, result) {\n  // result === [ [ <Buffer 01>, <Buffer 02> ], [ <Buffer 03>, <Buffer 04> ] ];\n});\n```\n\n## Monitor\n\nRedis supports the MONITOR command,\nwhich lets you see all commands received by the Redis server across all client connections,\nincluding from other client libraries and other computers.\n\nThe `monitor` method returns a monitor instance.\nAfter you send the MONITOR command, no other commands are valid on that connection. ioredis will emit a monitor event for every new monitor message that comes across.\nThe callback for the monitor event takes a timestamp from the Redis server and an array of command arguments.\n\nHere is a simple example:\n\n```javascript\nredis.monitor(function(err, monitor) {\n  monitor.on(\"monitor\", function(time, args, source, database) {});\n});\n```\n\n## Streamify Scanning\n\nRedis 2.8 added the `SCAN` command to incrementally iterate through the keys in the database. It's different from `KEYS` in that\n`SCAN` only returns a small number of elements each call, so it can be used in production without the downside\nof blocking the server for a long time. However, it requires recording the cursor on the client side each time\nthe `SCAN` command is called in order to iterate through all the keys correctly. Since it's a relatively common use case, ioredis\nprovides a streaming interface for the `SCAN` command to make things much easier. A readable stream can be created by calling `scanStream`:\n\n```javascript\nvar redis = new Redis();\n// Create a readable stream (object mode)\nvar stream = redis.scanStream();\nstream.on(\"data\", function(resultKeys) {\n  // `resultKeys` is an array of strings representing key names.\n  // Note that resultKeys may contain 0 keys, and that it will sometimes\n  // contain duplicates due to SCAN's implementation in Redis.\n  for (var i = 0; i < resultKeys.length; i++) {\n    console.log(resultKeys[i]);\n  }\n});\nstream.on(\"end\", function() {\n  console.log(\"all keys have been visited\");\n});\n```\n\n`scanStream` accepts an option, with which you can specify the `MATCH` pattern and the `COUNT` argument:\n\n```javascript\nvar stream = redis.scanStream({\n  // only returns keys following the pattern of `user:*`\n  match: \"user:*\",\n  // returns approximately 100 elements per call\n  count: 100\n});\n```\n\nJust like other commands, `scanStream` has a binary version `scanBufferStream`, which returns an array of buffers. It's useful when\nthe key names are not utf8 strings.\n\nThere are also `hscanStream`, `zscanStream` and `sscanStream` to iterate through elements in a hash, zset and set. The interface of each is\nsimilar to `scanStream` except the first argument is the key name:\n\n```javascript\nvar stream = redis.hscanStream(\"myhash\", {\n  match: \"age:??\"\n});\n```\n\nYou can learn more from the [Redis documentation](http://redis.io/commands/scan).\n\n**Useful Tips**\nIt's pretty common that doing an async task in the `data` handler. We'd like the scanning process to be paused until the async task to be finished. `Stream#pause()` and `Stream.resume()` do the trick. For example if we want to migrate data in Redis to MySQL:\n\n```javascript\nvar stream = redis.scanStream();\nstream.on(\"data\", function(resultKeys) {\n  // Pause the stream from scanning more keys until we've migrated the current keys.\n  stream.pause();\n\n  Promise.all(resultKeys.map(migrateKeyToMySQL)).then(() => {\n    // Resume the stream here.\n    stream.resume();\n  });\n});\n\nstream.on(\"end\", function() {\n  console.log(\"done migration\");\n});\n```\n\n## Auto-reconnect\n\nBy default, ioredis will try to reconnect when the connection to Redis is lost\nexcept when the connection is closed manually by `redis.disconnect()` or `redis.quit()`.\n\nIt's very flexible to control how long to wait to reconnect after disconnection\nusing the `retryStrategy` option:\n\n```javascript\nvar redis = new Redis({\n  // This is the default value of `retryStrategy`\n  retryStrategy: function(times) {\n    var delay = Math.min(times * 50, 2000);\n    return delay;\n  }\n});\n```\n\n`retryStrategy` is a function that will be called when the connection is lost.\nThe argument `times` means this is the nth reconnection being made and\nthe return value represents how long (in ms) to wait to reconnect. When the\nreturn value isn't a number, ioredis will stop trying to reconnect, and the connection\nwill be lost forever if the user doesn't call `redis.connect()` manually.\n\nWhen reconnected, the client will auto subscribe to channels that the previous connection subscribed to.\nThis behavior can be disabled by setting the `autoResubscribe` option to `false`.\n\nAnd if the previous connection has some unfulfilled commands (most likely blocking commands such as `brpop` and `blpop`),\nthe client will resend them when reconnected. This behavior can be disabled by setting the `autoResendUnfulfilledCommands` option to `false`.\n\nBy default, all pending commands will be flushed with an error every 20 retry attempts. That makes sure commands won't wait forever when the connection is down. You can change this behavior by setting `maxRetriesPerRequest`:\n\n```javascript\nvar redis = new Redis({\n  maxRetriesPerRequest: 1\n});\n```\n\nSet maxRetriesPerRequest to `null` to disable this behavior, and every command will wait forever until the connection is alive again (which is the default behavior before ioredis v4).\n\n### Reconnect on error\n\nBesides auto-reconnect when the connection is closed, ioredis supports reconnecting on the specified errors by the `reconnectOnError` option. Here's an example that will reconnect when receiving `READONLY` error:\n\n```javascript\nvar redis = new Redis({\n  reconnectOnError: function(err) {\n    var targetError = \"READONLY\";\n    if (err.message.slice(0, targetError.length) === targetError) {\n      // Only reconnect when the error starts with \"READONLY\"\n      return true; // or `return 1;`\n    }\n  }\n});\n```\n\nThis feature is useful when using Amazon ElastiCache. Once failover happens, Amazon ElastiCache will switch the master we currently connected with to a slave, leading to the following writes fails with the error `READONLY`. Using `reconnectOnError`, we can force the connection to reconnect on this error in order to connect to the new master.\n\nFurthermore, if the `reconnectOnError` returns `2`, ioredis will resend the failed command after reconnecting.\n\n## Connection Events\n\nThe Redis instance will emit some events about the state of the connection to the Redis server.\n\n| Event        | Description                                                                                                                                                                                                                                     |\n| :----------- | :---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| connect      | emits when a connection is established to the Redis server.                                                                                                                                                                                     |\n| ready        | If `enableReadyCheck` is `true`, client will emit `ready` when the server reports that it is ready to receive commands (e.g. finish loading data from disk).<br>Otherwise, `ready` will be emitted immediately right after the `connect` event. |\n| error        | emits when an error occurs while connecting.<br>However, ioredis emits all `error` events silently (only emits when there's at least one listener) so that your application won't crash if you're not listening to the `error` event.           |\n| close        | emits when an established Redis server connection has closed.                                                                                                                                                                                   |\n| reconnecting | emits after `close` when a reconnection will be made. The argument of the event is the time (in ms) before reconnecting.                                                                                                                        |\n| end          | emits after `close` when no more reconnections will be made, or the connection is failed to establish.                                                                                                                                          |\n\nYou can also check out the `Redis#status` property to get the current connection status.\n\nBesides the above connection events, there are several other custom events:\n\n| Event  | Description                                                         |\n| :----- | :------------------------------------------------------------------ |\n| select | emits when the database changed. The argument is the new db number. |\n\n## Offline Queue\n\nWhen a command can't be processed by Redis (being sent before the `ready` event), by default, it's added to the offline queue and will be\nexecuted when it can be processed. You can disable this feature by setting the `enableOfflineQueue`\noption to `false`:\n\n```javascript\nvar redis = new Redis({ enableOfflineQueue: false });\n```\n\n## TLS Options\n\nRedis doesn't support TLS natively, however if the redis server you want to connect to is hosted behind a TLS proxy (e.g. [stunnel](https://www.stunnel.org/)) or is offered by a PaaS service that supports TLS connection (e.g. [Redis Labs](https://redislabs.com/)), you can set the `tls` option:\n\n```javascript\nvar redis = new Redis({\n  host: \"localhost\",\n  tls: {\n    // Refer to `tls.connect()` section in\n    // https://nodejs.org/api/tls.html\n    // for all supported options\n    ca: fs.readFileSync(\"cert.pem\")\n  }\n});\n```\n\n<hr>\n\n## Sentinel\n\nioredis supports Sentinel out of the box. It works transparently as all features that work when\nyou connect to a single node also work when you connect to a sentinel group. Make sure to run Redis >= 2.8.12 if you want to use this feature. Sentinels have a default port of 26379.\n\nTo connect using Sentinel, use:\n\n```javascript\nvar redis = new Redis({\n  sentinels: [\n    { host: \"localhost\", port: 26379 },\n    { host: \"localhost\", port: 26380 }\n  ],\n  name: \"mymaster\"\n});\n\nredis.set(\"foo\", \"bar\");\n```\n\nThe arguments passed to the constructor are different from the ones you use to connect to a single node, where:\n\n- `name` identifies a group of Redis instances composed of a master and one or more slaves (`mymaster` in the example);\n- `sentinelPassword` (optional) password for Sentinel instances.\n- `sentinels` are a list of sentinels to connect to. The list does not need to enumerate all your sentinel instances, but a few so that if one is down the client will try the next one.\n- `role` (optional) with a value of `slave` will return a random slave from the Sentinel group.\n- `preferredSlaves` (optional) can be used to prefer a particular slave or set of slaves based on priority. It accepts a function or array.\n\nioredis **guarantees** that the node you connected to is always a master even after a failover. When a failover happens, instead of trying to reconnect to the failed node (which will be demoted to slave when it's available again), ioredis will ask sentinels for the new master node and connect to it. All commands sent during the failover are queued and will be executed when the new connection is established so that none of the commands will be lost.\n\nIt's possible to connect to a slave instead of a master by specifying the option `role` with the value of `slave` and ioredis will try to connect to a random slave of the specified master, with the guarantee that the connected node is always a slave. If the current node is promoted to master due to a failover, ioredis will disconnect from it and ask the sentinels for another slave node to connect to.\n\nIf you specify the option `preferredSlaves` along with `role: 'slave'` ioredis will attempt to use this value when selecting the slave from the pool of available slaves. The value of `preferredSlaves` should either be a function that accepts an array of avaiable slaves and returns a single result, or an array of slave values priorities by the lowest `prio` value first with a default value of `1`.\n\n```javascript\n// available slaves format\nvar availableSlaves = [{ ip: \"127.0.0.1\", port: \"31231\", flags: \"slave\" }];\n\n// preferredSlaves array format\nvar preferredSlaves = [\n  { ip: \"127.0.0.1\", port: \"31231\", prio: 1 },\n  { ip: \"127.0.0.1\", port: \"31232\", prio: 2 }\n];\n\n// preferredSlaves function format\npreferredSlaves = function(availableSlaves) {\n  for (var i = 0; i < availableSlaves.length; i++) {\n    var slave = availableSlaves[i];\n    if (slave.ip === \"127.0.0.1\") {\n      if (slave.port === \"31234\") {\n        return slave;\n      }\n    }\n  }\n  // if no preferred slaves are available a random one is used\n  return false;\n};\n\nvar redis = new Redis({\n  sentinels: [\n    { host: \"127.0.0.1\", port: 26379 },\n    { host: \"127.0.0.1\", port: 26380 }\n  ],\n  name: \"mymaster\",\n  role: \"slave\",\n  preferredSlaves: preferredSlaves\n});\n```\n\nBesides the `retryStrategy` option, there's also a `sentinelRetryStrategy` in Sentinel mode which will be invoked when all the sentinel nodes are unreachable during connecting. If `sentinelRetryStrategy` returns a valid delay time, ioredis will try to reconnect from scratch. The default value of `sentinelRetryStrategy` is:\n\n```javascript\nfunction (times) {\n  var delay = Math.min(times * 10, 1000);\n  return delay;\n}\n```\n\n## Cluster\n\nRedis Cluster provides a way to run a Redis installation where data is automatically sharded across multiple Redis nodes.\nYou can connect to a Redis Cluster like this:\n\n```javascript\nvar Redis = require(\"ioredis\");\n\nvar cluster = new Redis.Cluster([\n  {\n    port: 6380,\n    host: \"127.0.0.1\"\n  },\n  {\n    port: 6381,\n    host: \"127.0.0.1\"\n  }\n]);\n\ncluster.set(\"foo\", \"bar\");\ncluster.get(\"foo\", function(err, res) {\n  // res === 'bar'\n});\n```\n\n`Cluster` constructor accepts two arguments, where:\n\n0.  The first argument is a list of nodes of the cluster you want to connect to.\n    Just like Sentinel, the list does not need to enumerate all your cluster nodes,\n    but a few so that if one is unreachable the client will try the next one, and the client will discover other nodes automatically when at least one node is connected.\n1.  The second argument is the options, where:\n\n    - `clusterRetryStrategy`: When none of the startup nodes are reachable, `clusterRetryStrategy` will be invoked. When a number is returned,\n      ioredis will try to reconnect to the startup nodes from scratch after the specified delay (in ms). Otherwise, an error of \"None of startup nodes is available\" will be returned.\n      The default value of this option is:\n\n          ```javascript\n          function (times) {\n            var delay = Math.min(100 + times * 2, 2000);\n            return delay;\n          }\n          ```\n\n          It's possible to modify the `startupNodes` property in order to switch to another set of nodes here:\n\n          ```javascript\n          function (times) {\n            this.startupNodes = [{ port: 6790, host: '127.0.0.1' }];\n            return Math.min(100 + times * 2, 2000);\n          }\n          ```\n\n    - `dnsLookup`: Alternative DNS lookup function (`dns.lookup()` is used by default). It may be useful to override this in special cases, such as when AWS ElastiCache used with TLS enabled.\n    - `enableOfflineQueue`: Similar to the `enableOfflineQueue` option of `Redis` class.\n    - `enableReadyCheck`: When enabled, \"ready\" event will only be emitted when `CLUSTER INFO` command\n      reporting the cluster is ready for handling commands. Otherwise, it will be emitted immediately after \"connect\" is emitted.\n    - `scaleReads`: Config where to send the read queries. See below for more details.\n    - `maxRedirections`: When a cluster related error (e.g. `MOVED`, `ASK` and `CLUSTERDOWN` etc.) is received, the client will redirect the\n      command to another node. This option limits the max redirections allowed when sending a command. The default value is `16`.\n    - `retryDelayOnFailover`: If the target node is disconnected when sending a command,\n      ioredis will retry after the specified delay. The default value is `100`. You should make sure `retryDelayOnFailover * maxRedirections > cluster-node-timeout`\n      to insure that no command will fail during a failover.\n    - `retryDelayOnClusterDown`: When a cluster is down, all commands will be rejected with the error of `CLUSTERDOWN`. If this option is a number (by default, it is `100`), the client\n      will resend the commands after the specified time (in ms).\n    - `retryDelayOnTryAgain`: If this option is a number (by default, it is `100`), the client\n      will resend the commands rejected with `TRYAGAIN` error after the specified time (in ms).\n    - `redisOptions`: Default options passed to the constructor of `Redis` when connecting to a node.\n    - `slotsRefreshTimeout`: Milliseconds before a timeout occurs while refreshing slots from the cluster (default `1000`)\n    - `slotsRefreshInterval`: Milliseconds between every automatic slots refresh (default `5000`)\n\n### Read-write splitting\n\nA typical redis cluster contains three or more masters and several slaves for each master. It's possible to scale out redis cluster by sending read queries to slaves and write queries to masters by setting the `scaleReads` option.\n\n`scaleReads` is \"master\" by default, which means ioredis will never send any queries to slaves. There are other three available options:\n\n1. \"all\": Send write queries to masters and read queries to masters or slaves randomly.\n2. \"slave\": Send write queries to masters and read queries to slaves.\n3. a custom `function(nodes, command): node`: Will choose the custom function to select to which node to send read queries (write queries keep being sent to master). The first node in `nodes` is always the master serving the relevant slots. If the function returns an array of nodes, a random node of that list will be selected.\n\nFor example:\n\n```javascript\nvar cluster = new Redis.Cluster(\n  [\n    /* nodes */\n  ],\n  {\n    scaleReads: \"slave\"\n  }\n);\ncluster.set(\"foo\", \"bar\"); // This query will be sent to one of the masters.\ncluster.get(\"foo\", function(err, res) {\n  // This query will be sent to one of the slaves.\n});\n```\n\n**NB** In the code snippet above, the `res` may not be equal to \"bar\" because of the lag of replication between the master and slaves.\n\n### Running commands to multiple nodes\n\nEvery command will be sent to exactly one node. For commands containing keys, (e.g. `GET`, `SET` and `HGETALL`), ioredis sends them to the node that serving the keys, and for other commands not containing keys, (e.g. `INFO`, `KEYS` and `FLUSHDB`), ioredis sends them to a random node.\n\nSometimes you may want to send a command to multiple nodes (masters or slaves) of the cluster, you can get the nodes via `Cluster#nodes()` method.\n\n`Cluster#nodes()` accepts a parameter role, which can be \"master\", \"slave\" and \"all\" (default), and returns an array of `Redis` instance. For example:\n\n```javascript\n// Send `FLUSHDB` command to all slaves:\nvar slaves = cluster.nodes(\"slave\");\nPromise.all(\n  slaves.map(function(node) {\n    return node.flushdb();\n  })\n);\n\n// Get keys of all the masters:\nvar masters = cluster.nodes(\"master\");\nPromise.all(\n  masters.map(function(node) {\n    return node.keys();\n  })\n).then(function(keys) {\n  // keys: [['key1', 'key2'], ['key3', 'key4']]\n});\n```\n\n### NAT Mapping\n\nSometimes the cluster is hosted within a internal network that can only be accessed via a NAT (Network Address Translation) instance. See [Accessing ElastiCache from outside AWS](https://docs.aws.amazon.com/AmazonElastiCache/latest/red-ug/accessing-elasticache.html) as an example.\n\nYou can specify nat mapping rules via `natMap` option:\n\n```javascript\nconst cluster = new Redis.Cluster(\n  [\n    {\n      host: \"203.0.113.73\",\n      port: 30001\n    }\n  ],\n  {\n    natMap: {\n      \"10.0.1.230:30001\": { host: \"203.0.113.73\", port: 30001 },\n      \"10.0.1.231:30001\": { host: \"203.0.113.73\", port: 30002 },\n      \"10.0.1.232:30001\": { host: \"203.0.113.73\", port: 30003 }\n    }\n  }\n);\n```\n\nThis option is also useful when the cluster is running inside a Docker container.\n\n### Transaction and pipeline in Cluster mode\n\nAlmost all features that are supported by `Redis` are also supported by `Redis.Cluster`, e.g. custom commands, transaction and pipeline.\nHowever there are some differences when using transaction and pipeline in Cluster mode:\n\n0. All keys in a pipeline should belong to the same slot since ioredis sends all commands in a pipeline to the same node.\n1. You can't use `multi` without pipeline (aka `cluster.multi({ pipeline: false })`). This is because when you call `cluster.multi({ pipeline: false })`, ioredis doesn't know which node the `multi` command should be sent to.\n2. Chaining custom commands in the pipeline is not supported in Cluster mode.\n\nWhen any commands in a pipeline receives a `MOVED` or `ASK` error, ioredis will resend the whole pipeline to the specified node automatically if all of the following conditions are satisfied:\n\n0. All errors received in the pipeline are the same. For example, we won't resend the pipeline if we got two `MOVED` errors pointing to different nodes.\n1. All commands executed successfully are readonly commands. This makes sure that resending the pipeline won't have side effects.\n\n### Pub/Sub\n\nPub/Sub in cluster mode works exactly as the same as in standalone mode. Internally, when a node of the cluster receives a message, it will broadcast the message to the other nodes. ioredis makes sure that each message will only be received once by strictly subscribing one node at the same time.\n\n```javascript\nvar nodes = [\n  /* nodes */\n];\nvar pub = new Redis.Cluster(nodes);\nvar sub = new Redis.Cluster(nodes);\nsub.on(\"message\", function(channel, message) {\n  console.log(channel, message);\n});\n\nsub.subscribe(\"news\", function() {\n  pub.publish(\"news\", \"highlights\");\n});\n```\n\n### Events\n\n| Event        | Description                                                                                                                                                                                                |\n| :----------- | :--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| connect      | emits when a connection is established to the Redis server.                                                                                                                                                |\n| ready        | emits when `CLUSTER INFO` reporting the cluster is able to receive commands (if `enableReadyCheck` is `true`) or immediately after `connect` event (if `enableReadyCheck` is false).                       |\n| error        | emits when an error occurs while connecting with a property of `lastNodeError` representing the last node error received. This event is emitted silently (only emitting if there's at least one listener). |\n| close        | emits when an established Redis server connection has closed.                                                                                                                                              |\n| reconnecting | emits after `close` when a reconnection will be made. The argument of the event is the time (in ms) before reconnecting.                                                                                   |\n| end          | emits after `close` when no more reconnections will be made.                                                                                                                                               |\n| +node        | emits when a new node is connected.                                                                                                                                                                        |\n| -node        | emits when a node is disconnected.                                                                                                                                                                         |\n| node error   | emits when an error occurs when connecting to a node. The second argument indicates the address of the node.                                                                                               |\n\n### Password\n\nSetting the `password` option to access password-protected clusters:\n\n```javascript\nvar Redis = require(\"ioredis\");\nvar cluster = new Redis.Cluster(nodes, {\n  redisOptions: {\n    password: \"your-cluster-password\"\n  }\n});\n```\n\nIf some of nodes in the cluster using a different password, you should specify them in the first parameter:\n\n```javascript\nvar Redis = require(\"ioredis\");\nvar cluster = new Redis.Cluster(\n  [\n    // Use password \"password-for-30001\" for 30001\n    { port: 30001, password: \"password-for-30001\" },\n    // Don't use password when accessing 30002\n    { port: 30002, password: null }\n    // Other nodes will use \"fallback-password\"\n  ],\n  {\n    redisOptions: {\n      password: \"fallback-password\"\n    }\n  }\n);\n```\n\n### Special note: AWS ElastiCache Clusters with TLS\n\nAWS ElastiCache for Redis (Clustered Mode) supports TLS encryption. If you use\nthis, you may encounter errors with invalid certificates. To resolve this\nissue, construct the `Cluster` with the `dnsLookup` option as follows:\n\n```javascript\nvar cluster = new Redis.Cluster(\n  [{\n    host: 'clustercfg.myCluster.abcdefg.xyz.cache.amazonaws.com',\n    port: 6379\n  }],\n  {\n    dnsLookup: (address, callback) => callback(null, address),\n    redisOptions: {\n      tls: {}\n    },\n  }\n};\n```\n\n<hr>\n\n# Error Handling\n\nAll the errors returned by the Redis server are instances of `ReplyError`, which can be accessed via `Redis`:\n\n```javascript\nvar Redis = require(\"ioredis\");\nvar redis = new Redis();\n// This command causes a reply error since the SET command requires two arguments.\nredis.set(\"foo\", function(err) {\n  err instanceof Redis.ReplyError;\n});\n```\n\nThis is the error stack of the `ReplyError`:\n\n```\nReplyError: ERR wrong number of arguments for 'set' command\n    at ReplyParser._parseResult (/app/node_modules/ioredis/lib/parsers/javascript.js:60:14)\n    at ReplyParser.execute (/app/node_modules/ioredis/lib/parsers/javascript.js:178:20)\n    at Socket.<anonymous> (/app/node_modules/ioredis/lib/redis/event_handler.js:99:22)\n    at Socket.emit (events.js:97:17)\n    at readableAddChunk (_stream_readable.js:143:16)\n    at Socket.Readable.push (_stream_readable.js:106:10)\n    at TCP.onread (net.js:509:20)\n```\n\nBy default, the error stack doesn't make any sense because the whole stack happens in the ioredis\nmodule itself, not in your code. So it's not easy to find out where the error happens in your code.\nioredis provides an option `showFriendlyErrorStack` to solve the problem. When you enable\n`showFriendlyErrorStack`, ioredis will optimize the error stack for you:\n\n```javascript\nvar Redis = require(\"ioredis\");\nvar redis = new Redis({ showFriendlyErrorStack: true });\nredis.set(\"foo\");\n```\n\nAnd the output will be:\n\n```\nReplyError: ERR wrong number of arguments for 'set' command\n    at Object.<anonymous> (/app/index.js:3:7)\n    at Module._compile (module.js:446:26)\n    at Object.Module._extensions..js (module.js:464:10)\n    at Module.load (module.js:341:32)\n    at Function.Module._load (module.js:296:12)\n    at Function.Module.runMain (module.js:487:10)\n    at startup (node.js:111:16)\n    at node.js:799:3\n```\n\nThis time the stack tells you that the error happens on the third line in your code. Pretty sweet!\nHowever, it would decrease the performance significantly to optimize the error stack. So by\ndefault, this option is disabled and can only be used for debugging purposes. You **shouldn't** use this feature in a production environment.\n\n# Plugging in your own Promises Library\n\nIf you're an advanced user, you may want to plug in your own promise library like [bluebird](https://www.npmjs.com/package/bluebird). Just set Redis.Promise to your favorite ES6-style promise constructor and ioredis will use it.\n\n```javascript\nconst Redis = require(\"ioredis\");\nRedis.Promise = require(\"bluebird\");\n\nconst redis = new Redis();\n\n// Use bluebird\nassert.equal(redis.get().constructor, require(\"bluebird\"));\n\n// You can change the Promise implementation at any time:\nRedis.Promise = global.Promise;\nassert.equal(redis.get().constructor, global.Promise);\n```\n\n# Running tests\n\nStart a Redis server on 127.0.0.1:6379, and then:\n\n```shell\n$ npm test\n```\n\n`FLUSH ALL` will be invoked after each test, so make sure there's no valuable data in it before running tests.\n\nIf your testing environment does not let you spin up a Redis server [ioredis-mock](https://github.com/stipsan/ioredis-mock) is a drop-in replacement you can use in your tests. It aims to behave identically to ioredis connected to a Redis server so that your integration tests is easier to write and of better quality.\n\n# Debug\n\nYou can set the `DEBUG` env to `ioredis:*` to print debug info:\n\n```shell\n$ DEBUG=ioredis:* node app.js\n```\n\n# Join in!\n\nI'm happy to receive bug reports, fixes, documentation enhancements, and any other improvements.\n\nAnd since I'm not a native English speaker, if you find any grammar mistakes in the documentation, please also let me know. :)\n\n# Become a Sponsor\n\nOpen source is hard and time-consuming. If you want to invest in ioredis's future you can become a sponsor and make us spend more time on this library's improvements and new features.\n\n<a href=\"https://opencollective.com/ioredis\"><img src=\"https://opencollective.com/ioredis/tiers/sponsor.svg?avatarHeight=36\"></a>\n\nThank you for using ioredis :-)\n\n# Contributors\n\nThis project exists thanks to all the people who contribute:\n\n<a href=\"https://github.com/luin/ioredis/graphs/contributors\"><img src=\"https://opencollective.com/ioredis/contributors.svg?width=890&showBtn=false\" /></a>\n\n# License\n\nMIT\n\n[![FOSSA Status](https://app.fossa.io/api/projects/git%2Bgithub.com%2Fluin%2Fioredis.svg?type=large)](https://app.fossa.io/projects/git%2Bgithub.com%2Fluin%2Fioredis?ref=badge_large)\n","readmeFilename":"README.md","bugs":{"url":"https://github.com/luin/ioredis/issues"},"homepage":"https://github.com/luin/ioredis#readme","_id":"ioredis@4.13.1","_nodeVersion":"10.16.0","_npmVersion":"6.9.0","dist":{"integrity":"sha512-AsfcOmo+imI4pt2Jd5c6NWGYYKrmoWZIN972xeTwMqqSSbdOxWoSXHyaDDMhDbX7aGDwqN19z6i5e1J6wSJhsQ==","shasum":"09b3eebc0cbf38a62960da7f5fe5e6e5f1cdfec2","tarball":"https://registry.npmjs.org/ioredis/-/ioredis-4.13.1.tgz","fileCount":36,"unpackedSize":238329,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJdNUSjCRA9TVsSAnZWagAAC8EQAKSOWyBtN1FYjYEsdz6Z\nPeky2CvSI8RJqmxhUGLi9PKY2JoT/8V680xi1jVu8b6V7xkQgpj+IPiEqhEa\nNkfXjMqsdFkYMrGDiuI4/GFE5OUKmMlOX41lZh/bJawK5X4BphnzuSQTLcj8\nu0WPU5xgVevruUgczW971oRoj9kS+BHu2T1oRDSA63gJQREiQqdyzhqFPAFZ\nrMaMZfcahxt4GgGo5QsPIGzBkBds8p+gL4UIo9g6PH4/3JjJPrekVGtXf3cp\ncY9Nl7+7tnRaB4HfJNdPMaIl3I35BcttERk6kPLWs2rWoaB/1zYDB20ihFbO\naop/FWisEb3aObyBtNLjdmvPeoC0iH1f/SRi2cHIZgXseCPljQcOKl+74f9m\nkQrjmQNarMykpi+suw497u8LnywTyagrlsRiPGvr+TMkChN6xFvQupKqbej4\n4GF97AS+uXElYXG0Tio0oiv622oylLXFy5RVBF/c1UI+usbPHpBRI9MfxN+T\nzi2ZX5V9QqNZ8p7em6BM2/QV8ur0nuvtNs6qQ61cMdVSvTOBbHRjNmIF0vwx\n41QK8vNdYhXiG806gdIKq9Lzki865qb/TsWhGAZEXhOno5D/y8DFCRP2gigW\nZX6dUJnPqQiluW+pFRP7s0VpVTwWd0PbU9WjZPZxVynMx5H/Foy3eViMsDIu\nmVx4\r\n=p6xc\r\n-----END PGP SIGNATURE-----\r\n"},"maintainers":[{"email":"ioredis-robot@zihua.li","name":"ioredis-robot"},{"email":"i@zihua.li","name":"luin"}],"_npmUser":{"name":"luin","email":"i@zihua.li"},"directories":{},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/ioredis_4.13.1_1563772066871_0.13987673174314175"},"_hasShrinkwrap":false},"4.14.0":{"name":"ioredis","version":"4.14.0","description":"A robust, performance-focused and full-featured Redis client for Node.js.","main":"built/index.js","scripts":{"test":"TS_NODE_TRANSPILE_ONLY=true TS_NODE_LOG_ERROR=true NODE_ENV=test mocha \"test/**/*.ts\"","test:cov":"TS_NODE_TRANSPILE_ONLY=true TS_NODE_LOG_ERROR=true NODE_ENV=test node ./node_modules/istanbul/lib/cli.js cover --preserve-comments ./node_modules/mocha/bin/_mocha -- -r ts-node/register -R spec --exit \"test/**/*.ts\"","lint":"eslint --ext .js,.ts .","format":"prettier --write \"{,!(node_modules)/**/}*.{js,ts}\"","format-check":"prettier --check \"{,!(node_modules)/**/}*.{js,ts}\"","build":"rm -rf built && tsc","prepublishOnly":"npm run build && npm test","bench":"matcha benchmarks/*.js","semantic-release":"semantic-release"},"repository":{"type":"git","url":"git://github.com/luin/ioredis.git"},"keywords":["redis","cluster","sentinel","pipelining"],"author":{"name":"luin","email":"i@zihua.li","url":"http://zihua.li"},"license":"MIT","dependencies":{"cluster-key-slot":"^1.1.0","debug":"^4.1.1","denque":"^1.1.0","lodash.defaults":"^4.2.0","lodash.flatten":"^4.4.0","redis-commands":"1.5.0","redis-errors":"^1.2.0","redis-parser":"^3.0.0","standard-as-callback":"^2.0.1"},"devDependencies":{"@semantic-release/changelog":"^3.0.4","@semantic-release/git":"^7.0.12","@types/bluebird":"^3.5.27","@types/chai":"^4.1.7","@types/debug":"^4.1.4","@types/lodash.defaults":"^4.2.6","@types/lodash.flatten":"^4.4.6","@types/mocha":"^5.2.7","@types/node":"^12.0.2","@types/redis-errors":"1.2.0","@types/sinon":"^7.0.13","@typescript-eslint/eslint-plugin":"^1.11.0","@typescript-eslint/parser":"^1.11.0","bluebird":"^3.5.4","chai":"^4.2.0","cz-conventional-changelog":"^2.0.0","eslint":"^5.16.0","eslint-config-prettier":"^5.1.0","husky":"^2.5.0","istanbul":"^0.4.5","mocha":"^5.0.0","prettier":"^1.18.2","pretty-quick":"^1.11.1","server-destroy":"^1.0.1","sinon":"^7.3.2","ts-node":"^8.1.0","typescript":"^3.5.1"},"engines":{"node":">=6"},"config":{"commitizen":{"path":"./node_modules/cz-conventional-changelog"}},"husky":{"hooks":{"pre-commit":"pretty-quick --staged"}},"gitHead":"c1f0d037c4ae61540b18d23d95417f136b02ffa3","bugs":{"url":"https://github.com/luin/ioredis/issues"},"homepage":"https://github.com/luin/ioredis#readme","_id":"ioredis@4.14.0","_nodeVersion":"10.16.0","_npmVersion":"6.9.0","dist":{"integrity":"sha512-vGzyW9QTdGMjaAPUhMj48Z31mIO5qJLzkbsE5dg+orNi7L5Ph035htmkBZNDTDdDk7kp7e9UJUr+alhRuaWp8g==","shasum":"d0e83b1d308ca1ba6e849798bfe91583b560eaac","tarball":"https://registry.npmjs.org/ioredis/-/ioredis-4.14.0.tgz","fileCount":36,"unpackedSize":239024,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJdQRk7CRA9TVsSAnZWagAAmb0P/0MWw/7N6uFp0BgQyB3s\nWgCb/My7lDjvpGHNB5pLREtPGSVglBDtcyCVwUsvGX0v+3Be+UR6wj1lmN2N\njGJ9wFQCsoZWBjK8RwkMeUKEUSlIDj1fvzhXOtVXfRpa8JKcy5axouOm88EO\nKQ8KaVPHYXmhSLRtLsmi9seNHSvUGtsZaa/oMDCFKj/y+51DgImelpaSnVmD\nDVOX0PFuSwfMC0CpTOL9GgDBcUWVxhytYzvfH3tI3/RwVF+mvSDelxqvv/jC\nKBWIRK+g8zqTOU041JKt4COYWYu5OE1wrudQrOikWRVfaDkjbVIG6QnAp9cD\nejDfaevoXLanAg6bptTFtt01BsuP+/4sjh7RyKrv1rCvYDUgl+920q31e4NX\n98ISEXm2w3a0yytsqXkkKw8WjwPKKdR8hVy8lbWl39NYgWIguXq3AjOAWIqX\nUKLSwxweifBaXnSaB8uNPc1uyWkeiozZvg3Li/mu8NvCXH153Vwg2RZiX18L\nqxte/tQDK5XAmhIi2C642oaR1DdgLl5w+FNARnBP2ExBp9+akEqbfMmj39yL\nvx+JQ3YvxDVsO+6+SGUouHtHm0jDurQtzdKP7+p5BH9pTzLnOXx6v5U00hq9\ngt79C6todrlemIvreQCKdRSso/XR9aKgq1PyRdeHoS0GLr0JqoMq2pfeUr6Q\noGsh\r\n=OTx4\r\n-----END PGP SIGNATURE-----\r\n"},"maintainers":[{"email":"ioredis-robot@zihua.li","name":"ioredis-robot"},{"email":"i@zihua.li","name":"luin"}],"_npmUser":{"name":"luin","email":"i@zihua.li"},"directories":{},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/ioredis_4.14.0_1564547386411_0.8995506111196299"},"_hasShrinkwrap":false},"4.14.1":{"name":"ioredis","version":"4.14.1","description":"A robust, performance-focused and full-featured Redis client for Node.js.","main":"built/index.js","scripts":{"test":"TS_NODE_TRANSPILE_ONLY=true TS_NODE_LOG_ERROR=true NODE_ENV=test mocha \"test/**/*.ts\"","test:cov":"TS_NODE_TRANSPILE_ONLY=true TS_NODE_LOG_ERROR=true NODE_ENV=test node ./node_modules/istanbul/lib/cli.js cover --preserve-comments ./node_modules/mocha/bin/_mocha -- -r ts-node/register -R spec --exit \"test/**/*.ts\"","lint":"eslint --ext .js,.ts .","format":"prettier --write \"{,!(node_modules)/**/}*.{js,ts}\"","format-check":"prettier --check \"{,!(node_modules)/**/}*.{js,ts}\"","build":"rm -rf built && tsc","prepublishOnly":"npm run build && npm test","bench":"matcha benchmarks/*.js","semantic-release":"semantic-release"},"repository":{"type":"git","url":"git://github.com/luin/ioredis.git"},"keywords":["redis","cluster","sentinel","pipelining"],"author":{"name":"luin","email":"i@zihua.li","url":"http://zihua.li"},"license":"MIT","dependencies":{"cluster-key-slot":"^1.1.0","debug":"^4.1.1","denque":"^1.1.0","lodash.defaults":"^4.2.0","lodash.flatten":"^4.4.0","redis-commands":"1.5.0","redis-errors":"^1.2.0","redis-parser":"^3.0.0","standard-as-callback":"^2.0.1"},"devDependencies":{"@semantic-release/changelog":"^3.0.4","@semantic-release/git":"^7.0.12","@types/bluebird":"^3.5.27","@types/chai":"^4.1.7","@types/debug":"^4.1.4","@types/lodash.defaults":"^4.2.6","@types/lodash.flatten":"^4.4.6","@types/mocha":"^5.2.7","@types/node":"^12.0.2","@types/redis-errors":"1.2.0","@types/sinon":"^7.0.13","@typescript-eslint/eslint-plugin":"^1.11.0","@typescript-eslint/parser":"^1.11.0","bluebird":"^3.5.4","chai":"^4.2.0","cz-conventional-changelog":"^2.0.0","eslint":"^5.16.0","eslint-config-prettier":"^5.1.0","husky":"^2.5.0","istanbul":"^0.4.5","mocha":"^5.0.0","prettier":"^1.18.2","pretty-quick":"^1.11.1","server-destroy":"^1.0.1","sinon":"^7.3.2","ts-node":"^8.1.0","typescript":"^3.5.1"},"engines":{"node":">=6"},"config":{"commitizen":{"path":"./node_modules/cz-conventional-changelog"}},"husky":{"hooks":{"pre-commit":"pretty-quick --staged"}},"gitHead":"1baff479b2abfb1cba73e84ce514b3330b2b0993","bugs":{"url":"https://github.com/luin/ioredis/issues"},"homepage":"https://github.com/luin/ioredis#readme","_id":"ioredis@4.14.1","_nodeVersion":"10.16.3","_npmVersion":"6.9.0","dist":{"integrity":"sha512-94W+X//GHM+1GJvDk6JPc+8qlM7Dul+9K+lg3/aHixPN7ZGkW6qlvX0DG6At9hWtH2v3B32myfZqWoANUJYGJA==","shasum":"b73ded95fcf220f106d33125a92ef6213aa31318","tarball":"https://registry.npmjs.org/ioredis/-/ioredis-4.14.1.tgz","fileCount":36,"unpackedSize":239629,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJdZJjrCRA9TVsSAnZWagAAooUP/iwXxBU063rNiYpO/hqj\nVt4QNNNuM52HZuaTX+MAVlepa4GJPoZQOtbMTwcYhlOSIXNOszsxi1jHXicc\nAklUWHCa3rL6iiM1czgGyoVHMeqBQ+hawnwMdqmqGRY0sfP/WQWwi+ZIW7s1\nwyto07YE448lwZ8MKdYdO053vkJbM8BQzrvM6Gngcjpf4O1HPnGB8OSpp2HA\nshQs+hnKK2A80jnXc7+yhn30Ko3UecdBRBLo4Ns6TD6hy6zWRSxQX8w6g/zs\nZ9mv0iTlqKxRyzGN+1NmtwfIYLeFg7kbgspUQP0zRPkxZ+PESqdQIkYcKkj6\nrHXKxps1yMa1sOR36we8gMV++iJNY+yvqkwTu9OwB2Lj7Z+89WXX4fNrisZy\nnysbSVTThwutCVjfcRcaEu547rTH6YH2M9PGwh4hx4rz/yCAZ2m9Tzc2S9oR\ntGscwWcbzcOYZv9FyTClDwJG4cLr9mAQUvsGU2TVrN+JJ3xOVrJbyO+/8hxJ\nP+Y5R/U9FDDpROsF230qXMGEXbKq7ik2NZC1WggsU1YvJ/3mS0pmya3D7NY2\nyzHsDHUbWfJuPD0zMaE4w9zSPne1Yxm61dI0rrFLT+VRiHEySgOjpgaeYbo9\nv/aOdxfFwN21T5bLk/cevER56sSZ9H+/54Glm4KDcIbiKKkgrJhmVoL/hze9\nPuOV\r\n=PEde\r\n-----END PGP SIGNATURE-----\r\n"},"maintainers":[{"email":"ioredis-robot@zihua.li","name":"ioredis-robot"},{"email":"i@zihua.li","name":"luin"}],"_npmUser":{"name":"luin","email":"i@zihua.li"},"directories":{},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/ioredis_4.14.1_1566873834932_0.020175407670396384"},"_hasShrinkwrap":false},"4.14.2":{"name":"ioredis","version":"4.14.2","description":"A robust, performance-focused and full-featured Redis client for Node.js.","main":"built/index.js","scripts":{"test":"TS_NODE_TRANSPILE_ONLY=true TS_NODE_LOG_ERROR=true NODE_ENV=test mocha \"test/**/*.ts\"","test:cov":"TS_NODE_TRANSPILE_ONLY=true TS_NODE_LOG_ERROR=true NODE_ENV=test node ./node_modules/istanbul/lib/cli.js cover --preserve-comments ./node_modules/mocha/bin/_mocha -- -r ts-node/register -R spec --exit \"test/**/*.ts\"","lint":"eslint --ext .js,.ts .","format":"prettier --write \"{,!(node_modules)/**/}*.{js,ts}\"","format-check":"prettier --check \"{,!(node_modules)/**/}*.{js,ts}\"","build":"rm -rf built && tsc","prepublishOnly":"npm run build && npm test","bench":"matcha benchmarks/*.js","semantic-release":"semantic-release"},"repository":{"type":"git","url":"git://github.com/luin/ioredis.git"},"keywords":["redis","cluster","sentinel","pipelining"],"author":{"name":"luin","email":"i@zihua.li","url":"http://zihua.li"},"license":"MIT","dependencies":{"cluster-key-slot":"^1.1.0","debug":"^4.1.1","denque":"^1.1.0","lodash.defaults":"^4.2.0","lodash.flatten":"^4.4.0","redis-commands":"1.5.0","redis-errors":"^1.2.0","redis-parser":"^3.0.0","standard-as-callback":"^2.0.1"},"devDependencies":{"@semantic-release/changelog":"^3.0.4","@semantic-release/git":"^7.0.12","@types/bluebird":"^3.5.27","@types/chai":"^4.1.7","@types/debug":"^4.1.4","@types/lodash.defaults":"^4.2.6","@types/lodash.flatten":"^4.4.6","@types/mocha":"^5.2.7","@types/node":"^12.0.2","@types/redis-errors":"1.2.0","@types/sinon":"^7.0.13","@typescript-eslint/eslint-plugin":"^1.11.0","@typescript-eslint/parser":"^1.11.0","bluebird":"^3.5.4","chai":"^4.2.0","cz-conventional-changelog":"^2.0.0","eslint":"^5.16.0","eslint-config-prettier":"^5.1.0","husky":"^2.5.0","istanbul":"^0.4.5","mocha":"^5.0.0","prettier":"^1.18.2","pretty-quick":"^1.11.1","server-destroy":"^1.0.1","sinon":"^7.3.2","ts-node":"^8.1.0","typescript":"^3.5.1"},"engines":{"node":">=6"},"config":{"commitizen":{"path":"./node_modules/cz-conventional-changelog"}},"husky":{"hooks":{"pre-commit":"pretty-quick --staged"}},"gitHead":"b0dcf196bc46413c6a7f9813d0e069fe4837161c","readme":"[![ioredis](https://cdn.jsdelivr.net/gh/luin/ioredis@b5e8c74/logo.svg)](https://github.com/luin/ioredis)\n\n[![Build Status](https://travis-ci.org/luin/ioredis.svg?branch=master)](https://travis-ci.org/luin/ioredis)\n[![Test Coverage](https://codeclimate.com/github/luin/ioredis/badges/coverage.svg)](https://codeclimate.com/github/luin/ioredis)\n[![code style: prettier](https://img.shields.io/badge/code_style-prettier-ff69b4.svg?style=flat-square)](https://github.com/prettier/prettier)\n[![Join the chat at https://gitter.im/luin/ioredis](https://badges.gitter.im/Join%20Chat.svg)](https://gitter.im/luin/ioredis?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge)\n[![Commitizen friendly](https://img.shields.io/badge/commitizen-friendly-brightgreen.svg)](http://commitizen.github.io/cz-cli/)\n[![semantic-release](https://img.shields.io/badge/%20%20%F0%9F%93%A6%F0%9F%9A%80-semantic--release-e10079.svg)](https://github.com/semantic-release/semantic-release)\n[![npm latest version](https://img.shields.io/npm/v/ioredis/latest.svg)](https://www.npmjs.com/package/ioredis)\n[![npm next version](https://img.shields.io/npm/v/ioredis/next.svg)](https://www.npmjs.com/package/ioredis)\n<img alt=\"\" src=\"\">\n\nA robust, performance-focused and full-featured [Redis](http://redis.io) client for [Node.js](https://nodejs.org).\n\nSupports Redis >= 2.6.12 and (Node.js >= 6).\n\n# Features\n\nioredis is a robust, full-featured Redis client that is\nused in the world's biggest online commerce company [Alibaba](http://www.alibaba.com/) and many other awesome companies.\n\n0. Full-featured. It supports [Cluster](http://redis.io/topics/cluster-tutorial), [Sentinel](http://redis.io/topics/sentinel), [Pipelining](http://redis.io/topics/pipelining) and of course [Lua scripting](http://redis.io/commands/eval) & [Pub/Sub](http://redis.io/topics/pubsub) (with the support of binary messages).\n1. High performance.\n2. Delightful API. It works with Node callbacks and Native promises.\n3. Transformation of command arguments and replies.\n4. Transparent key prefixing.\n5. Abstraction for Lua scripting, allowing you to define custom commands.\n6. Support for binary data.\n7. Support for TLS.\n8. Support for offline queue and ready checking.\n9. Support for ES6 types, such as `Map` and `Set`.\n10. Support for GEO commands (Redis 3.2 Unstable).\n11. Sophisticated error handling strategy.\n12. Support for NAT mapping.\n\n# Links\n\n- [API Documentation](API.md)\n- [Changelog](Changelog.md)\n- [Migrating from node_redis](https://github.com/luin/ioredis/wiki/Migrating-from-node_redis)\n- [Error Handling](#error-handling)\n\n<hr>\n<a href=\"http://bit.ly/medis-macos\"><img align=\"right\" src=\"resources/medis.png\" alt=\"Download on the App Store\"></a>\n\n### [AD] Medis: Redis GUI for OS X\n\nLooking for a Redis GUI manager for OS X, Windows and Linux? Here's [Medis](http://bit.ly/medis-macos)!\n\nMedis is an open-sourced, beautiful, easy-to-use Redis GUI management application.\n\nMedis starts with all the basic features you need:\n\n- Keys viewing/editing\n- SSH Tunnel for connecting with remote servers\n- Terminal for executing custom commands\n- JSON/MessagePack format viewing/editing and built-in highlighting/validator\n- And other awesome features...\n\n[Medis is open sourced on GitHub](https://github.com/luin/medis)\n\n### [AD] Kuber: Kubernetes Dashboard for iOS\n\n<a href=\"http://bit.ly/kuber-ios\"><img src=\"resources/kuber.png\" alt=\"Download on the App Store\"></a>\n\n<hr>\n\n# Quick Start\n\n## Install\n\n```shell\n$ npm install ioredis\n```\n\n## Basic Usage\n\n```javascript\nvar Redis = require(\"ioredis\");\nvar redis = new Redis();\n\nredis.set(\"foo\", \"bar\");\nredis.get(\"foo\", function(err, result) {\n  console.log(result);\n});\nredis.del(\"foo\");\n\n// Or using a promise if the last argument isn't a function\nredis.get(\"foo\").then(function(result) {\n  console.log(result);\n});\n\n// Arguments to commands are flattened, so the following are the same:\nredis.sadd(\"set\", 1, 3, 5, 7);\nredis.sadd(\"set\", [1, 3, 5, 7]);\n\n// All arguments are passed directly to the redis server:\nredis.set(\"key\", 100, \"EX\", 10);\n```\n\nSee the `examples/` folder for more examples.\n\n## Connect to Redis\n\nWhen a new `Redis` instance is created,\na connection to Redis will be created at the same time.\nYou can specify which Redis to connect to by:\n\n```javascript\nnew Redis(); // Connect to 127.0.0.1:6379\nnew Redis(6380); // 127.0.0.1:6380\nnew Redis(6379, \"192.168.1.1\"); // 192.168.1.1:6379\nnew Redis(\"/tmp/redis.sock\");\nnew Redis({\n  port: 6379, // Redis port\n  host: \"127.0.0.1\", // Redis host\n  family: 4, // 4 (IPv4) or 6 (IPv6)\n  password: \"auth\",\n  db: 0\n});\n```\n\nYou can also specify connection options as a [`redis://` URL](http://www.iana.org/assignments/uri-schemes/prov/redis) or [`rediss://` URL](https://www.iana.org/assignments/uri-schemes/prov/rediss) when using [TLS encryption](#tls-options):\n\n```javascript\n// Connect to 127.0.0.1:6380, db 4, using password \"authpassword\":\nnew Redis(\"redis://:authpassword@127.0.0.1:6380/4\");\n```\n\nSee [API Documentation](API.md#new_Redis) for all available options.\n\n## Pub/Sub\n\nHere is a simple example of the API for publish/subscribe.\nThe following program opens two client connections.\nIt subscribes to a channel with one connection\nand publishes to that channel with the other:\n\n```javascript\nvar Redis = require(\"ioredis\");\nvar redis = new Redis();\nvar pub = new Redis();\nredis.subscribe(\"news\", \"music\", function(err, count) {\n  // Now we are subscribed to both the 'news' and 'music' channels.\n  // `count` represents the number of channels we are currently subscribed to.\n\n  pub.publish(\"news\", \"Hello world!\");\n  pub.publish(\"music\", \"Hello again!\");\n});\n\nredis.on(\"message\", function(channel, message) {\n  // Receive message Hello world! from channel news\n  // Receive message Hello again! from channel music\n  console.log(\"Receive message %s from channel %s\", message, channel);\n});\n\n// There's also an event called 'messageBuffer', which is the same as 'message' except\n// it returns buffers instead of strings.\nredis.on(\"messageBuffer\", function(channel, message) {\n  // Both `channel` and `message` are buffers.\n});\n```\n\n`PSUBSCRIBE` is also supported in a similar way:\n\n```javascript\nredis.psubscribe(\"pat?ern\", function(err, count) {});\nredis.on(\"pmessage\", function(pattern, channel, message) {});\nredis.on(\"pmessageBuffer\", function(pattern, channel, message) {});\n```\n\nWhen a client issues a SUBSCRIBE or PSUBSCRIBE, that connection is put into a \"subscriber\" mode.\nAt that point, only commands that modify the subscription set are valid.\nWhen the subscription set is empty, the connection is put back into regular mode.\n\nIf you need to send regular commands to Redis while in subscriber mode, just open another connection.\n\n## Handle Binary Data\n\nArguments can be buffers:\n\n```javascript\nredis.set(\"foo\", Buffer.from(\"bar\"));\n```\n\nAnd every command has a method that returns a Buffer (by adding a suffix of \"Buffer\" to the command name).\nTo get a buffer instead of a utf8 string:\n\n```javascript\nredis.getBuffer(\"foo\", function(err, result) {\n  // result is a buffer.\n});\n```\n\n## Pipelining\n\nIf you want to send a batch of commands (e.g. > 5), you can use pipelining to queue\nthe commands in memory and then send them to Redis all at once. This way the performance improves by 50%~300% (See [benchmark section](#benchmark)).\n\n`redis.pipeline()` creates a `Pipeline` instance. You can call any Redis\ncommands on it just like the `Redis` instance. The commands are queued in memory\nand flushed to Redis by calling the `exec` method:\n\n```javascript\nvar pipeline = redis.pipeline();\npipeline.set(\"foo\", \"bar\");\npipeline.del(\"cc\");\npipeline.exec(function(err, results) {\n  // `err` is always null, and `results` is an array of responses\n  // corresponding to the sequence of queued commands.\n  // Each response follows the format `[err, result]`.\n});\n\n// You can even chain the commands:\nredis\n  .pipeline()\n  .set(\"foo\", \"bar\")\n  .del(\"cc\")\n  .exec(function(err, results) {});\n\n// `exec` also returns a Promise:\nvar promise = redis\n  .pipeline()\n  .set(\"foo\", \"bar\")\n  .get(\"foo\")\n  .exec();\npromise.then(function(result) {\n  // result === [[null, 'OK'], [null, 'bar']]\n});\n```\n\nEach chained command can also have a callback, which will be invoked when the command\ngets a reply:\n\n```javascript\nredis\n  .pipeline()\n  .set(\"foo\", \"bar\")\n  .get(\"foo\", function(err, result) {\n    // result === 'bar'\n  })\n  .exec(function(err, result) {\n    // result[1][1] === 'bar'\n  });\n```\n\nIn addition to adding commands to the `pipeline` queue individually, you can also pass an array of commands and arguments to the constructor:\n\n```javascript\nredis.pipeline([[\"set\", \"foo\", \"bar\"], [\"get\", \"foo\"]]).exec(function() {\n  /* ... */\n});\n```\n\n`#length` property shows how many commands in the pipeline:\n\n```javascript\nconst length = redis\n  .pipeline()\n  .set(\"foo\", \"bar\")\n  .get(\"foo\").length;\n// length === 2\n```\n\n## Transaction\n\nMost of the time, the transaction commands `multi` & `exec` are used together with pipeline.\nTherefore, when `multi` is called, a `Pipeline` instance is created automatically by default,\nso you can use `multi` just like `pipeline`:\n\n```javascript\nredis\n  .multi()\n  .set(\"foo\", \"bar\")\n  .get(\"foo\")\n  .exec(function(err, results) {\n    // results === [[null, 'OK'], [null, 'bar']]\n  });\n```\n\nIf there's a syntax error in the transaction's command chain (e.g. wrong number of arguments, wrong command name, etc),\nthen none of the commands would be executed, and an error is returned:\n\n```javascript\nredis\n  .multi()\n  .set(\"foo\")\n  .set(\"foo\", \"new value\")\n  .exec(function(err, results) {\n    // err:\n    //  { [ReplyError: EXECABORT Transaction discarded because of previous errors.]\n    //    name: 'ReplyError',\n    //    message: 'EXECABORT Transaction discarded because of previous errors.',\n    //    command: { name: 'exec', args: [] },\n    //    previousErrors:\n    //     [ { [ReplyError: ERR wrong number of arguments for 'set' command]\n    //         name: 'ReplyError',\n    //         message: 'ERR wrong number of arguments for \\'set\\' command',\n    //         command: [Object] } ] }\n  });\n```\n\nIn terms of the interface, `multi` differs from `pipeline` in that when specifying a callback\nto each chained command, the queueing state is passed to the callback instead of the result of the command:\n\n```javascript\nredis\n  .multi()\n  .set(\"foo\", \"bar\", function(err, result) {\n    // result === 'QUEUED'\n  })\n  .exec(/* ... */);\n```\n\nIf you want to use transaction without pipeline, pass `{ pipeline: false }` to `multi`,\nand every command will be sent to Redis immediately without waiting for an `exec` invocation:\n\n```javascript\nredis.multi({ pipeline: false });\nredis.set(\"foo\", \"bar\");\nredis.get(\"foo\");\nredis.exec(function(err, result) {\n  // result === [[null, 'OK'], [null, 'bar']]\n});\n```\n\nThe constructor of `multi` also accepts a batch of commands:\n\n```javascript\nredis.multi([[\"set\", \"foo\", \"bar\"], [\"get\", \"foo\"]]).exec(function() {\n  /* ... */\n});\n```\n\nInline transactions are supported by pipeline, which means you can group a subset of commands\nin the pipeline into a transaction:\n\n```javascript\nredis\n  .pipeline()\n  .get(\"foo\")\n  .multi()\n  .set(\"foo\", \"bar\")\n  .get(\"foo\")\n  .exec()\n  .get(\"foo\")\n  .exec();\n```\n\n## Lua Scripting\n\nioredis supports all of the scripting commands such as `EVAL`, `EVALSHA` and `SCRIPT`.\nHowever, it's tedious to use in real world scenarios since developers have to take\ncare of script caching and to detect when to use `EVAL` and when to use `EVALSHA`.\nioredis exposes a `defineCommand` method to make scripting much easier to use:\n\n```javascript\nvar redis = new Redis();\n\n// This will define a command echo:\nredis.defineCommand(\"echo\", {\n  numberOfKeys: 2,\n  lua: \"return {KEYS[1],KEYS[2],ARGV[1],ARGV[2]}\"\n});\n\n// Now `echo` can be used just like any other ordinary command,\n// and ioredis will try to use `EVALSHA` internally when possible for better performance.\nredis.echo(\"k1\", \"k2\", \"a1\", \"a2\", function(err, result) {\n  // result === ['k1', 'k2', 'a1', 'a2']\n});\n\n// `echoBuffer` is also defined automatically to return buffers instead of strings:\nredis.echoBuffer(\"k1\", \"k2\", \"a1\", \"a2\", function(err, result) {\n  // result[0] equals to Buffer.from('k1');\n});\n\n// And of course it works with pipeline:\nredis\n  .pipeline()\n  .set(\"foo\", \"bar\")\n  .echo(\"k1\", \"k2\", \"a1\", \"a2\")\n  .exec();\n```\n\nIf the number of keys can't be determined when defining a command, you can\nomit the `numberOfKeys` property and pass the number of keys as the first argument\nwhen you call the command:\n\n```javascript\nredis.defineCommand(\"echoDynamicKeyNumber\", {\n  lua: \"return {KEYS[1],KEYS[2],ARGV[1],ARGV[2]}\"\n});\n\n// Now you have to pass the number of keys as the first argument every time\n// you invoke the `echoDynamicKeyNumber` command:\nredis.echoDynamicKeyNumber(2, \"k1\", \"k2\", \"a1\", \"a2\", function(err, result) {\n  // result === ['k1', 'k2', 'a1', 'a2']\n});\n```\n\n## Transparent Key Prefixing\n\nThis feature allows you to specify a string that will automatically be prepended\nto all the keys in a command, which makes it easier to manage your key\nnamespaces.\n\n**Warning** This feature won't apply to commands like [KEYS](http://redis.io/commands/KEYS) and [SCAN](http://redis.io/commands/scan) that take patterns rather than actual keys([#239](https://github.com/luin/ioredis/issues/239)),\nand this feature also won't apply to the replies of commands even they are key names ([#325](https://github.com/luin/ioredis/issues/325)).\n\n```javascript\nvar fooRedis = new Redis({ keyPrefix: \"foo:\" });\nfooRedis.set(\"bar\", \"baz\"); // Actually sends SET foo:bar baz\n\nfooRedis.defineCommand(\"echo\", {\n  numberOfKeys: 2,\n  lua: \"return {KEYS[1],KEYS[2],ARGV[1],ARGV[2]}\"\n});\n\n// Works well with pipelining/transaction\nfooRedis\n  .pipeline()\n  // Sends SORT foo:list BY foo:weight_*->fieldname\n  .sort(\"list\", \"BY\", \"weight_*->fieldname\")\n  // Supports custom commands\n  // Sends EVALSHA xxx foo:k1 foo:k2 a1 a2\n  .echo(\"k1\", \"k2\", \"a1\", \"a2\")\n  .exec();\n```\n\n## Transforming Arguments & Replies\n\nMost Redis commands take one or more Strings as arguments,\nand replies are sent back as a single String or an Array of Strings. However, sometimes\nyou may want something different. For instance, it would be more convenient if the `HGETALL`\ncommand returns a hash (e.g. `{ key: val1, key2: v2 }`) rather than an array of key values (e.g. `[key1, val1, key2, val2]`).\n\nioredis has a flexible system for transforming arguments and replies. There are two types\nof transformers, argument transformer and reply transformer:\n\n```javascript\nvar Redis = require(\"ioredis\");\n\n// Here's the built-in argument transformer converting\n// hmset('key', { k1: 'v1', k2: 'v2' })\n// or\n// hmset('key', new Map([['k1', 'v1'], ['k2', 'v2']]))\n// into\n// hmset('key', 'k1', 'v1', 'k2', 'v2')\nRedis.Command.setArgumentTransformer(\"hmset\", function(args) {\n  if (args.length === 2) {\n    if (typeof Map !== \"undefined\" && args[1] instanceof Map) {\n      // utils is a internal module of ioredis\n      return [args[0]].concat(utils.convertMapToArray(args[1]));\n    }\n    if (typeof args[1] === \"object\" && args[1] !== null) {\n      return [args[0]].concat(utils.convertObjectToArray(args[1]));\n    }\n  }\n  return args;\n});\n\n// Here's the built-in reply transformer converting the HGETALL reply\n// ['k1', 'v1', 'k2', 'v2']\n// into\n// { k1: 'v1', 'k2': 'v2' }\nRedis.Command.setReplyTransformer(\"hgetall\", function(result) {\n  if (Array.isArray(result)) {\n    var obj = {};\n    for (var i = 0; i < result.length; i += 2) {\n      obj[result[i]] = result[i + 1];\n    }\n    return obj;\n  }\n  return result;\n});\n```\n\nThere are three built-in transformers, two argument transformers for `hmset` & `mset` and\na reply transformer for `hgetall`. Transformers for `hmset` and `hgetall` were mentioned\nabove, and the transformer for `mset` is similar to the one for `hmset`:\n\n```javascript\nredis.mset({ k1: \"v1\", k2: \"v2\" });\nredis.get(\"k1\", function(err, result) {\n  // result === 'v1';\n});\n\nredis.mset(new Map([[\"k3\", \"v3\"], [\"k4\", \"v4\"]]));\nredis.get(\"k3\", function(err, result) {\n  // result === 'v3';\n});\n```\n\nAnother useful example of a reply transformer is one that changes `hgetall` to return array of arrays instead of objects which avoids a unwanted conversation of hash keys to strings when dealing with binary hash keys:\n\n```javascript\nRedis.Command.setReplyTransformer(\"hgetall\", function(result) {\n  var arr = [];\n  for (var i = 0; i < result.length; i += 2) {\n    arr.push([result[i], result[i + 1]]);\n  }\n  return arr;\n});\nredis.hset(\"h1\", Buffer.from([0x01]), Buffer.from([0x02]));\nredis.hset(\"h1\", Buffer.from([0x03]), Buffer.from([0x04]));\nredis.hgetallBuffer(\"h1\", function(err, result) {\n  // result === [ [ <Buffer 01>, <Buffer 02> ], [ <Buffer 03>, <Buffer 04> ] ];\n});\n```\n\n## Monitor\n\nRedis supports the MONITOR command,\nwhich lets you see all commands received by the Redis server across all client connections,\nincluding from other client libraries and other computers.\n\nThe `monitor` method returns a monitor instance.\nAfter you send the MONITOR command, no other commands are valid on that connection. ioredis will emit a monitor event for every new monitor message that comes across.\nThe callback for the monitor event takes a timestamp from the Redis server and an array of command arguments.\n\nHere is a simple example:\n\n```javascript\nredis.monitor(function(err, monitor) {\n  monitor.on(\"monitor\", function(time, args, source, database) {});\n});\n```\nHere is another example illustrating an `async` function and `monitor.disconnect()`:\n```javascript\nasync () => {\n  const monitor = await redis.monitor()\n  monitor.on('monitor', console.log)\n  // Any other tasks\n  monitor.disconnect()\n}\n```\n## Streamify Scanning\n\nRedis 2.8 added the `SCAN` command to incrementally iterate through the keys in the database. It's different from `KEYS` in that\n`SCAN` only returns a small number of elements each call, so it can be used in production without the downside\nof blocking the server for a long time. However, it requires recording the cursor on the client side each time\nthe `SCAN` command is called in order to iterate through all the keys correctly. Since it's a relatively common use case, ioredis\nprovides a streaming interface for the `SCAN` command to make things much easier. A readable stream can be created by calling `scanStream`:\n\n```javascript\nvar redis = new Redis();\n// Create a readable stream (object mode)\nvar stream = redis.scanStream();\nstream.on(\"data\", function(resultKeys) {\n  // `resultKeys` is an array of strings representing key names.\n  // Note that resultKeys may contain 0 keys, and that it will sometimes\n  // contain duplicates due to SCAN's implementation in Redis.\n  for (var i = 0; i < resultKeys.length; i++) {\n    console.log(resultKeys[i]);\n  }\n});\nstream.on(\"end\", function() {\n  console.log(\"all keys have been visited\");\n});\n```\n\n`scanStream` accepts an option, with which you can specify the `MATCH` pattern and the `COUNT` argument:\n\n```javascript\nvar stream = redis.scanStream({\n  // only returns keys following the pattern of `user:*`\n  match: \"user:*\",\n  // returns approximately 100 elements per call\n  count: 100\n});\n```\n\nJust like other commands, `scanStream` has a binary version `scanBufferStream`, which returns an array of buffers. It's useful when\nthe key names are not utf8 strings.\n\nThere are also `hscanStream`, `zscanStream` and `sscanStream` to iterate through elements in a hash, zset and set. The interface of each is\nsimilar to `scanStream` except the first argument is the key name:\n\n```javascript\nvar stream = redis.hscanStream(\"myhash\", {\n  match: \"age:??\"\n});\n```\n\nYou can learn more from the [Redis documentation](http://redis.io/commands/scan).\n\n**Useful Tips**\nIt's pretty common that doing an async task in the `data` handler. We'd like the scanning process to be paused until the async task to be finished. `Stream#pause()` and `Stream.resume()` do the trick. For example if we want to migrate data in Redis to MySQL:\n\n```javascript\nvar stream = redis.scanStream();\nstream.on(\"data\", function(resultKeys) {\n  // Pause the stream from scanning more keys until we've migrated the current keys.\n  stream.pause();\n\n  Promise.all(resultKeys.map(migrateKeyToMySQL)).then(() => {\n    // Resume the stream here.\n    stream.resume();\n  });\n});\n\nstream.on(\"end\", function() {\n  console.log(\"done migration\");\n});\n```\n\n## Auto-reconnect\n\nBy default, ioredis will try to reconnect when the connection to Redis is lost\nexcept when the connection is closed manually by `redis.disconnect()` or `redis.quit()`.\n\nIt's very flexible to control how long to wait to reconnect after disconnection\nusing the `retryStrategy` option:\n\n```javascript\nvar redis = new Redis({\n  // This is the default value of `retryStrategy`\n  retryStrategy: function(times) {\n    var delay = Math.min(times * 50, 2000);\n    return delay;\n  }\n});\n```\n\n`retryStrategy` is a function that will be called when the connection is lost.\nThe argument `times` means this is the nth reconnection being made and\nthe return value represents how long (in ms) to wait to reconnect. When the\nreturn value isn't a number, ioredis will stop trying to reconnect, and the connection\nwill be lost forever if the user doesn't call `redis.connect()` manually.\n\nWhen reconnected, the client will auto subscribe to channels that the previous connection subscribed to.\nThis behavior can be disabled by setting the `autoResubscribe` option to `false`.\n\nAnd if the previous connection has some unfulfilled commands (most likely blocking commands such as `brpop` and `blpop`),\nthe client will resend them when reconnected. This behavior can be disabled by setting the `autoResendUnfulfilledCommands` option to `false`.\n\nBy default, all pending commands will be flushed with an error every 20 retry attempts. That makes sure commands won't wait forever when the connection is down. You can change this behavior by setting `maxRetriesPerRequest`:\n\n```javascript\nvar redis = new Redis({\n  maxRetriesPerRequest: 1\n});\n```\n\nSet maxRetriesPerRequest to `null` to disable this behavior, and every command will wait forever until the connection is alive again (which is the default behavior before ioredis v4).\n\n### Reconnect on error\n\nBesides auto-reconnect when the connection is closed, ioredis supports reconnecting on the specified errors by the `reconnectOnError` option. Here's an example that will reconnect when receiving `READONLY` error:\n\n```javascript\nvar redis = new Redis({\n  reconnectOnError: function(err) {\n    var targetError = \"READONLY\";\n    if (err.message.slice(0, targetError.length) === targetError) {\n      // Only reconnect when the error starts with \"READONLY\"\n      return true; // or `return 1;`\n    }\n  }\n});\n```\n\nThis feature is useful when using Amazon ElastiCache. Once failover happens, Amazon ElastiCache will switch the master we currently connected with to a slave, leading to the following writes fails with the error `READONLY`. Using `reconnectOnError`, we can force the connection to reconnect on this error in order to connect to the new master.\n\nFurthermore, if the `reconnectOnError` returns `2`, ioredis will resend the failed command after reconnecting.\n\n## Connection Events\n\nThe Redis instance will emit some events about the state of the connection to the Redis server.\n\n| Event        | Description                                                                                                                                                                                                                                     |\n| :----------- | :---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| connect      | emits when a connection is established to the Redis server.                                                                                                                                                                                     |\n| ready        | If `enableReadyCheck` is `true`, client will emit `ready` when the server reports that it is ready to receive commands (e.g. finish loading data from disk).<br>Otherwise, `ready` will be emitted immediately right after the `connect` event. |\n| error        | emits when an error occurs while connecting.<br>However, ioredis emits all `error` events silently (only emits when there's at least one listener) so that your application won't crash if you're not listening to the `error` event.           |\n| close        | emits when an established Redis server connection has closed.                                                                                                                                                                                   |\n| reconnecting | emits after `close` when a reconnection will be made. The argument of the event is the time (in ms) before reconnecting.                                                                                                                        |\n| end          | emits after `close` when no more reconnections will be made, or the connection is failed to establish.                                                                                                                                          |\n\nYou can also check out the `Redis#status` property to get the current connection status.\n\nBesides the above connection events, there are several other custom events:\n\n| Event  | Description                                                         |\n| :----- | :------------------------------------------------------------------ |\n| select | emits when the database changed. The argument is the new db number. |\n\n## Offline Queue\n\nWhen a command can't be processed by Redis (being sent before the `ready` event), by default, it's added to the offline queue and will be\nexecuted when it can be processed. You can disable this feature by setting the `enableOfflineQueue`\noption to `false`:\n\n```javascript\nvar redis = new Redis({ enableOfflineQueue: false });\n```\n\n## TLS Options\n\nRedis doesn't support TLS natively, however if the redis server you want to connect to is hosted behind a TLS proxy (e.g. [stunnel](https://www.stunnel.org/)) or is offered by a PaaS service that supports TLS connection (e.g. [Redis Labs](https://redislabs.com/)), you can set the `tls` option:\n\n```javascript\nvar redis = new Redis({\n  host: \"localhost\",\n  tls: {\n    // Refer to `tls.connect()` section in\n    // https://nodejs.org/api/tls.html\n    // for all supported options\n    ca: fs.readFileSync(\"cert.pem\")\n  }\n});\n```\n\nAlternatively, specify the connection through a [`rediss://` URL](https://www.iana.org/assignments/uri-schemes/prov/rediss).\n\n```javascript\nvar redis = new Redis(\"rediss://redis.my-service.com\");\n```\n\n<hr>\n\n## Sentinel\n\nioredis supports Sentinel out of the box. It works transparently as all features that work when\nyou connect to a single node also work when you connect to a sentinel group. Make sure to run Redis >= 2.8.12 if you want to use this feature. Sentinels have a default port of 26379.\n\nTo connect using Sentinel, use:\n\n```javascript\nvar redis = new Redis({\n  sentinels: [\n    { host: \"localhost\", port: 26379 },\n    { host: \"localhost\", port: 26380 }\n  ],\n  name: \"mymaster\"\n});\n\nredis.set(\"foo\", \"bar\");\n```\n\nThe arguments passed to the constructor are different from the ones you use to connect to a single node, where:\n\n- `name` identifies a group of Redis instances composed of a master and one or more slaves (`mymaster` in the example);\n- `sentinelPassword` (optional) password for Sentinel instances.\n- `sentinels` are a list of sentinels to connect to. The list does not need to enumerate all your sentinel instances, but a few so that if one is down the client will try the next one.\n- `role` (optional) with a value of `slave` will return a random slave from the Sentinel group.\n- `preferredSlaves` (optional) can be used to prefer a particular slave or set of slaves based on priority. It accepts a function or array.\n\nioredis **guarantees** that the node you connected to is always a master even after a failover. When a failover happens, instead of trying to reconnect to the failed node (which will be demoted to slave when it's available again), ioredis will ask sentinels for the new master node and connect to it. All commands sent during the failover are queued and will be executed when the new connection is established so that none of the commands will be lost.\n\nIt's possible to connect to a slave instead of a master by specifying the option `role` with the value of `slave` and ioredis will try to connect to a random slave of the specified master, with the guarantee that the connected node is always a slave. If the current node is promoted to master due to a failover, ioredis will disconnect from it and ask the sentinels for another slave node to connect to.\n\nIf you specify the option `preferredSlaves` along with `role: 'slave'` ioredis will attempt to use this value when selecting the slave from the pool of available slaves. The value of `preferredSlaves` should either be a function that accepts an array of avaiable slaves and returns a single result, or an array of slave values priorities by the lowest `prio` value first with a default value of `1`.\n\n```javascript\n// available slaves format\nvar availableSlaves = [{ ip: \"127.0.0.1\", port: \"31231\", flags: \"slave\" }];\n\n// preferredSlaves array format\nvar preferredSlaves = [\n  { ip: \"127.0.0.1\", port: \"31231\", prio: 1 },\n  { ip: \"127.0.0.1\", port: \"31232\", prio: 2 }\n];\n\n// preferredSlaves function format\npreferredSlaves = function(availableSlaves) {\n  for (var i = 0; i < availableSlaves.length; i++) {\n    var slave = availableSlaves[i];\n    if (slave.ip === \"127.0.0.1\") {\n      if (slave.port === \"31234\") {\n        return slave;\n      }\n    }\n  }\n  // if no preferred slaves are available a random one is used\n  return false;\n};\n\nvar redis = new Redis({\n  sentinels: [\n    { host: \"127.0.0.1\", port: 26379 },\n    { host: \"127.0.0.1\", port: 26380 }\n  ],\n  name: \"mymaster\",\n  role: \"slave\",\n  preferredSlaves: preferredSlaves\n});\n```\n\nBesides the `retryStrategy` option, there's also a `sentinelRetryStrategy` in Sentinel mode which will be invoked when all the sentinel nodes are unreachable during connecting. If `sentinelRetryStrategy` returns a valid delay time, ioredis will try to reconnect from scratch. The default value of `sentinelRetryStrategy` is:\n\n```javascript\nfunction (times) {\n  var delay = Math.min(times * 10, 1000);\n  return delay;\n}\n```\n\n## Cluster\n\nRedis Cluster provides a way to run a Redis installation where data is automatically sharded across multiple Redis nodes.\nYou can connect to a Redis Cluster like this:\n\n```javascript\nvar Redis = require(\"ioredis\");\n\nvar cluster = new Redis.Cluster([\n  {\n    port: 6380,\n    host: \"127.0.0.1\"\n  },\n  {\n    port: 6381,\n    host: \"127.0.0.1\"\n  }\n]);\n\ncluster.set(\"foo\", \"bar\");\ncluster.get(\"foo\", function(err, res) {\n  // res === 'bar'\n});\n```\n\n`Cluster` constructor accepts two arguments, where:\n\n0.  The first argument is a list of nodes of the cluster you want to connect to.\n    Just like Sentinel, the list does not need to enumerate all your cluster nodes,\n    but a few so that if one is unreachable the client will try the next one, and the client will discover other nodes automatically when at least one node is connected.\n1.  The second argument is the options, where:\n\n    - `clusterRetryStrategy`: When none of the startup nodes are reachable, `clusterRetryStrategy` will be invoked. When a number is returned,\n      ioredis will try to reconnect to the startup nodes from scratch after the specified delay (in ms). Otherwise, an error of \"None of startup nodes is available\" will be returned.\n      The default value of this option is:\n\n          ```javascript\n          function (times) {\n            var delay = Math.min(100 + times * 2, 2000);\n            return delay;\n          }\n          ```\n\n          It's possible to modify the `startupNodes` property in order to switch to another set of nodes here:\n\n          ```javascript\n          function (times) {\n            this.startupNodes = [{ port: 6790, host: '127.0.0.1' }];\n            return Math.min(100 + times * 2, 2000);\n          }\n          ```\n\n    - `dnsLookup`: Alternative DNS lookup function (`dns.lookup()` is used by default). It may be useful to override this in special cases, such as when AWS ElastiCache used with TLS enabled.\n    - `enableOfflineQueue`: Similar to the `enableOfflineQueue` option of `Redis` class.\n    - `enableReadyCheck`: When enabled, \"ready\" event will only be emitted when `CLUSTER INFO` command\n      reporting the cluster is ready for handling commands. Otherwise, it will be emitted immediately after \"connect\" is emitted.\n    - `scaleReads`: Config where to send the read queries. See below for more details.\n    - `maxRedirections`: When a cluster related error (e.g. `MOVED`, `ASK` and `CLUSTERDOWN` etc.) is received, the client will redirect the\n      command to another node. This option limits the max redirections allowed when sending a command. The default value is `16`.\n    - `retryDelayOnFailover`: If the target node is disconnected when sending a command,\n      ioredis will retry after the specified delay. The default value is `100`. You should make sure `retryDelayOnFailover * maxRedirections > cluster-node-timeout`\n      to insure that no command will fail during a failover.\n    - `retryDelayOnClusterDown`: When a cluster is down, all commands will be rejected with the error of `CLUSTERDOWN`. If this option is a number (by default, it is `100`), the client\n      will resend the commands after the specified time (in ms).\n    - `retryDelayOnTryAgain`: If this option is a number (by default, it is `100`), the client\n      will resend the commands rejected with `TRYAGAIN` error after the specified time (in ms).\n    - `redisOptions`: Default options passed to the constructor of `Redis` when connecting to a node.\n    - `slotsRefreshTimeout`: Milliseconds before a timeout occurs while refreshing slots from the cluster (default `1000`)\n    - `slotsRefreshInterval`: Milliseconds between every automatic slots refresh (default `5000`)\n\n### Read-write splitting\n\nA typical redis cluster contains three or more masters and several slaves for each master. It's possible to scale out redis cluster by sending read queries to slaves and write queries to masters by setting the `scaleReads` option.\n\n`scaleReads` is \"master\" by default, which means ioredis will never send any queries to slaves. There are other three available options:\n\n1. \"all\": Send write queries to masters and read queries to masters or slaves randomly.\n2. \"slave\": Send write queries to masters and read queries to slaves.\n3. a custom `function(nodes, command): node`: Will choose the custom function to select to which node to send read queries (write queries keep being sent to master). The first node in `nodes` is always the master serving the relevant slots. If the function returns an array of nodes, a random node of that list will be selected.\n\nFor example:\n\n```javascript\nvar cluster = new Redis.Cluster(\n  [\n    /* nodes */\n  ],\n  {\n    scaleReads: \"slave\"\n  }\n);\ncluster.set(\"foo\", \"bar\"); // This query will be sent to one of the masters.\ncluster.get(\"foo\", function(err, res) {\n  // This query will be sent to one of the slaves.\n});\n```\n\n**NB** In the code snippet above, the `res` may not be equal to \"bar\" because of the lag of replication between the master and slaves.\n\n### Running commands to multiple nodes\n\nEvery command will be sent to exactly one node. For commands containing keys, (e.g. `GET`, `SET` and `HGETALL`), ioredis sends them to the node that serving the keys, and for other commands not containing keys, (e.g. `INFO`, `KEYS` and `FLUSHDB`), ioredis sends them to a random node.\n\nSometimes you may want to send a command to multiple nodes (masters or slaves) of the cluster, you can get the nodes via `Cluster#nodes()` method.\n\n`Cluster#nodes()` accepts a parameter role, which can be \"master\", \"slave\" and \"all\" (default), and returns an array of `Redis` instance. For example:\n\n```javascript\n// Send `FLUSHDB` command to all slaves:\nvar slaves = cluster.nodes(\"slave\");\nPromise.all(\n  slaves.map(function(node) {\n    return node.flushdb();\n  })\n);\n\n// Get keys of all the masters:\nvar masters = cluster.nodes(\"master\");\nPromise.all(\n  masters.map(function(node) {\n    return node.keys();\n  })\n).then(function(keys) {\n  // keys: [['key1', 'key2'], ['key3', 'key4']]\n});\n```\n\n### NAT Mapping\n\nSometimes the cluster is hosted within a internal network that can only be accessed via a NAT (Network Address Translation) instance. See [Accessing ElastiCache from outside AWS](https://docs.aws.amazon.com/AmazonElastiCache/latest/red-ug/accessing-elasticache.html) as an example.\n\nYou can specify nat mapping rules via `natMap` option:\n\n```javascript\nconst cluster = new Redis.Cluster(\n  [\n    {\n      host: \"203.0.113.73\",\n      port: 30001\n    }\n  ],\n  {\n    natMap: {\n      \"10.0.1.230:30001\": { host: \"203.0.113.73\", port: 30001 },\n      \"10.0.1.231:30001\": { host: \"203.0.113.73\", port: 30002 },\n      \"10.0.1.232:30001\": { host: \"203.0.113.73\", port: 30003 }\n    }\n  }\n);\n```\n\nThis option is also useful when the cluster is running inside a Docker container.\n\n### Transaction and pipeline in Cluster mode\n\nAlmost all features that are supported by `Redis` are also supported by `Redis.Cluster`, e.g. custom commands, transaction and pipeline.\nHowever there are some differences when using transaction and pipeline in Cluster mode:\n\n0. All keys in a pipeline should belong to the same slot since ioredis sends all commands in a pipeline to the same node.\n1. You can't use `multi` without pipeline (aka `cluster.multi({ pipeline: false })`). This is because when you call `cluster.multi({ pipeline: false })`, ioredis doesn't know which node the `multi` command should be sent to.\n2. Chaining custom commands in the pipeline is not supported in Cluster mode.\n\nWhen any commands in a pipeline receives a `MOVED` or `ASK` error, ioredis will resend the whole pipeline to the specified node automatically if all of the following conditions are satisfied:\n\n0. All errors received in the pipeline are the same. For example, we won't resend the pipeline if we got two `MOVED` errors pointing to different nodes.\n1. All commands executed successfully are readonly commands. This makes sure that resending the pipeline won't have side effects.\n\n### Pub/Sub\n\nPub/Sub in cluster mode works exactly as the same as in standalone mode. Internally, when a node of the cluster receives a message, it will broadcast the message to the other nodes. ioredis makes sure that each message will only be received once by strictly subscribing one node at the same time.\n\n```javascript\nvar nodes = [\n  /* nodes */\n];\nvar pub = new Redis.Cluster(nodes);\nvar sub = new Redis.Cluster(nodes);\nsub.on(\"message\", function(channel, message) {\n  console.log(channel, message);\n});\n\nsub.subscribe(\"news\", function() {\n  pub.publish(\"news\", \"highlights\");\n});\n```\n\n### Events\n\n| Event        | Description                                                                                                                                                                                                |\n| :----------- | :--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| connect      | emits when a connection is established to the Redis server.                                                                                                                                                |\n| ready        | emits when `CLUSTER INFO` reporting the cluster is able to receive commands (if `enableReadyCheck` is `true`) or immediately after `connect` event (if `enableReadyCheck` is false).                       |\n| error        | emits when an error occurs while connecting with a property of `lastNodeError` representing the last node error received. This event is emitted silently (only emitting if there's at least one listener). |\n| close        | emits when an established Redis server connection has closed.                                                                                                                                              |\n| reconnecting | emits after `close` when a reconnection will be made. The argument of the event is the time (in ms) before reconnecting.                                                                                   |\n| end          | emits after `close` when no more reconnections will be made.                                                                                                                                               |\n| +node        | emits when a new node is connected.                                                                                                                                                                        |\n| -node        | emits when a node is disconnected.                                                                                                                                                                         |\n| node error   | emits when an error occurs when connecting to a node. The second argument indicates the address of the node.                                                                                               |\n\n### Password\n\nSetting the `password` option to access password-protected clusters:\n\n```javascript\nvar Redis = require(\"ioredis\");\nvar cluster = new Redis.Cluster(nodes, {\n  redisOptions: {\n    password: \"your-cluster-password\"\n  }\n});\n```\n\nIf some of nodes in the cluster using a different password, you should specify them in the first parameter:\n\n```javascript\nvar Redis = require(\"ioredis\");\nvar cluster = new Redis.Cluster(\n  [\n    // Use password \"password-for-30001\" for 30001\n    { port: 30001, password: \"password-for-30001\" },\n    // Don't use password when accessing 30002\n    { port: 30002, password: null }\n    // Other nodes will use \"fallback-password\"\n  ],\n  {\n    redisOptions: {\n      password: \"fallback-password\"\n    }\n  }\n);\n```\n\n### Special note: AWS ElastiCache Clusters with TLS\n\nAWS ElastiCache for Redis (Clustered Mode) supports TLS encryption. If you use\nthis, you may encounter errors with invalid certificates. To resolve this\nissue, construct the `Cluster` with the `dnsLookup` option as follows:\n\n```javascript\nvar cluster = new Redis.Cluster(\n  [{\n    host: 'clustercfg.myCluster.abcdefg.xyz.cache.amazonaws.com',\n    port: 6379\n  }],\n  {\n    dnsLookup: (address, callback) => callback(null, address),\n    redisOptions: {\n      tls: {}\n    },\n  }\n};\n```\n\n<hr>\n\n# Error Handling\n\nAll the errors returned by the Redis server are instances of `ReplyError`, which can be accessed via `Redis`:\n\n```javascript\nvar Redis = require(\"ioredis\");\nvar redis = new Redis();\n// This command causes a reply error since the SET command requires two arguments.\nredis.set(\"foo\", function(err) {\n  err instanceof Redis.ReplyError;\n});\n```\n\nThis is the error stack of the `ReplyError`:\n\n```\nReplyError: ERR wrong number of arguments for 'set' command\n    at ReplyParser._parseResult (/app/node_modules/ioredis/lib/parsers/javascript.js:60:14)\n    at ReplyParser.execute (/app/node_modules/ioredis/lib/parsers/javascript.js:178:20)\n    at Socket.<anonymous> (/app/node_modules/ioredis/lib/redis/event_handler.js:99:22)\n    at Socket.emit (events.js:97:17)\n    at readableAddChunk (_stream_readable.js:143:16)\n    at Socket.Readable.push (_stream_readable.js:106:10)\n    at TCP.onread (net.js:509:20)\n```\n\nBy default, the error stack doesn't make any sense because the whole stack happens in the ioredis\nmodule itself, not in your code. So it's not easy to find out where the error happens in your code.\nioredis provides an option `showFriendlyErrorStack` to solve the problem. When you enable\n`showFriendlyErrorStack`, ioredis will optimize the error stack for you:\n\n```javascript\nvar Redis = require(\"ioredis\");\nvar redis = new Redis({ showFriendlyErrorStack: true });\nredis.set(\"foo\");\n```\n\nAnd the output will be:\n\n```\nReplyError: ERR wrong number of arguments for 'set' command\n    at Object.<anonymous> (/app/index.js:3:7)\n    at Module._compile (module.js:446:26)\n    at Object.Module._extensions..js (module.js:464:10)\n    at Module.load (module.js:341:32)\n    at Function.Module._load (module.js:296:12)\n    at Function.Module.runMain (module.js:487:10)\n    at startup (node.js:111:16)\n    at node.js:799:3\n```\n\nThis time the stack tells you that the error happens on the third line in your code. Pretty sweet!\nHowever, it would decrease the performance significantly to optimize the error stack. So by\ndefault, this option is disabled and can only be used for debugging purposes. You **shouldn't** use this feature in a production environment.\n\n# Plugging in your own Promises Library\n\nIf you're an advanced user, you may want to plug in your own promise library like [bluebird](https://www.npmjs.com/package/bluebird). Just set Redis.Promise to your favorite ES6-style promise constructor and ioredis will use it.\n\n```javascript\nconst Redis = require(\"ioredis\");\nRedis.Promise = require(\"bluebird\");\n\nconst redis = new Redis();\n\n// Use bluebird\nassert.equal(redis.get().constructor, require(\"bluebird\"));\n\n// You can change the Promise implementation at any time:\nRedis.Promise = global.Promise;\nassert.equal(redis.get().constructor, global.Promise);\n```\n\n# Running tests\n\nStart a Redis server on 127.0.0.1:6379, and then:\n\n```shell\n$ npm test\n```\n\n`FLUSH ALL` will be invoked after each test, so make sure there's no valuable data in it before running tests.\n\nIf your testing environment does not let you spin up a Redis server [ioredis-mock](https://github.com/stipsan/ioredis-mock) is a drop-in replacement you can use in your tests. It aims to behave identically to ioredis connected to a Redis server so that your integration tests is easier to write and of better quality.\n\n# Debug\n\nYou can set the `DEBUG` env to `ioredis:*` to print debug info:\n\n```shell\n$ DEBUG=ioredis:* node app.js\n```\n\n# Join in!\n\nI'm happy to receive bug reports, fixes, documentation enhancements, and any other improvements.\n\nAnd since I'm not a native English speaker, if you find any grammar mistakes in the documentation, please also let me know. :)\n\n# Become a Sponsor\n\nOpen source is hard and time-consuming. If you want to invest in ioredis's future you can become a sponsor and make us spend more time on this library's improvements and new features.\n\n<a href=\"https://opencollective.com/ioredis\"><img src=\"https://opencollective.com/ioredis/tiers/sponsor.svg?avatarHeight=36\"></a>\n\nThank you for using ioredis :-)\n\n# Contributors\n\nThis project exists thanks to all the people who contribute:\n\n<a href=\"https://github.com/luin/ioredis/graphs/contributors\"><img src=\"https://opencollective.com/ioredis/contributors.svg?width=890&showBtn=false\" /></a>\n\n# License\n\nMIT\n\n[![FOSSA Status](https://app.fossa.io/api/projects/git%2Bgithub.com%2Fluin%2Fioredis.svg?type=large)](https://app.fossa.io/projects/git%2Bgithub.com%2Fluin%2Fioredis?ref=badge_large)\n","readmeFilename":"README.md","bugs":{"url":"https://github.com/luin/ioredis/issues"},"homepage":"https://github.com/luin/ioredis#readme","_id":"ioredis@4.14.2","_nodeVersion":"10.17.0","_npmVersion":"6.11.3","dist":{"integrity":"sha512-B7st5okm4tixxlfbAvRWUcEhpCjnfqQ6uxYhEdLEndnFUsKOKgiarqkm5eIdFHN1/s8CCRs0GQhqY7E9ucZ+Ew==","shasum":"f5dc5f9abe202547c04e716f9cccbb5a712ab793","tarball":"https://registry.npmjs.org/ioredis/-/ioredis-4.14.2.tgz","fileCount":36,"unpackedSize":240112,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJdsA6YCRA9TVsSAnZWagAAilsP/jjAWezozV3NhIF0keTK\nMOIqiRKNFzlQz+J78QbkDqGrG1OG++zwWvHktqvvTQ7pfvKT74zSE1pfJlPN\ndNdHDluB6uMEEQr6MkPOuXQ0oMXgWzg2dwimX124wqAfDXUiLte8sSDygenR\n0kxWphwzbZlKgJPygftKBJCQ5584aWZeCt3wzkuqA7Uq68Pk/InNYC3mjWNl\nH8vHFi1PlQeXm893NBkMR4GkR2F9ShFABvLIQnnadLbtTdm7fOoCoLG8VocJ\ng11fWxJBP9NrvblvMUliLKzDCINC//6XyYUXdQdHhesWZ2l04tUqqrBmXfjj\nTY2WMrIQyWB84yLZ+Mi7kLAGVqbRmxPv8bSWD39gtQe4dKzkeh7x/9IfswoD\nNw8xSApK2Hm0533otDWtiGKuYp+r6fD7B3QO5hicrD8vfaZ0uf6djVWhAfjD\n336WG54Y0gHUGSujm1YaqoEGsxtiQFjG1+44TEMObWSI6/1A6nVTYUJeYzdz\naia1db+bNHNnQ2h8iGMsxA1i/5jWuti2PECNgiuWZkwWAOGn34nlLJ4jNk/A\nInlUsfWu6tnaO3eSiymtug19xsM1BRooNQHoICPFha8mood+0eofxyLALIZU\nrNzHqhU8dt0zccHdat/cu4ZrWRlBt/egDCoKyzW6Mtsrf15ih9cNnNzQDVZu\ncfun\r\n=C16d\r\n-----END PGP SIGNATURE-----\r\n"},"maintainers":[{"email":"ioredis-robot@zihua.li","name":"ioredis-robot"},{"email":"i@zihua.li","name":"luin"}],"_npmUser":{"name":"luin","email":"i@zihua.li"},"directories":{},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/ioredis_4.14.2_1571819159594_0.6995063729468156"},"_hasShrinkwrap":false},"4.14.3":{"name":"ioredis","version":"4.14.3","description":"A robust, performance-focused and full-featured Redis client for Node.js.","main":"built/index.js","scripts":{"test":"TS_NODE_TRANSPILE_ONLY=true TS_NODE_LOG_ERROR=true NODE_ENV=test mocha \"test/**/*.ts\"","test:cov":"TS_NODE_TRANSPILE_ONLY=true TS_NODE_LOG_ERROR=true NODE_ENV=test node ./node_modules/istanbul/lib/cli.js cover --preserve-comments ./node_modules/mocha/bin/_mocha -- -r ts-node/register -R spec --exit \"test/**/*.ts\"","lint":"eslint --ext .js,.ts .","format":"prettier --write \"{,!(node_modules)/**/}*.{js,ts}\"","format-check":"prettier --check \"{,!(node_modules)/**/}*.{js,ts}\"","build":"rm -rf built && tsc","prepublishOnly":"npm run build && npm test","bench":"matcha benchmarks/*.js","semantic-release":"semantic-release"},"repository":{"type":"git","url":"git://github.com/luin/ioredis.git"},"keywords":["redis","cluster","sentinel","pipelining"],"author":{"name":"luin","email":"i@zihua.li","url":"http://zihua.li"},"license":"MIT","funding":{"type":"opencollective","url":"https://opencollective.com/ioredis"},"dependencies":{"cluster-key-slot":"^1.1.0","debug":"^4.1.1","denque":"^1.1.0","lodash.defaults":"^4.2.0","lodash.flatten":"^4.4.0","redis-commands":"1.5.0","redis-errors":"^1.2.0","redis-parser":"^3.0.0","standard-as-callback":"^2.0.1"},"devDependencies":{"@semantic-release/changelog":"^3.0.4","@semantic-release/git":"^7.0.12","@types/bluebird":"^3.5.27","@types/chai":"^4.1.7","@types/debug":"^4.1.4","@types/lodash.defaults":"^4.2.6","@types/lodash.flatten":"^4.4.6","@types/mocha":"^5.2.7","@types/node":"^12.0.2","@types/redis-errors":"1.2.0","@types/sinon":"^7.0.13","@typescript-eslint/eslint-plugin":"^1.11.0","@typescript-eslint/parser":"^1.11.0","bluebird":"^3.5.4","chai":"^4.2.0","cz-conventional-changelog":"^2.0.0","eslint":"^5.16.0","eslint-config-prettier":"^5.1.0","husky":"^2.5.0","istanbul":"^0.4.5","mocha":"^5.0.0","prettier":"^1.18.2","pretty-quick":"^1.11.1","server-destroy":"^1.0.1","sinon":"^7.3.2","ts-node":"^8.1.0","typescript":"^3.5.1"},"engines":{"node":">=6"},"config":{"commitizen":{"path":"./node_modules/cz-conventional-changelog"}},"husky":{"hooks":{"pre-commit":"pretty-quick --staged"}},"gitHead":"533346874b7218f76530734fb0651a7c1ef57702","readme":"[![ioredis](https://cdn.jsdelivr.net/gh/luin/ioredis@b5e8c74/logo.svg)](https://github.com/luin/ioredis)\n\n[![Build Status](https://travis-ci.org/luin/ioredis.svg?branch=master)](https://travis-ci.org/luin/ioredis)\n[![Test Coverage](https://codeclimate.com/github/luin/ioredis/badges/coverage.svg)](https://codeclimate.com/github/luin/ioredis)\n[![code style: prettier](https://img.shields.io/badge/code_style-prettier-ff69b4.svg?style=flat-square)](https://github.com/prettier/prettier)\n[![Join the chat at https://gitter.im/luin/ioredis](https://badges.gitter.im/Join%20Chat.svg)](https://gitter.im/luin/ioredis?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge)\n[![Commitizen friendly](https://img.shields.io/badge/commitizen-friendly-brightgreen.svg)](http://commitizen.github.io/cz-cli/)\n[![semantic-release](https://img.shields.io/badge/%20%20%F0%9F%93%A6%F0%9F%9A%80-semantic--release-e10079.svg)](https://github.com/semantic-release/semantic-release)\n[![npm latest version](https://img.shields.io/npm/v/ioredis/latest.svg)](https://www.npmjs.com/package/ioredis)\n[![npm next version](https://img.shields.io/npm/v/ioredis/next.svg)](https://www.npmjs.com/package/ioredis)\n<img alt=\"\" src=\"\">\n\nA robust, performance-focused and full-featured [Redis](http://redis.io) client for [Node.js](https://nodejs.org).\n\nSupports Redis >= 2.6.12 and (Node.js >= 6).\n\n# Features\n\nioredis is a robust, full-featured Redis client that is\nused in the world's biggest online commerce company [Alibaba](http://www.alibaba.com/) and many other awesome companies.\n\n0. Full-featured. It supports [Cluster](http://redis.io/topics/cluster-tutorial), [Sentinel](http://redis.io/topics/sentinel), [Pipelining](http://redis.io/topics/pipelining) and of course [Lua scripting](http://redis.io/commands/eval) & [Pub/Sub](http://redis.io/topics/pubsub) (with the support of binary messages).\n1. High performance.\n2. Delightful API. It works with Node callbacks and Native promises.\n3. Transformation of command arguments and replies.\n4. Transparent key prefixing.\n5. Abstraction for Lua scripting, allowing you to define custom commands.\n6. Support for binary data.\n7. Support for TLS.\n8. Support for offline queue and ready checking.\n9. Support for ES6 types, such as `Map` and `Set`.\n10. Support for GEO commands (Redis 3.2 Unstable).\n11. Sophisticated error handling strategy.\n12. Support for NAT mapping.\n\n# Links\n\n- [API Documentation](API.md)\n- [Changelog](Changelog.md)\n- [Migrating from node_redis](https://github.com/luin/ioredis/wiki/Migrating-from-node_redis)\n- [Error Handling](#error-handling)\n\n<hr>\n<a href=\"http://bit.ly/medis-macos\"><img align=\"right\" src=\"resources/medis.png\" alt=\"Download on the App Store\"></a>\n\n### [AD] Medis: Redis GUI for OS X\n\nLooking for a Redis GUI manager for OS X, Windows and Linux? Here's [Medis](http://bit.ly/medis-macos)!\n\nMedis is an open-sourced, beautiful, easy-to-use Redis GUI management application.\n\nMedis starts with all the basic features you need:\n\n- Keys viewing/editing\n- SSH Tunnel for connecting with remote servers\n- Terminal for executing custom commands\n- JSON/MessagePack format viewing/editing and built-in highlighting/validator\n- And other awesome features...\n\n[Medis is open sourced on GitHub](https://github.com/luin/medis)\n\n### [AD] Kuber: Kubernetes Dashboard for iOS\n\n<a href=\"http://bit.ly/kuber-ios\"><img src=\"resources/kuber.png\" alt=\"Download on the App Store\"></a>\n\n<hr>\n\n# Quick Start\n\n## Install\n\n```shell\n$ npm install ioredis\n```\n\n## Basic Usage\n\n```javascript\nvar Redis = require(\"ioredis\");\nvar redis = new Redis();\n\nredis.set(\"foo\", \"bar\");\nredis.get(\"foo\", function(err, result) {\n  console.log(result);\n});\nredis.del(\"foo\");\n\n// Or using a promise if the last argument isn't a function\nredis.get(\"foo\").then(function(result) {\n  console.log(result);\n});\n\n// Arguments to commands are flattened, so the following are the same:\nredis.sadd(\"set\", 1, 3, 5, 7);\nredis.sadd(\"set\", [1, 3, 5, 7]);\n\n// All arguments are passed directly to the redis server:\nredis.set(\"key\", 100, \"EX\", 10);\n```\n\nSee the `examples/` folder for more examples.\n\n## Connect to Redis\n\nWhen a new `Redis` instance is created,\na connection to Redis will be created at the same time.\nYou can specify which Redis to connect to by:\n\n```javascript\nnew Redis(); // Connect to 127.0.0.1:6379\nnew Redis(6380); // 127.0.0.1:6380\nnew Redis(6379, \"192.168.1.1\"); // 192.168.1.1:6379\nnew Redis(\"/tmp/redis.sock\");\nnew Redis({\n  port: 6379, // Redis port\n  host: \"127.0.0.1\", // Redis host\n  family: 4, // 4 (IPv4) or 6 (IPv6)\n  password: \"auth\",\n  db: 0\n});\n```\n\nYou can also specify connection options as a [`redis://` URL](http://www.iana.org/assignments/uri-schemes/prov/redis) or [`rediss://` URL](https://www.iana.org/assignments/uri-schemes/prov/rediss) when using [TLS encryption](#tls-options):\n\n```javascript\n// Connect to 127.0.0.1:6380, db 4, using password \"authpassword\":\nnew Redis(\"redis://:authpassword@127.0.0.1:6380/4\");\n```\n\nSee [API Documentation](API.md#new_Redis) for all available options.\n\n## Pub/Sub\n\nHere is a simple example of the API for publish/subscribe.\nThe following program opens two client connections.\nIt subscribes to a channel with one connection\nand publishes to that channel with the other:\n\n```javascript\nvar Redis = require(\"ioredis\");\nvar redis = new Redis();\nvar pub = new Redis();\nredis.subscribe(\"news\", \"music\", function(err, count) {\n  // Now we are subscribed to both the 'news' and 'music' channels.\n  // `count` represents the number of channels we are currently subscribed to.\n\n  pub.publish(\"news\", \"Hello world!\");\n  pub.publish(\"music\", \"Hello again!\");\n});\n\nredis.on(\"message\", function(channel, message) {\n  // Receive message Hello world! from channel news\n  // Receive message Hello again! from channel music\n  console.log(\"Receive message %s from channel %s\", message, channel);\n});\n\n// There's also an event called 'messageBuffer', which is the same as 'message' except\n// it returns buffers instead of strings.\nredis.on(\"messageBuffer\", function(channel, message) {\n  // Both `channel` and `message` are buffers.\n});\n```\n\n`PSUBSCRIBE` is also supported in a similar way:\n\n```javascript\nredis.psubscribe(\"pat?ern\", function(err, count) {});\nredis.on(\"pmessage\", function(pattern, channel, message) {});\nredis.on(\"pmessageBuffer\", function(pattern, channel, message) {});\n```\n\nWhen a client issues a SUBSCRIBE or PSUBSCRIBE, that connection is put into a \"subscriber\" mode.\nAt that point, only commands that modify the subscription set are valid.\nWhen the subscription set is empty, the connection is put back into regular mode.\n\nIf you need to send regular commands to Redis while in subscriber mode, just open another connection.\n\n## Handle Binary Data\n\nArguments can be buffers:\n\n```javascript\nredis.set(\"foo\", Buffer.from(\"bar\"));\n```\n\nAnd every command has a method that returns a Buffer (by adding a suffix of \"Buffer\" to the command name).\nTo get a buffer instead of a utf8 string:\n\n```javascript\nredis.getBuffer(\"foo\", function(err, result) {\n  // result is a buffer.\n});\n```\n\n## Pipelining\n\nIf you want to send a batch of commands (e.g. > 5), you can use pipelining to queue\nthe commands in memory and then send them to Redis all at once. This way the performance improves by 50%~300% (See [benchmark section](#benchmark)).\n\n`redis.pipeline()` creates a `Pipeline` instance. You can call any Redis\ncommands on it just like the `Redis` instance. The commands are queued in memory\nand flushed to Redis by calling the `exec` method:\n\n```javascript\nvar pipeline = redis.pipeline();\npipeline.set(\"foo\", \"bar\");\npipeline.del(\"cc\");\npipeline.exec(function(err, results) {\n  // `err` is always null, and `results` is an array of responses\n  // corresponding to the sequence of queued commands.\n  // Each response follows the format `[err, result]`.\n});\n\n// You can even chain the commands:\nredis\n  .pipeline()\n  .set(\"foo\", \"bar\")\n  .del(\"cc\")\n  .exec(function(err, results) {});\n\n// `exec` also returns a Promise:\nvar promise = redis\n  .pipeline()\n  .set(\"foo\", \"bar\")\n  .get(\"foo\")\n  .exec();\npromise.then(function(result) {\n  // result === [[null, 'OK'], [null, 'bar']]\n});\n```\n\nEach chained command can also have a callback, which will be invoked when the command\ngets a reply:\n\n```javascript\nredis\n  .pipeline()\n  .set(\"foo\", \"bar\")\n  .get(\"foo\", function(err, result) {\n    // result === 'bar'\n  })\n  .exec(function(err, result) {\n    // result[1][1] === 'bar'\n  });\n```\n\nIn addition to adding commands to the `pipeline` queue individually, you can also pass an array of commands and arguments to the constructor:\n\n```javascript\nredis.pipeline([[\"set\", \"foo\", \"bar\"], [\"get\", \"foo\"]]).exec(function() {\n  /* ... */\n});\n```\n\n`#length` property shows how many commands in the pipeline:\n\n```javascript\nconst length = redis\n  .pipeline()\n  .set(\"foo\", \"bar\")\n  .get(\"foo\").length;\n// length === 2\n```\n\n## Transaction\n\nMost of the time, the transaction commands `multi` & `exec` are used together with pipeline.\nTherefore, when `multi` is called, a `Pipeline` instance is created automatically by default,\nso you can use `multi` just like `pipeline`:\n\n```javascript\nredis\n  .multi()\n  .set(\"foo\", \"bar\")\n  .get(\"foo\")\n  .exec(function(err, results) {\n    // results === [[null, 'OK'], [null, 'bar']]\n  });\n```\n\nIf there's a syntax error in the transaction's command chain (e.g. wrong number of arguments, wrong command name, etc),\nthen none of the commands would be executed, and an error is returned:\n\n```javascript\nredis\n  .multi()\n  .set(\"foo\")\n  .set(\"foo\", \"new value\")\n  .exec(function(err, results) {\n    // err:\n    //  { [ReplyError: EXECABORT Transaction discarded because of previous errors.]\n    //    name: 'ReplyError',\n    //    message: 'EXECABORT Transaction discarded because of previous errors.',\n    //    command: { name: 'exec', args: [] },\n    //    previousErrors:\n    //     [ { [ReplyError: ERR wrong number of arguments for 'set' command]\n    //         name: 'ReplyError',\n    //         message: 'ERR wrong number of arguments for \\'set\\' command',\n    //         command: [Object] } ] }\n  });\n```\n\nIn terms of the interface, `multi` differs from `pipeline` in that when specifying a callback\nto each chained command, the queueing state is passed to the callback instead of the result of the command:\n\n```javascript\nredis\n  .multi()\n  .set(\"foo\", \"bar\", function(err, result) {\n    // result === 'QUEUED'\n  })\n  .exec(/* ... */);\n```\n\nIf you want to use transaction without pipeline, pass `{ pipeline: false }` to `multi`,\nand every command will be sent to Redis immediately without waiting for an `exec` invocation:\n\n```javascript\nredis.multi({ pipeline: false });\nredis.set(\"foo\", \"bar\");\nredis.get(\"foo\");\nredis.exec(function(err, result) {\n  // result === [[null, 'OK'], [null, 'bar']]\n});\n```\n\nThe constructor of `multi` also accepts a batch of commands:\n\n```javascript\nredis.multi([[\"set\", \"foo\", \"bar\"], [\"get\", \"foo\"]]).exec(function() {\n  /* ... */\n});\n```\n\nInline transactions are supported by pipeline, which means you can group a subset of commands\nin the pipeline into a transaction:\n\n```javascript\nredis\n  .pipeline()\n  .get(\"foo\")\n  .multi()\n  .set(\"foo\", \"bar\")\n  .get(\"foo\")\n  .exec()\n  .get(\"foo\")\n  .exec();\n```\n\n## Lua Scripting\n\nioredis supports all of the scripting commands such as `EVAL`, `EVALSHA` and `SCRIPT`.\nHowever, it's tedious to use in real world scenarios since developers have to take\ncare of script caching and to detect when to use `EVAL` and when to use `EVALSHA`.\nioredis exposes a `defineCommand` method to make scripting much easier to use:\n\n```javascript\nvar redis = new Redis();\n\n// This will define a command echo:\nredis.defineCommand(\"echo\", {\n  numberOfKeys: 2,\n  lua: \"return {KEYS[1],KEYS[2],ARGV[1],ARGV[2]}\"\n});\n\n// Now `echo` can be used just like any other ordinary command,\n// and ioredis will try to use `EVALSHA` internally when possible for better performance.\nredis.echo(\"k1\", \"k2\", \"a1\", \"a2\", function(err, result) {\n  // result === ['k1', 'k2', 'a1', 'a2']\n});\n\n// `echoBuffer` is also defined automatically to return buffers instead of strings:\nredis.echoBuffer(\"k1\", \"k2\", \"a1\", \"a2\", function(err, result) {\n  // result[0] equals to Buffer.from('k1');\n});\n\n// And of course it works with pipeline:\nredis\n  .pipeline()\n  .set(\"foo\", \"bar\")\n  .echo(\"k1\", \"k2\", \"a1\", \"a2\")\n  .exec();\n```\n\nIf the number of keys can't be determined when defining a command, you can\nomit the `numberOfKeys` property and pass the number of keys as the first argument\nwhen you call the command:\n\n```javascript\nredis.defineCommand(\"echoDynamicKeyNumber\", {\n  lua: \"return {KEYS[1],KEYS[2],ARGV[1],ARGV[2]}\"\n});\n\n// Now you have to pass the number of keys as the first argument every time\n// you invoke the `echoDynamicKeyNumber` command:\nredis.echoDynamicKeyNumber(2, \"k1\", \"k2\", \"a1\", \"a2\", function(err, result) {\n  // result === ['k1', 'k2', 'a1', 'a2']\n});\n```\n\n## Transparent Key Prefixing\n\nThis feature allows you to specify a string that will automatically be prepended\nto all the keys in a command, which makes it easier to manage your key\nnamespaces.\n\n**Warning** This feature won't apply to commands like [KEYS](http://redis.io/commands/KEYS) and [SCAN](http://redis.io/commands/scan) that take patterns rather than actual keys([#239](https://github.com/luin/ioredis/issues/239)),\nand this feature also won't apply to the replies of commands even they are key names ([#325](https://github.com/luin/ioredis/issues/325)).\n\n```javascript\nvar fooRedis = new Redis({ keyPrefix: \"foo:\" });\nfooRedis.set(\"bar\", \"baz\"); // Actually sends SET foo:bar baz\n\nfooRedis.defineCommand(\"echo\", {\n  numberOfKeys: 2,\n  lua: \"return {KEYS[1],KEYS[2],ARGV[1],ARGV[2]}\"\n});\n\n// Works well with pipelining/transaction\nfooRedis\n  .pipeline()\n  // Sends SORT foo:list BY foo:weight_*->fieldname\n  .sort(\"list\", \"BY\", \"weight_*->fieldname\")\n  // Supports custom commands\n  // Sends EVALSHA xxx foo:k1 foo:k2 a1 a2\n  .echo(\"k1\", \"k2\", \"a1\", \"a2\")\n  .exec();\n```\n\n## Transforming Arguments & Replies\n\nMost Redis commands take one or more Strings as arguments,\nand replies are sent back as a single String or an Array of Strings. However, sometimes\nyou may want something different. For instance, it would be more convenient if the `HGETALL`\ncommand returns a hash (e.g. `{ key: val1, key2: v2 }`) rather than an array of key values (e.g. `[key1, val1, key2, val2]`).\n\nioredis has a flexible system for transforming arguments and replies. There are two types\nof transformers, argument transformer and reply transformer:\n\n```javascript\nvar Redis = require(\"ioredis\");\n\n// Here's the built-in argument transformer converting\n// hmset('key', { k1: 'v1', k2: 'v2' })\n// or\n// hmset('key', new Map([['k1', 'v1'], ['k2', 'v2']]))\n// into\n// hmset('key', 'k1', 'v1', 'k2', 'v2')\nRedis.Command.setArgumentTransformer(\"hmset\", function(args) {\n  if (args.length === 2) {\n    if (typeof Map !== \"undefined\" && args[1] instanceof Map) {\n      // utils is a internal module of ioredis\n      return [args[0]].concat(utils.convertMapToArray(args[1]));\n    }\n    if (typeof args[1] === \"object\" && args[1] !== null) {\n      return [args[0]].concat(utils.convertObjectToArray(args[1]));\n    }\n  }\n  return args;\n});\n\n// Here's the built-in reply transformer converting the HGETALL reply\n// ['k1', 'v1', 'k2', 'v2']\n// into\n// { k1: 'v1', 'k2': 'v2' }\nRedis.Command.setReplyTransformer(\"hgetall\", function(result) {\n  if (Array.isArray(result)) {\n    var obj = {};\n    for (var i = 0; i < result.length; i += 2) {\n      obj[result[i]] = result[i + 1];\n    }\n    return obj;\n  }\n  return result;\n});\n```\n\nThere are three built-in transformers, two argument transformers for `hmset` & `mset` and\na reply transformer for `hgetall`. Transformers for `hmset` and `hgetall` were mentioned\nabove, and the transformer for `mset` is similar to the one for `hmset`:\n\n```javascript\nredis.mset({ k1: \"v1\", k2: \"v2\" });\nredis.get(\"k1\", function(err, result) {\n  // result === 'v1';\n});\n\nredis.mset(new Map([[\"k3\", \"v3\"], [\"k4\", \"v4\"]]));\nredis.get(\"k3\", function(err, result) {\n  // result === 'v3';\n});\n```\n\nAnother useful example of a reply transformer is one that changes `hgetall` to return array of arrays instead of objects which avoids a unwanted conversation of hash keys to strings when dealing with binary hash keys:\n\n```javascript\nRedis.Command.setReplyTransformer(\"hgetall\", function(result) {\n  var arr = [];\n  for (var i = 0; i < result.length; i += 2) {\n    arr.push([result[i], result[i + 1]]);\n  }\n  return arr;\n});\nredis.hset(\"h1\", Buffer.from([0x01]), Buffer.from([0x02]));\nredis.hset(\"h1\", Buffer.from([0x03]), Buffer.from([0x04]));\nredis.hgetallBuffer(\"h1\", function(err, result) {\n  // result === [ [ <Buffer 01>, <Buffer 02> ], [ <Buffer 03>, <Buffer 04> ] ];\n});\n```\n\n## Monitor\n\nRedis supports the MONITOR command,\nwhich lets you see all commands received by the Redis server across all client connections,\nincluding from other client libraries and other computers.\n\nThe `monitor` method returns a monitor instance.\nAfter you send the MONITOR command, no other commands are valid on that connection. ioredis will emit a monitor event for every new monitor message that comes across.\nThe callback for the monitor event takes a timestamp from the Redis server and an array of command arguments.\n\nHere is a simple example:\n\n```javascript\nredis.monitor(function(err, monitor) {\n  monitor.on(\"monitor\", function(time, args, source, database) {});\n});\n```\nHere is another example illustrating an `async` function and `monitor.disconnect()`:\n```javascript\nasync () => {\n  const monitor = await redis.monitor()\n  monitor.on('monitor', console.log)\n  // Any other tasks\n  monitor.disconnect()\n}\n```\n## Streamify Scanning\n\nRedis 2.8 added the `SCAN` command to incrementally iterate through the keys in the database. It's different from `KEYS` in that\n`SCAN` only returns a small number of elements each call, so it can be used in production without the downside\nof blocking the server for a long time. However, it requires recording the cursor on the client side each time\nthe `SCAN` command is called in order to iterate through all the keys correctly. Since it's a relatively common use case, ioredis\nprovides a streaming interface for the `SCAN` command to make things much easier. A readable stream can be created by calling `scanStream`:\n\n```javascript\nvar redis = new Redis();\n// Create a readable stream (object mode)\nvar stream = redis.scanStream();\nstream.on(\"data\", function(resultKeys) {\n  // `resultKeys` is an array of strings representing key names.\n  // Note that resultKeys may contain 0 keys, and that it will sometimes\n  // contain duplicates due to SCAN's implementation in Redis.\n  for (var i = 0; i < resultKeys.length; i++) {\n    console.log(resultKeys[i]);\n  }\n});\nstream.on(\"end\", function() {\n  console.log(\"all keys have been visited\");\n});\n```\n\n`scanStream` accepts an option, with which you can specify the `MATCH` pattern and the `COUNT` argument:\n\n```javascript\nvar stream = redis.scanStream({\n  // only returns keys following the pattern of `user:*`\n  match: \"user:*\",\n  // returns approximately 100 elements per call\n  count: 100\n});\n```\n\nJust like other commands, `scanStream` has a binary version `scanBufferStream`, which returns an array of buffers. It's useful when\nthe key names are not utf8 strings.\n\nThere are also `hscanStream`, `zscanStream` and `sscanStream` to iterate through elements in a hash, zset and set. The interface of each is\nsimilar to `scanStream` except the first argument is the key name:\n\n```javascript\nvar stream = redis.hscanStream(\"myhash\", {\n  match: \"age:??\"\n});\n```\n\nYou can learn more from the [Redis documentation](http://redis.io/commands/scan).\n\n**Useful Tips**\nIt's pretty common that doing an async task in the `data` handler. We'd like the scanning process to be paused until the async task to be finished. `Stream#pause()` and `Stream.resume()` do the trick. For example if we want to migrate data in Redis to MySQL:\n\n```javascript\nvar stream = redis.scanStream();\nstream.on(\"data\", function(resultKeys) {\n  // Pause the stream from scanning more keys until we've migrated the current keys.\n  stream.pause();\n\n  Promise.all(resultKeys.map(migrateKeyToMySQL)).then(() => {\n    // Resume the stream here.\n    stream.resume();\n  });\n});\n\nstream.on(\"end\", function() {\n  console.log(\"done migration\");\n});\n```\n\n## Auto-reconnect\n\nBy default, ioredis will try to reconnect when the connection to Redis is lost\nexcept when the connection is closed manually by `redis.disconnect()` or `redis.quit()`.\n\nIt's very flexible to control how long to wait to reconnect after disconnection\nusing the `retryStrategy` option:\n\n```javascript\nvar redis = new Redis({\n  // This is the default value of `retryStrategy`\n  retryStrategy: function(times) {\n    var delay = Math.min(times * 50, 2000);\n    return delay;\n  }\n});\n```\n\n`retryStrategy` is a function that will be called when the connection is lost.\nThe argument `times` means this is the nth reconnection being made and\nthe return value represents how long (in ms) to wait to reconnect. When the\nreturn value isn't a number, ioredis will stop trying to reconnect, and the connection\nwill be lost forever if the user doesn't call `redis.connect()` manually.\n\nWhen reconnected, the client will auto subscribe to channels that the previous connection subscribed to.\nThis behavior can be disabled by setting the `autoResubscribe` option to `false`.\n\nAnd if the previous connection has some unfulfilled commands (most likely blocking commands such as `brpop` and `blpop`),\nthe client will resend them when reconnected. This behavior can be disabled by setting the `autoResendUnfulfilledCommands` option to `false`.\n\nBy default, all pending commands will be flushed with an error every 20 retry attempts. That makes sure commands won't wait forever when the connection is down. You can change this behavior by setting `maxRetriesPerRequest`:\n\n```javascript\nvar redis = new Redis({\n  maxRetriesPerRequest: 1\n});\n```\n\nSet maxRetriesPerRequest to `null` to disable this behavior, and every command will wait forever until the connection is alive again (which is the default behavior before ioredis v4).\n\n### Reconnect on error\n\nBesides auto-reconnect when the connection is closed, ioredis supports reconnecting on the specified errors by the `reconnectOnError` option. Here's an example that will reconnect when receiving `READONLY` error:\n\n```javascript\nvar redis = new Redis({\n  reconnectOnError: function(err) {\n    var targetError = \"READONLY\";\n    if (err.message.slice(0, targetError.length) === targetError) {\n      // Only reconnect when the error starts with \"READONLY\"\n      return true; // or `return 1;`\n    }\n  }\n});\n```\n\nThis feature is useful when using Amazon ElastiCache. Once failover happens, Amazon ElastiCache will switch the master we currently connected with to a slave, leading to the following writes fails with the error `READONLY`. Using `reconnectOnError`, we can force the connection to reconnect on this error in order to connect to the new master.\n\nFurthermore, if the `reconnectOnError` returns `2`, ioredis will resend the failed command after reconnecting.\n\n## Connection Events\n\nThe Redis instance will emit some events about the state of the connection to the Redis server.\n\n| Event        | Description                                                                                                                                                                                                                                     |\n| :----------- | :---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| connect      | emits when a connection is established to the Redis server.                                                                                                                                                                                     |\n| ready        | If `enableReadyCheck` is `true`, client will emit `ready` when the server reports that it is ready to receive commands (e.g. finish loading data from disk).<br>Otherwise, `ready` will be emitted immediately right after the `connect` event. |\n| error        | emits when an error occurs while connecting.<br>However, ioredis emits all `error` events silently (only emits when there's at least one listener) so that your application won't crash if you're not listening to the `error` event.           |\n| close        | emits when an established Redis server connection has closed.                                                                                                                                                                                   |\n| reconnecting | emits after `close` when a reconnection will be made. The argument of the event is the time (in ms) before reconnecting.                                                                                                                        |\n| end          | emits after `close` when no more reconnections will be made, or the connection is failed to establish.                                                                                                                                          |\n\nYou can also check out the `Redis#status` property to get the current connection status.\n\nBesides the above connection events, there are several other custom events:\n\n| Event  | Description                                                         |\n| :----- | :------------------------------------------------------------------ |\n| select | emits when the database changed. The argument is the new db number. |\n\n## Offline Queue\n\nWhen a command can't be processed by Redis (being sent before the `ready` event), by default, it's added to the offline queue and will be\nexecuted when it can be processed. You can disable this feature by setting the `enableOfflineQueue`\noption to `false`:\n\n```javascript\nvar redis = new Redis({ enableOfflineQueue: false });\n```\n\n## TLS Options\n\nRedis doesn't support TLS natively, however if the redis server you want to connect to is hosted behind a TLS proxy (e.g. [stunnel](https://www.stunnel.org/)) or is offered by a PaaS service that supports TLS connection (e.g. [Redis Labs](https://redislabs.com/)), you can set the `tls` option:\n\n```javascript\nvar redis = new Redis({\n  host: \"localhost\",\n  tls: {\n    // Refer to `tls.connect()` section in\n    // https://nodejs.org/api/tls.html\n    // for all supported options\n    ca: fs.readFileSync(\"cert.pem\")\n  }\n});\n```\n\nAlternatively, specify the connection through a [`rediss://` URL](https://www.iana.org/assignments/uri-schemes/prov/rediss).\n\n```javascript\nvar redis = new Redis(\"rediss://redis.my-service.com\");\n```\n\n<hr>\n\n## Sentinel\n\nioredis supports Sentinel out of the box. It works transparently as all features that work when\nyou connect to a single node also work when you connect to a sentinel group. Make sure to run Redis >= 2.8.12 if you want to use this feature. Sentinels have a default port of 26379.\n\nTo connect using Sentinel, use:\n\n```javascript\nvar redis = new Redis({\n  sentinels: [\n    { host: \"localhost\", port: 26379 },\n    { host: \"localhost\", port: 26380 }\n  ],\n  name: \"mymaster\"\n});\n\nredis.set(\"foo\", \"bar\");\n```\n\nThe arguments passed to the constructor are different from the ones you use to connect to a single node, where:\n\n- `name` identifies a group of Redis instances composed of a master and one or more slaves (`mymaster` in the example);\n- `sentinelPassword` (optional) password for Sentinel instances.\n- `sentinels` are a list of sentinels to connect to. The list does not need to enumerate all your sentinel instances, but a few so that if one is down the client will try the next one.\n- `role` (optional) with a value of `slave` will return a random slave from the Sentinel group.\n- `preferredSlaves` (optional) can be used to prefer a particular slave or set of slaves based on priority. It accepts a function or array.\n\nioredis **guarantees** that the node you connected to is always a master even after a failover. When a failover happens, instead of trying to reconnect to the failed node (which will be demoted to slave when it's available again), ioredis will ask sentinels for the new master node and connect to it. All commands sent during the failover are queued and will be executed when the new connection is established so that none of the commands will be lost.\n\nIt's possible to connect to a slave instead of a master by specifying the option `role` with the value of `slave` and ioredis will try to connect to a random slave of the specified master, with the guarantee that the connected node is always a slave. If the current node is promoted to master due to a failover, ioredis will disconnect from it and ask the sentinels for another slave node to connect to.\n\nIf you specify the option `preferredSlaves` along with `role: 'slave'` ioredis will attempt to use this value when selecting the slave from the pool of available slaves. The value of `preferredSlaves` should either be a function that accepts an array of avaiable slaves and returns a single result, or an array of slave values priorities by the lowest `prio` value first with a default value of `1`.\n\n```javascript\n// available slaves format\nvar availableSlaves = [{ ip: \"127.0.0.1\", port: \"31231\", flags: \"slave\" }];\n\n// preferredSlaves array format\nvar preferredSlaves = [\n  { ip: \"127.0.0.1\", port: \"31231\", prio: 1 },\n  { ip: \"127.0.0.1\", port: \"31232\", prio: 2 }\n];\n\n// preferredSlaves function format\npreferredSlaves = function(availableSlaves) {\n  for (var i = 0; i < availableSlaves.length; i++) {\n    var slave = availableSlaves[i];\n    if (slave.ip === \"127.0.0.1\") {\n      if (slave.port === \"31234\") {\n        return slave;\n      }\n    }\n  }\n  // if no preferred slaves are available a random one is used\n  return false;\n};\n\nvar redis = new Redis({\n  sentinels: [\n    { host: \"127.0.0.1\", port: 26379 },\n    { host: \"127.0.0.1\", port: 26380 }\n  ],\n  name: \"mymaster\",\n  role: \"slave\",\n  preferredSlaves: preferredSlaves\n});\n```\n\nBesides the `retryStrategy` option, there's also a `sentinelRetryStrategy` in Sentinel mode which will be invoked when all the sentinel nodes are unreachable during connecting. If `sentinelRetryStrategy` returns a valid delay time, ioredis will try to reconnect from scratch. The default value of `sentinelRetryStrategy` is:\n\n```javascript\nfunction (times) {\n  var delay = Math.min(times * 10, 1000);\n  return delay;\n}\n```\n\n## Cluster\n\nRedis Cluster provides a way to run a Redis installation where data is automatically sharded across multiple Redis nodes.\nYou can connect to a Redis Cluster like this:\n\n```javascript\nvar Redis = require(\"ioredis\");\n\nvar cluster = new Redis.Cluster([\n  {\n    port: 6380,\n    host: \"127.0.0.1\"\n  },\n  {\n    port: 6381,\n    host: \"127.0.0.1\"\n  }\n]);\n\ncluster.set(\"foo\", \"bar\");\ncluster.get(\"foo\", function(err, res) {\n  // res === 'bar'\n});\n```\n\n`Cluster` constructor accepts two arguments, where:\n\n0.  The first argument is a list of nodes of the cluster you want to connect to.\n    Just like Sentinel, the list does not need to enumerate all your cluster nodes,\n    but a few so that if one is unreachable the client will try the next one, and the client will discover other nodes automatically when at least one node is connected.\n1.  The second argument is the options, where:\n\n    - `clusterRetryStrategy`: When none of the startup nodes are reachable, `clusterRetryStrategy` will be invoked. When a number is returned,\n      ioredis will try to reconnect to the startup nodes from scratch after the specified delay (in ms). Otherwise, an error of \"None of startup nodes is available\" will be returned.\n      The default value of this option is:\n\n          ```javascript\n          function (times) {\n            var delay = Math.min(100 + times * 2, 2000);\n            return delay;\n          }\n          ```\n\n          It's possible to modify the `startupNodes` property in order to switch to another set of nodes here:\n\n          ```javascript\n          function (times) {\n            this.startupNodes = [{ port: 6790, host: '127.0.0.1' }];\n            return Math.min(100 + times * 2, 2000);\n          }\n          ```\n\n    - `dnsLookup`: Alternative DNS lookup function (`dns.lookup()` is used by default). It may be useful to override this in special cases, such as when AWS ElastiCache used with TLS enabled.\n    - `enableOfflineQueue`: Similar to the `enableOfflineQueue` option of `Redis` class.\n    - `enableReadyCheck`: When enabled, \"ready\" event will only be emitted when `CLUSTER INFO` command\n      reporting the cluster is ready for handling commands. Otherwise, it will be emitted immediately after \"connect\" is emitted.\n    - `scaleReads`: Config where to send the read queries. See below for more details.\n    - `maxRedirections`: When a cluster related error (e.g. `MOVED`, `ASK` and `CLUSTERDOWN` etc.) is received, the client will redirect the\n      command to another node. This option limits the max redirections allowed when sending a command. The default value is `16`.\n    - `retryDelayOnFailover`: If the target node is disconnected when sending a command,\n      ioredis will retry after the specified delay. The default value is `100`. You should make sure `retryDelayOnFailover * maxRedirections > cluster-node-timeout`\n      to insure that no command will fail during a failover.\n    - `retryDelayOnClusterDown`: When a cluster is down, all commands will be rejected with the error of `CLUSTERDOWN`. If this option is a number (by default, it is `100`), the client\n      will resend the commands after the specified time (in ms).\n    - `retryDelayOnTryAgain`: If this option is a number (by default, it is `100`), the client\n      will resend the commands rejected with `TRYAGAIN` error after the specified time (in ms).\n    - `redisOptions`: Default options passed to the constructor of `Redis` when connecting to a node.\n    - `slotsRefreshTimeout`: Milliseconds before a timeout occurs while refreshing slots from the cluster (default `1000`)\n    - `slotsRefreshInterval`: Milliseconds between every automatic slots refresh (default `5000`)\n\n### Read-write splitting\n\nA typical redis cluster contains three or more masters and several slaves for each master. It's possible to scale out redis cluster by sending read queries to slaves and write queries to masters by setting the `scaleReads` option.\n\n`scaleReads` is \"master\" by default, which means ioredis will never send any queries to slaves. There are other three available options:\n\n1. \"all\": Send write queries to masters and read queries to masters or slaves randomly.\n2. \"slave\": Send write queries to masters and read queries to slaves.\n3. a custom `function(nodes, command): node`: Will choose the custom function to select to which node to send read queries (write queries keep being sent to master). The first node in `nodes` is always the master serving the relevant slots. If the function returns an array of nodes, a random node of that list will be selected.\n\nFor example:\n\n```javascript\nvar cluster = new Redis.Cluster(\n  [\n    /* nodes */\n  ],\n  {\n    scaleReads: \"slave\"\n  }\n);\ncluster.set(\"foo\", \"bar\"); // This query will be sent to one of the masters.\ncluster.get(\"foo\", function(err, res) {\n  // This query will be sent to one of the slaves.\n});\n```\n\n**NB** In the code snippet above, the `res` may not be equal to \"bar\" because of the lag of replication between the master and slaves.\n\n### Running commands to multiple nodes\n\nEvery command will be sent to exactly one node. For commands containing keys, (e.g. `GET`, `SET` and `HGETALL`), ioredis sends them to the node that serving the keys, and for other commands not containing keys, (e.g. `INFO`, `KEYS` and `FLUSHDB`), ioredis sends them to a random node.\n\nSometimes you may want to send a command to multiple nodes (masters or slaves) of the cluster, you can get the nodes via `Cluster#nodes()` method.\n\n`Cluster#nodes()` accepts a parameter role, which can be \"master\", \"slave\" and \"all\" (default), and returns an array of `Redis` instance. For example:\n\n```javascript\n// Send `FLUSHDB` command to all slaves:\nvar slaves = cluster.nodes(\"slave\");\nPromise.all(\n  slaves.map(function(node) {\n    return node.flushdb();\n  })\n);\n\n// Get keys of all the masters:\nvar masters = cluster.nodes(\"master\");\nPromise.all(\n  masters.map(function(node) {\n    return node.keys();\n  })\n).then(function(keys) {\n  // keys: [['key1', 'key2'], ['key3', 'key4']]\n});\n```\n\n### NAT Mapping\n\nSometimes the cluster is hosted within a internal network that can only be accessed via a NAT (Network Address Translation) instance. See [Accessing ElastiCache from outside AWS](https://docs.aws.amazon.com/AmazonElastiCache/latest/red-ug/accessing-elasticache.html) as an example.\n\nYou can specify nat mapping rules via `natMap` option:\n\n```javascript\nconst cluster = new Redis.Cluster(\n  [\n    {\n      host: \"203.0.113.73\",\n      port: 30001\n    }\n  ],\n  {\n    natMap: {\n      \"10.0.1.230:30001\": { host: \"203.0.113.73\", port: 30001 },\n      \"10.0.1.231:30001\": { host: \"203.0.113.73\", port: 30002 },\n      \"10.0.1.232:30001\": { host: \"203.0.113.73\", port: 30003 }\n    }\n  }\n);\n```\n\nThis option is also useful when the cluster is running inside a Docker container.\n\n### Transaction and pipeline in Cluster mode\n\nAlmost all features that are supported by `Redis` are also supported by `Redis.Cluster`, e.g. custom commands, transaction and pipeline.\nHowever there are some differences when using transaction and pipeline in Cluster mode:\n\n0. All keys in a pipeline should belong to the same slot since ioredis sends all commands in a pipeline to the same node.\n1. You can't use `multi` without pipeline (aka `cluster.multi({ pipeline: false })`). This is because when you call `cluster.multi({ pipeline: false })`, ioredis doesn't know which node the `multi` command should be sent to.\n2. Chaining custom commands in the pipeline is not supported in Cluster mode.\n\nWhen any commands in a pipeline receives a `MOVED` or `ASK` error, ioredis will resend the whole pipeline to the specified node automatically if all of the following conditions are satisfied:\n\n0. All errors received in the pipeline are the same. For example, we won't resend the pipeline if we got two `MOVED` errors pointing to different nodes.\n1. All commands executed successfully are readonly commands. This makes sure that resending the pipeline won't have side effects.\n\n### Pub/Sub\n\nPub/Sub in cluster mode works exactly as the same as in standalone mode. Internally, when a node of the cluster receives a message, it will broadcast the message to the other nodes. ioredis makes sure that each message will only be received once by strictly subscribing one node at the same time.\n\n```javascript\nvar nodes = [\n  /* nodes */\n];\nvar pub = new Redis.Cluster(nodes);\nvar sub = new Redis.Cluster(nodes);\nsub.on(\"message\", function(channel, message) {\n  console.log(channel, message);\n});\n\nsub.subscribe(\"news\", function() {\n  pub.publish(\"news\", \"highlights\");\n});\n```\n\n### Events\n\n| Event        | Description                                                                                                                                                                                                |\n| :----------- | :--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| connect      | emits when a connection is established to the Redis server.                                                                                                                                                |\n| ready        | emits when `CLUSTER INFO` reporting the cluster is able to receive commands (if `enableReadyCheck` is `true`) or immediately after `connect` event (if `enableReadyCheck` is false).                       |\n| error        | emits when an error occurs while connecting with a property of `lastNodeError` representing the last node error received. This event is emitted silently (only emitting if there's at least one listener). |\n| close        | emits when an established Redis server connection has closed.                                                                                                                                              |\n| reconnecting | emits after `close` when a reconnection will be made. The argument of the event is the time (in ms) before reconnecting.                                                                                   |\n| end          | emits after `close` when no more reconnections will be made.                                                                                                                                               |\n| +node        | emits when a new node is connected.                                                                                                                                                                        |\n| -node        | emits when a node is disconnected.                                                                                                                                                                         |\n| node error   | emits when an error occurs when connecting to a node. The second argument indicates the address of the node.                                                                                               |\n\n### Password\n\nSetting the `password` option to access password-protected clusters:\n\n```javascript\nvar Redis = require(\"ioredis\");\nvar cluster = new Redis.Cluster(nodes, {\n  redisOptions: {\n    password: \"your-cluster-password\"\n  }\n});\n```\n\nIf some of nodes in the cluster using a different password, you should specify them in the first parameter:\n\n```javascript\nvar Redis = require(\"ioredis\");\nvar cluster = new Redis.Cluster(\n  [\n    // Use password \"password-for-30001\" for 30001\n    { port: 30001, password: \"password-for-30001\" },\n    // Don't use password when accessing 30002\n    { port: 30002, password: null }\n    // Other nodes will use \"fallback-password\"\n  ],\n  {\n    redisOptions: {\n      password: \"fallback-password\"\n    }\n  }\n);\n```\n\n### Special note: AWS ElastiCache Clusters with TLS\n\nAWS ElastiCache for Redis (Clustered Mode) supports TLS encryption. If you use\nthis, you may encounter errors with invalid certificates. To resolve this\nissue, construct the `Cluster` with the `dnsLookup` option as follows:\n\n```javascript\nvar cluster = new Redis.Cluster(\n  [{\n    host: 'clustercfg.myCluster.abcdefg.xyz.cache.amazonaws.com',\n    port: 6379\n  }],\n  {\n    dnsLookup: (address, callback) => callback(null, address),\n    redisOptions: {\n      tls: {}\n    },\n  }\n};\n```\n\n<hr>\n\n# Error Handling\n\nAll the errors returned by the Redis server are instances of `ReplyError`, which can be accessed via `Redis`:\n\n```javascript\nvar Redis = require(\"ioredis\");\nvar redis = new Redis();\n// This command causes a reply error since the SET command requires two arguments.\nredis.set(\"foo\", function(err) {\n  err instanceof Redis.ReplyError;\n});\n```\n\nThis is the error stack of the `ReplyError`:\n\n```\nReplyError: ERR wrong number of arguments for 'set' command\n    at ReplyParser._parseResult (/app/node_modules/ioredis/lib/parsers/javascript.js:60:14)\n    at ReplyParser.execute (/app/node_modules/ioredis/lib/parsers/javascript.js:178:20)\n    at Socket.<anonymous> (/app/node_modules/ioredis/lib/redis/event_handler.js:99:22)\n    at Socket.emit (events.js:97:17)\n    at readableAddChunk (_stream_readable.js:143:16)\n    at Socket.Readable.push (_stream_readable.js:106:10)\n    at TCP.onread (net.js:509:20)\n```\n\nBy default, the error stack doesn't make any sense because the whole stack happens in the ioredis\nmodule itself, not in your code. So it's not easy to find out where the error happens in your code.\nioredis provides an option `showFriendlyErrorStack` to solve the problem. When you enable\n`showFriendlyErrorStack`, ioredis will optimize the error stack for you:\n\n```javascript\nvar Redis = require(\"ioredis\");\nvar redis = new Redis({ showFriendlyErrorStack: true });\nredis.set(\"foo\");\n```\n\nAnd the output will be:\n\n```\nReplyError: ERR wrong number of arguments for 'set' command\n    at Object.<anonymous> (/app/index.js:3:7)\n    at Module._compile (module.js:446:26)\n    at Object.Module._extensions..js (module.js:464:10)\n    at Module.load (module.js:341:32)\n    at Function.Module._load (module.js:296:12)\n    at Function.Module.runMain (module.js:487:10)\n    at startup (node.js:111:16)\n    at node.js:799:3\n```\n\nThis time the stack tells you that the error happens on the third line in your code. Pretty sweet!\nHowever, it would decrease the performance significantly to optimize the error stack. So by\ndefault, this option is disabled and can only be used for debugging purposes. You **shouldn't** use this feature in a production environment.\n\n# Plugging in your own Promises Library\n\nIf you're an advanced user, you may want to plug in your own promise library like [bluebird](https://www.npmjs.com/package/bluebird). Just set Redis.Promise to your favorite ES6-style promise constructor and ioredis will use it.\n\n```javascript\nconst Redis = require(\"ioredis\");\nRedis.Promise = require(\"bluebird\");\n\nconst redis = new Redis();\n\n// Use bluebird\nassert.equal(redis.get().constructor, require(\"bluebird\"));\n\n// You can change the Promise implementation at any time:\nRedis.Promise = global.Promise;\nassert.equal(redis.get().constructor, global.Promise);\n```\n\n# Running tests\n\nStart a Redis server on 127.0.0.1:6379, and then:\n\n```shell\n$ npm test\n```\n\n`FLUSH ALL` will be invoked after each test, so make sure there's no valuable data in it before running tests.\n\nIf your testing environment does not let you spin up a Redis server [ioredis-mock](https://github.com/stipsan/ioredis-mock) is a drop-in replacement you can use in your tests. It aims to behave identically to ioredis connected to a Redis server so that your integration tests is easier to write and of better quality.\n\n# Debug\n\nYou can set the `DEBUG` env to `ioredis:*` to print debug info:\n\n```shell\n$ DEBUG=ioredis:* node app.js\n```\n\n# Join in!\n\nI'm happy to receive bug reports, fixes, documentation enhancements, and any other improvements.\n\nAnd since I'm not a native English speaker, if you find any grammar mistakes in the documentation, please also let me know. :)\n\n# Become a Sponsor\n\nOpen source is hard and time-consuming. If you want to invest in ioredis's future you can become a sponsor and make us spend more time on this library's improvements and new features.\n\n<a href=\"https://opencollective.com/ioredis\"><img src=\"https://opencollective.com/ioredis/tiers/sponsor.svg?avatarHeight=36\"></a>\n\nThank you for using ioredis :-)\n\n# Contributors\n\nThis project exists thanks to all the people who contribute:\n\n<a href=\"https://github.com/luin/ioredis/graphs/contributors\"><img src=\"https://opencollective.com/ioredis/contributors.svg?width=890&showBtn=false\" /></a>\n\n# License\n\nMIT\n\n[![FOSSA Status](https://app.fossa.io/api/projects/git%2Bgithub.com%2Fluin%2Fioredis.svg?type=large)](https://app.fossa.io/projects/git%2Bgithub.com%2Fluin%2Fioredis?ref=badge_large)\n","readmeFilename":"README.md","bugs":{"url":"https://github.com/luin/ioredis/issues"},"homepage":"https://github.com/luin/ioredis#readme","_id":"ioredis@4.14.3","_nodeVersion":"10.17.0","_npmVersion":"6.11.3","dist":{"integrity":"sha512-vpDvNRP+hqio/yuZgIz9u5prwXZFm3rfYBxEtvKkCtsd+iJMDC3VIOfJ8i0/HvOUmWXOZEB1/H+X6oI3ZP7Jrg==","shasum":"e9ecb545e58a02c089f5764b23112061cb2ca1ae","tarball":"https://registry.npmjs.org/ioredis/-/ioredis-4.14.3.tgz","fileCount":36,"unpackedSize":240434,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJdw7+SCRA9TVsSAnZWagAAmegP/0YSTKDdpicAvtZB4DV2\nMS+fQ/DMxKyp9daUP1i1m3ZJqyR7EbiF/T67Fa4xFbHv2tDLk1dq/dEloZIq\ncaml7EmujZ31z6xeKIubulmvQClRHjhMNImEbyhGiHgwnH8sCrvVNSlny0gQ\nl2QKjVu916mIfe+DP4R424bRCmJbkYrtGMdx9egHJKUO+7nMOwrFV2pdVdIh\nxuc6Zy7/lW+E6UaOI/GoRnSVMnO2bLymz/SN2KYgMi1f7+PDXY49aAAEjnLh\nH4sBGdDNbnKIbyMnn5vCvMK8ZGVZjpGlwbBdZHvuapPy+DbuNghWY0UK85SI\nEdXszXfTamCIfUHGC/ZBlubdKkhxmjP5SbDB4BtIF63Xi1yLywNWMuXPaLY+\n12pK8pqDnmGQmlwFqsvEgqOyycy3nNDw+Zae9l43zpMclkozAQno72pjF60H\ny2pnQmWaULcAcrnMZVMopB1tQhyKnfc6tdQmKWeJO0/G6GG9/sZ+5a8S3s+J\nwcD2QNSqoCYZw+BjUyk3ZwsEqELt7QH40CC4bGs9LE8hfMiU4YSbhQZG7151\n8eahbBSHCl31vgBit6cvO8KXxOdBsvmgo+8Nooh4aU67mZvQW0Ys0mWDmSIy\nWHVBCjaHNNWm6wrRlTmHalabaj1fQwuB5eBKs3azkMCk+XvGovpwr5sDc4Za\nNdT4\r\n=9dU6\r\n-----END PGP SIGNATURE-----\r\n"},"maintainers":[{"email":"ioredis-robot@zihua.li","name":"ioredis-robot"},{"email":"i@zihua.li","name":"luin"}],"_npmUser":{"name":"luin","email":"i@zihua.li"},"directories":{},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/ioredis_4.14.3_1573109650234_0.393471575823364"},"_hasShrinkwrap":false},"4.14.4":{"name":"ioredis","version":"4.14.4","description":"A robust, performance-focused and full-featured Redis client for Node.js.","main":"built/index.js","scripts":{"test":"TS_NODE_TRANSPILE_ONLY=true TS_NODE_LOG_ERROR=true NODE_ENV=test mocha \"test/**/*.ts\"","test:cov":"TS_NODE_TRANSPILE_ONLY=true TS_NODE_LOG_ERROR=true NODE_ENV=test node ./node_modules/istanbul/lib/cli.js cover --preserve-comments ./node_modules/mocha/bin/_mocha -- -r ts-node/register -R spec --exit \"test/**/*.ts\"","lint":"eslint --ext .js,.ts .","format":"prettier --write \"{,!(node_modules)/**/}*.{js,ts}\"","format-check":"prettier --check \"{,!(node_modules)/**/}*.{js,ts}\"","build":"rm -rf built && tsc","prepublishOnly":"npm run build && npm test","bench":"matcha benchmarks/*.js","semantic-release":"semantic-release"},"repository":{"type":"git","url":"git://github.com/luin/ioredis.git"},"keywords":["redis","cluster","sentinel","pipelining"],"author":{"name":"luin","email":"i@zihua.li","url":"http://zihua.li"},"license":"MIT","funding":{"type":"opencollective","url":"https://opencollective.com/ioredis"},"dependencies":{"cluster-key-slot":"^1.1.0","debug":"^4.1.1","denque":"^1.1.0","lodash.defaults":"^4.2.0","lodash.flatten":"^4.4.0","redis-commands":"1.5.0","redis-errors":"^1.2.0","redis-parser":"^3.0.0","standard-as-callback":"^2.0.1"},"devDependencies":{"@semantic-release/changelog":"^3.0.4","@semantic-release/git":"^7.0.12","@types/bluebird":"^3.5.27","@types/chai":"^4.1.7","@types/debug":"^4.1.4","@types/lodash.defaults":"^4.2.6","@types/lodash.flatten":"^4.4.6","@types/mocha":"^5.2.7","@types/node":"^12.0.2","@types/redis-errors":"1.2.0","@types/sinon":"^7.0.13","@typescript-eslint/eslint-plugin":"^1.11.0","@typescript-eslint/parser":"^1.11.0","bluebird":"^3.5.4","chai":"^4.2.0","cz-conventional-changelog":"^2.0.0","eslint":"^5.16.0","eslint-config-prettier":"^5.1.0","husky":"^2.5.0","istanbul":"^0.4.5","mocha":"^5.0.0","prettier":"^1.18.2","pretty-quick":"^1.11.1","server-destroy":"^1.0.1","sinon":"^7.3.2","ts-node":"^8.1.0","typescript":"^3.5.1"},"engines":{"node":">=6"},"config":{"commitizen":{"path":"./node_modules/cz-conventional-changelog"}},"husky":{"hooks":{"pre-commit":"pretty-quick --staged"}},"gitHead":"9bda5931334d77e91d6b09f5a6223bdfadd7220f","readme":"[![ioredis](https://cdn.jsdelivr.net/gh/luin/ioredis@b5e8c74/logo.svg)](https://github.com/luin/ioredis)\n\n[![Build Status](https://travis-ci.org/luin/ioredis.svg?branch=master)](https://travis-ci.org/luin/ioredis)\n[![Test Coverage](https://codeclimate.com/github/luin/ioredis/badges/coverage.svg)](https://codeclimate.com/github/luin/ioredis)\n[![code style: prettier](https://img.shields.io/badge/code_style-prettier-ff69b4.svg?style=flat-square)](https://github.com/prettier/prettier)\n[![Join the chat at https://gitter.im/luin/ioredis](https://badges.gitter.im/Join%20Chat.svg)](https://gitter.im/luin/ioredis?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge)\n[![Commitizen friendly](https://img.shields.io/badge/commitizen-friendly-brightgreen.svg)](http://commitizen.github.io/cz-cli/)\n[![semantic-release](https://img.shields.io/badge/%20%20%F0%9F%93%A6%F0%9F%9A%80-semantic--release-e10079.svg)](https://github.com/semantic-release/semantic-release)\n[![npm latest version](https://img.shields.io/npm/v/ioredis/latest.svg)](https://www.npmjs.com/package/ioredis)\n[![npm next version](https://img.shields.io/npm/v/ioredis/next.svg)](https://www.npmjs.com/package/ioredis)\n<img alt=\"\" src=\"\">\n\nA robust, performance-focused and full-featured [Redis](http://redis.io) client for [Node.js](https://nodejs.org).\n\nSupports Redis >= 2.6.12 and (Node.js >= 6).\n\n# Features\n\nioredis is a robust, full-featured Redis client that is\nused in the world's biggest online commerce company [Alibaba](http://www.alibaba.com/) and many other awesome companies.\n\n0. Full-featured. It supports [Cluster](http://redis.io/topics/cluster-tutorial), [Sentinel](http://redis.io/topics/sentinel), [Pipelining](http://redis.io/topics/pipelining) and of course [Lua scripting](http://redis.io/commands/eval) & [Pub/Sub](http://redis.io/topics/pubsub) (with the support of binary messages).\n1. High performance.\n2. Delightful API. It works with Node callbacks and Native promises.\n3. Transformation of command arguments and replies.\n4. Transparent key prefixing.\n5. Abstraction for Lua scripting, allowing you to define custom commands.\n6. Support for binary data.\n7. Support for TLS.\n8. Support for offline queue and ready checking.\n9. Support for ES6 types, such as `Map` and `Set`.\n10. Support for GEO commands (Redis 3.2 Unstable).\n11. Sophisticated error handling strategy.\n12. Support for NAT mapping.\n\n# Links\n\n- [API Documentation](API.md)\n- [Changelog](Changelog.md)\n- [Migrating from node_redis](https://github.com/luin/ioredis/wiki/Migrating-from-node_redis)\n- [Error Handling](#error-handling)\n\n<hr>\n<a href=\"http://bit.ly/medis-macos\"><img align=\"right\" src=\"resources/medis.png\" alt=\"Download on the App Store\"></a>\n\n### [AD] Medis: Redis GUI for OS X\n\nLooking for a Redis GUI manager for OS X, Windows and Linux? Here's [Medis](http://bit.ly/medis-macos)!\n\nMedis is an open-sourced, beautiful, easy-to-use Redis GUI management application.\n\nMedis starts with all the basic features you need:\n\n- Keys viewing/editing\n- SSH Tunnel for connecting with remote servers\n- Terminal for executing custom commands\n- JSON/MessagePack format viewing/editing and built-in highlighting/validator\n- And other awesome features...\n\n[Medis is open sourced on GitHub](https://github.com/luin/medis)\n\n### [AD] Kuber: Kubernetes Dashboard for iOS\n\n<a href=\"http://bit.ly/kuber-ios\"><img src=\"resources/kuber.png\" alt=\"Download on the App Store\"></a>\n\n<hr>\n\n# Quick Start\n\n## Install\n\n```shell\n$ npm install ioredis\n```\n\n## Basic Usage\n\n```javascript\nvar Redis = require(\"ioredis\");\nvar redis = new Redis();\n\nredis.set(\"foo\", \"bar\");\nredis.get(\"foo\", function(err, result) {\n  console.log(result);\n});\nredis.del(\"foo\");\n\n// Or using a promise if the last argument isn't a function\nredis.get(\"foo\").then(function(result) {\n  console.log(result);\n});\n\n// Arguments to commands are flattened, so the following are the same:\nredis.sadd(\"set\", 1, 3, 5, 7);\nredis.sadd(\"set\", [1, 3, 5, 7]);\n\n// All arguments are passed directly to the redis server:\nredis.set(\"key\", 100, \"EX\", 10);\n```\n\nSee the `examples/` folder for more examples.\n\n## Connect to Redis\n\nWhen a new `Redis` instance is created,\na connection to Redis will be created at the same time.\nYou can specify which Redis to connect to by:\n\n```javascript\nnew Redis(); // Connect to 127.0.0.1:6379\nnew Redis(6380); // 127.0.0.1:6380\nnew Redis(6379, \"192.168.1.1\"); // 192.168.1.1:6379\nnew Redis(\"/tmp/redis.sock\");\nnew Redis({\n  port: 6379, // Redis port\n  host: \"127.0.0.1\", // Redis host\n  family: 4, // 4 (IPv4) or 6 (IPv6)\n  password: \"auth\",\n  db: 0\n});\n```\n\nYou can also specify connection options as a [`redis://` URL](http://www.iana.org/assignments/uri-schemes/prov/redis) or [`rediss://` URL](https://www.iana.org/assignments/uri-schemes/prov/rediss) when using [TLS encryption](#tls-options):\n\n```javascript\n// Connect to 127.0.0.1:6380, db 4, using password \"authpassword\":\nnew Redis(\"redis://:authpassword@127.0.0.1:6380/4\");\n```\n\nSee [API Documentation](API.md#new_Redis) for all available options.\n\n## Pub/Sub\n\nHere is a simple example of the API for publish/subscribe.\nThe following program opens two client connections.\nIt subscribes to a channel with one connection\nand publishes to that channel with the other:\n\n```javascript\nvar Redis = require(\"ioredis\");\nvar redis = new Redis();\nvar pub = new Redis();\nredis.subscribe(\"news\", \"music\", function(err, count) {\n  // Now we are subscribed to both the 'news' and 'music' channels.\n  // `count` represents the number of channels we are currently subscribed to.\n\n  pub.publish(\"news\", \"Hello world!\");\n  pub.publish(\"music\", \"Hello again!\");\n});\n\nredis.on(\"message\", function(channel, message) {\n  // Receive message Hello world! from channel news\n  // Receive message Hello again! from channel music\n  console.log(\"Receive message %s from channel %s\", message, channel);\n});\n\n// There's also an event called 'messageBuffer', which is the same as 'message' except\n// it returns buffers instead of strings.\nredis.on(\"messageBuffer\", function(channel, message) {\n  // Both `channel` and `message` are buffers.\n});\n```\n\n`PSUBSCRIBE` is also supported in a similar way:\n\n```javascript\nredis.psubscribe(\"pat?ern\", function(err, count) {});\nredis.on(\"pmessage\", function(pattern, channel, message) {});\nredis.on(\"pmessageBuffer\", function(pattern, channel, message) {});\n```\n\nWhen a client issues a SUBSCRIBE or PSUBSCRIBE, that connection is put into a \"subscriber\" mode.\nAt that point, only commands that modify the subscription set are valid.\nWhen the subscription set is empty, the connection is put back into regular mode.\n\nIf you need to send regular commands to Redis while in subscriber mode, just open another connection.\n\n## Handle Binary Data\n\nArguments can be buffers:\n\n```javascript\nredis.set(\"foo\", Buffer.from(\"bar\"));\n```\n\nAnd every command has a method that returns a Buffer (by adding a suffix of \"Buffer\" to the command name).\nTo get a buffer instead of a utf8 string:\n\n```javascript\nredis.getBuffer(\"foo\", function(err, result) {\n  // result is a buffer.\n});\n```\n\n## Pipelining\n\nIf you want to send a batch of commands (e.g. > 5), you can use pipelining to queue\nthe commands in memory and then send them to Redis all at once. This way the performance improves by 50%~300% (See [benchmark section](#benchmark)).\n\n`redis.pipeline()` creates a `Pipeline` instance. You can call any Redis\ncommands on it just like the `Redis` instance. The commands are queued in memory\nand flushed to Redis by calling the `exec` method:\n\n```javascript\nvar pipeline = redis.pipeline();\npipeline.set(\"foo\", \"bar\");\npipeline.del(\"cc\");\npipeline.exec(function(err, results) {\n  // `err` is always null, and `results` is an array of responses\n  // corresponding to the sequence of queued commands.\n  // Each response follows the format `[err, result]`.\n});\n\n// You can even chain the commands:\nredis\n  .pipeline()\n  .set(\"foo\", \"bar\")\n  .del(\"cc\")\n  .exec(function(err, results) {});\n\n// `exec` also returns a Promise:\nvar promise = redis\n  .pipeline()\n  .set(\"foo\", \"bar\")\n  .get(\"foo\")\n  .exec();\npromise.then(function(result) {\n  // result === [[null, 'OK'], [null, 'bar']]\n});\n```\n\nEach chained command can also have a callback, which will be invoked when the command\ngets a reply:\n\n```javascript\nredis\n  .pipeline()\n  .set(\"foo\", \"bar\")\n  .get(\"foo\", function(err, result) {\n    // result === 'bar'\n  })\n  .exec(function(err, result) {\n    // result[1][1] === 'bar'\n  });\n```\n\nIn addition to adding commands to the `pipeline` queue individually, you can also pass an array of commands and arguments to the constructor:\n\n```javascript\nredis.pipeline([[\"set\", \"foo\", \"bar\"], [\"get\", \"foo\"]]).exec(function() {\n  /* ... */\n});\n```\n\n`#length` property shows how many commands in the pipeline:\n\n```javascript\nconst length = redis\n  .pipeline()\n  .set(\"foo\", \"bar\")\n  .get(\"foo\").length;\n// length === 2\n```\n\n## Transaction\n\nMost of the time, the transaction commands `multi` & `exec` are used together with pipeline.\nTherefore, when `multi` is called, a `Pipeline` instance is created automatically by default,\nso you can use `multi` just like `pipeline`:\n\n```javascript\nredis\n  .multi()\n  .set(\"foo\", \"bar\")\n  .get(\"foo\")\n  .exec(function(err, results) {\n    // results === [[null, 'OK'], [null, 'bar']]\n  });\n```\n\nIf there's a syntax error in the transaction's command chain (e.g. wrong number of arguments, wrong command name, etc),\nthen none of the commands would be executed, and an error is returned:\n\n```javascript\nredis\n  .multi()\n  .set(\"foo\")\n  .set(\"foo\", \"new value\")\n  .exec(function(err, results) {\n    // err:\n    //  { [ReplyError: EXECABORT Transaction discarded because of previous errors.]\n    //    name: 'ReplyError',\n    //    message: 'EXECABORT Transaction discarded because of previous errors.',\n    //    command: { name: 'exec', args: [] },\n    //    previousErrors:\n    //     [ { [ReplyError: ERR wrong number of arguments for 'set' command]\n    //         name: 'ReplyError',\n    //         message: 'ERR wrong number of arguments for \\'set\\' command',\n    //         command: [Object] } ] }\n  });\n```\n\nIn terms of the interface, `multi` differs from `pipeline` in that when specifying a callback\nto each chained command, the queueing state is passed to the callback instead of the result of the command:\n\n```javascript\nredis\n  .multi()\n  .set(\"foo\", \"bar\", function(err, result) {\n    // result === 'QUEUED'\n  })\n  .exec(/* ... */);\n```\n\nIf you want to use transaction without pipeline, pass `{ pipeline: false }` to `multi`,\nand every command will be sent to Redis immediately without waiting for an `exec` invocation:\n\n```javascript\nredis.multi({ pipeline: false });\nredis.set(\"foo\", \"bar\");\nredis.get(\"foo\");\nredis.exec(function(err, result) {\n  // result === [[null, 'OK'], [null, 'bar']]\n});\n```\n\nThe constructor of `multi` also accepts a batch of commands:\n\n```javascript\nredis.multi([[\"set\", \"foo\", \"bar\"], [\"get\", \"foo\"]]).exec(function() {\n  /* ... */\n});\n```\n\nInline transactions are supported by pipeline, which means you can group a subset of commands\nin the pipeline into a transaction:\n\n```javascript\nredis\n  .pipeline()\n  .get(\"foo\")\n  .multi()\n  .set(\"foo\", \"bar\")\n  .get(\"foo\")\n  .exec()\n  .get(\"foo\")\n  .exec();\n```\n\n## Lua Scripting\n\nioredis supports all of the scripting commands such as `EVAL`, `EVALSHA` and `SCRIPT`.\nHowever, it's tedious to use in real world scenarios since developers have to take\ncare of script caching and to detect when to use `EVAL` and when to use `EVALSHA`.\nioredis exposes a `defineCommand` method to make scripting much easier to use:\n\n```javascript\nvar redis = new Redis();\n\n// This will define a command echo:\nredis.defineCommand(\"echo\", {\n  numberOfKeys: 2,\n  lua: \"return {KEYS[1],KEYS[2],ARGV[1],ARGV[2]}\"\n});\n\n// Now `echo` can be used just like any other ordinary command,\n// and ioredis will try to use `EVALSHA` internally when possible for better performance.\nredis.echo(\"k1\", \"k2\", \"a1\", \"a2\", function(err, result) {\n  // result === ['k1', 'k2', 'a1', 'a2']\n});\n\n// `echoBuffer` is also defined automatically to return buffers instead of strings:\nredis.echoBuffer(\"k1\", \"k2\", \"a1\", \"a2\", function(err, result) {\n  // result[0] equals to Buffer.from('k1');\n});\n\n// And of course it works with pipeline:\nredis\n  .pipeline()\n  .set(\"foo\", \"bar\")\n  .echo(\"k1\", \"k2\", \"a1\", \"a2\")\n  .exec();\n```\n\nIf the number of keys can't be determined when defining a command, you can\nomit the `numberOfKeys` property and pass the number of keys as the first argument\nwhen you call the command:\n\n```javascript\nredis.defineCommand(\"echoDynamicKeyNumber\", {\n  lua: \"return {KEYS[1],KEYS[2],ARGV[1],ARGV[2]}\"\n});\n\n// Now you have to pass the number of keys as the first argument every time\n// you invoke the `echoDynamicKeyNumber` command:\nredis.echoDynamicKeyNumber(2, \"k1\", \"k2\", \"a1\", \"a2\", function(err, result) {\n  // result === ['k1', 'k2', 'a1', 'a2']\n});\n```\n\n## Transparent Key Prefixing\n\nThis feature allows you to specify a string that will automatically be prepended\nto all the keys in a command, which makes it easier to manage your key\nnamespaces.\n\n**Warning** This feature won't apply to commands like [KEYS](http://redis.io/commands/KEYS) and [SCAN](http://redis.io/commands/scan) that take patterns rather than actual keys([#239](https://github.com/luin/ioredis/issues/239)),\nand this feature also won't apply to the replies of commands even they are key names ([#325](https://github.com/luin/ioredis/issues/325)).\n\n```javascript\nvar fooRedis = new Redis({ keyPrefix: \"foo:\" });\nfooRedis.set(\"bar\", \"baz\"); // Actually sends SET foo:bar baz\n\nfooRedis.defineCommand(\"echo\", {\n  numberOfKeys: 2,\n  lua: \"return {KEYS[1],KEYS[2],ARGV[1],ARGV[2]}\"\n});\n\n// Works well with pipelining/transaction\nfooRedis\n  .pipeline()\n  // Sends SORT foo:list BY foo:weight_*->fieldname\n  .sort(\"list\", \"BY\", \"weight_*->fieldname\")\n  // Supports custom commands\n  // Sends EVALSHA xxx foo:k1 foo:k2 a1 a2\n  .echo(\"k1\", \"k2\", \"a1\", \"a2\")\n  .exec();\n```\n\n## Transforming Arguments & Replies\n\nMost Redis commands take one or more Strings as arguments,\nand replies are sent back as a single String or an Array of Strings. However, sometimes\nyou may want something different. For instance, it would be more convenient if the `HGETALL`\ncommand returns a hash (e.g. `{ key: val1, key2: v2 }`) rather than an array of key values (e.g. `[key1, val1, key2, val2]`).\n\nioredis has a flexible system for transforming arguments and replies. There are two types\nof transformers, argument transformer and reply transformer:\n\n```javascript\nvar Redis = require(\"ioredis\");\n\n// Here's the built-in argument transformer converting\n// hmset('key', { k1: 'v1', k2: 'v2' })\n// or\n// hmset('key', new Map([['k1', 'v1'], ['k2', 'v2']]))\n// into\n// hmset('key', 'k1', 'v1', 'k2', 'v2')\nRedis.Command.setArgumentTransformer(\"hmset\", function(args) {\n  if (args.length === 2) {\n    if (typeof Map !== \"undefined\" && args[1] instanceof Map) {\n      // utils is a internal module of ioredis\n      return [args[0]].concat(utils.convertMapToArray(args[1]));\n    }\n    if (typeof args[1] === \"object\" && args[1] !== null) {\n      return [args[0]].concat(utils.convertObjectToArray(args[1]));\n    }\n  }\n  return args;\n});\n\n// Here's the built-in reply transformer converting the HGETALL reply\n// ['k1', 'v1', 'k2', 'v2']\n// into\n// { k1: 'v1', 'k2': 'v2' }\nRedis.Command.setReplyTransformer(\"hgetall\", function(result) {\n  if (Array.isArray(result)) {\n    var obj = {};\n    for (var i = 0; i < result.length; i += 2) {\n      obj[result[i]] = result[i + 1];\n    }\n    return obj;\n  }\n  return result;\n});\n```\n\nThere are three built-in transformers, two argument transformers for `hmset` & `mset` and\na reply transformer for `hgetall`. Transformers for `hmset` and `hgetall` were mentioned\nabove, and the transformer for `mset` is similar to the one for `hmset`:\n\n```javascript\nredis.mset({ k1: \"v1\", k2: \"v2\" });\nredis.get(\"k1\", function(err, result) {\n  // result === 'v1';\n});\n\nredis.mset(new Map([[\"k3\", \"v3\"], [\"k4\", \"v4\"]]));\nredis.get(\"k3\", function(err, result) {\n  // result === 'v3';\n});\n```\n\nAnother useful example of a reply transformer is one that changes `hgetall` to return array of arrays instead of objects which avoids a unwanted conversation of hash keys to strings when dealing with binary hash keys:\n\n```javascript\nRedis.Command.setReplyTransformer(\"hgetall\", function(result) {\n  var arr = [];\n  for (var i = 0; i < result.length; i += 2) {\n    arr.push([result[i], result[i + 1]]);\n  }\n  return arr;\n});\nredis.hset(\"h1\", Buffer.from([0x01]), Buffer.from([0x02]));\nredis.hset(\"h1\", Buffer.from([0x03]), Buffer.from([0x04]));\nredis.hgetallBuffer(\"h1\", function(err, result) {\n  // result === [ [ <Buffer 01>, <Buffer 02> ], [ <Buffer 03>, <Buffer 04> ] ];\n});\n```\n\n## Monitor\n\nRedis supports the MONITOR command,\nwhich lets you see all commands received by the Redis server across all client connections,\nincluding from other client libraries and other computers.\n\nThe `monitor` method returns a monitor instance.\nAfter you send the MONITOR command, no other commands are valid on that connection. ioredis will emit a monitor event for every new monitor message that comes across.\nThe callback for the monitor event takes a timestamp from the Redis server and an array of command arguments.\n\nHere is a simple example:\n\n```javascript\nredis.monitor(function(err, monitor) {\n  monitor.on(\"monitor\", function(time, args, source, database) {});\n});\n```\nHere is another example illustrating an `async` function and `monitor.disconnect()`:\n```javascript\nasync () => {\n  const monitor = await redis.monitor()\n  monitor.on('monitor', console.log)\n  // Any other tasks\n  monitor.disconnect()\n}\n```\n## Streamify Scanning\n\nRedis 2.8 added the `SCAN` command to incrementally iterate through the keys in the database. It's different from `KEYS` in that\n`SCAN` only returns a small number of elements each call, so it can be used in production without the downside\nof blocking the server for a long time. However, it requires recording the cursor on the client side each time\nthe `SCAN` command is called in order to iterate through all the keys correctly. Since it's a relatively common use case, ioredis\nprovides a streaming interface for the `SCAN` command to make things much easier. A readable stream can be created by calling `scanStream`:\n\n```javascript\nvar redis = new Redis();\n// Create a readable stream (object mode)\nvar stream = redis.scanStream();\nstream.on(\"data\", function(resultKeys) {\n  // `resultKeys` is an array of strings representing key names.\n  // Note that resultKeys may contain 0 keys, and that it will sometimes\n  // contain duplicates due to SCAN's implementation in Redis.\n  for (var i = 0; i < resultKeys.length; i++) {\n    console.log(resultKeys[i]);\n  }\n});\nstream.on(\"end\", function() {\n  console.log(\"all keys have been visited\");\n});\n```\n\n`scanStream` accepts an option, with which you can specify the `MATCH` pattern and the `COUNT` argument:\n\n```javascript\nvar stream = redis.scanStream({\n  // only returns keys following the pattern of `user:*`\n  match: \"user:*\",\n  // returns approximately 100 elements per call\n  count: 100\n});\n```\n\nJust like other commands, `scanStream` has a binary version `scanBufferStream`, which returns an array of buffers. It's useful when\nthe key names are not utf8 strings.\n\nThere are also `hscanStream`, `zscanStream` and `sscanStream` to iterate through elements in a hash, zset and set. The interface of each is\nsimilar to `scanStream` except the first argument is the key name:\n\n```javascript\nvar stream = redis.hscanStream(\"myhash\", {\n  match: \"age:??\"\n});\n```\n\nYou can learn more from the [Redis documentation](http://redis.io/commands/scan).\n\n**Useful Tips**\nIt's pretty common that doing an async task in the `data` handler. We'd like the scanning process to be paused until the async task to be finished. `Stream#pause()` and `Stream.resume()` do the trick. For example if we want to migrate data in Redis to MySQL:\n\n```javascript\nvar stream = redis.scanStream();\nstream.on(\"data\", function(resultKeys) {\n  // Pause the stream from scanning more keys until we've migrated the current keys.\n  stream.pause();\n\n  Promise.all(resultKeys.map(migrateKeyToMySQL)).then(() => {\n    // Resume the stream here.\n    stream.resume();\n  });\n});\n\nstream.on(\"end\", function() {\n  console.log(\"done migration\");\n});\n```\n\n## Auto-reconnect\n\nBy default, ioredis will try to reconnect when the connection to Redis is lost\nexcept when the connection is closed manually by `redis.disconnect()` or `redis.quit()`.\n\nIt's very flexible to control how long to wait to reconnect after disconnection\nusing the `retryStrategy` option:\n\n```javascript\nvar redis = new Redis({\n  // This is the default value of `retryStrategy`\n  retryStrategy: function(times) {\n    var delay = Math.min(times * 50, 2000);\n    return delay;\n  }\n});\n```\n\n`retryStrategy` is a function that will be called when the connection is lost.\nThe argument `times` means this is the nth reconnection being made and\nthe return value represents how long (in ms) to wait to reconnect. When the\nreturn value isn't a number, ioredis will stop trying to reconnect, and the connection\nwill be lost forever if the user doesn't call `redis.connect()` manually.\n\nWhen reconnected, the client will auto subscribe to channels that the previous connection subscribed to.\nThis behavior can be disabled by setting the `autoResubscribe` option to `false`.\n\nAnd if the previous connection has some unfulfilled commands (most likely blocking commands such as `brpop` and `blpop`),\nthe client will resend them when reconnected. This behavior can be disabled by setting the `autoResendUnfulfilledCommands` option to `false`.\n\nBy default, all pending commands will be flushed with an error every 20 retry attempts. That makes sure commands won't wait forever when the connection is down. You can change this behavior by setting `maxRetriesPerRequest`:\n\n```javascript\nvar redis = new Redis({\n  maxRetriesPerRequest: 1\n});\n```\n\nSet maxRetriesPerRequest to `null` to disable this behavior, and every command will wait forever until the connection is alive again (which is the default behavior before ioredis v4).\n\n### Reconnect on error\n\nBesides auto-reconnect when the connection is closed, ioredis supports reconnecting on the specified errors by the `reconnectOnError` option. Here's an example that will reconnect when receiving `READONLY` error:\n\n```javascript\nvar redis = new Redis({\n  reconnectOnError: function(err) {\n    var targetError = \"READONLY\";\n    if (err.message.slice(0, targetError.length) === targetError) {\n      // Only reconnect when the error starts with \"READONLY\"\n      return true; // or `return 1;`\n    }\n  }\n});\n```\n\nThis feature is useful when using Amazon ElastiCache. Once failover happens, Amazon ElastiCache will switch the master we currently connected with to a slave, leading to the following writes fails with the error `READONLY`. Using `reconnectOnError`, we can force the connection to reconnect on this error in order to connect to the new master.\n\nFurthermore, if the `reconnectOnError` returns `2`, ioredis will resend the failed command after reconnecting.\n\n## Connection Events\n\nThe Redis instance will emit some events about the state of the connection to the Redis server.\n\n| Event        | Description                                                                                                                                                                                                                                     |\n| :----------- | :---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| connect      | emits when a connection is established to the Redis server.                                                                                                                                                                                     |\n| ready        | If `enableReadyCheck` is `true`, client will emit `ready` when the server reports that it is ready to receive commands (e.g. finish loading data from disk).<br>Otherwise, `ready` will be emitted immediately right after the `connect` event. |\n| error        | emits when an error occurs while connecting.<br>However, ioredis emits all `error` events silently (only emits when there's at least one listener) so that your application won't crash if you're not listening to the `error` event.           |\n| close        | emits when an established Redis server connection has closed.                                                                                                                                                                                   |\n| reconnecting | emits after `close` when a reconnection will be made. The argument of the event is the time (in ms) before reconnecting.                                                                                                                        |\n| end          | emits after `close` when no more reconnections will be made, or the connection is failed to establish.                                                                                                                                          |\n\nYou can also check out the `Redis#status` property to get the current connection status.\n\nBesides the above connection events, there are several other custom events:\n\n| Event  | Description                                                         |\n| :----- | :------------------------------------------------------------------ |\n| select | emits when the database changed. The argument is the new db number. |\n\n## Offline Queue\n\nWhen a command can't be processed by Redis (being sent before the `ready` event), by default, it's added to the offline queue and will be\nexecuted when it can be processed. You can disable this feature by setting the `enableOfflineQueue`\noption to `false`:\n\n```javascript\nvar redis = new Redis({ enableOfflineQueue: false });\n```\n\n## TLS Options\n\nRedis doesn't support TLS natively, however if the redis server you want to connect to is hosted behind a TLS proxy (e.g. [stunnel](https://www.stunnel.org/)) or is offered by a PaaS service that supports TLS connection (e.g. [Redis Labs](https://redislabs.com/)), you can set the `tls` option:\n\n```javascript\nvar redis = new Redis({\n  host: \"localhost\",\n  tls: {\n    // Refer to `tls.connect()` section in\n    // https://nodejs.org/api/tls.html\n    // for all supported options\n    ca: fs.readFileSync(\"cert.pem\")\n  }\n});\n```\n\nAlternatively, specify the connection through a [`rediss://` URL](https://www.iana.org/assignments/uri-schemes/prov/rediss).\n\n```javascript\nvar redis = new Redis(\"rediss://redis.my-service.com\");\n```\n\n<hr>\n\n## Sentinel\n\nioredis supports Sentinel out of the box. It works transparently as all features that work when\nyou connect to a single node also work when you connect to a sentinel group. Make sure to run Redis >= 2.8.12 if you want to use this feature. Sentinels have a default port of 26379.\n\nTo connect using Sentinel, use:\n\n```javascript\nvar redis = new Redis({\n  sentinels: [\n    { host: \"localhost\", port: 26379 },\n    { host: \"localhost\", port: 26380 }\n  ],\n  name: \"mymaster\"\n});\n\nredis.set(\"foo\", \"bar\");\n```\n\nThe arguments passed to the constructor are different from the ones you use to connect to a single node, where:\n\n- `name` identifies a group of Redis instances composed of a master and one or more slaves (`mymaster` in the example);\n- `sentinelPassword` (optional) password for Sentinel instances.\n- `sentinels` are a list of sentinels to connect to. The list does not need to enumerate all your sentinel instances, but a few so that if one is down the client will try the next one.\n- `role` (optional) with a value of `slave` will return a random slave from the Sentinel group.\n- `preferredSlaves` (optional) can be used to prefer a particular slave or set of slaves based on priority. It accepts a function or array.\n\nioredis **guarantees** that the node you connected to is always a master even after a failover. When a failover happens, instead of trying to reconnect to the failed node (which will be demoted to slave when it's available again), ioredis will ask sentinels for the new master node and connect to it. All commands sent during the failover are queued and will be executed when the new connection is established so that none of the commands will be lost.\n\nIt's possible to connect to a slave instead of a master by specifying the option `role` with the value of `slave` and ioredis will try to connect to a random slave of the specified master, with the guarantee that the connected node is always a slave. If the current node is promoted to master due to a failover, ioredis will disconnect from it and ask the sentinels for another slave node to connect to.\n\nIf you specify the option `preferredSlaves` along with `role: 'slave'` ioredis will attempt to use this value when selecting the slave from the pool of available slaves. The value of `preferredSlaves` should either be a function that accepts an array of avaiable slaves and returns a single result, or an array of slave values priorities by the lowest `prio` value first with a default value of `1`.\n\n```javascript\n// available slaves format\nvar availableSlaves = [{ ip: \"127.0.0.1\", port: \"31231\", flags: \"slave\" }];\n\n// preferredSlaves array format\nvar preferredSlaves = [\n  { ip: \"127.0.0.1\", port: \"31231\", prio: 1 },\n  { ip: \"127.0.0.1\", port: \"31232\", prio: 2 }\n];\n\n// preferredSlaves function format\npreferredSlaves = function(availableSlaves) {\n  for (var i = 0; i < availableSlaves.length; i++) {\n    var slave = availableSlaves[i];\n    if (slave.ip === \"127.0.0.1\") {\n      if (slave.port === \"31234\") {\n        return slave;\n      }\n    }\n  }\n  // if no preferred slaves are available a random one is used\n  return false;\n};\n\nvar redis = new Redis({\n  sentinels: [\n    { host: \"127.0.0.1\", port: 26379 },\n    { host: \"127.0.0.1\", port: 26380 }\n  ],\n  name: \"mymaster\",\n  role: \"slave\",\n  preferredSlaves: preferredSlaves\n});\n```\n\nBesides the `retryStrategy` option, there's also a `sentinelRetryStrategy` in Sentinel mode which will be invoked when all the sentinel nodes are unreachable during connecting. If `sentinelRetryStrategy` returns a valid delay time, ioredis will try to reconnect from scratch. The default value of `sentinelRetryStrategy` is:\n\n```javascript\nfunction (times) {\n  var delay = Math.min(times * 10, 1000);\n  return delay;\n}\n```\n\n## Cluster\n\nRedis Cluster provides a way to run a Redis installation where data is automatically sharded across multiple Redis nodes.\nYou can connect to a Redis Cluster like this:\n\n```javascript\nvar Redis = require(\"ioredis\");\n\nvar cluster = new Redis.Cluster([\n  {\n    port: 6380,\n    host: \"127.0.0.1\"\n  },\n  {\n    port: 6381,\n    host: \"127.0.0.1\"\n  }\n]);\n\ncluster.set(\"foo\", \"bar\");\ncluster.get(\"foo\", function(err, res) {\n  // res === 'bar'\n});\n```\n\n`Cluster` constructor accepts two arguments, where:\n\n0.  The first argument is a list of nodes of the cluster you want to connect to.\n    Just like Sentinel, the list does not need to enumerate all your cluster nodes,\n    but a few so that if one is unreachable the client will try the next one, and the client will discover other nodes automatically when at least one node is connected.\n1.  The second argument is the options, where:\n\n    - `clusterRetryStrategy`: When none of the startup nodes are reachable, `clusterRetryStrategy` will be invoked. When a number is returned,\n      ioredis will try to reconnect to the startup nodes from scratch after the specified delay (in ms). Otherwise, an error of \"None of startup nodes is available\" will be returned.\n      The default value of this option is:\n\n          ```javascript\n          function (times) {\n            var delay = Math.min(100 + times * 2, 2000);\n            return delay;\n          }\n          ```\n\n          It's possible to modify the `startupNodes` property in order to switch to another set of nodes here:\n\n          ```javascript\n          function (times) {\n            this.startupNodes = [{ port: 6790, host: '127.0.0.1' }];\n            return Math.min(100 + times * 2, 2000);\n          }\n          ```\n\n    - `dnsLookup`: Alternative DNS lookup function (`dns.lookup()` is used by default). It may be useful to override this in special cases, such as when AWS ElastiCache used with TLS enabled.\n    - `enableOfflineQueue`: Similar to the `enableOfflineQueue` option of `Redis` class.\n    - `enableReadyCheck`: When enabled, \"ready\" event will only be emitted when `CLUSTER INFO` command\n      reporting the cluster is ready for handling commands. Otherwise, it will be emitted immediately after \"connect\" is emitted.\n    - `scaleReads`: Config where to send the read queries. See below for more details.\n    - `maxRedirections`: When a cluster related error (e.g. `MOVED`, `ASK` and `CLUSTERDOWN` etc.) is received, the client will redirect the\n      command to another node. This option limits the max redirections allowed when sending a command. The default value is `16`.\n    - `retryDelayOnFailover`: If the target node is disconnected when sending a command,\n      ioredis will retry after the specified delay. The default value is `100`. You should make sure `retryDelayOnFailover * maxRedirections > cluster-node-timeout`\n      to insure that no command will fail during a failover.\n    - `retryDelayOnClusterDown`: When a cluster is down, all commands will be rejected with the error of `CLUSTERDOWN`. If this option is a number (by default, it is `100`), the client\n      will resend the commands after the specified time (in ms).\n    - `retryDelayOnTryAgain`: If this option is a number (by default, it is `100`), the client\n      will resend the commands rejected with `TRYAGAIN` error after the specified time (in ms).\n    - `redisOptions`: Default options passed to the constructor of `Redis` when connecting to a node.\n    - `slotsRefreshTimeout`: Milliseconds before a timeout occurs while refreshing slots from the cluster (default `1000`)\n    - `slotsRefreshInterval`: Milliseconds between every automatic slots refresh (default `5000`)\n\n### Read-write splitting\n\nA typical redis cluster contains three or more masters and several slaves for each master. It's possible to scale out redis cluster by sending read queries to slaves and write queries to masters by setting the `scaleReads` option.\n\n`scaleReads` is \"master\" by default, which means ioredis will never send any queries to slaves. There are other three available options:\n\n1. \"all\": Send write queries to masters and read queries to masters or slaves randomly.\n2. \"slave\": Send write queries to masters and read queries to slaves.\n3. a custom `function(nodes, command): node`: Will choose the custom function to select to which node to send read queries (write queries keep being sent to master). The first node in `nodes` is always the master serving the relevant slots. If the function returns an array of nodes, a random node of that list will be selected.\n\nFor example:\n\n```javascript\nvar cluster = new Redis.Cluster(\n  [\n    /* nodes */\n  ],\n  {\n    scaleReads: \"slave\"\n  }\n);\ncluster.set(\"foo\", \"bar\"); // This query will be sent to one of the masters.\ncluster.get(\"foo\", function(err, res) {\n  // This query will be sent to one of the slaves.\n});\n```\n\n**NB** In the code snippet above, the `res` may not be equal to \"bar\" because of the lag of replication between the master and slaves.\n\n### Running commands to multiple nodes\n\nEvery command will be sent to exactly one node. For commands containing keys, (e.g. `GET`, `SET` and `HGETALL`), ioredis sends them to the node that serving the keys, and for other commands not containing keys, (e.g. `INFO`, `KEYS` and `FLUSHDB`), ioredis sends them to a random node.\n\nSometimes you may want to send a command to multiple nodes (masters or slaves) of the cluster, you can get the nodes via `Cluster#nodes()` method.\n\n`Cluster#nodes()` accepts a parameter role, which can be \"master\", \"slave\" and \"all\" (default), and returns an array of `Redis` instance. For example:\n\n```javascript\n// Send `FLUSHDB` command to all slaves:\nvar slaves = cluster.nodes(\"slave\");\nPromise.all(\n  slaves.map(function(node) {\n    return node.flushdb();\n  })\n);\n\n// Get keys of all the masters:\nvar masters = cluster.nodes(\"master\");\nPromise.all(\n  masters.map(function(node) {\n    return node.keys();\n  })\n).then(function(keys) {\n  // keys: [['key1', 'key2'], ['key3', 'key4']]\n});\n```\n\n### NAT Mapping\n\nSometimes the cluster is hosted within a internal network that can only be accessed via a NAT (Network Address Translation) instance. See [Accessing ElastiCache from outside AWS](https://docs.aws.amazon.com/AmazonElastiCache/latest/red-ug/accessing-elasticache.html) as an example.\n\nYou can specify nat mapping rules via `natMap` option:\n\n```javascript\nconst cluster = new Redis.Cluster(\n  [\n    {\n      host: \"203.0.113.73\",\n      port: 30001\n    }\n  ],\n  {\n    natMap: {\n      \"10.0.1.230:30001\": { host: \"203.0.113.73\", port: 30001 },\n      \"10.0.1.231:30001\": { host: \"203.0.113.73\", port: 30002 },\n      \"10.0.1.232:30001\": { host: \"203.0.113.73\", port: 30003 }\n    }\n  }\n);\n```\n\nThis option is also useful when the cluster is running inside a Docker container.\n\n### Transaction and pipeline in Cluster mode\n\nAlmost all features that are supported by `Redis` are also supported by `Redis.Cluster`, e.g. custom commands, transaction and pipeline.\nHowever there are some differences when using transaction and pipeline in Cluster mode:\n\n0. All keys in a pipeline should belong to the same slot since ioredis sends all commands in a pipeline to the same node.\n1. You can't use `multi` without pipeline (aka `cluster.multi({ pipeline: false })`). This is because when you call `cluster.multi({ pipeline: false })`, ioredis doesn't know which node the `multi` command should be sent to.\n2. Chaining custom commands in the pipeline is not supported in Cluster mode.\n\nWhen any commands in a pipeline receives a `MOVED` or `ASK` error, ioredis will resend the whole pipeline to the specified node automatically if all of the following conditions are satisfied:\n\n0. All errors received in the pipeline are the same. For example, we won't resend the pipeline if we got two `MOVED` errors pointing to different nodes.\n1. All commands executed successfully are readonly commands. This makes sure that resending the pipeline won't have side effects.\n\n### Pub/Sub\n\nPub/Sub in cluster mode works exactly as the same as in standalone mode. Internally, when a node of the cluster receives a message, it will broadcast the message to the other nodes. ioredis makes sure that each message will only be received once by strictly subscribing one node at the same time.\n\n```javascript\nvar nodes = [\n  /* nodes */\n];\nvar pub = new Redis.Cluster(nodes);\nvar sub = new Redis.Cluster(nodes);\nsub.on(\"message\", function(channel, message) {\n  console.log(channel, message);\n});\n\nsub.subscribe(\"news\", function() {\n  pub.publish(\"news\", \"highlights\");\n});\n```\n\n### Events\n\n| Event        | Description                                                                                                                                                                                                |\n| :----------- | :--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| connect      | emits when a connection is established to the Redis server.                                                                                                                                                |\n| ready        | emits when `CLUSTER INFO` reporting the cluster is able to receive commands (if `enableReadyCheck` is `true`) or immediately after `connect` event (if `enableReadyCheck` is false).                       |\n| error        | emits when an error occurs while connecting with a property of `lastNodeError` representing the last node error received. This event is emitted silently (only emitting if there's at least one listener). |\n| close        | emits when an established Redis server connection has closed.                                                                                                                                              |\n| reconnecting | emits after `close` when a reconnection will be made. The argument of the event is the time (in ms) before reconnecting.                                                                                   |\n| end          | emits after `close` when no more reconnections will be made.                                                                                                                                               |\n| +node        | emits when a new node is connected.                                                                                                                                                                        |\n| -node        | emits when a node is disconnected.                                                                                                                                                                         |\n| node error   | emits when an error occurs when connecting to a node. The second argument indicates the address of the node.                                                                                               |\n\n### Password\n\nSetting the `password` option to access password-protected clusters:\n\n```javascript\nvar Redis = require(\"ioredis\");\nvar cluster = new Redis.Cluster(nodes, {\n  redisOptions: {\n    password: \"your-cluster-password\"\n  }\n});\n```\n\nIf some of nodes in the cluster using a different password, you should specify them in the first parameter:\n\n```javascript\nvar Redis = require(\"ioredis\");\nvar cluster = new Redis.Cluster(\n  [\n    // Use password \"password-for-30001\" for 30001\n    { port: 30001, password: \"password-for-30001\" },\n    // Don't use password when accessing 30002\n    { port: 30002, password: null }\n    // Other nodes will use \"fallback-password\"\n  ],\n  {\n    redisOptions: {\n      password: \"fallback-password\"\n    }\n  }\n);\n```\n\n### Special note: AWS ElastiCache Clusters with TLS\n\nAWS ElastiCache for Redis (Clustered Mode) supports TLS encryption. If you use\nthis, you may encounter errors with invalid certificates. To resolve this\nissue, construct the `Cluster` with the `dnsLookup` option as follows:\n\n```javascript\nvar cluster = new Redis.Cluster(\n  [{\n    host: 'clustercfg.myCluster.abcdefg.xyz.cache.amazonaws.com',\n    port: 6379\n  }],\n  {\n    dnsLookup: (address, callback) => callback(null, address),\n    redisOptions: {\n      tls: {}\n    },\n  }\n};\n```\n\n<hr>\n\n# Error Handling\n\nAll the errors returned by the Redis server are instances of `ReplyError`, which can be accessed via `Redis`:\n\n```javascript\nvar Redis = require(\"ioredis\");\nvar redis = new Redis();\n// This command causes a reply error since the SET command requires two arguments.\nredis.set(\"foo\", function(err) {\n  err instanceof Redis.ReplyError;\n});\n```\n\nThis is the error stack of the `ReplyError`:\n\n```\nReplyError: ERR wrong number of arguments for 'set' command\n    at ReplyParser._parseResult (/app/node_modules/ioredis/lib/parsers/javascript.js:60:14)\n    at ReplyParser.execute (/app/node_modules/ioredis/lib/parsers/javascript.js:178:20)\n    at Socket.<anonymous> (/app/node_modules/ioredis/lib/redis/event_handler.js:99:22)\n    at Socket.emit (events.js:97:17)\n    at readableAddChunk (_stream_readable.js:143:16)\n    at Socket.Readable.push (_stream_readable.js:106:10)\n    at TCP.onread (net.js:509:20)\n```\n\nBy default, the error stack doesn't make any sense because the whole stack happens in the ioredis\nmodule itself, not in your code. So it's not easy to find out where the error happens in your code.\nioredis provides an option `showFriendlyErrorStack` to solve the problem. When you enable\n`showFriendlyErrorStack`, ioredis will optimize the error stack for you:\n\n```javascript\nvar Redis = require(\"ioredis\");\nvar redis = new Redis({ showFriendlyErrorStack: true });\nredis.set(\"foo\");\n```\n\nAnd the output will be:\n\n```\nReplyError: ERR wrong number of arguments for 'set' command\n    at Object.<anonymous> (/app/index.js:3:7)\n    at Module._compile (module.js:446:26)\n    at Object.Module._extensions..js (module.js:464:10)\n    at Module.load (module.js:341:32)\n    at Function.Module._load (module.js:296:12)\n    at Function.Module.runMain (module.js:487:10)\n    at startup (node.js:111:16)\n    at node.js:799:3\n```\n\nThis time the stack tells you that the error happens on the third line in your code. Pretty sweet!\nHowever, it would decrease the performance significantly to optimize the error stack. So by\ndefault, this option is disabled and can only be used for debugging purposes. You **shouldn't** use this feature in a production environment.\n\n# Plugging in your own Promises Library\n\nIf you're an advanced user, you may want to plug in your own promise library like [bluebird](https://www.npmjs.com/package/bluebird). Just set Redis.Promise to your favorite ES6-style promise constructor and ioredis will use it.\n\n```javascript\nconst Redis = require(\"ioredis\");\nRedis.Promise = require(\"bluebird\");\n\nconst redis = new Redis();\n\n// Use bluebird\nassert.equal(redis.get().constructor, require(\"bluebird\"));\n\n// You can change the Promise implementation at any time:\nRedis.Promise = global.Promise;\nassert.equal(redis.get().constructor, global.Promise);\n```\n\n# Running tests\n\nStart a Redis server on 127.0.0.1:6379, and then:\n\n```shell\n$ npm test\n```\n\n`FLUSH ALL` will be invoked after each test, so make sure there's no valuable data in it before running tests.\n\nIf your testing environment does not let you spin up a Redis server [ioredis-mock](https://github.com/stipsan/ioredis-mock) is a drop-in replacement you can use in your tests. It aims to behave identically to ioredis connected to a Redis server so that your integration tests is easier to write and of better quality.\n\n# Debug\n\nYou can set the `DEBUG` env to `ioredis:*` to print debug info:\n\n```shell\n$ DEBUG=ioredis:* node app.js\n```\n\n# Join in!\n\nI'm happy to receive bug reports, fixes, documentation enhancements, and any other improvements.\n\nAnd since I'm not a native English speaker, if you find any grammar mistakes in the documentation, please also let me know. :)\n\n# Become a Sponsor\n\nOpen source is hard and time-consuming. If you want to invest in ioredis's future you can become a sponsor and make us spend more time on this library's improvements and new features.\n\n<a href=\"https://opencollective.com/ioredis\"><img src=\"https://opencollective.com/ioredis/tiers/sponsor.svg?avatarHeight=36\"></a>\n\nThank you for using ioredis :-)\n\n# Contributors\n\nThis project exists thanks to all the people who contribute:\n\n<a href=\"https://github.com/luin/ioredis/graphs/contributors\"><img src=\"https://opencollective.com/ioredis/contributors.svg?width=890&showBtn=false\" /></a>\n\n# License\n\nMIT\n\n[![FOSSA Status](https://app.fossa.io/api/projects/git%2Bgithub.com%2Fluin%2Fioredis.svg?type=large)](https://app.fossa.io/projects/git%2Bgithub.com%2Fluin%2Fioredis?ref=badge_large)\n","readmeFilename":"README.md","bugs":{"url":"https://github.com/luin/ioredis/issues"},"homepage":"https://github.com/luin/ioredis#readme","_id":"ioredis@4.14.4","_nodeVersion":"10.17.0","_npmVersion":"6.11.3","dist":{"integrity":"sha512-9JAQi9Z0OioGNFKIgDKv6CpjNHaUX3CbkF02jDpPMe3+6v+TI47Ky4XvByeDV0wb7yrZyKCilW/6STIZs8GX3Q==","shasum":"76dd85e99f5c93e899d1e8098d2eec745ab7b4e1","tarball":"https://registry.npmjs.org/ioredis/-/ioredis-4.14.4.tgz","fileCount":36,"unpackedSize":241160,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJd2BvfCRA9TVsSAnZWagAA0i4P+wUIjprMqmBfUonTHam3\nfGoHep2PC/x1NmeGIvMXMIVemqj/9k3NCRY//R8DwAly/KquLwUphrm03Mrb\nBu0gpExjeRfJhdiwGRSpKT9hvNb++1Xq4nCezYQuVawc3LAzo0E9UHvc3497\nGXk4He5+xP7GLMaMTdHF6MgLCfGPQ98mjMiyZp0PotNfYb0yATE4VrZMd9a7\nKPEQuAtv0f66bzWn76qQP3nk2Q0yBWmK+2W1s0K6hcjRIjq3ckzABlzj9jhZ\n05RnpTlWVEteYRFsKte9+B7jHRUpwV4xQJUI8Hi0Lp7gipLtwOYJ7g+OncA3\nzdHefXhj8HcR95Z1NFFSPpu+ItYHZGvr/bNfsUCNw74EU3InwmPkki7p9lTZ\nDG8Bs3ZGRcKiK8CySObCZFltZIslpteCAnl8iEXTg71agvwkjhF1qKwnnuZb\nDsX/rctEjHkdycOpxpr4sMBVn6vgNdhLVzY3ET53xQTpoppo0pNo+9NGskZW\nss5u7CDFmm4xYJJMtjTzXAQ0R/nf9KYwxhRRL0u899DejAgg2bv30gjUXohS\nDK4La5sfp4pKUI6Amsi3eUdAIjKvrZm96U32cCKJ/lejJuNwPOF/fWiUpHHI\njPg8xDOMppPjepL02f5g/a0X0sy01SsYHz0uyjj02oW7z/G5q19pWM52hP9V\nrbVe\r\n=XPtH\r\n-----END PGP SIGNATURE-----\r\n"},"maintainers":[{"email":"ioredis-robot@zihua.li","name":"ioredis-robot"},{"email":"i@zihua.li","name":"luin"}],"_npmUser":{"name":"luin","email":"i@zihua.li"},"directories":{},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/ioredis_4.14.4_1574443999107_0.8642609803944938"},"_hasShrinkwrap":false},"4.15.0":{"name":"ioredis","version":"4.15.0","description":"A robust, performance-focused and full-featured Redis client for Node.js.","main":"built/index.js","scripts":{"test":"TS_NODE_TRANSPILE_ONLY=true TS_NODE_LOG_ERROR=true NODE_ENV=test mocha \"test/**/*.ts\"","test:cov":"TS_NODE_TRANSPILE_ONLY=true TS_NODE_LOG_ERROR=true NODE_ENV=test node ./node_modules/istanbul/lib/cli.js cover --preserve-comments ./node_modules/mocha/bin/_mocha -- -r ts-node/register -R spec --exit \"test/**/*.ts\"","lint":"eslint --ext .js,.ts .","format":"prettier --write \"{,!(node_modules)/**/}*.{js,ts}\"","format-check":"prettier --check \"{,!(node_modules)/**/}*.{js,ts}\"","build":"rm -rf built && tsc","prepublishOnly":"npm run build && npm test","bench":"matcha benchmarks/*.js","semantic-release":"semantic-release"},"repository":{"type":"git","url":"git://github.com/luin/ioredis.git"},"keywords":["redis","cluster","sentinel","pipelining"],"author":{"name":"luin","email":"i@zihua.li","url":"http://zihua.li"},"license":"MIT","funding":{"type":"opencollective","url":"https://opencollective.com/ioredis"},"dependencies":{"cluster-key-slot":"^1.1.0","debug":"^4.1.1","denque":"^1.1.0","lodash.defaults":"^4.2.0","lodash.flatten":"^4.4.0","redis-commands":"1.5.0","redis-errors":"^1.2.0","redis-parser":"^3.0.0","standard-as-callback":"^2.0.1"},"devDependencies":{"@semantic-release/changelog":"^3.0.4","@semantic-release/git":"^7.0.12","@types/bluebird":"^3.5.27","@types/chai":"^4.1.7","@types/debug":"^4.1.4","@types/lodash.defaults":"^4.2.6","@types/lodash.flatten":"^4.4.6","@types/mocha":"^5.2.7","@types/node":"^12.0.2","@types/redis-errors":"1.2.0","@types/sinon":"^7.0.13","@typescript-eslint/eslint-plugin":"^1.11.0","@typescript-eslint/parser":"^1.11.0","bluebird":"^3.5.4","chai":"^4.2.0","cz-conventional-changelog":"^2.0.0","eslint":"^5.16.0","eslint-config-prettier":"^5.1.0","husky":"^2.5.0","istanbul":"^0.4.5","mocha":"^5.0.0","prettier":"^1.18.2","pretty-quick":"^1.11.1","server-destroy":"^1.0.1","sinon":"^7.3.2","ts-node":"^8.1.0","typescript":"^3.5.1"},"engines":{"node":">=6"},"config":{"commitizen":{"path":"./node_modules/cz-conventional-changelog"}},"husky":{"hooks":{"pre-commit":"pretty-quick --staged"}},"gitHead":"0db527fd4266913583bce55245940e825dba1a46","readme":"[![ioredis](https://cdn.jsdelivr.net/gh/luin/ioredis@b5e8c74/logo.svg)](https://github.com/luin/ioredis)\n\n[![Build Status](https://travis-ci.org/luin/ioredis.svg?branch=master)](https://travis-ci.org/luin/ioredis)\n[![Test Coverage](https://codeclimate.com/github/luin/ioredis/badges/coverage.svg)](https://codeclimate.com/github/luin/ioredis)\n[![code style: prettier](https://img.shields.io/badge/code_style-prettier-ff69b4.svg?style=flat-square)](https://github.com/prettier/prettier)\n[![Join the chat at https://gitter.im/luin/ioredis](https://badges.gitter.im/Join%20Chat.svg)](https://gitter.im/luin/ioredis?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge)\n[![Commitizen friendly](https://img.shields.io/badge/commitizen-friendly-brightgreen.svg)](http://commitizen.github.io/cz-cli/)\n[![semantic-release](https://img.shields.io/badge/%20%20%F0%9F%93%A6%F0%9F%9A%80-semantic--release-e10079.svg)](https://github.com/semantic-release/semantic-release)\n[![npm latest version](https://img.shields.io/npm/v/ioredis/latest.svg)](https://www.npmjs.com/package/ioredis)\n[![npm next version](https://img.shields.io/npm/v/ioredis/next.svg)](https://www.npmjs.com/package/ioredis)\n<img alt=\"\" src=\"\">\n\nA robust, performance-focused and full-featured [Redis](http://redis.io) client for [Node.js](https://nodejs.org).\n\nSupports Redis >= 2.6.12 and (Node.js >= 6).\n\n# Features\n\nioredis is a robust, full-featured Redis client that is\nused in the world's biggest online commerce company [Alibaba](http://www.alibaba.com/) and many other awesome companies.\n\n0. Full-featured. It supports [Cluster](http://redis.io/topics/cluster-tutorial), [Sentinel](http://redis.io/topics/sentinel), [Pipelining](http://redis.io/topics/pipelining) and of course [Lua scripting](http://redis.io/commands/eval) & [Pub/Sub](http://redis.io/topics/pubsub) (with the support of binary messages).\n1. High performance.\n2. Delightful API. It works with Node callbacks and Native promises.\n3. Transformation of command arguments and replies.\n4. Transparent key prefixing.\n5. Abstraction for Lua scripting, allowing you to define custom commands.\n6. Support for binary data.\n7. Support for TLS.\n8. Support for offline queue and ready checking.\n9. Support for ES6 types, such as `Map` and `Set`.\n10. Support for GEO commands (Redis 3.2 Unstable).\n11. Sophisticated error handling strategy.\n12. Support for NAT mapping.\n\n# Links\n\n- [API Documentation](API.md)\n- [Changelog](Changelog.md)\n- [Migrating from node_redis](https://github.com/luin/ioredis/wiki/Migrating-from-node_redis)\n- [Error Handling](#error-handling)\n\n<hr>\n<a href=\"http://bit.ly/medis-macos\"><img align=\"right\" src=\"resources/medis.png\" alt=\"Download on the App Store\"></a>\n\n### [AD] Medis: Redis GUI for OS X\n\nLooking for a Redis GUI manager for OS X, Windows and Linux? Here's [Medis](http://bit.ly/medis-macos)!\n\nMedis is an open-sourced, beautiful, easy-to-use Redis GUI management application.\n\nMedis starts with all the basic features you need:\n\n- Keys viewing/editing\n- SSH Tunnel for connecting with remote servers\n- Terminal for executing custom commands\n- JSON/MessagePack format viewing/editing and built-in highlighting/validator\n- And other awesome features...\n\n[Medis is open sourced on GitHub](https://github.com/luin/medis)\n\n### [AD] Kuber: Kubernetes Dashboard for iOS\n\n<a href=\"http://bit.ly/kuber-ios\"><img src=\"resources/kuber.png\" alt=\"Download on the App Store\"></a>\n\n<hr>\n\n# Quick Start\n\n## Install\n\n```shell\n$ npm install ioredis\n```\n\n## Basic Usage\n\n```javascript\nvar Redis = require(\"ioredis\");\nvar redis = new Redis();\n\nredis.set(\"foo\", \"bar\");\nredis.get(\"foo\", function(err, result) {\n  console.log(result);\n});\nredis.del(\"foo\");\n\n// Or using a promise if the last argument isn't a function\nredis.get(\"foo\").then(function(result) {\n  console.log(result);\n});\n\n// Arguments to commands are flattened, so the following are the same:\nredis.sadd(\"set\", 1, 3, 5, 7);\nredis.sadd(\"set\", [1, 3, 5, 7]);\n\n// All arguments are passed directly to the redis server:\nredis.set(\"key\", 100, \"EX\", 10);\n```\n\nSee the `examples/` folder for more examples.\n\n## Connect to Redis\n\nWhen a new `Redis` instance is created,\na connection to Redis will be created at the same time.\nYou can specify which Redis to connect to by:\n\n```javascript\nnew Redis(); // Connect to 127.0.0.1:6379\nnew Redis(6380); // 127.0.0.1:6380\nnew Redis(6379, \"192.168.1.1\"); // 192.168.1.1:6379\nnew Redis(\"/tmp/redis.sock\");\nnew Redis({\n  port: 6379, // Redis port\n  host: \"127.0.0.1\", // Redis host\n  family: 4, // 4 (IPv4) or 6 (IPv6)\n  password: \"auth\",\n  db: 0\n});\n```\n\nYou can also specify connection options as a [`redis://` URL](http://www.iana.org/assignments/uri-schemes/prov/redis) or [`rediss://` URL](https://www.iana.org/assignments/uri-schemes/prov/rediss) when using [TLS encryption](#tls-options):\n\n```javascript\n// Connect to 127.0.0.1:6380, db 4, using password \"authpassword\":\nnew Redis(\"redis://:authpassword@127.0.0.1:6380/4\");\n```\n\nSee [API Documentation](API.md#new_Redis) for all available options.\n\n## Pub/Sub\n\nHere is a simple example of the API for publish/subscribe.\nThe following program opens two client connections.\nIt subscribes to a channel with one connection\nand publishes to that channel with the other:\n\n```javascript\nvar Redis = require(\"ioredis\");\nvar redis = new Redis();\nvar pub = new Redis();\nredis.subscribe(\"news\", \"music\", function(err, count) {\n  // Now we are subscribed to both the 'news' and 'music' channels.\n  // `count` represents the number of channels we are currently subscribed to.\n\n  pub.publish(\"news\", \"Hello world!\");\n  pub.publish(\"music\", \"Hello again!\");\n});\n\nredis.on(\"message\", function(channel, message) {\n  // Receive message Hello world! from channel news\n  // Receive message Hello again! from channel music\n  console.log(\"Receive message %s from channel %s\", message, channel);\n});\n\n// There's also an event called 'messageBuffer', which is the same as 'message' except\n// it returns buffers instead of strings.\nredis.on(\"messageBuffer\", function(channel, message) {\n  // Both `channel` and `message` are buffers.\n});\n```\n\n`PSUBSCRIBE` is also supported in a similar way:\n\n```javascript\nredis.psubscribe(\"pat?ern\", function(err, count) {});\nredis.on(\"pmessage\", function(pattern, channel, message) {});\nredis.on(\"pmessageBuffer\", function(pattern, channel, message) {});\n```\n\nWhen a client issues a SUBSCRIBE or PSUBSCRIBE, that connection is put into a \"subscriber\" mode.\nAt that point, only commands that modify the subscription set are valid.\nWhen the subscription set is empty, the connection is put back into regular mode.\n\nIf you need to send regular commands to Redis while in subscriber mode, just open another connection.\n\n## Handle Binary Data\n\nArguments can be buffers:\n\n```javascript\nredis.set(\"foo\", Buffer.from(\"bar\"));\n```\n\nAnd every command has a method that returns a Buffer (by adding a suffix of \"Buffer\" to the command name).\nTo get a buffer instead of a utf8 string:\n\n```javascript\nredis.getBuffer(\"foo\", function(err, result) {\n  // result is a buffer.\n});\n```\n\n## Pipelining\n\nIf you want to send a batch of commands (e.g. > 5), you can use pipelining to queue\nthe commands in memory and then send them to Redis all at once. This way the performance improves by 50%~300% (See [benchmark section](#benchmark)).\n\n`redis.pipeline()` creates a `Pipeline` instance. You can call any Redis\ncommands on it just like the `Redis` instance. The commands are queued in memory\nand flushed to Redis by calling the `exec` method:\n\n```javascript\nvar pipeline = redis.pipeline();\npipeline.set(\"foo\", \"bar\");\npipeline.del(\"cc\");\npipeline.exec(function(err, results) {\n  // `err` is always null, and `results` is an array of responses\n  // corresponding to the sequence of queued commands.\n  // Each response follows the format `[err, result]`.\n});\n\n// You can even chain the commands:\nredis\n  .pipeline()\n  .set(\"foo\", \"bar\")\n  .del(\"cc\")\n  .exec(function(err, results) {});\n\n// `exec` also returns a Promise:\nvar promise = redis\n  .pipeline()\n  .set(\"foo\", \"bar\")\n  .get(\"foo\")\n  .exec();\npromise.then(function(result) {\n  // result === [[null, 'OK'], [null, 'bar']]\n});\n```\n\nEach chained command can also have a callback, which will be invoked when the command\ngets a reply:\n\n```javascript\nredis\n  .pipeline()\n  .set(\"foo\", \"bar\")\n  .get(\"foo\", function(err, result) {\n    // result === 'bar'\n  })\n  .exec(function(err, result) {\n    // result[1][1] === 'bar'\n  });\n```\n\nIn addition to adding commands to the `pipeline` queue individually, you can also pass an array of commands and arguments to the constructor:\n\n```javascript\nredis.pipeline([[\"set\", \"foo\", \"bar\"], [\"get\", \"foo\"]]).exec(function() {\n  /* ... */\n});\n```\n\n`#length` property shows how many commands in the pipeline:\n\n```javascript\nconst length = redis\n  .pipeline()\n  .set(\"foo\", \"bar\")\n  .get(\"foo\").length;\n// length === 2\n```\n\n## Transaction\n\nMost of the time, the transaction commands `multi` & `exec` are used together with pipeline.\nTherefore, when `multi` is called, a `Pipeline` instance is created automatically by default,\nso you can use `multi` just like `pipeline`:\n\n```javascript\nredis\n  .multi()\n  .set(\"foo\", \"bar\")\n  .get(\"foo\")\n  .exec(function(err, results) {\n    // results === [[null, 'OK'], [null, 'bar']]\n  });\n```\n\nIf there's a syntax error in the transaction's command chain (e.g. wrong number of arguments, wrong command name, etc),\nthen none of the commands would be executed, and an error is returned:\n\n```javascript\nredis\n  .multi()\n  .set(\"foo\")\n  .set(\"foo\", \"new value\")\n  .exec(function(err, results) {\n    // err:\n    //  { [ReplyError: EXECABORT Transaction discarded because of previous errors.]\n    //    name: 'ReplyError',\n    //    message: 'EXECABORT Transaction discarded because of previous errors.',\n    //    command: { name: 'exec', args: [] },\n    //    previousErrors:\n    //     [ { [ReplyError: ERR wrong number of arguments for 'set' command]\n    //         name: 'ReplyError',\n    //         message: 'ERR wrong number of arguments for \\'set\\' command',\n    //         command: [Object] } ] }\n  });\n```\n\nIn terms of the interface, `multi` differs from `pipeline` in that when specifying a callback\nto each chained command, the queueing state is passed to the callback instead of the result of the command:\n\n```javascript\nredis\n  .multi()\n  .set(\"foo\", \"bar\", function(err, result) {\n    // result === 'QUEUED'\n  })\n  .exec(/* ... */);\n```\n\nIf you want to use transaction without pipeline, pass `{ pipeline: false }` to `multi`,\nand every command will be sent to Redis immediately without waiting for an `exec` invocation:\n\n```javascript\nredis.multi({ pipeline: false });\nredis.set(\"foo\", \"bar\");\nredis.get(\"foo\");\nredis.exec(function(err, result) {\n  // result === [[null, 'OK'], [null, 'bar']]\n});\n```\n\nThe constructor of `multi` also accepts a batch of commands:\n\n```javascript\nredis.multi([[\"set\", \"foo\", \"bar\"], [\"get\", \"foo\"]]).exec(function() {\n  /* ... */\n});\n```\n\nInline transactions are supported by pipeline, which means you can group a subset of commands\nin the pipeline into a transaction:\n\n```javascript\nredis\n  .pipeline()\n  .get(\"foo\")\n  .multi()\n  .set(\"foo\", \"bar\")\n  .get(\"foo\")\n  .exec()\n  .get(\"foo\")\n  .exec();\n```\n\n## Lua Scripting\n\nioredis supports all of the scripting commands such as `EVAL`, `EVALSHA` and `SCRIPT`.\nHowever, it's tedious to use in real world scenarios since developers have to take\ncare of script caching and to detect when to use `EVAL` and when to use `EVALSHA`.\nioredis exposes a `defineCommand` method to make scripting much easier to use:\n\n```javascript\nvar redis = new Redis();\n\n// This will define a command echo:\nredis.defineCommand(\"echo\", {\n  numberOfKeys: 2,\n  lua: \"return {KEYS[1],KEYS[2],ARGV[1],ARGV[2]}\"\n});\n\n// Now `echo` can be used just like any other ordinary command,\n// and ioredis will try to use `EVALSHA` internally when possible for better performance.\nredis.echo(\"k1\", \"k2\", \"a1\", \"a2\", function(err, result) {\n  // result === ['k1', 'k2', 'a1', 'a2']\n});\n\n// `echoBuffer` is also defined automatically to return buffers instead of strings:\nredis.echoBuffer(\"k1\", \"k2\", \"a1\", \"a2\", function(err, result) {\n  // result[0] equals to Buffer.from('k1');\n});\n\n// And of course it works with pipeline:\nredis\n  .pipeline()\n  .set(\"foo\", \"bar\")\n  .echo(\"k1\", \"k2\", \"a1\", \"a2\")\n  .exec();\n```\n\nIf the number of keys can't be determined when defining a command, you can\nomit the `numberOfKeys` property and pass the number of keys as the first argument\nwhen you call the command:\n\n```javascript\nredis.defineCommand(\"echoDynamicKeyNumber\", {\n  lua: \"return {KEYS[1],KEYS[2],ARGV[1],ARGV[2]}\"\n});\n\n// Now you have to pass the number of keys as the first argument every time\n// you invoke the `echoDynamicKeyNumber` command:\nredis.echoDynamicKeyNumber(2, \"k1\", \"k2\", \"a1\", \"a2\", function(err, result) {\n  // result === ['k1', 'k2', 'a1', 'a2']\n});\n```\n\n## Transparent Key Prefixing\n\nThis feature allows you to specify a string that will automatically be prepended\nto all the keys in a command, which makes it easier to manage your key\nnamespaces.\n\n**Warning** This feature won't apply to commands like [KEYS](http://redis.io/commands/KEYS) and [SCAN](http://redis.io/commands/scan) that take patterns rather than actual keys([#239](https://github.com/luin/ioredis/issues/239)),\nand this feature also won't apply to the replies of commands even they are key names ([#325](https://github.com/luin/ioredis/issues/325)).\n\n```javascript\nvar fooRedis = new Redis({ keyPrefix: \"foo:\" });\nfooRedis.set(\"bar\", \"baz\"); // Actually sends SET foo:bar baz\n\nfooRedis.defineCommand(\"echo\", {\n  numberOfKeys: 2,\n  lua: \"return {KEYS[1],KEYS[2],ARGV[1],ARGV[2]}\"\n});\n\n// Works well with pipelining/transaction\nfooRedis\n  .pipeline()\n  // Sends SORT foo:list BY foo:weight_*->fieldname\n  .sort(\"list\", \"BY\", \"weight_*->fieldname\")\n  // Supports custom commands\n  // Sends EVALSHA xxx foo:k1 foo:k2 a1 a2\n  .echo(\"k1\", \"k2\", \"a1\", \"a2\")\n  .exec();\n```\n\n## Transforming Arguments & Replies\n\nMost Redis commands take one or more Strings as arguments,\nand replies are sent back as a single String or an Array of Strings. However, sometimes\nyou may want something different. For instance, it would be more convenient if the `HGETALL`\ncommand returns a hash (e.g. `{ key: val1, key2: v2 }`) rather than an array of key values (e.g. `[key1, val1, key2, val2]`).\n\nioredis has a flexible system for transforming arguments and replies. There are two types\nof transformers, argument transformer and reply transformer:\n\n```javascript\nvar Redis = require(\"ioredis\");\n\n// Here's the built-in argument transformer converting\n// hmset('key', { k1: 'v1', k2: 'v2' })\n// or\n// hmset('key', new Map([['k1', 'v1'], ['k2', 'v2']]))\n// into\n// hmset('key', 'k1', 'v1', 'k2', 'v2')\nRedis.Command.setArgumentTransformer(\"hmset\", function(args) {\n  if (args.length === 2) {\n    if (typeof Map !== \"undefined\" && args[1] instanceof Map) {\n      // utils is a internal module of ioredis\n      return [args[0]].concat(utils.convertMapToArray(args[1]));\n    }\n    if (typeof args[1] === \"object\" && args[1] !== null) {\n      return [args[0]].concat(utils.convertObjectToArray(args[1]));\n    }\n  }\n  return args;\n});\n\n// Here's the built-in reply transformer converting the HGETALL reply\n// ['k1', 'v1', 'k2', 'v2']\n// into\n// { k1: 'v1', 'k2': 'v2' }\nRedis.Command.setReplyTransformer(\"hgetall\", function(result) {\n  if (Array.isArray(result)) {\n    var obj = {};\n    for (var i = 0; i < result.length; i += 2) {\n      obj[result[i]] = result[i + 1];\n    }\n    return obj;\n  }\n  return result;\n});\n```\n\nThere are three built-in transformers, two argument transformers for `hmset` & `mset` and\na reply transformer for `hgetall`. Transformers for `hmset` and `hgetall` were mentioned\nabove, and the transformer for `mset` is similar to the one for `hmset`:\n\n```javascript\nredis.mset({ k1: \"v1\", k2: \"v2\" });\nredis.get(\"k1\", function(err, result) {\n  // result === 'v1';\n});\n\nredis.mset(new Map([[\"k3\", \"v3\"], [\"k4\", \"v4\"]]));\nredis.get(\"k3\", function(err, result) {\n  // result === 'v3';\n});\n```\n\nAnother useful example of a reply transformer is one that changes `hgetall` to return array of arrays instead of objects which avoids a unwanted conversation of hash keys to strings when dealing with binary hash keys:\n\n```javascript\nRedis.Command.setReplyTransformer(\"hgetall\", function(result) {\n  var arr = [];\n  for (var i = 0; i < result.length; i += 2) {\n    arr.push([result[i], result[i + 1]]);\n  }\n  return arr;\n});\nredis.hset(\"h1\", Buffer.from([0x01]), Buffer.from([0x02]));\nredis.hset(\"h1\", Buffer.from([0x03]), Buffer.from([0x04]));\nredis.hgetallBuffer(\"h1\", function(err, result) {\n  // result === [ [ <Buffer 01>, <Buffer 02> ], [ <Buffer 03>, <Buffer 04> ] ];\n});\n```\n\n## Monitor\n\nRedis supports the MONITOR command,\nwhich lets you see all commands received by the Redis server across all client connections,\nincluding from other client libraries and other computers.\n\nThe `monitor` method returns a monitor instance.\nAfter you send the MONITOR command, no other commands are valid on that connection. ioredis will emit a monitor event for every new monitor message that comes across.\nThe callback for the monitor event takes a timestamp from the Redis server and an array of command arguments.\n\nHere is a simple example:\n\n```javascript\nredis.monitor(function(err, monitor) {\n  monitor.on(\"monitor\", function(time, args, source, database) {});\n});\n```\nHere is another example illustrating an `async` function and `monitor.disconnect()`:\n```javascript\nasync () => {\n  const monitor = await redis.monitor()\n  monitor.on('monitor', console.log)\n  // Any other tasks\n  monitor.disconnect()\n}\n```\n## Streamify Scanning\n\nRedis 2.8 added the `SCAN` command to incrementally iterate through the keys in the database. It's different from `KEYS` in that\n`SCAN` only returns a small number of elements each call, so it can be used in production without the downside\nof blocking the server for a long time. However, it requires recording the cursor on the client side each time\nthe `SCAN` command is called in order to iterate through all the keys correctly. Since it's a relatively common use case, ioredis\nprovides a streaming interface for the `SCAN` command to make things much easier. A readable stream can be created by calling `scanStream`:\n\n```javascript\nvar redis = new Redis();\n// Create a readable stream (object mode)\nvar stream = redis.scanStream();\nstream.on(\"data\", function(resultKeys) {\n  // `resultKeys` is an array of strings representing key names.\n  // Note that resultKeys may contain 0 keys, and that it will sometimes\n  // contain duplicates due to SCAN's implementation in Redis.\n  for (var i = 0; i < resultKeys.length; i++) {\n    console.log(resultKeys[i]);\n  }\n});\nstream.on(\"end\", function() {\n  console.log(\"all keys have been visited\");\n});\n```\n\n`scanStream` accepts an option, with which you can specify the `MATCH` pattern and the `COUNT` argument:\n\n```javascript\nvar stream = redis.scanStream({\n  // only returns keys following the pattern of `user:*`\n  match: \"user:*\",\n  // returns approximately 100 elements per call\n  count: 100\n});\n```\n\nJust like other commands, `scanStream` has a binary version `scanBufferStream`, which returns an array of buffers. It's useful when\nthe key names are not utf8 strings.\n\nThere are also `hscanStream`, `zscanStream` and `sscanStream` to iterate through elements in a hash, zset and set. The interface of each is\nsimilar to `scanStream` except the first argument is the key name:\n\n```javascript\nvar stream = redis.hscanStream(\"myhash\", {\n  match: \"age:??\"\n});\n```\n\nYou can learn more from the [Redis documentation](http://redis.io/commands/scan).\n\n**Useful Tips**\nIt's pretty common that doing an async task in the `data` handler. We'd like the scanning process to be paused until the async task to be finished. `Stream#pause()` and `Stream.resume()` do the trick. For example if we want to migrate data in Redis to MySQL:\n\n```javascript\nvar stream = redis.scanStream();\nstream.on(\"data\", function(resultKeys) {\n  // Pause the stream from scanning more keys until we've migrated the current keys.\n  stream.pause();\n\n  Promise.all(resultKeys.map(migrateKeyToMySQL)).then(() => {\n    // Resume the stream here.\n    stream.resume();\n  });\n});\n\nstream.on(\"end\", function() {\n  console.log(\"done migration\");\n});\n```\n\n## Auto-reconnect\n\nBy default, ioredis will try to reconnect when the connection to Redis is lost\nexcept when the connection is closed manually by `redis.disconnect()` or `redis.quit()`.\n\nIt's very flexible to control how long to wait to reconnect after disconnection\nusing the `retryStrategy` option:\n\n```javascript\nvar redis = new Redis({\n  // This is the default value of `retryStrategy`\n  retryStrategy: function(times) {\n    var delay = Math.min(times * 50, 2000);\n    return delay;\n  }\n});\n```\n\n`retryStrategy` is a function that will be called when the connection is lost.\nThe argument `times` means this is the nth reconnection being made and\nthe return value represents how long (in ms) to wait to reconnect. When the\nreturn value isn't a number, ioredis will stop trying to reconnect, and the connection\nwill be lost forever if the user doesn't call `redis.connect()` manually.\n\nWhen reconnected, the client will auto subscribe to channels that the previous connection subscribed to.\nThis behavior can be disabled by setting the `autoResubscribe` option to `false`.\n\nAnd if the previous connection has some unfulfilled commands (most likely blocking commands such as `brpop` and `blpop`),\nthe client will resend them when reconnected. This behavior can be disabled by setting the `autoResendUnfulfilledCommands` option to `false`.\n\nBy default, all pending commands will be flushed with an error every 20 retry attempts. That makes sure commands won't wait forever when the connection is down. You can change this behavior by setting `maxRetriesPerRequest`:\n\n```javascript\nvar redis = new Redis({\n  maxRetriesPerRequest: 1\n});\n```\n\nSet maxRetriesPerRequest to `null` to disable this behavior, and every command will wait forever until the connection is alive again (which is the default behavior before ioredis v4).\n\n### Reconnect on error\n\nBesides auto-reconnect when the connection is closed, ioredis supports reconnecting on the specified errors by the `reconnectOnError` option. Here's an example that will reconnect when receiving `READONLY` error:\n\n```javascript\nvar redis = new Redis({\n  reconnectOnError: function(err) {\n    var targetError = \"READONLY\";\n    if (err.message.slice(0, targetError.length) === targetError) {\n      // Only reconnect when the error starts with \"READONLY\"\n      return true; // or `return 1;`\n    }\n  }\n});\n```\n\nThis feature is useful when using Amazon ElastiCache. Once failover happens, Amazon ElastiCache will switch the master we currently connected with to a slave, leading to the following writes fails with the error `READONLY`. Using `reconnectOnError`, we can force the connection to reconnect on this error in order to connect to the new master.\n\nFurthermore, if the `reconnectOnError` returns `2`, ioredis will resend the failed command after reconnecting.\n\n## Connection Events\n\nThe Redis instance will emit some events about the state of the connection to the Redis server.\n\n| Event        | Description                                                                                                                                                                                                                                     |\n| :----------- | :---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| connect      | emits when a connection is established to the Redis server.                                                                                                                                                                                     |\n| ready        | If `enableReadyCheck` is `true`, client will emit `ready` when the server reports that it is ready to receive commands (e.g. finish loading data from disk).<br>Otherwise, `ready` will be emitted immediately right after the `connect` event. |\n| error        | emits when an error occurs while connecting.<br>However, ioredis emits all `error` events silently (only emits when there's at least one listener) so that your application won't crash if you're not listening to the `error` event.           |\n| close        | emits when an established Redis server connection has closed.                                                                                                                                                                                   |\n| reconnecting | emits after `close` when a reconnection will be made. The argument of the event is the time (in ms) before reconnecting.                                                                                                                        |\n| end          | emits after `close` when no more reconnections will be made, or the connection is failed to establish.                                                                                                                                          |\n\nYou can also check out the `Redis#status` property to get the current connection status.\n\nBesides the above connection events, there are several other custom events:\n\n| Event  | Description                                                         |\n| :----- | :------------------------------------------------------------------ |\n| select | emits when the database changed. The argument is the new db number. |\n\n## Offline Queue\n\nWhen a command can't be processed by Redis (being sent before the `ready` event), by default, it's added to the offline queue and will be\nexecuted when it can be processed. You can disable this feature by setting the `enableOfflineQueue`\noption to `false`:\n\n```javascript\nvar redis = new Redis({ enableOfflineQueue: false });\n```\n\n## TLS Options\n\nRedis doesn't support TLS natively, however if the redis server you want to connect to is hosted behind a TLS proxy (e.g. [stunnel](https://www.stunnel.org/)) or is offered by a PaaS service that supports TLS connection (e.g. [Redis Labs](https://redislabs.com/)), you can set the `tls` option:\n\n```javascript\nvar redis = new Redis({\n  host: \"localhost\",\n  tls: {\n    // Refer to `tls.connect()` section in\n    // https://nodejs.org/api/tls.html\n    // for all supported options\n    ca: fs.readFileSync(\"cert.pem\")\n  }\n});\n```\n\nAlternatively, specify the connection through a [`rediss://` URL](https://www.iana.org/assignments/uri-schemes/prov/rediss).\n\n```javascript\nvar redis = new Redis(\"rediss://redis.my-service.com\");\n```\n\n<hr>\n\n## Sentinel\n\nioredis supports Sentinel out of the box. It works transparently as all features that work when\nyou connect to a single node also work when you connect to a sentinel group. Make sure to run Redis >= 2.8.12 if you want to use this feature. Sentinels have a default port of 26379.\n\nTo connect using Sentinel, use:\n\n```javascript\nvar redis = new Redis({\n  sentinels: [\n    { host: \"localhost\", port: 26379 },\n    { host: \"localhost\", port: 26380 }\n  ],\n  name: \"mymaster\"\n});\n\nredis.set(\"foo\", \"bar\");\n```\n\nThe arguments passed to the constructor are different from the ones you use to connect to a single node, where:\n\n- `name` identifies a group of Redis instances composed of a master and one or more slaves (`mymaster` in the example);\n- `sentinelPassword` (optional) password for Sentinel instances.\n- `sentinels` are a list of sentinels to connect to. The list does not need to enumerate all your sentinel instances, but a few so that if one is down the client will try the next one.\n- `role` (optional) with a value of `slave` will return a random slave from the Sentinel group.\n- `preferredSlaves` (optional) can be used to prefer a particular slave or set of slaves based on priority. It accepts a function or array.\n\nioredis **guarantees** that the node you connected to is always a master even after a failover. When a failover happens, instead of trying to reconnect to the failed node (which will be demoted to slave when it's available again), ioredis will ask sentinels for the new master node and connect to it. All commands sent during the failover are queued and will be executed when the new connection is established so that none of the commands will be lost.\n\nIt's possible to connect to a slave instead of a master by specifying the option `role` with the value of `slave` and ioredis will try to connect to a random slave of the specified master, with the guarantee that the connected node is always a slave. If the current node is promoted to master due to a failover, ioredis will disconnect from it and ask the sentinels for another slave node to connect to.\n\nIf you specify the option `preferredSlaves` along with `role: 'slave'` ioredis will attempt to use this value when selecting the slave from the pool of available slaves. The value of `preferredSlaves` should either be a function that accepts an array of avaiable slaves and returns a single result, or an array of slave values priorities by the lowest `prio` value first with a default value of `1`.\n\n```javascript\n// available slaves format\nvar availableSlaves = [{ ip: \"127.0.0.1\", port: \"31231\", flags: \"slave\" }];\n\n// preferredSlaves array format\nvar preferredSlaves = [\n  { ip: \"127.0.0.1\", port: \"31231\", prio: 1 },\n  { ip: \"127.0.0.1\", port: \"31232\", prio: 2 }\n];\n\n// preferredSlaves function format\npreferredSlaves = function(availableSlaves) {\n  for (var i = 0; i < availableSlaves.length; i++) {\n    var slave = availableSlaves[i];\n    if (slave.ip === \"127.0.0.1\") {\n      if (slave.port === \"31234\") {\n        return slave;\n      }\n    }\n  }\n  // if no preferred slaves are available a random one is used\n  return false;\n};\n\nvar redis = new Redis({\n  sentinels: [\n    { host: \"127.0.0.1\", port: 26379 },\n    { host: \"127.0.0.1\", port: 26380 }\n  ],\n  name: \"mymaster\",\n  role: \"slave\",\n  preferredSlaves: preferredSlaves\n});\n```\n\nBesides the `retryStrategy` option, there's also a `sentinelRetryStrategy` in Sentinel mode which will be invoked when all the sentinel nodes are unreachable during connecting. If `sentinelRetryStrategy` returns a valid delay time, ioredis will try to reconnect from scratch. The default value of `sentinelRetryStrategy` is:\n\n```javascript\nfunction (times) {\n  var delay = Math.min(times * 10, 1000);\n  return delay;\n}\n```\n\n## Cluster\n\nRedis Cluster provides a way to run a Redis installation where data is automatically sharded across multiple Redis nodes.\nYou can connect to a Redis Cluster like this:\n\n```javascript\nvar Redis = require(\"ioredis\");\n\nvar cluster = new Redis.Cluster([\n  {\n    port: 6380,\n    host: \"127.0.0.1\"\n  },\n  {\n    port: 6381,\n    host: \"127.0.0.1\"\n  }\n]);\n\ncluster.set(\"foo\", \"bar\");\ncluster.get(\"foo\", function(err, res) {\n  // res === 'bar'\n});\n```\n\n`Cluster` constructor accepts two arguments, where:\n\n0.  The first argument is a list of nodes of the cluster you want to connect to.\n    Just like Sentinel, the list does not need to enumerate all your cluster nodes,\n    but a few so that if one is unreachable the client will try the next one, and the client will discover other nodes automatically when at least one node is connected.\n1.  The second argument is the options, where:\n\n    - `clusterRetryStrategy`: When none of the startup nodes are reachable, `clusterRetryStrategy` will be invoked. When a number is returned,\n      ioredis will try to reconnect to the startup nodes from scratch after the specified delay (in ms). Otherwise, an error of \"None of startup nodes is available\" will be returned.\n      The default value of this option is:\n\n          ```javascript\n          function (times) {\n            var delay = Math.min(100 + times * 2, 2000);\n            return delay;\n          }\n          ```\n\n          It's possible to modify the `startupNodes` property in order to switch to another set of nodes here:\n\n          ```javascript\n          function (times) {\n            this.startupNodes = [{ port: 6790, host: '127.0.0.1' }];\n            return Math.min(100 + times * 2, 2000);\n          }\n          ```\n\n    - `dnsLookup`: Alternative DNS lookup function (`dns.lookup()` is used by default). It may be useful to override this in special cases, such as when AWS ElastiCache used with TLS enabled.\n    - `enableOfflineQueue`: Similar to the `enableOfflineQueue` option of `Redis` class.\n    - `enableReadyCheck`: When enabled, \"ready\" event will only be emitted when `CLUSTER INFO` command\n      reporting the cluster is ready for handling commands. Otherwise, it will be emitted immediately after \"connect\" is emitted.\n    - `scaleReads`: Config where to send the read queries. See below for more details.\n    - `maxRedirections`: When a cluster related error (e.g. `MOVED`, `ASK` and `CLUSTERDOWN` etc.) is received, the client will redirect the\n      command to another node. This option limits the max redirections allowed when sending a command. The default value is `16`.\n    - `retryDelayOnFailover`: If the target node is disconnected when sending a command,\n      ioredis will retry after the specified delay. The default value is `100`. You should make sure `retryDelayOnFailover * maxRedirections > cluster-node-timeout`\n      to insure that no command will fail during a failover.\n    - `retryDelayOnClusterDown`: When a cluster is down, all commands will be rejected with the error of `CLUSTERDOWN`. If this option is a number (by default, it is `100`), the client\n      will resend the commands after the specified time (in ms).\n    - `retryDelayOnTryAgain`: If this option is a number (by default, it is `100`), the client\n      will resend the commands rejected with `TRYAGAIN` error after the specified time (in ms).\n    - `redisOptions`: Default options passed to the constructor of `Redis` when connecting to a node.\n    - `slotsRefreshTimeout`: Milliseconds before a timeout occurs while refreshing slots from the cluster (default `1000`)\n    - `slotsRefreshInterval`: Milliseconds between every automatic slots refresh (default `5000`)\n\n### Read-write splitting\n\nA typical redis cluster contains three or more masters and several slaves for each master. It's possible to scale out redis cluster by sending read queries to slaves and write queries to masters by setting the `scaleReads` option.\n\n`scaleReads` is \"master\" by default, which means ioredis will never send any queries to slaves. There are other three available options:\n\n1. \"all\": Send write queries to masters and read queries to masters or slaves randomly.\n2. \"slave\": Send write queries to masters and read queries to slaves.\n3. a custom `function(nodes, command): node`: Will choose the custom function to select to which node to send read queries (write queries keep being sent to master). The first node in `nodes` is always the master serving the relevant slots. If the function returns an array of nodes, a random node of that list will be selected.\n\nFor example:\n\n```javascript\nvar cluster = new Redis.Cluster(\n  [\n    /* nodes */\n  ],\n  {\n    scaleReads: \"slave\"\n  }\n);\ncluster.set(\"foo\", \"bar\"); // This query will be sent to one of the masters.\ncluster.get(\"foo\", function(err, res) {\n  // This query will be sent to one of the slaves.\n});\n```\n\n**NB** In the code snippet above, the `res` may not be equal to \"bar\" because of the lag of replication between the master and slaves.\n\n### Running commands to multiple nodes\n\nEvery command will be sent to exactly one node. For commands containing keys, (e.g. `GET`, `SET` and `HGETALL`), ioredis sends them to the node that serving the keys, and for other commands not containing keys, (e.g. `INFO`, `KEYS` and `FLUSHDB`), ioredis sends them to a random node.\n\nSometimes you may want to send a command to multiple nodes (masters or slaves) of the cluster, you can get the nodes via `Cluster#nodes()` method.\n\n`Cluster#nodes()` accepts a parameter role, which can be \"master\", \"slave\" and \"all\" (default), and returns an array of `Redis` instance. For example:\n\n```javascript\n// Send `FLUSHDB` command to all slaves:\nvar slaves = cluster.nodes(\"slave\");\nPromise.all(\n  slaves.map(function(node) {\n    return node.flushdb();\n  })\n);\n\n// Get keys of all the masters:\nvar masters = cluster.nodes(\"master\");\nPromise.all(\n  masters.map(function(node) {\n    return node.keys();\n  })\n).then(function(keys) {\n  // keys: [['key1', 'key2'], ['key3', 'key4']]\n});\n```\n\n### NAT Mapping\n\nSometimes the cluster is hosted within a internal network that can only be accessed via a NAT (Network Address Translation) instance. See [Accessing ElastiCache from outside AWS](https://docs.aws.amazon.com/AmazonElastiCache/latest/red-ug/accessing-elasticache.html) as an example.\n\nYou can specify nat mapping rules via `natMap` option:\n\n```javascript\nconst cluster = new Redis.Cluster(\n  [\n    {\n      host: \"203.0.113.73\",\n      port: 30001\n    }\n  ],\n  {\n    natMap: {\n      \"10.0.1.230:30001\": { host: \"203.0.113.73\", port: 30001 },\n      \"10.0.1.231:30001\": { host: \"203.0.113.73\", port: 30002 },\n      \"10.0.1.232:30001\": { host: \"203.0.113.73\", port: 30003 }\n    }\n  }\n);\n```\n\nThis option is also useful when the cluster is running inside a Docker container.\n\n### Transaction and pipeline in Cluster mode\n\nAlmost all features that are supported by `Redis` are also supported by `Redis.Cluster`, e.g. custom commands, transaction and pipeline.\nHowever there are some differences when using transaction and pipeline in Cluster mode:\n\n0. All keys in a pipeline should belong to the same slot since ioredis sends all commands in a pipeline to the same node.\n1. You can't use `multi` without pipeline (aka `cluster.multi({ pipeline: false })`). This is because when you call `cluster.multi({ pipeline: false })`, ioredis doesn't know which node the `multi` command should be sent to.\n2. Chaining custom commands in the pipeline is not supported in Cluster mode.\n\nWhen any commands in a pipeline receives a `MOVED` or `ASK` error, ioredis will resend the whole pipeline to the specified node automatically if all of the following conditions are satisfied:\n\n0. All errors received in the pipeline are the same. For example, we won't resend the pipeline if we got two `MOVED` errors pointing to different nodes.\n1. All commands executed successfully are readonly commands. This makes sure that resending the pipeline won't have side effects.\n\n### Pub/Sub\n\nPub/Sub in cluster mode works exactly as the same as in standalone mode. Internally, when a node of the cluster receives a message, it will broadcast the message to the other nodes. ioredis makes sure that each message will only be received once by strictly subscribing one node at the same time.\n\n```javascript\nvar nodes = [\n  /* nodes */\n];\nvar pub = new Redis.Cluster(nodes);\nvar sub = new Redis.Cluster(nodes);\nsub.on(\"message\", function(channel, message) {\n  console.log(channel, message);\n});\n\nsub.subscribe(\"news\", function() {\n  pub.publish(\"news\", \"highlights\");\n});\n```\n\n### Events\n\n| Event        | Description                                                                                                                                                                                                |\n| :----------- | :--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| connect      | emits when a connection is established to the Redis server.                                                                                                                                                |\n| ready        | emits when `CLUSTER INFO` reporting the cluster is able to receive commands (if `enableReadyCheck` is `true`) or immediately after `connect` event (if `enableReadyCheck` is false).                       |\n| error        | emits when an error occurs while connecting with a property of `lastNodeError` representing the last node error received. This event is emitted silently (only emitting if there's at least one listener). |\n| close        | emits when an established Redis server connection has closed.                                                                                                                                              |\n| reconnecting | emits after `close` when a reconnection will be made. The argument of the event is the time (in ms) before reconnecting.                                                                                   |\n| end          | emits after `close` when no more reconnections will be made.                                                                                                                                               |\n| +node        | emits when a new node is connected.                                                                                                                                                                        |\n| -node        | emits when a node is disconnected.                                                                                                                                                                         |\n| node error   | emits when an error occurs when connecting to a node. The second argument indicates the address of the node.                                                                                               |\n\n### Password\n\nSetting the `password` option to access password-protected clusters:\n\n```javascript\nvar Redis = require(\"ioredis\");\nvar cluster = new Redis.Cluster(nodes, {\n  redisOptions: {\n    password: \"your-cluster-password\"\n  }\n});\n```\n\nIf some of nodes in the cluster using a different password, you should specify them in the first parameter:\n\n```javascript\nvar Redis = require(\"ioredis\");\nvar cluster = new Redis.Cluster(\n  [\n    // Use password \"password-for-30001\" for 30001\n    { port: 30001, password: \"password-for-30001\" },\n    // Don't use password when accessing 30002\n    { port: 30002, password: null }\n    // Other nodes will use \"fallback-password\"\n  ],\n  {\n    redisOptions: {\n      password: \"fallback-password\"\n    }\n  }\n);\n```\n\n### Special note: AWS ElastiCache Clusters with TLS\n\nAWS ElastiCache for Redis (Clustered Mode) supports TLS encryption. If you use\nthis, you may encounter errors with invalid certificates. To resolve this\nissue, construct the `Cluster` with the `dnsLookup` option as follows:\n\n```javascript\nvar cluster = new Redis.Cluster(\n  [{\n    host: 'clustercfg.myCluster.abcdefg.xyz.cache.amazonaws.com',\n    port: 6379\n  }],\n  {\n    dnsLookup: (address, callback) => callback(null, address),\n    redisOptions: {\n      tls: {}\n    },\n  }\n};\n```\n\n<hr>\n\n# Error Handling\n\nAll the errors returned by the Redis server are instances of `ReplyError`, which can be accessed via `Redis`:\n\n```javascript\nvar Redis = require(\"ioredis\");\nvar redis = new Redis();\n// This command causes a reply error since the SET command requires two arguments.\nredis.set(\"foo\", function(err) {\n  err instanceof Redis.ReplyError;\n});\n```\n\nThis is the error stack of the `ReplyError`:\n\n```\nReplyError: ERR wrong number of arguments for 'set' command\n    at ReplyParser._parseResult (/app/node_modules/ioredis/lib/parsers/javascript.js:60:14)\n    at ReplyParser.execute (/app/node_modules/ioredis/lib/parsers/javascript.js:178:20)\n    at Socket.<anonymous> (/app/node_modules/ioredis/lib/redis/event_handler.js:99:22)\n    at Socket.emit (events.js:97:17)\n    at readableAddChunk (_stream_readable.js:143:16)\n    at Socket.Readable.push (_stream_readable.js:106:10)\n    at TCP.onread (net.js:509:20)\n```\n\nBy default, the error stack doesn't make any sense because the whole stack happens in the ioredis\nmodule itself, not in your code. So it's not easy to find out where the error happens in your code.\nioredis provides an option `showFriendlyErrorStack` to solve the problem. When you enable\n`showFriendlyErrorStack`, ioredis will optimize the error stack for you:\n\n```javascript\nvar Redis = require(\"ioredis\");\nvar redis = new Redis({ showFriendlyErrorStack: true });\nredis.set(\"foo\");\n```\n\nAnd the output will be:\n\n```\nReplyError: ERR wrong number of arguments for 'set' command\n    at Object.<anonymous> (/app/index.js:3:7)\n    at Module._compile (module.js:446:26)\n    at Object.Module._extensions..js (module.js:464:10)\n    at Module.load (module.js:341:32)\n    at Function.Module._load (module.js:296:12)\n    at Function.Module.runMain (module.js:487:10)\n    at startup (node.js:111:16)\n    at node.js:799:3\n```\n\nThis time the stack tells you that the error happens on the third line in your code. Pretty sweet!\nHowever, it would decrease the performance significantly to optimize the error stack. So by\ndefault, this option is disabled and can only be used for debugging purposes. You **shouldn't** use this feature in a production environment.\n\n# Plugging in your own Promises Library\n\nIf you're an advanced user, you may want to plug in your own promise library like [bluebird](https://www.npmjs.com/package/bluebird). Just set Redis.Promise to your favorite ES6-style promise constructor and ioredis will use it.\n\n```javascript\nconst Redis = require(\"ioredis\");\nRedis.Promise = require(\"bluebird\");\n\nconst redis = new Redis();\n\n// Use bluebird\nassert.equal(redis.get().constructor, require(\"bluebird\"));\n\n// You can change the Promise implementation at any time:\nRedis.Promise = global.Promise;\nassert.equal(redis.get().constructor, global.Promise);\n```\n\n# Running tests\n\nStart a Redis server on 127.0.0.1:6379, and then:\n\n```shell\n$ npm test\n```\n\n`FLUSH ALL` will be invoked after each test, so make sure there's no valuable data in it before running tests.\n\nIf your testing environment does not let you spin up a Redis server [ioredis-mock](https://github.com/stipsan/ioredis-mock) is a drop-in replacement you can use in your tests. It aims to behave identically to ioredis connected to a Redis server so that your integration tests is easier to write and of better quality.\n\n# Debug\n\nYou can set the `DEBUG` env to `ioredis:*` to print debug info:\n\n```shell\n$ DEBUG=ioredis:* node app.js\n```\n\n# Join in!\n\nI'm happy to receive bug reports, fixes, documentation enhancements, and any other improvements.\n\nAnd since I'm not a native English speaker, if you find any grammar mistakes in the documentation, please also let me know. :)\n\n# Become a Sponsor\n\nOpen source is hard and time-consuming. If you want to invest in ioredis's future you can become a sponsor and make us spend more time on this library's improvements and new features.\n\n<a href=\"https://opencollective.com/ioredis\"><img src=\"https://opencollective.com/ioredis/tiers/sponsor.svg?avatarHeight=36\"></a>\n\nThank you for using ioredis :-)\n\n# Contributors\n\nThis project exists thanks to all the people who contribute:\n\n<a href=\"https://github.com/luin/ioredis/graphs/contributors\"><img src=\"https://opencollective.com/ioredis/contributors.svg?width=890&showBtn=false\" /></a>\n\n# License\n\nMIT\n\n[![FOSSA Status](https://app.fossa.io/api/projects/git%2Bgithub.com%2Fluin%2Fioredis.svg?type=large)](https://app.fossa.io/projects/git%2Bgithub.com%2Fluin%2Fioredis?ref=badge_large)\n","readmeFilename":"README.md","bugs":{"url":"https://github.com/luin/ioredis/issues"},"homepage":"https://github.com/luin/ioredis#readme","_id":"ioredis@4.15.0","_nodeVersion":"10.17.0","_npmVersion":"6.11.3","dist":{"integrity":"sha512-iN5hqxglSjopYcmnFjQqYSyP83P9HhrnWWyBZsfZsNzczEWgRTsUCccajeP70QdXHHwblh2T3pLCxS4D5K4zDw==","shasum":"cd0ad6b9ce0664a413641ebf2ea0e99081cbcaf0","tarball":"https://registry.npmjs.org/ioredis/-/ioredis-4.15.0.tgz","fileCount":36,"unpackedSize":241801,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJd4NCyCRA9TVsSAnZWagAAEToP/RhmkG1QlQ2hxjm/EkdN\nDm5JUFNufndy9/G3EQaNP+rNw60teRpfsNTGg20QJaAAtfrL9JWRufHAFaME\ngDXog7erRW7vsttiAEfZmSp26vaBhfUX2mV4p54sx4k8mEFHsf7oFQnsT2Mu\n7oVRVbiz84zEISLini+bd3tfsay61gL60GT292Ipr4AvxwDefLEjVWnzAc74\nzg1++eJCfpzyRwjxj5JYoW1WNGG936phnSEQJfz863w7r1pEn0Rhxqo0ZnXm\nDKOX5ItpNNd1N/sUFfgjSHvKGmvsft3uu3aitjY/CHr2tRl1BkwUfWxy1Pqq\nO1dDx6+5ia34tWyBEHLT/EiyLZuHBpm+3hqS43lRpRsAXzRyVEkkATVH9vcI\nj3IV9aHURQAmwZt1kImr5TRZ3zL7CuVXQ8thN7QFsKgs6J6ox7QC6JgUzx2a\nPhWS39tBlzsXzZLMyckZZ/XUkkmM8/7/DwR+mw+xHPPc8BQILMRqDbwCcO/y\nkrQZZNFYSwlx/5DvDN0u03nQQrE26dSlmICAumb2aSAiOpzznJNcmwzhwocN\nw/EsG+KbuJvkJRTOePwtpWYzZ8lW4gJUj5fVXWvNjM3zZmg9ragIYd4uhWuR\n5dMlQCdMdVy1PHi/aVRaxxidKg/H9tAJw5WMymVgy9sMlJd43IaWOUwl2MsQ\npmKm\r\n=i/jp\r\n-----END PGP SIGNATURE-----\r\n"},"maintainers":[{"email":"ioredis-robot@zihua.li","name":"ioredis-robot"},{"email":"i@zihua.li","name":"luin"}],"_npmUser":{"name":"luin","email":"i@zihua.li"},"directories":{},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/ioredis_4.15.0_1575014577640_0.3396994033406078"},"_hasShrinkwrap":false},"4.15.1":{"name":"ioredis","version":"4.15.1","description":"A robust, performance-focused and full-featured Redis client for Node.js.","main":"built/index.js","scripts":{"test":"TS_NODE_TRANSPILE_ONLY=true TS_NODE_LOG_ERROR=true NODE_ENV=test mocha \"test/**/*.ts\"","test:cov":"TS_NODE_TRANSPILE_ONLY=true TS_NODE_LOG_ERROR=true NODE_ENV=test node ./node_modules/istanbul/lib/cli.js cover --preserve-comments ./node_modules/mocha/bin/_mocha -- -r ts-node/register -R spec --exit \"test/**/*.ts\"","lint":"eslint --ext .js,.ts .","format":"prettier --write \"{,!(node_modules)/**/}*.{js,ts}\"","format-check":"prettier --check \"{,!(node_modules)/**/}*.{js,ts}\"","build":"rm -rf built && tsc","prepublishOnly":"npm run build && npm test","bench":"matcha benchmarks/*.js","semantic-release":"semantic-release"},"repository":{"type":"git","url":"git://github.com/luin/ioredis.git"},"keywords":["redis","cluster","sentinel","pipelining"],"author":{"name":"luin","email":"i@zihua.li","url":"http://zihua.li"},"license":"MIT","funding":{"type":"opencollective","url":"https://opencollective.com/ioredis"},"dependencies":{"cluster-key-slot":"^1.1.0","debug":"^4.1.1","denque":"^1.1.0","lodash.defaults":"^4.2.0","lodash.flatten":"^4.4.0","redis-commands":"1.5.0","redis-errors":"^1.2.0","redis-parser":"^3.0.0","standard-as-callback":"^2.0.1"},"devDependencies":{"@semantic-release/changelog":"^3.0.4","@semantic-release/git":"^7.0.12","@types/bluebird":"^3.5.27","@types/chai":"^4.1.7","@types/debug":"^4.1.4","@types/lodash.defaults":"^4.2.6","@types/lodash.flatten":"^4.4.6","@types/mocha":"^5.2.7","@types/node":"^12.0.2","@types/redis-errors":"1.2.0","@types/sinon":"^7.0.13","@typescript-eslint/eslint-plugin":"^1.11.0","@typescript-eslint/parser":"^1.11.0","bluebird":"^3.5.4","chai":"^4.2.0","cz-conventional-changelog":"^2.0.0","eslint":"^5.16.0","eslint-config-prettier":"^5.1.0","husky":"^2.5.0","istanbul":"^0.4.5","mocha":"^5.0.0","prettier":"^1.18.2","pretty-quick":"^1.11.1","server-destroy":"^1.0.1","sinon":"^7.3.2","ts-node":"^8.1.0","typescript":"^3.5.1"},"engines":{"node":">=6"},"config":{"commitizen":{"path":"./node_modules/cz-conventional-changelog"}},"husky":{"hooks":{"pre-commit":"pretty-quick --staged"}},"gitHead":"1d06cf4bd968fd9762b87d7cd3d756c396158ce0","readme":"[![ioredis](https://cdn.jsdelivr.net/gh/luin/ioredis@b5e8c74/logo.svg)](https://github.com/luin/ioredis)\n\n[![Build Status](https://travis-ci.org/luin/ioredis.svg?branch=master)](https://travis-ci.org/luin/ioredis)\n[![Test Coverage](https://codeclimate.com/github/luin/ioredis/badges/coverage.svg)](https://codeclimate.com/github/luin/ioredis)\n[![code style: prettier](https://img.shields.io/badge/code_style-prettier-ff69b4.svg?style=flat-square)](https://github.com/prettier/prettier)\n[![Join the chat at https://gitter.im/luin/ioredis](https://badges.gitter.im/Join%20Chat.svg)](https://gitter.im/luin/ioredis?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge)\n[![Commitizen friendly](https://img.shields.io/badge/commitizen-friendly-brightgreen.svg)](http://commitizen.github.io/cz-cli/)\n[![semantic-release](https://img.shields.io/badge/%20%20%F0%9F%93%A6%F0%9F%9A%80-semantic--release-e10079.svg)](https://github.com/semantic-release/semantic-release)\n[![npm latest version](https://img.shields.io/npm/v/ioredis/latest.svg)](https://www.npmjs.com/package/ioredis)\n[![npm next version](https://img.shields.io/npm/v/ioredis/next.svg)](https://www.npmjs.com/package/ioredis)\n<img alt=\"\" src=\"\">\n\nA robust, performance-focused and full-featured [Redis](http://redis.io) client for [Node.js](https://nodejs.org).\n\nSupports Redis >= 2.6.12 and (Node.js >= 6).\n\n# Features\n\nioredis is a robust, full-featured Redis client that is\nused in the world's biggest online commerce company [Alibaba](http://www.alibaba.com/) and many other awesome companies.\n\n0. Full-featured. It supports [Cluster](http://redis.io/topics/cluster-tutorial), [Sentinel](http://redis.io/topics/sentinel), [Pipelining](http://redis.io/topics/pipelining) and of course [Lua scripting](http://redis.io/commands/eval) & [Pub/Sub](http://redis.io/topics/pubsub) (with the support of binary messages).\n1. High performance.\n2. Delightful API. It works with Node callbacks and Native promises.\n3. Transformation of command arguments and replies.\n4. Transparent key prefixing.\n5. Abstraction for Lua scripting, allowing you to define custom commands.\n6. Support for binary data.\n7. Support for TLS.\n8. Support for offline queue and ready checking.\n9. Support for ES6 types, such as `Map` and `Set`.\n10. Support for GEO commands (Redis 3.2 Unstable).\n11. Sophisticated error handling strategy.\n12. Support for NAT mapping.\n\n# Links\n\n- [API Documentation](API.md)\n- [Changelog](Changelog.md)\n- [Migrating from node_redis](https://github.com/luin/ioredis/wiki/Migrating-from-node_redis)\n- [Error Handling](#error-handling)\n\n<hr>\n<a href=\"http://bit.ly/medis-macos\"><img align=\"right\" src=\"resources/medis.png\" alt=\"Download on the App Store\"></a>\n\n### [AD] Medis: Redis GUI for OS X\n\nLooking for a Redis GUI manager for OS X, Windows and Linux? Here's [Medis](http://bit.ly/medis-macos)!\n\nMedis is an open-sourced, beautiful, easy-to-use Redis GUI management application.\n\nMedis starts with all the basic features you need:\n\n- Keys viewing/editing\n- SSH Tunnel for connecting with remote servers\n- Terminal for executing custom commands\n- JSON/MessagePack format viewing/editing and built-in highlighting/validator\n- And other awesome features...\n\n[Medis is open sourced on GitHub](https://github.com/luin/medis)\n\n### [AD] Kuber: Kubernetes Dashboard for iOS\n\n<a href=\"http://bit.ly/kuber-ios\"><img src=\"resources/kuber.png\" alt=\"Download on the App Store\"></a>\n\n<hr>\n\n# Quick Start\n\n## Install\n\n```shell\n$ npm install ioredis\n```\n\n## Basic Usage\n\n```javascript\nvar Redis = require(\"ioredis\");\nvar redis = new Redis();\n\nredis.set(\"foo\", \"bar\");\nredis.get(\"foo\", function(err, result) {\n  console.log(result);\n});\nredis.del(\"foo\");\n\n// Or using a promise if the last argument isn't a function\nredis.get(\"foo\").then(function(result) {\n  console.log(result);\n});\n\n// Arguments to commands are flattened, so the following are the same:\nredis.sadd(\"set\", 1, 3, 5, 7);\nredis.sadd(\"set\", [1, 3, 5, 7]);\n\n// All arguments are passed directly to the redis server:\nredis.set(\"key\", 100, \"EX\", 10);\n```\n\nSee the `examples/` folder for more examples.\n\n## Connect to Redis\n\nWhen a new `Redis` instance is created,\na connection to Redis will be created at the same time.\nYou can specify which Redis to connect to by:\n\n```javascript\nnew Redis(); // Connect to 127.0.0.1:6379\nnew Redis(6380); // 127.0.0.1:6380\nnew Redis(6379, \"192.168.1.1\"); // 192.168.1.1:6379\nnew Redis(\"/tmp/redis.sock\");\nnew Redis({\n  port: 6379, // Redis port\n  host: \"127.0.0.1\", // Redis host\n  family: 4, // 4 (IPv4) or 6 (IPv6)\n  password: \"auth\",\n  db: 0\n});\n```\n\nYou can also specify connection options as a [`redis://` URL](http://www.iana.org/assignments/uri-schemes/prov/redis) or [`rediss://` URL](https://www.iana.org/assignments/uri-schemes/prov/rediss) when using [TLS encryption](#tls-options):\n\n```javascript\n// Connect to 127.0.0.1:6380, db 4, using password \"authpassword\":\nnew Redis(\"redis://:authpassword@127.0.0.1:6380/4\");\n```\n\nSee [API Documentation](API.md#new_Redis) for all available options.\n\n## Pub/Sub\n\nHere is a simple example of the API for publish/subscribe.\nThe following program opens two client connections.\nIt subscribes to a channel with one connection\nand publishes to that channel with the other:\n\n```javascript\nvar Redis = require(\"ioredis\");\nvar redis = new Redis();\nvar pub = new Redis();\nredis.subscribe(\"news\", \"music\", function(err, count) {\n  // Now we are subscribed to both the 'news' and 'music' channels.\n  // `count` represents the number of channels we are currently subscribed to.\n\n  pub.publish(\"news\", \"Hello world!\");\n  pub.publish(\"music\", \"Hello again!\");\n});\n\nredis.on(\"message\", function(channel, message) {\n  // Receive message Hello world! from channel news\n  // Receive message Hello again! from channel music\n  console.log(\"Receive message %s from channel %s\", message, channel);\n});\n\n// There's also an event called 'messageBuffer', which is the same as 'message' except\n// it returns buffers instead of strings.\nredis.on(\"messageBuffer\", function(channel, message) {\n  // Both `channel` and `message` are buffers.\n});\n```\n\n`PSUBSCRIBE` is also supported in a similar way:\n\n```javascript\nredis.psubscribe(\"pat?ern\", function(err, count) {});\nredis.on(\"pmessage\", function(pattern, channel, message) {});\nredis.on(\"pmessageBuffer\", function(pattern, channel, message) {});\n```\n\nWhen a client issues a SUBSCRIBE or PSUBSCRIBE, that connection is put into a \"subscriber\" mode.\nAt that point, only commands that modify the subscription set are valid.\nWhen the subscription set is empty, the connection is put back into regular mode.\n\nIf you need to send regular commands to Redis while in subscriber mode, just open another connection.\n\n## Handle Binary Data\n\nArguments can be buffers:\n\n```javascript\nredis.set(\"foo\", Buffer.from(\"bar\"));\n```\n\nAnd every command has a method that returns a Buffer (by adding a suffix of \"Buffer\" to the command name).\nTo get a buffer instead of a utf8 string:\n\n```javascript\nredis.getBuffer(\"foo\", function(err, result) {\n  // result is a buffer.\n});\n```\n\n## Pipelining\n\nIf you want to send a batch of commands (e.g. > 5), you can use pipelining to queue\nthe commands in memory and then send them to Redis all at once. This way the performance improves by 50%~300% (See [benchmark section](#benchmark)).\n\n`redis.pipeline()` creates a `Pipeline` instance. You can call any Redis\ncommands on it just like the `Redis` instance. The commands are queued in memory\nand flushed to Redis by calling the `exec` method:\n\n```javascript\nvar pipeline = redis.pipeline();\npipeline.set(\"foo\", \"bar\");\npipeline.del(\"cc\");\npipeline.exec(function(err, results) {\n  // `err` is always null, and `results` is an array of responses\n  // corresponding to the sequence of queued commands.\n  // Each response follows the format `[err, result]`.\n});\n\n// You can even chain the commands:\nredis\n  .pipeline()\n  .set(\"foo\", \"bar\")\n  .del(\"cc\")\n  .exec(function(err, results) {});\n\n// `exec` also returns a Promise:\nvar promise = redis\n  .pipeline()\n  .set(\"foo\", \"bar\")\n  .get(\"foo\")\n  .exec();\npromise.then(function(result) {\n  // result === [[null, 'OK'], [null, 'bar']]\n});\n```\n\nEach chained command can also have a callback, which will be invoked when the command\ngets a reply:\n\n```javascript\nredis\n  .pipeline()\n  .set(\"foo\", \"bar\")\n  .get(\"foo\", function(err, result) {\n    // result === 'bar'\n  })\n  .exec(function(err, result) {\n    // result[1][1] === 'bar'\n  });\n```\n\nIn addition to adding commands to the `pipeline` queue individually, you can also pass an array of commands and arguments to the constructor:\n\n```javascript\nredis.pipeline([[\"set\", \"foo\", \"bar\"], [\"get\", \"foo\"]]).exec(function() {\n  /* ... */\n});\n```\n\n`#length` property shows how many commands in the pipeline:\n\n```javascript\nconst length = redis\n  .pipeline()\n  .set(\"foo\", \"bar\")\n  .get(\"foo\").length;\n// length === 2\n```\n\n## Transaction\n\nMost of the time, the transaction commands `multi` & `exec` are used together with pipeline.\nTherefore, when `multi` is called, a `Pipeline` instance is created automatically by default,\nso you can use `multi` just like `pipeline`:\n\n```javascript\nredis\n  .multi()\n  .set(\"foo\", \"bar\")\n  .get(\"foo\")\n  .exec(function(err, results) {\n    // results === [[null, 'OK'], [null, 'bar']]\n  });\n```\n\nIf there's a syntax error in the transaction's command chain (e.g. wrong number of arguments, wrong command name, etc),\nthen none of the commands would be executed, and an error is returned:\n\n```javascript\nredis\n  .multi()\n  .set(\"foo\")\n  .set(\"foo\", \"new value\")\n  .exec(function(err, results) {\n    // err:\n    //  { [ReplyError: EXECABORT Transaction discarded because of previous errors.]\n    //    name: 'ReplyError',\n    //    message: 'EXECABORT Transaction discarded because of previous errors.',\n    //    command: { name: 'exec', args: [] },\n    //    previousErrors:\n    //     [ { [ReplyError: ERR wrong number of arguments for 'set' command]\n    //         name: 'ReplyError',\n    //         message: 'ERR wrong number of arguments for \\'set\\' command',\n    //         command: [Object] } ] }\n  });\n```\n\nIn terms of the interface, `multi` differs from `pipeline` in that when specifying a callback\nto each chained command, the queueing state is passed to the callback instead of the result of the command:\n\n```javascript\nredis\n  .multi()\n  .set(\"foo\", \"bar\", function(err, result) {\n    // result === 'QUEUED'\n  })\n  .exec(/* ... */);\n```\n\nIf you want to use transaction without pipeline, pass `{ pipeline: false }` to `multi`,\nand every command will be sent to Redis immediately without waiting for an `exec` invocation:\n\n```javascript\nredis.multi({ pipeline: false });\nredis.set(\"foo\", \"bar\");\nredis.get(\"foo\");\nredis.exec(function(err, result) {\n  // result === [[null, 'OK'], [null, 'bar']]\n});\n```\n\nThe constructor of `multi` also accepts a batch of commands:\n\n```javascript\nredis.multi([[\"set\", \"foo\", \"bar\"], [\"get\", \"foo\"]]).exec(function() {\n  /* ... */\n});\n```\n\nInline transactions are supported by pipeline, which means you can group a subset of commands\nin the pipeline into a transaction:\n\n```javascript\nredis\n  .pipeline()\n  .get(\"foo\")\n  .multi()\n  .set(\"foo\", \"bar\")\n  .get(\"foo\")\n  .exec()\n  .get(\"foo\")\n  .exec();\n```\n\n## Lua Scripting\n\nioredis supports all of the scripting commands such as `EVAL`, `EVALSHA` and `SCRIPT`.\nHowever, it's tedious to use in real world scenarios since developers have to take\ncare of script caching and to detect when to use `EVAL` and when to use `EVALSHA`.\nioredis exposes a `defineCommand` method to make scripting much easier to use:\n\n```javascript\nvar redis = new Redis();\n\n// This will define a command echo:\nredis.defineCommand(\"echo\", {\n  numberOfKeys: 2,\n  lua: \"return {KEYS[1],KEYS[2],ARGV[1],ARGV[2]}\"\n});\n\n// Now `echo` can be used just like any other ordinary command,\n// and ioredis will try to use `EVALSHA` internally when possible for better performance.\nredis.echo(\"k1\", \"k2\", \"a1\", \"a2\", function(err, result) {\n  // result === ['k1', 'k2', 'a1', 'a2']\n});\n\n// `echoBuffer` is also defined automatically to return buffers instead of strings:\nredis.echoBuffer(\"k1\", \"k2\", \"a1\", \"a2\", function(err, result) {\n  // result[0] equals to Buffer.from('k1');\n});\n\n// And of course it works with pipeline:\nredis\n  .pipeline()\n  .set(\"foo\", \"bar\")\n  .echo(\"k1\", \"k2\", \"a1\", \"a2\")\n  .exec();\n```\n\nIf the number of keys can't be determined when defining a command, you can\nomit the `numberOfKeys` property and pass the number of keys as the first argument\nwhen you call the command:\n\n```javascript\nredis.defineCommand(\"echoDynamicKeyNumber\", {\n  lua: \"return {KEYS[1],KEYS[2],ARGV[1],ARGV[2]}\"\n});\n\n// Now you have to pass the number of keys as the first argument every time\n// you invoke the `echoDynamicKeyNumber` command:\nredis.echoDynamicKeyNumber(2, \"k1\", \"k2\", \"a1\", \"a2\", function(err, result) {\n  // result === ['k1', 'k2', 'a1', 'a2']\n});\n```\n\n## Transparent Key Prefixing\n\nThis feature allows you to specify a string that will automatically be prepended\nto all the keys in a command, which makes it easier to manage your key\nnamespaces.\n\n**Warning** This feature won't apply to commands like [KEYS](http://redis.io/commands/KEYS) and [SCAN](http://redis.io/commands/scan) that take patterns rather than actual keys([#239](https://github.com/luin/ioredis/issues/239)),\nand this feature also won't apply to the replies of commands even they are key names ([#325](https://github.com/luin/ioredis/issues/325)).\n\n```javascript\nvar fooRedis = new Redis({ keyPrefix: \"foo:\" });\nfooRedis.set(\"bar\", \"baz\"); // Actually sends SET foo:bar baz\n\nfooRedis.defineCommand(\"echo\", {\n  numberOfKeys: 2,\n  lua: \"return {KEYS[1],KEYS[2],ARGV[1],ARGV[2]}\"\n});\n\n// Works well with pipelining/transaction\nfooRedis\n  .pipeline()\n  // Sends SORT foo:list BY foo:weight_*->fieldname\n  .sort(\"list\", \"BY\", \"weight_*->fieldname\")\n  // Supports custom commands\n  // Sends EVALSHA xxx foo:k1 foo:k2 a1 a2\n  .echo(\"k1\", \"k2\", \"a1\", \"a2\")\n  .exec();\n```\n\n## Transforming Arguments & Replies\n\nMost Redis commands take one or more Strings as arguments,\nand replies are sent back as a single String or an Array of Strings. However, sometimes\nyou may want something different. For instance, it would be more convenient if the `HGETALL`\ncommand returns a hash (e.g. `{ key: val1, key2: v2 }`) rather than an array of key values (e.g. `[key1, val1, key2, val2]`).\n\nioredis has a flexible system for transforming arguments and replies. There are two types\nof transformers, argument transformer and reply transformer:\n\n```javascript\nvar Redis = require(\"ioredis\");\n\n// Here's the built-in argument transformer converting\n// hmset('key', { k1: 'v1', k2: 'v2' })\n// or\n// hmset('key', new Map([['k1', 'v1'], ['k2', 'v2']]))\n// into\n// hmset('key', 'k1', 'v1', 'k2', 'v2')\nRedis.Command.setArgumentTransformer(\"hmset\", function(args) {\n  if (args.length === 2) {\n    if (typeof Map !== \"undefined\" && args[1] instanceof Map) {\n      // utils is a internal module of ioredis\n      return [args[0]].concat(utils.convertMapToArray(args[1]));\n    }\n    if (typeof args[1] === \"object\" && args[1] !== null) {\n      return [args[0]].concat(utils.convertObjectToArray(args[1]));\n    }\n  }\n  return args;\n});\n\n// Here's the built-in reply transformer converting the HGETALL reply\n// ['k1', 'v1', 'k2', 'v2']\n// into\n// { k1: 'v1', 'k2': 'v2' }\nRedis.Command.setReplyTransformer(\"hgetall\", function(result) {\n  if (Array.isArray(result)) {\n    var obj = {};\n    for (var i = 0; i < result.length; i += 2) {\n      obj[result[i]] = result[i + 1];\n    }\n    return obj;\n  }\n  return result;\n});\n```\n\nThere are three built-in transformers, two argument transformers for `hmset` & `mset` and\na reply transformer for `hgetall`. Transformers for `hmset` and `hgetall` were mentioned\nabove, and the transformer for `mset` is similar to the one for `hmset`:\n\n```javascript\nredis.mset({ k1: \"v1\", k2: \"v2\" });\nredis.get(\"k1\", function(err, result) {\n  // result === 'v1';\n});\n\nredis.mset(new Map([[\"k3\", \"v3\"], [\"k4\", \"v4\"]]));\nredis.get(\"k3\", function(err, result) {\n  // result === 'v3';\n});\n```\n\nAnother useful example of a reply transformer is one that changes `hgetall` to return array of arrays instead of objects which avoids a unwanted conversation of hash keys to strings when dealing with binary hash keys:\n\n```javascript\nRedis.Command.setReplyTransformer(\"hgetall\", function(result) {\n  var arr = [];\n  for (var i = 0; i < result.length; i += 2) {\n    arr.push([result[i], result[i + 1]]);\n  }\n  return arr;\n});\nredis.hset(\"h1\", Buffer.from([0x01]), Buffer.from([0x02]));\nredis.hset(\"h1\", Buffer.from([0x03]), Buffer.from([0x04]));\nredis.hgetallBuffer(\"h1\", function(err, result) {\n  // result === [ [ <Buffer 01>, <Buffer 02> ], [ <Buffer 03>, <Buffer 04> ] ];\n});\n```\n\n## Monitor\n\nRedis supports the MONITOR command,\nwhich lets you see all commands received by the Redis server across all client connections,\nincluding from other client libraries and other computers.\n\nThe `monitor` method returns a monitor instance.\nAfter you send the MONITOR command, no other commands are valid on that connection. ioredis will emit a monitor event for every new monitor message that comes across.\nThe callback for the monitor event takes a timestamp from the Redis server and an array of command arguments.\n\nHere is a simple example:\n\n```javascript\nredis.monitor(function(err, monitor) {\n  monitor.on(\"monitor\", function(time, args, source, database) {});\n});\n```\nHere is another example illustrating an `async` function and `monitor.disconnect()`:\n```javascript\nasync () => {\n  const monitor = await redis.monitor()\n  monitor.on('monitor', console.log)\n  // Any other tasks\n  monitor.disconnect()\n}\n```\n## Streamify Scanning\n\nRedis 2.8 added the `SCAN` command to incrementally iterate through the keys in the database. It's different from `KEYS` in that\n`SCAN` only returns a small number of elements each call, so it can be used in production without the downside\nof blocking the server for a long time. However, it requires recording the cursor on the client side each time\nthe `SCAN` command is called in order to iterate through all the keys correctly. Since it's a relatively common use case, ioredis\nprovides a streaming interface for the `SCAN` command to make things much easier. A readable stream can be created by calling `scanStream`:\n\n```javascript\nvar redis = new Redis();\n// Create a readable stream (object mode)\nvar stream = redis.scanStream();\nstream.on(\"data\", function(resultKeys) {\n  // `resultKeys` is an array of strings representing key names.\n  // Note that resultKeys may contain 0 keys, and that it will sometimes\n  // contain duplicates due to SCAN's implementation in Redis.\n  for (var i = 0; i < resultKeys.length; i++) {\n    console.log(resultKeys[i]);\n  }\n});\nstream.on(\"end\", function() {\n  console.log(\"all keys have been visited\");\n});\n```\n\n`scanStream` accepts an option, with which you can specify the `MATCH` pattern and the `COUNT` argument:\n\n```javascript\nvar stream = redis.scanStream({\n  // only returns keys following the pattern of `user:*`\n  match: \"user:*\",\n  // returns approximately 100 elements per call\n  count: 100\n});\n```\n\nJust like other commands, `scanStream` has a binary version `scanBufferStream`, which returns an array of buffers. It's useful when\nthe key names are not utf8 strings.\n\nThere are also `hscanStream`, `zscanStream` and `sscanStream` to iterate through elements in a hash, zset and set. The interface of each is\nsimilar to `scanStream` except the first argument is the key name:\n\n```javascript\nvar stream = redis.hscanStream(\"myhash\", {\n  match: \"age:??\"\n});\n```\n\nYou can learn more from the [Redis documentation](http://redis.io/commands/scan).\n\n**Useful Tips**\nIt's pretty common that doing an async task in the `data` handler. We'd like the scanning process to be paused until the async task to be finished. `Stream#pause()` and `Stream.resume()` do the trick. For example if we want to migrate data in Redis to MySQL:\n\n```javascript\nvar stream = redis.scanStream();\nstream.on(\"data\", function(resultKeys) {\n  // Pause the stream from scanning more keys until we've migrated the current keys.\n  stream.pause();\n\n  Promise.all(resultKeys.map(migrateKeyToMySQL)).then(() => {\n    // Resume the stream here.\n    stream.resume();\n  });\n});\n\nstream.on(\"end\", function() {\n  console.log(\"done migration\");\n});\n```\n\n## Auto-reconnect\n\nBy default, ioredis will try to reconnect when the connection to Redis is lost\nexcept when the connection is closed manually by `redis.disconnect()` or `redis.quit()`.\n\nIt's very flexible to control how long to wait to reconnect after disconnection\nusing the `retryStrategy` option:\n\n```javascript\nvar redis = new Redis({\n  // This is the default value of `retryStrategy`\n  retryStrategy: function(times) {\n    var delay = Math.min(times * 50, 2000);\n    return delay;\n  }\n});\n```\n\n`retryStrategy` is a function that will be called when the connection is lost.\nThe argument `times` means this is the nth reconnection being made and\nthe return value represents how long (in ms) to wait to reconnect. When the\nreturn value isn't a number, ioredis will stop trying to reconnect, and the connection\nwill be lost forever if the user doesn't call `redis.connect()` manually.\n\nWhen reconnected, the client will auto subscribe to channels that the previous connection subscribed to.\nThis behavior can be disabled by setting the `autoResubscribe` option to `false`.\n\nAnd if the previous connection has some unfulfilled commands (most likely blocking commands such as `brpop` and `blpop`),\nthe client will resend them when reconnected. This behavior can be disabled by setting the `autoResendUnfulfilledCommands` option to `false`.\n\nBy default, all pending commands will be flushed with an error every 20 retry attempts. That makes sure commands won't wait forever when the connection is down. You can change this behavior by setting `maxRetriesPerRequest`:\n\n```javascript\nvar redis = new Redis({\n  maxRetriesPerRequest: 1\n});\n```\n\nSet maxRetriesPerRequest to `null` to disable this behavior, and every command will wait forever until the connection is alive again (which is the default behavior before ioredis v4).\n\n### Reconnect on error\n\nBesides auto-reconnect when the connection is closed, ioredis supports reconnecting on the specified errors by the `reconnectOnError` option. Here's an example that will reconnect when receiving `READONLY` error:\n\n```javascript\nvar redis = new Redis({\n  reconnectOnError: function(err) {\n    var targetError = \"READONLY\";\n    if (err.message.slice(0, targetError.length) === targetError) {\n      // Only reconnect when the error starts with \"READONLY\"\n      return true; // or `return 1;`\n    }\n  }\n});\n```\n\nThis feature is useful when using Amazon ElastiCache. Once failover happens, Amazon ElastiCache will switch the master we currently connected with to a slave, leading to the following writes fails with the error `READONLY`. Using `reconnectOnError`, we can force the connection to reconnect on this error in order to connect to the new master.\n\nFurthermore, if the `reconnectOnError` returns `2`, ioredis will resend the failed command after reconnecting.\n\n## Connection Events\n\nThe Redis instance will emit some events about the state of the connection to the Redis server.\n\n| Event        | Description                                                                                                                                                                                                                                     |\n| :----------- | :---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| connect      | emits when a connection is established to the Redis server.                                                                                                                                                                                     |\n| ready        | If `enableReadyCheck` is `true`, client will emit `ready` when the server reports that it is ready to receive commands (e.g. finish loading data from disk).<br>Otherwise, `ready` will be emitted immediately right after the `connect` event. |\n| error        | emits when an error occurs while connecting.<br>However, ioredis emits all `error` events silently (only emits when there's at least one listener) so that your application won't crash if you're not listening to the `error` event.           |\n| close        | emits when an established Redis server connection has closed.                                                                                                                                                                                   |\n| reconnecting | emits after `close` when a reconnection will be made. The argument of the event is the time (in ms) before reconnecting.                                                                                                                        |\n| end          | emits after `close` when no more reconnections will be made, or the connection is failed to establish.                                                                                                                                          |\n\nYou can also check out the `Redis#status` property to get the current connection status.\n\nBesides the above connection events, there are several other custom events:\n\n| Event  | Description                                                         |\n| :----- | :------------------------------------------------------------------ |\n| select | emits when the database changed. The argument is the new db number. |\n\n## Offline Queue\n\nWhen a command can't be processed by Redis (being sent before the `ready` event), by default, it's added to the offline queue and will be\nexecuted when it can be processed. You can disable this feature by setting the `enableOfflineQueue`\noption to `false`:\n\n```javascript\nvar redis = new Redis({ enableOfflineQueue: false });\n```\n\n## TLS Options\n\nRedis doesn't support TLS natively, however if the redis server you want to connect to is hosted behind a TLS proxy (e.g. [stunnel](https://www.stunnel.org/)) or is offered by a PaaS service that supports TLS connection (e.g. [Redis Labs](https://redislabs.com/)), you can set the `tls` option:\n\n```javascript\nvar redis = new Redis({\n  host: \"localhost\",\n  tls: {\n    // Refer to `tls.connect()` section in\n    // https://nodejs.org/api/tls.html\n    // for all supported options\n    ca: fs.readFileSync(\"cert.pem\")\n  }\n});\n```\n\nAlternatively, specify the connection through a [`rediss://` URL](https://www.iana.org/assignments/uri-schemes/prov/rediss).\n\n```javascript\nvar redis = new Redis(\"rediss://redis.my-service.com\");\n```\n\n<hr>\n\n## Sentinel\n\nioredis supports Sentinel out of the box. It works transparently as all features that work when\nyou connect to a single node also work when you connect to a sentinel group. Make sure to run Redis >= 2.8.12 if you want to use this feature. Sentinels have a default port of 26379.\n\nTo connect using Sentinel, use:\n\n```javascript\nvar redis = new Redis({\n  sentinels: [\n    { host: \"localhost\", port: 26379 },\n    { host: \"localhost\", port: 26380 }\n  ],\n  name: \"mymaster\"\n});\n\nredis.set(\"foo\", \"bar\");\n```\n\nThe arguments passed to the constructor are different from the ones you use to connect to a single node, where:\n\n- `name` identifies a group of Redis instances composed of a master and one or more slaves (`mymaster` in the example);\n- `sentinelPassword` (optional) password for Sentinel instances.\n- `sentinels` are a list of sentinels to connect to. The list does not need to enumerate all your sentinel instances, but a few so that if one is down the client will try the next one.\n- `role` (optional) with a value of `slave` will return a random slave from the Sentinel group.\n- `preferredSlaves` (optional) can be used to prefer a particular slave or set of slaves based on priority. It accepts a function or array.\n\nioredis **guarantees** that the node you connected to is always a master even after a failover. When a failover happens, instead of trying to reconnect to the failed node (which will be demoted to slave when it's available again), ioredis will ask sentinels for the new master node and connect to it. All commands sent during the failover are queued and will be executed when the new connection is established so that none of the commands will be lost.\n\nIt's possible to connect to a slave instead of a master by specifying the option `role` with the value of `slave` and ioredis will try to connect to a random slave of the specified master, with the guarantee that the connected node is always a slave. If the current node is promoted to master due to a failover, ioredis will disconnect from it and ask the sentinels for another slave node to connect to.\n\nIf you specify the option `preferredSlaves` along with `role: 'slave'` ioredis will attempt to use this value when selecting the slave from the pool of available slaves. The value of `preferredSlaves` should either be a function that accepts an array of avaiable slaves and returns a single result, or an array of slave values priorities by the lowest `prio` value first with a default value of `1`.\n\n```javascript\n// available slaves format\nvar availableSlaves = [{ ip: \"127.0.0.1\", port: \"31231\", flags: \"slave\" }];\n\n// preferredSlaves array format\nvar preferredSlaves = [\n  { ip: \"127.0.0.1\", port: \"31231\", prio: 1 },\n  { ip: \"127.0.0.1\", port: \"31232\", prio: 2 }\n];\n\n// preferredSlaves function format\npreferredSlaves = function(availableSlaves) {\n  for (var i = 0; i < availableSlaves.length; i++) {\n    var slave = availableSlaves[i];\n    if (slave.ip === \"127.0.0.1\") {\n      if (slave.port === \"31234\") {\n        return slave;\n      }\n    }\n  }\n  // if no preferred slaves are available a random one is used\n  return false;\n};\n\nvar redis = new Redis({\n  sentinels: [\n    { host: \"127.0.0.1\", port: 26379 },\n    { host: \"127.0.0.1\", port: 26380 }\n  ],\n  name: \"mymaster\",\n  role: \"slave\",\n  preferredSlaves: preferredSlaves\n});\n```\n\nBesides the `retryStrategy` option, there's also a `sentinelRetryStrategy` in Sentinel mode which will be invoked when all the sentinel nodes are unreachable during connecting. If `sentinelRetryStrategy` returns a valid delay time, ioredis will try to reconnect from scratch. The default value of `sentinelRetryStrategy` is:\n\n```javascript\nfunction (times) {\n  var delay = Math.min(times * 10, 1000);\n  return delay;\n}\n```\n\n## Cluster\n\nRedis Cluster provides a way to run a Redis installation where data is automatically sharded across multiple Redis nodes.\nYou can connect to a Redis Cluster like this:\n\n```javascript\nvar Redis = require(\"ioredis\");\n\nvar cluster = new Redis.Cluster([\n  {\n    port: 6380,\n    host: \"127.0.0.1\"\n  },\n  {\n    port: 6381,\n    host: \"127.0.0.1\"\n  }\n]);\n\ncluster.set(\"foo\", \"bar\");\ncluster.get(\"foo\", function(err, res) {\n  // res === 'bar'\n});\n```\n\n`Cluster` constructor accepts two arguments, where:\n\n0.  The first argument is a list of nodes of the cluster you want to connect to.\n    Just like Sentinel, the list does not need to enumerate all your cluster nodes,\n    but a few so that if one is unreachable the client will try the next one, and the client will discover other nodes automatically when at least one node is connected.\n1.  The second argument is the options, where:\n\n    - `clusterRetryStrategy`: When none of the startup nodes are reachable, `clusterRetryStrategy` will be invoked. When a number is returned,\n      ioredis will try to reconnect to the startup nodes from scratch after the specified delay (in ms). Otherwise, an error of \"None of startup nodes is available\" will be returned.\n      The default value of this option is:\n\n          ```javascript\n          function (times) {\n            var delay = Math.min(100 + times * 2, 2000);\n            return delay;\n          }\n          ```\n\n          It's possible to modify the `startupNodes` property in order to switch to another set of nodes here:\n\n          ```javascript\n          function (times) {\n            this.startupNodes = [{ port: 6790, host: '127.0.0.1' }];\n            return Math.min(100 + times * 2, 2000);\n          }\n          ```\n\n    - `dnsLookup`: Alternative DNS lookup function (`dns.lookup()` is used by default). It may be useful to override this in special cases, such as when AWS ElastiCache used with TLS enabled.\n    - `enableOfflineQueue`: Similar to the `enableOfflineQueue` option of `Redis` class.\n    - `enableReadyCheck`: When enabled, \"ready\" event will only be emitted when `CLUSTER INFO` command\n      reporting the cluster is ready for handling commands. Otherwise, it will be emitted immediately after \"connect\" is emitted.\n    - `scaleReads`: Config where to send the read queries. See below for more details.\n    - `maxRedirections`: When a cluster related error (e.g. `MOVED`, `ASK` and `CLUSTERDOWN` etc.) is received, the client will redirect the\n      command to another node. This option limits the max redirections allowed when sending a command. The default value is `16`.\n    - `retryDelayOnFailover`: If the target node is disconnected when sending a command,\n      ioredis will retry after the specified delay. The default value is `100`. You should make sure `retryDelayOnFailover * maxRedirections > cluster-node-timeout`\n      to insure that no command will fail during a failover.\n    - `retryDelayOnClusterDown`: When a cluster is down, all commands will be rejected with the error of `CLUSTERDOWN`. If this option is a number (by default, it is `100`), the client\n      will resend the commands after the specified time (in ms).\n    - `retryDelayOnTryAgain`: If this option is a number (by default, it is `100`), the client\n      will resend the commands rejected with `TRYAGAIN` error after the specified time (in ms).\n    - `redisOptions`: Default options passed to the constructor of `Redis` when connecting to a node.\n    - `slotsRefreshTimeout`: Milliseconds before a timeout occurs while refreshing slots from the cluster (default `1000`)\n    - `slotsRefreshInterval`: Milliseconds between every automatic slots refresh (default `5000`)\n\n### Read-write splitting\n\nA typical redis cluster contains three or more masters and several slaves for each master. It's possible to scale out redis cluster by sending read queries to slaves and write queries to masters by setting the `scaleReads` option.\n\n`scaleReads` is \"master\" by default, which means ioredis will never send any queries to slaves. There are other three available options:\n\n1. \"all\": Send write queries to masters and read queries to masters or slaves randomly.\n2. \"slave\": Send write queries to masters and read queries to slaves.\n3. a custom `function(nodes, command): node`: Will choose the custom function to select to which node to send read queries (write queries keep being sent to master). The first node in `nodes` is always the master serving the relevant slots. If the function returns an array of nodes, a random node of that list will be selected.\n\nFor example:\n\n```javascript\nvar cluster = new Redis.Cluster(\n  [\n    /* nodes */\n  ],\n  {\n    scaleReads: \"slave\"\n  }\n);\ncluster.set(\"foo\", \"bar\"); // This query will be sent to one of the masters.\ncluster.get(\"foo\", function(err, res) {\n  // This query will be sent to one of the slaves.\n});\n```\n\n**NB** In the code snippet above, the `res` may not be equal to \"bar\" because of the lag of replication between the master and slaves.\n\n### Running commands to multiple nodes\n\nEvery command will be sent to exactly one node. For commands containing keys, (e.g. `GET`, `SET` and `HGETALL`), ioredis sends them to the node that serving the keys, and for other commands not containing keys, (e.g. `INFO`, `KEYS` and `FLUSHDB`), ioredis sends them to a random node.\n\nSometimes you may want to send a command to multiple nodes (masters or slaves) of the cluster, you can get the nodes via `Cluster#nodes()` method.\n\n`Cluster#nodes()` accepts a parameter role, which can be \"master\", \"slave\" and \"all\" (default), and returns an array of `Redis` instance. For example:\n\n```javascript\n// Send `FLUSHDB` command to all slaves:\nvar slaves = cluster.nodes(\"slave\");\nPromise.all(\n  slaves.map(function(node) {\n    return node.flushdb();\n  })\n);\n\n// Get keys of all the masters:\nvar masters = cluster.nodes(\"master\");\nPromise.all(\n  masters.map(function(node) {\n    return node.keys();\n  })\n).then(function(keys) {\n  // keys: [['key1', 'key2'], ['key3', 'key4']]\n});\n```\n\n### NAT Mapping\n\nSometimes the cluster is hosted within a internal network that can only be accessed via a NAT (Network Address Translation) instance. See [Accessing ElastiCache from outside AWS](https://docs.aws.amazon.com/AmazonElastiCache/latest/red-ug/accessing-elasticache.html) as an example.\n\nYou can specify nat mapping rules via `natMap` option:\n\n```javascript\nconst cluster = new Redis.Cluster(\n  [\n    {\n      host: \"203.0.113.73\",\n      port: 30001\n    }\n  ],\n  {\n    natMap: {\n      \"10.0.1.230:30001\": { host: \"203.0.113.73\", port: 30001 },\n      \"10.0.1.231:30001\": { host: \"203.0.113.73\", port: 30002 },\n      \"10.0.1.232:30001\": { host: \"203.0.113.73\", port: 30003 }\n    }\n  }\n);\n```\n\nThis option is also useful when the cluster is running inside a Docker container.\n\n### Transaction and pipeline in Cluster mode\n\nAlmost all features that are supported by `Redis` are also supported by `Redis.Cluster`, e.g. custom commands, transaction and pipeline.\nHowever there are some differences when using transaction and pipeline in Cluster mode:\n\n0. All keys in a pipeline should belong to the same slot since ioredis sends all commands in a pipeline to the same node.\n1. You can't use `multi` without pipeline (aka `cluster.multi({ pipeline: false })`). This is because when you call `cluster.multi({ pipeline: false })`, ioredis doesn't know which node the `multi` command should be sent to.\n2. Chaining custom commands in the pipeline is not supported in Cluster mode.\n\nWhen any commands in a pipeline receives a `MOVED` or `ASK` error, ioredis will resend the whole pipeline to the specified node automatically if all of the following conditions are satisfied:\n\n0. All errors received in the pipeline are the same. For example, we won't resend the pipeline if we got two `MOVED` errors pointing to different nodes.\n1. All commands executed successfully are readonly commands. This makes sure that resending the pipeline won't have side effects.\n\n### Pub/Sub\n\nPub/Sub in cluster mode works exactly as the same as in standalone mode. Internally, when a node of the cluster receives a message, it will broadcast the message to the other nodes. ioredis makes sure that each message will only be received once by strictly subscribing one node at the same time.\n\n```javascript\nvar nodes = [\n  /* nodes */\n];\nvar pub = new Redis.Cluster(nodes);\nvar sub = new Redis.Cluster(nodes);\nsub.on(\"message\", function(channel, message) {\n  console.log(channel, message);\n});\n\nsub.subscribe(\"news\", function() {\n  pub.publish(\"news\", \"highlights\");\n});\n```\n\n### Events\n\n| Event        | Description                                                                                                                                                                                                |\n| :----------- | :--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| connect      | emits when a connection is established to the Redis server.                                                                                                                                                |\n| ready        | emits when `CLUSTER INFO` reporting the cluster is able to receive commands (if `enableReadyCheck` is `true`) or immediately after `connect` event (if `enableReadyCheck` is false).                       |\n| error        | emits when an error occurs while connecting with a property of `lastNodeError` representing the last node error received. This event is emitted silently (only emitting if there's at least one listener). |\n| close        | emits when an established Redis server connection has closed.                                                                                                                                              |\n| reconnecting | emits after `close` when a reconnection will be made. The argument of the event is the time (in ms) before reconnecting.                                                                                   |\n| end          | emits after `close` when no more reconnections will be made.                                                                                                                                               |\n| +node        | emits when a new node is connected.                                                                                                                                                                        |\n| -node        | emits when a node is disconnected.                                                                                                                                                                         |\n| node error   | emits when an error occurs when connecting to a node. The second argument indicates the address of the node.                                                                                               |\n\n### Password\n\nSetting the `password` option to access password-protected clusters:\n\n```javascript\nvar Redis = require(\"ioredis\");\nvar cluster = new Redis.Cluster(nodes, {\n  redisOptions: {\n    password: \"your-cluster-password\"\n  }\n});\n```\n\nIf some of nodes in the cluster using a different password, you should specify them in the first parameter:\n\n```javascript\nvar Redis = require(\"ioredis\");\nvar cluster = new Redis.Cluster(\n  [\n    // Use password \"password-for-30001\" for 30001\n    { port: 30001, password: \"password-for-30001\" },\n    // Don't use password when accessing 30002\n    { port: 30002, password: null }\n    // Other nodes will use \"fallback-password\"\n  ],\n  {\n    redisOptions: {\n      password: \"fallback-password\"\n    }\n  }\n);\n```\n\n### Special note: AWS ElastiCache Clusters with TLS\n\nAWS ElastiCache for Redis (Clustered Mode) supports TLS encryption. If you use\nthis, you may encounter errors with invalid certificates. To resolve this\nissue, construct the `Cluster` with the `dnsLookup` option as follows:\n\n```javascript\nvar cluster = new Redis.Cluster(\n  [{\n    host: 'clustercfg.myCluster.abcdefg.xyz.cache.amazonaws.com',\n    port: 6379\n  }],\n  {\n    dnsLookup: (address, callback) => callback(null, address),\n    redisOptions: {\n      tls: {}\n    },\n  }\n);\n```\n\n<hr>\n\n# Error Handling\n\nAll the errors returned by the Redis server are instances of `ReplyError`, which can be accessed via `Redis`:\n\n```javascript\nvar Redis = require(\"ioredis\");\nvar redis = new Redis();\n// This command causes a reply error since the SET command requires two arguments.\nredis.set(\"foo\", function(err) {\n  err instanceof Redis.ReplyError;\n});\n```\n\nThis is the error stack of the `ReplyError`:\n\n```\nReplyError: ERR wrong number of arguments for 'set' command\n    at ReplyParser._parseResult (/app/node_modules/ioredis/lib/parsers/javascript.js:60:14)\n    at ReplyParser.execute (/app/node_modules/ioredis/lib/parsers/javascript.js:178:20)\n    at Socket.<anonymous> (/app/node_modules/ioredis/lib/redis/event_handler.js:99:22)\n    at Socket.emit (events.js:97:17)\n    at readableAddChunk (_stream_readable.js:143:16)\n    at Socket.Readable.push (_stream_readable.js:106:10)\n    at TCP.onread (net.js:509:20)\n```\n\nBy default, the error stack doesn't make any sense because the whole stack happens in the ioredis\nmodule itself, not in your code. So it's not easy to find out where the error happens in your code.\nioredis provides an option `showFriendlyErrorStack` to solve the problem. When you enable\n`showFriendlyErrorStack`, ioredis will optimize the error stack for you:\n\n```javascript\nvar Redis = require(\"ioredis\");\nvar redis = new Redis({ showFriendlyErrorStack: true });\nredis.set(\"foo\");\n```\n\nAnd the output will be:\n\n```\nReplyError: ERR wrong number of arguments for 'set' command\n    at Object.<anonymous> (/app/index.js:3:7)\n    at Module._compile (module.js:446:26)\n    at Object.Module._extensions..js (module.js:464:10)\n    at Module.load (module.js:341:32)\n    at Function.Module._load (module.js:296:12)\n    at Function.Module.runMain (module.js:487:10)\n    at startup (node.js:111:16)\n    at node.js:799:3\n```\n\nThis time the stack tells you that the error happens on the third line in your code. Pretty sweet!\nHowever, it would decrease the performance significantly to optimize the error stack. So by\ndefault, this option is disabled and can only be used for debugging purposes. You **shouldn't** use this feature in a production environment.\n\n# Plugging in your own Promises Library\n\nIf you're an advanced user, you may want to plug in your own promise library like [bluebird](https://www.npmjs.com/package/bluebird). Just set Redis.Promise to your favorite ES6-style promise constructor and ioredis will use it.\n\n```javascript\nconst Redis = require(\"ioredis\");\nRedis.Promise = require(\"bluebird\");\n\nconst redis = new Redis();\n\n// Use bluebird\nassert.equal(redis.get().constructor, require(\"bluebird\"));\n\n// You can change the Promise implementation at any time:\nRedis.Promise = global.Promise;\nassert.equal(redis.get().constructor, global.Promise);\n```\n\n# Running tests\n\nStart a Redis server on 127.0.0.1:6379, and then:\n\n```shell\n$ npm test\n```\n\n`FLUSH ALL` will be invoked after each test, so make sure there's no valuable data in it before running tests.\n\nIf your testing environment does not let you spin up a Redis server [ioredis-mock](https://github.com/stipsan/ioredis-mock) is a drop-in replacement you can use in your tests. It aims to behave identically to ioredis connected to a Redis server so that your integration tests is easier to write and of better quality.\n\n# Debug\n\nYou can set the `DEBUG` env to `ioredis:*` to print debug info:\n\n```shell\n$ DEBUG=ioredis:* node app.js\n```\n\n# Join in!\n\nI'm happy to receive bug reports, fixes, documentation enhancements, and any other improvements.\n\nAnd since I'm not a native English speaker, if you find any grammar mistakes in the documentation, please also let me know. :)\n\n# Become a Sponsor\n\nOpen source is hard and time-consuming. If you want to invest in ioredis's future you can become a sponsor and make us spend more time on this library's improvements and new features.\n\n<a href=\"https://opencollective.com/ioredis\"><img src=\"https://opencollective.com/ioredis/tiers/sponsor.svg?avatarHeight=36\"></a>\n\nThank you for using ioredis :-)\n\n# Contributors\n\nThis project exists thanks to all the people who contribute:\n\n<a href=\"https://github.com/luin/ioredis/graphs/contributors\"><img src=\"https://opencollective.com/ioredis/contributors.svg?width=890&showBtn=false\" /></a>\n\n# License\n\nMIT\n\n[![FOSSA Status](https://app.fossa.io/api/projects/git%2Bgithub.com%2Fluin%2Fioredis.svg?type=large)](https://app.fossa.io/projects/git%2Bgithub.com%2Fluin%2Fioredis?ref=badge_large)\n","readmeFilename":"README.md","bugs":{"url":"https://github.com/luin/ioredis/issues"},"homepage":"https://github.com/luin/ioredis#readme","_id":"ioredis@4.15.1","_nodeVersion":"10.18.0","_npmVersion":"6.13.4","dist":{"integrity":"sha512-vbSsIlmI2P31c+nxZvYjChAcgMK5Ssn9FLdhOXi0O+KVOp6JLXrkVFlq8Zrmc3ee5e5eoqB9nHFYIQzWKc/12Q==","shasum":"01c15e358b5065c05c2cb5fa297092b4e310146b","tarball":"https://registry.npmjs.org/ioredis/-/ioredis-4.15.1.tgz","fileCount":36,"unpackedSize":242377,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJeAuIFCRA9TVsSAnZWagAA3KYP/RS9TfbKRyP/mWI+3ot2\n1caqo5UVUybN41wIsiUq3CLu2/6rWL9YWZsAElWZ4huo/6+e0+N6aZRA+qX+\nRoUAJHVxwdpKzOKF7ysd7KzveX38u6dW2FxVyvUOkYAajsTlV8A8v+uRKhK6\nSHsDMEW1TvHxZg+S/3j13dKfoGEGtXA4rapeXPgpbZmJBlqhYQYjZ68X8DGB\n0AVQb7I0algqV3pnelb12/UhgCHfQi3czsQGlS0SQXdcYlCdyJbeGwVYt7R+\nIXCYXvko/bVAOEU5oz/7UArxV51MWyqtpLoIG9nrczstQp8aVSPelKE+gbZg\nZGB+UhWCmdYYSV/1eQKmiiGCJhzILLb+deb+R01+XmPlTNMRIRfZEySYtq0t\ntP/f7BqKlAIWSj4AMaFbcGWFI6OSrwCcOjocK/lJhEYo+9yzHkDV0zuOZyYC\n5z0ERe9Th5XaCqlsY/S70rMm/B/cZcXDYC0I5NqvPf0TH40D17IrJTqlCARI\nt2gGQ9gICN7Xtdu+aSveW5HpxTv4Im1iqI4tEO822Qt5PkrLnTP4lP7bmsba\nQVcjW9+boUmdwy77kFxAzJXOIilPyhaRJHEZp5+ugVggS5pSgyEWI7GkU4Ow\nAZsRAa+o5c2Htd8qfSsgy3JG/ufK12pckBtY/ao5Xdk1ssO+67BEat27hkVk\ntMWu\r\n=vZLD\r\n-----END PGP SIGNATURE-----\r\n"},"maintainers":[{"email":"ioredis-robot@zihua.li","name":"ioredis-robot"},{"email":"i@zihua.li","name":"luin"}],"_npmUser":{"name":"luin","email":"i@zihua.li"},"directories":{},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/ioredis_4.15.1_1577247236867_0.2536328760166242"},"_hasShrinkwrap":false},"4.16.0":{"name":"ioredis","version":"4.16.0","description":"A robust, performance-focused and full-featured Redis client for Node.js.","main":"built/index.js","scripts":{"test":"TS_NODE_TRANSPILE_ONLY=true TS_NODE_LOG_ERROR=true NODE_ENV=test mocha \"test/**/*.ts\"","test:cov":"TS_NODE_TRANSPILE_ONLY=true TS_NODE_LOG_ERROR=true NODE_ENV=test node ./node_modules/istanbul/lib/cli.js cover --preserve-comments ./node_modules/mocha/bin/_mocha -- -r ts-node/register -R spec --exit \"test/**/*.ts\"","lint":"eslint --ext .js,.ts .","format":"prettier --write \"{,!(node_modules)/**/}*.{js,ts}\"","format-check":"prettier --check \"{,!(node_modules)/**/}*.{js,ts}\"","build":"rm -rf built && tsc","prepublishOnly":"npm run build && npm test","bench":"matcha benchmarks/*.js","semantic-release":"semantic-release"},"repository":{"type":"git","url":"git://github.com/luin/ioredis.git"},"keywords":["redis","cluster","sentinel","pipelining"],"author":{"name":"luin","email":"i@zihua.li","url":"http://zihua.li"},"license":"MIT","funding":{"type":"opencollective","url":"https://opencollective.com/ioredis"},"dependencies":{"cluster-key-slot":"^1.1.0","debug":"^4.1.1","denque":"^1.1.0","lodash.defaults":"^4.2.0","lodash.flatten":"^4.4.0","redis-commands":"1.5.0","redis-errors":"^1.2.0","redis-parser":"^3.0.0","standard-as-callback":"^2.0.1"},"devDependencies":{"@semantic-release/changelog":"^3.0.4","@semantic-release/git":"^7.0.12","@types/bluebird":"^3.5.27","@types/chai":"^4.1.7","@types/debug":"^4.1.4","@types/lodash.defaults":"^4.2.6","@types/lodash.flatten":"^4.4.6","@types/mocha":"^5.2.7","@types/node":"^12.0.2","@types/redis-errors":"1.2.0","@types/sinon":"^7.0.13","@typescript-eslint/eslint-plugin":"^1.11.0","@typescript-eslint/parser":"^1.11.0","bluebird":"^3.5.4","chai":"^4.2.0","cz-conventional-changelog":"^2.0.0","eslint":"^5.16.0","eslint-config-prettier":"^5.1.0","husky":"^2.5.0","istanbul":"^0.4.5","mocha":"^5.0.0","prettier":"^1.18.2","pretty-quick":"^1.11.1","server-destroy":"^1.0.1","sinon":"^7.3.2","ts-node":"^8.1.0","typescript":"^3.5.1"},"engines":{"node":">=6"},"config":{"commitizen":{"path":"./node_modules/cz-conventional-changelog"}},"husky":{"hooks":{"pre-commit":"pretty-quick --staged"}},"gitHead":"f4fe62f231b33b28fda1cb28b4f5690655007b80","bugs":{"url":"https://github.com/luin/ioredis/issues"},"homepage":"https://github.com/luin/ioredis#readme","_id":"ioredis@4.16.0","_nodeVersion":"10.19.0","_npmVersion":"6.13.4","dist":{"integrity":"sha512-tlalhtuvnxXJNtrPjec1nGicuOCpi9ErYV/fRfwaWSzktX9ESrzHlcFwj1pVAL326E8dmt7h9pPQZyyVPPksRA==","shasum":"44d51288e20da14e5b6f687b2db0312e69106556","tarball":"https://registry.npmjs.org/ioredis/-/ioredis-4.16.0.tgz","fileCount":36,"unpackedSize":243701,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJeTW03CRA9TVsSAnZWagAAJWMP/0Kcxg5vu/KjS7jmAWTq\nEwlUliBVH2qMAWKisEpXEJ/L93PK+M+vIRDJc81B1sAEYwOb/Cxln0ajcbo2\nDghNuQugY+oaNdc0mCIxI6h61mvj3reV67lPFUgp1gn77NPkhb06KNCwJJZE\n751MVEn+lv9BoiJVkyfk4xxbcMcsWbR1TF2L4TDVtziWFcsrRkRFkbze0tgy\nVk7wiqeROl49zmH2Qv4PRl61c3lgMyM+m/ELzA9m/Zi6IcFgN9gVYhIEgjCN\nOgHnxrotmWVjpKvZOGx/ILaGoyd8QGDaephTW2JLabqiPz73FWB6uJG5KmhA\n+Txt64HJRRqS4XW8mBYtqLySIXz8W/ifbJ4j2xtTcG23f8gWUjSraFr3Iqvr\nNf7RxqLUz8AkAlw1XEH/TmfD4jSWqLXb2ZrBs67/wuhSsi3KmPjLgPjjV4n6\nyXtRG4J55X9eI9hkKPJtvUKISKOuWigsE88/FlOQpmal5m+LpJv3g7f/Xrvy\n8bnznEcwMw1IPvgBp2VEOBIsf9Zh/lyi0lEDJv74JIfncxelRDZfGVvo3YNk\nKib8oxCnhNmgIgThDFiQnLBWkSW8vUqk04/wodGHrWlQf1NJp+dgHWWJ1NCM\n5MA9d+eOsYWp5S+Vx+BsL8iRxRJQd8cWNOeT98Rsa8zuvSpMYNk9tVwEOl2L\nJGgw\r\n=aLeu\r\n-----END PGP SIGNATURE-----\r\n"},"maintainers":[{"email":"ioredis-robot@zihua.li","name":"ioredis-robot"},{"email":"i@zihua.li","name":"luin"}],"_npmUser":{"name":"luin","email":"i@zihua.li"},"directories":{},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/ioredis_4.16.0_1582132535272_0.16590491466478507"},"_hasShrinkwrap":false},"4.16.1":{"name":"ioredis","version":"4.16.1","description":"A robust, performance-focused and full-featured Redis client for Node.js.","main":"built/index.js","scripts":{"test":"TS_NODE_TRANSPILE_ONLY=true TS_NODE_LOG_ERROR=true NODE_ENV=test mocha \"test/**/*.ts\"","test:cov":"TS_NODE_TRANSPILE_ONLY=true TS_NODE_LOG_ERROR=true NODE_ENV=test node ./node_modules/istanbul/lib/cli.js cover --preserve-comments ./node_modules/mocha/bin/_mocha -- -r ts-node/register -R spec --exit \"test/**/*.ts\"","lint":"eslint --ext .js,.ts .","format":"prettier --write \"{,!(node_modules)/**/}*.{js,ts}\"","format-check":"prettier --check \"{,!(node_modules)/**/}*.{js,ts}\"","build":"rm -rf built && tsc","prepublishOnly":"npm run build && npm test","bench":"matcha benchmarks/*.js","semantic-release":"semantic-release"},"repository":{"type":"git","url":"git://github.com/luin/ioredis.git"},"keywords":["redis","cluster","sentinel","pipelining"],"author":{"name":"luin","email":"i@zihua.li","url":"http://zihua.li"},"license":"MIT","funding":{"type":"opencollective","url":"https://opencollective.com/ioredis"},"dependencies":{"cluster-key-slot":"^1.1.0","debug":"^4.1.1","denque":"^1.1.0","lodash.defaults":"^4.2.0","lodash.flatten":"^4.4.0","redis-commands":"1.5.0","redis-errors":"^1.2.0","redis-parser":"^3.0.0","standard-as-callback":"^2.0.1"},"devDependencies":{"@semantic-release/changelog":"^3.0.4","@semantic-release/git":"^7.0.12","@types/bluebird":"^3.5.27","@types/chai":"^4.1.7","@types/debug":"^4.1.4","@types/lodash.defaults":"^4.2.6","@types/lodash.flatten":"^4.4.6","@types/mocha":"^5.2.7","@types/node":"^12.0.2","@types/redis-errors":"1.2.0","@types/sinon":"^7.0.13","@typescript-eslint/eslint-plugin":"^1.11.0","@typescript-eslint/parser":"^1.11.0","bluebird":"^3.5.4","chai":"^4.2.0","cz-conventional-changelog":"^2.0.0","eslint":"^5.16.0","eslint-config-prettier":"^5.1.0","husky":"^2.5.0","istanbul":"^0.4.5","mocha":"^5.0.0","prettier":"^1.18.2","pretty-quick":"^1.11.1","server-destroy":"^1.0.1","sinon":"^7.3.2","ts-node":"^8.1.0","typescript":"^3.5.1"},"engines":{"node":">=6"},"config":{"commitizen":{"path":"./node_modules/cz-conventional-changelog"}},"husky":{"hooks":{"pre-commit":"pretty-quick --staged"}},"gitHead":"0b4826f1242abd3e85220278ec2d03865cf69e25","bugs":{"url":"https://github.com/luin/ioredis/issues"},"homepage":"https://github.com/luin/ioredis#readme","_id":"ioredis@4.16.1","_nodeVersion":"10.19.0","_npmVersion":"6.13.4","dist":{"integrity":"sha512-g76Mm9dE7BLuewncu1MimGZw5gDDjDwjoRony/VoSxSJEKAhuYncDEwYKYjtHi2NWsTNIB6XXRjE64uVa/wpKQ==","shasum":"377c21d2a4fa8cc31fe9028c666f8dd16a6255bf","tarball":"https://registry.npmjs.org/ioredis/-/ioredis-4.16.1.tgz","fileCount":36,"unpackedSize":246015,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJefyPaCRA9TVsSAnZWagAAlIAP/iBouJIN+U/VjqOOQ1JA\nDPl4F1qEzVA86ea8rqTZ8oRV8ZxQjsrojC9oMkaoHYF3++g9IWA7/Oj0Yg1W\nGmsMV51DKNIn2+1ynwi0vNDfPrCXMoIAQ8ulWf/XLG05Xu6H7X59Fcr5PfI8\nRGmv6Po9t1Csa1kek8VjkK3vOagwHmX9s8kSFXd8f7xaUYzly3o6ifIZ2jVr\nR04XtWlGFVXXOntQ/nnSLppdjm05Xsc3qmWhKqCsAjMgoy4kNTx0I6Q+JtxH\ncjveQEemEH0Yhb/dhWge/6c4Z0Q/Cfnau2nYllVsm8EmeJ+4H8ZC1E1g/y+g\n5juzOLDacB/4dPWCmWds61PiBUVD/v7cuXWMe5v0H3fBnPJMCWIN+Nlly6ab\nlnhBF4+OCxvlxf6fNqhSocOD+/t2ZG6mOWZBtEE1AQpym720sztuP9Ff+EWd\nh06aO+GiCSDqU4v/4tGSkC3AZrjtIPFltszny9t2JUSlNgVoTHEwkTiRm5yk\nC898GNidZOqMUvC+awKIsTD/HiiVan42PtUOM2NdE94cgpmr7gWbRu6TlnaD\nvq7P0sz1jeSFdtzO6ffohkMX57ilh+YR+0pn2MJOari1CAmw+h2DXTpp17GT\ninEJaJVF6WlIXy030Ptn0wzNvESyfrQ2xZeooSJ5Np+2qZP91Fzm042PUzO9\nb7TS\r\n=Tvns\r\n-----END PGP SIGNATURE-----\r\n"},"maintainers":[{"email":"ioredis-robot@zihua.li","name":"ioredis-robot"},{"email":"i@zihua.li","name":"luin"}],"_npmUser":{"name":"luin","email":"i@zihua.li"},"directories":{},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/ioredis_4.16.1_1585390553745_0.48993471487954676"},"_hasShrinkwrap":false}},"readme":"[![ioredis](https://cdn.jsdelivr.net/gh/luin/ioredis@b5e8c74/logo.svg)](https://github.com/luin/ioredis)\n\n[![Build Status](https://travis-ci.org/luin/ioredis.svg?branch=master)](https://travis-ci.org/luin/ioredis)\n[![Test Coverage](https://codeclimate.com/github/luin/ioredis/badges/coverage.svg)](https://codeclimate.com/github/luin/ioredis)\n[![code style: prettier](https://img.shields.io/badge/code_style-prettier-ff69b4.svg?style=flat-square)](https://github.com/prettier/prettier)\n[![Join the chat at https://gitter.im/luin/ioredis](https://badges.gitter.im/Join%20Chat.svg)](https://gitter.im/luin/ioredis?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge)\n[![Commitizen friendly](https://img.shields.io/badge/commitizen-friendly-brightgreen.svg)](http://commitizen.github.io/cz-cli/)\n[![semantic-release](https://img.shields.io/badge/%20%20%F0%9F%93%A6%F0%9F%9A%80-semantic--release-e10079.svg)](https://github.com/semantic-release/semantic-release)\n[![npm latest version](https://img.shields.io/npm/v/ioredis/latest.svg)](https://www.npmjs.com/package/ioredis)\n[![npm next version](https://img.shields.io/npm/v/ioredis/next.svg)](https://www.npmjs.com/package/ioredis)\n<img alt=\"\" src=\"\">\n\nA robust, performance-focused and full-featured [Redis](http://redis.io) client for [Node.js](https://nodejs.org).\n\nSupports Redis >= 2.6.12 and (Node.js >= 6).\n\n# Features\n\nioredis is a robust, full-featured Redis client that is\nused in the world's biggest online commerce company [Alibaba](http://www.alibaba.com/) and many other awesome companies.\n\n0. Full-featured. It supports [Cluster](http://redis.io/topics/cluster-tutorial), [Sentinel](http://redis.io/topics/sentinel), [Pipelining](http://redis.io/topics/pipelining) and of course [Lua scripting](http://redis.io/commands/eval) & [Pub/Sub](http://redis.io/topics/pubsub) (with the support of binary messages).\n1. High performance.\n2. Delightful API. It works with Node callbacks and Native promises.\n3. Transformation of command arguments and replies.\n4. Transparent key prefixing.\n5. Abstraction for Lua scripting, allowing you to define custom commands.\n6. Support for binary data.\n7. Support for TLS.\n8. Support for offline queue and ready checking.\n9. Support for ES6 types, such as `Map` and `Set`.\n10. Support for GEO commands (Redis 3.2 Unstable).\n11. Sophisticated error handling strategy.\n12. Support for NAT mapping.\n\n# Links\n\n- [API Documentation](API.md)\n- [Changelog](Changelog.md)\n- [Migrating from node_redis](https://github.com/luin/ioredis/wiki/Migrating-from-node_redis)\n- [Error Handling](#error-handling)\n\n<hr>\n<a href=\"http://bit.ly/medis-macos\"><img align=\"right\" src=\"resources/medis.png\" alt=\"Download on the App Store\"></a>\n\n### [AD] Medis: Redis GUI for OS X\n\nLooking for a Redis GUI manager for OS X, Windows and Linux? Here's [Medis](http://bit.ly/medis-macos)!\n\nMedis is an open-sourced, beautiful, easy-to-use Redis GUI management application.\n\nMedis starts with all the basic features you need:\n\n- Keys viewing/editing\n- SSH Tunnel for connecting with remote servers\n- Terminal for executing custom commands\n- JSON/MessagePack format viewing/editing and built-in highlighting/validator\n- And other awesome features...\n\n[Medis is open sourced on GitHub](https://github.com/luin/medis)\n\n### [AD] Kuber: Kubernetes Dashboard for iOS\n\n<a href=\"http://bit.ly/kuber-ios\"><img src=\"resources/kuber.png\" alt=\"Download on the App Store\"></a>\n\n<hr>\n\n# Quick Start\n\n## Install\n\n```shell\n$ npm install ioredis\n```\n\n## Basic Usage\n\n```javascript\nconst Redis = require(\"ioredis\");\nconst redis = new Redis(); // uses defaults unless given configuration object\n\n// ioredis supports all Redis commands:\nredis.set(\"foo\", \"bar\"); // returns promise which resolves to string, \"OK\"\n\n// the format is: redis[SOME_REDIS_COMMAND_IN_LOWERCASE](ARGUMENTS_ARE_JOINED_INTO_COMMAND_STRING)\n// the js: ` redis.set(\"mykey\", \"Hello\") ` is equivalent to the cli: ` redis> SET mykey \"Hello\" `\n\n// ioredis supports the node.js callback style\nredis.get(\"foo\", function(err, result) {\n  if (err) {\n    console.error(err);\n  } else {\n    console.log(result); // Promise resolves to \"bar\"\n  }\n});\n\n// Or ioredis returns a promise if the last argument isn't a function\nredis.get(\"foo\").then(function(result) {\n  console.log(result); // Prints \"bar\"\n});\n\n// Most responses are strings, or arrays of strings\nredis.zadd(\"sortedSet\", 1, \"one\", 2, \"dos\", 4, \"quatro\", 3, \"three\")\nredis.zrange(\"sortedSet\", 0, 2, \"WITHSCORES\").then(res => console.log(res)); // Promise resolves to [\"one\", \"1\", \"dos\", \"2\", \"three\", \"3\"] as if the command was ` redis> ZRANGE sortedSet 0 2 WITHSCORES `\n\n// All arguments are passed directly to the redis server:\nredis.set(\"key\", 100, \"EX\", 10);\n```\n\nSee the `examples/` folder for more examples.\n\n## Connect to Redis\n\nWhen a new `Redis` instance is created,\na connection to Redis will be created at the same time.\nYou can specify which Redis to connect to by:\n\n```javascript\nnew Redis(); // Connect to 127.0.0.1:6379\nnew Redis(6380); // 127.0.0.1:6380\nnew Redis(6379, \"192.168.1.1\"); // 192.168.1.1:6379\nnew Redis(\"/tmp/redis.sock\");\nnew Redis({\n  port: 6379, // Redis port\n  host: \"127.0.0.1\", // Redis host\n  family: 4, // 4 (IPv4) or 6 (IPv6)\n  password: \"auth\",\n  db: 0\n});\n```\n\nYou can also specify connection options as a [`redis://` URL](http://www.iana.org/assignments/uri-schemes/prov/redis) or [`rediss://` URL](https://www.iana.org/assignments/uri-schemes/prov/rediss) when using [TLS encryption](#tls-options):\n\n```javascript\n// Connect to 127.0.0.1:6380, db 4, using password \"authpassword\":\nnew Redis(\"redis://:authpassword@127.0.0.1:6380/4\");\n```\n\nSee [API Documentation](API.md#new_Redis) for all available options.\n\n## Pub/Sub\n\nHere is a simple example of the API for publish/subscribe.\nThe following program opens two client connections.\nIt subscribes to a channel with one connection\nand publishes to that channel with the other:\n\n```javascript\nvar Redis = require(\"ioredis\");\nvar redis = new Redis();\nvar pub = new Redis();\nredis.subscribe(\"news\", \"music\", function(err, count) {\n  // Now we are subscribed to both the 'news' and 'music' channels.\n  // `count` represents the number of channels we are currently subscribed to.\n\n  pub.publish(\"news\", \"Hello world!\");\n  pub.publish(\"music\", \"Hello again!\");\n});\n\nredis.on(\"message\", function(channel, message) {\n  // Receive message Hello world! from channel news\n  // Receive message Hello again! from channel music\n  console.log(\"Receive message %s from channel %s\", message, channel);\n});\n\n// There's also an event called 'messageBuffer', which is the same as 'message' except\n// it returns buffers instead of strings.\nredis.on(\"messageBuffer\", function(channel, message) {\n  // Both `channel` and `message` are buffers.\n});\n```\n\n`PSUBSCRIBE` is also supported in a similar way:\n\n```javascript\nredis.psubscribe(\"pat?ern\", function(err, count) {});\nredis.on(\"pmessage\", function(pattern, channel, message) {});\nredis.on(\"pmessageBuffer\", function(pattern, channel, message) {});\n```\n\nWhen a client issues a SUBSCRIBE or PSUBSCRIBE, that connection is put into a \"subscriber\" mode.\nAt that point, only commands that modify the subscription set are valid.\nWhen the subscription set is empty, the connection is put back into regular mode.\n\nIf you need to send regular commands to Redis while in subscriber mode, just open another connection.\n\n## Handle Binary Data\n\nArguments can be buffers:\n\n```javascript\nredis.set(\"foo\", Buffer.from(\"bar\"));\n```\n\nAnd every command has a method that returns a Buffer (by adding a suffix of \"Buffer\" to the command name).\nTo get a buffer instead of a utf8 string:\n\n```javascript\nredis.getBuffer(\"foo\", function(err, result) {\n  // result is a buffer.\n});\n```\n\n## Pipelining\n\nIf you want to send a batch of commands (e.g. > 5), you can use pipelining to queue\nthe commands in memory and then send them to Redis all at once. This way the performance improves by 50%~300% (See [benchmark section](#benchmark)).\n\n`redis.pipeline()` creates a `Pipeline` instance. You can call any Redis\ncommands on it just like the `Redis` instance. The commands are queued in memory\nand flushed to Redis by calling the `exec` method:\n\n```javascript\nvar pipeline = redis.pipeline();\npipeline.set(\"foo\", \"bar\");\npipeline.del(\"cc\");\npipeline.exec(function(err, results) {\n  // `err` is always null, and `results` is an array of responses\n  // corresponding to the sequence of queued commands.\n  // Each response follows the format `[err, result]`.\n});\n\n// You can even chain the commands:\nredis\n  .pipeline()\n  .set(\"foo\", \"bar\")\n  .del(\"cc\")\n  .exec(function(err, results) {});\n\n// `exec` also returns a Promise:\nvar promise = redis\n  .pipeline()\n  .set(\"foo\", \"bar\")\n  .get(\"foo\")\n  .exec();\npromise.then(function(result) {\n  // result === [[null, 'OK'], [null, 'bar']]\n});\n```\n\nEach chained command can also have a callback, which will be invoked when the command\ngets a reply:\n\n```javascript\nredis\n  .pipeline()\n  .set(\"foo\", \"bar\")\n  .get(\"foo\", function(err, result) {\n    // result === 'bar'\n  })\n  .exec(function(err, result) {\n    // result[1][1] === 'bar'\n  });\n```\n\nIn addition to adding commands to the `pipeline` queue individually, you can also pass an array of commands and arguments to the constructor:\n\n```javascript\nredis.pipeline([[\"set\", \"foo\", \"bar\"], [\"get\", \"foo\"]]).exec(function() {\n  /* ... */\n});\n```\n\n`#length` property shows how many commands in the pipeline:\n\n```javascript\nconst length = redis\n  .pipeline()\n  .set(\"foo\", \"bar\")\n  .get(\"foo\").length;\n// length === 2\n```\n\n## Transaction\n\nMost of the time, the transaction commands `multi` & `exec` are used together with pipeline.\nTherefore, when `multi` is called, a `Pipeline` instance is created automatically by default,\nso you can use `multi` just like `pipeline`:\n\n```javascript\nredis\n  .multi()\n  .set(\"foo\", \"bar\")\n  .get(\"foo\")\n  .exec(function(err, results) {\n    // results === [[null, 'OK'], [null, 'bar']]\n  });\n```\n\nIf there's a syntax error in the transaction's command chain (e.g. wrong number of arguments, wrong command name, etc),\nthen none of the commands would be executed, and an error is returned:\n\n```javascript\nredis\n  .multi()\n  .set(\"foo\")\n  .set(\"foo\", \"new value\")\n  .exec(function(err, results) {\n    // err:\n    //  { [ReplyError: EXECABORT Transaction discarded because of previous errors.]\n    //    name: 'ReplyError',\n    //    message: 'EXECABORT Transaction discarded because of previous errors.',\n    //    command: { name: 'exec', args: [] },\n    //    previousErrors:\n    //     [ { [ReplyError: ERR wrong number of arguments for 'set' command]\n    //         name: 'ReplyError',\n    //         message: 'ERR wrong number of arguments for \\'set\\' command',\n    //         command: [Object] } ] }\n  });\n```\n\nIn terms of the interface, `multi` differs from `pipeline` in that when specifying a callback\nto each chained command, the queueing state is passed to the callback instead of the result of the command:\n\n```javascript\nredis\n  .multi()\n  .set(\"foo\", \"bar\", function(err, result) {\n    // result === 'QUEUED'\n  })\n  .exec(/* ... */);\n```\n\nIf you want to use transaction without pipeline, pass `{ pipeline: false }` to `multi`,\nand every command will be sent to Redis immediately without waiting for an `exec` invocation:\n\n```javascript\nredis.multi({ pipeline: false });\nredis.set(\"foo\", \"bar\");\nredis.get(\"foo\");\nredis.exec(function(err, result) {\n  // result === [[null, 'OK'], [null, 'bar']]\n});\n```\n\nThe constructor of `multi` also accepts a batch of commands:\n\n```javascript\nredis.multi([[\"set\", \"foo\", \"bar\"], [\"get\", \"foo\"]]).exec(function() {\n  /* ... */\n});\n```\n\nInline transactions are supported by pipeline, which means you can group a subset of commands\nin the pipeline into a transaction:\n\n```javascript\nredis\n  .pipeline()\n  .get(\"foo\")\n  .multi()\n  .set(\"foo\", \"bar\")\n  .get(\"foo\")\n  .exec()\n  .get(\"foo\")\n  .exec();\n```\n\n## Lua Scripting\n\nioredis supports all of the scripting commands such as `EVAL`, `EVALSHA` and `SCRIPT`.\nHowever, it's tedious to use in real world scenarios since developers have to take\ncare of script caching and to detect when to use `EVAL` and when to use `EVALSHA`.\nioredis exposes a `defineCommand` method to make scripting much easier to use:\n\n```javascript\nvar redis = new Redis();\n\n// This will define a command echo:\nredis.defineCommand(\"echo\", {\n  numberOfKeys: 2,\n  lua: \"return {KEYS[1],KEYS[2],ARGV[1],ARGV[2]}\"\n});\n\n// Now `echo` can be used just like any other ordinary command,\n// and ioredis will try to use `EVALSHA` internally when possible for better performance.\nredis.echo(\"k1\", \"k2\", \"a1\", \"a2\", function(err, result) {\n  // result === ['k1', 'k2', 'a1', 'a2']\n});\n\n// `echoBuffer` is also defined automatically to return buffers instead of strings:\nredis.echoBuffer(\"k1\", \"k2\", \"a1\", \"a2\", function(err, result) {\n  // result[0] equals to Buffer.from('k1');\n});\n\n// And of course it works with pipeline:\nredis\n  .pipeline()\n  .set(\"foo\", \"bar\")\n  .echo(\"k1\", \"k2\", \"a1\", \"a2\")\n  .exec();\n```\n\nIf the number of keys can't be determined when defining a command, you can\nomit the `numberOfKeys` property and pass the number of keys as the first argument\nwhen you call the command:\n\n```javascript\nredis.defineCommand(\"echoDynamicKeyNumber\", {\n  lua: \"return {KEYS[1],KEYS[2],ARGV[1],ARGV[2]}\"\n});\n\n// Now you have to pass the number of keys as the first argument every time\n// you invoke the `echoDynamicKeyNumber` command:\nredis.echoDynamicKeyNumber(2, \"k1\", \"k2\", \"a1\", \"a2\", function(err, result) {\n  // result === ['k1', 'k2', 'a1', 'a2']\n});\n```\n\n## Transparent Key Prefixing\n\nThis feature allows you to specify a string that will automatically be prepended\nto all the keys in a command, which makes it easier to manage your key\nnamespaces.\n\n**Warning** This feature won't apply to commands like [KEYS](http://redis.io/commands/KEYS) and [SCAN](http://redis.io/commands/scan) that take patterns rather than actual keys([#239](https://github.com/luin/ioredis/issues/239)),\nand this feature also won't apply to the replies of commands even they are key names ([#325](https://github.com/luin/ioredis/issues/325)).\n\n```javascript\nvar fooRedis = new Redis({ keyPrefix: \"foo:\" });\nfooRedis.set(\"bar\", \"baz\"); // Actually sends SET foo:bar baz\n\nfooRedis.defineCommand(\"echo\", {\n  numberOfKeys: 2,\n  lua: \"return {KEYS[1],KEYS[2],ARGV[1],ARGV[2]}\"\n});\n\n// Works well with pipelining/transaction\nfooRedis\n  .pipeline()\n  // Sends SORT foo:list BY foo:weight_*->fieldname\n  .sort(\"list\", \"BY\", \"weight_*->fieldname\")\n  // Supports custom commands\n  // Sends EVALSHA xxx foo:k1 foo:k2 a1 a2\n  .echo(\"k1\", \"k2\", \"a1\", \"a2\")\n  .exec();\n```\n\n## Transforming Arguments & Replies\n\nMost Redis commands take one or more Strings as arguments,\nand replies are sent back as a single String or an Array of Strings. However, sometimes\nyou may want something different. For instance, it would be more convenient if the `HGETALL`\ncommand returns a hash (e.g. `{ key: val1, key2: v2 }`) rather than an array of key values (e.g. `[key1, val1, key2, val2]`).\n\nioredis has a flexible system for transforming arguments and replies. There are two types\nof transformers, argument transformer and reply transformer:\n\n```javascript\nvar Redis = require(\"ioredis\");\n\n// Here's the built-in argument transformer converting\n// hmset('key', { k1: 'v1', k2: 'v2' })\n// or\n// hmset('key', new Map([['k1', 'v1'], ['k2', 'v2']]))\n// into\n// hmset('key', 'k1', 'v1', 'k2', 'v2')\nRedis.Command.setArgumentTransformer(\"hmset\", function(args) {\n  if (args.length === 2) {\n    if (typeof Map !== \"undefined\" && args[1] instanceof Map) {\n      // utils is a internal module of ioredis\n      return [args[0]].concat(utils.convertMapToArray(args[1]));\n    }\n    if (typeof args[1] === \"object\" && args[1] !== null) {\n      return [args[0]].concat(utils.convertObjectToArray(args[1]));\n    }\n  }\n  return args;\n});\n\n// Here's the built-in reply transformer converting the HGETALL reply\n// ['k1', 'v1', 'k2', 'v2']\n// into\n// { k1: 'v1', 'k2': 'v2' }\nRedis.Command.setReplyTransformer(\"hgetall\", function(result) {\n  if (Array.isArray(result)) {\n    var obj = {};\n    for (var i = 0; i < result.length; i += 2) {\n      obj[result[i]] = result[i + 1];\n    }\n    return obj;\n  }\n  return result;\n});\n```\n\nThere are three built-in transformers, two argument transformers for `hmset` & `mset` and\na reply transformer for `hgetall`. Transformers for `hmset` and `hgetall` were mentioned\nabove, and the transformer for `mset` is similar to the one for `hmset`:\n\n```javascript\nredis.mset({ k1: \"v1\", k2: \"v2\" });\nredis.get(\"k1\", function(err, result) {\n  // result === 'v1';\n});\n\nredis.mset(new Map([[\"k3\", \"v3\"], [\"k4\", \"v4\"]]));\nredis.get(\"k3\", function(err, result) {\n  // result === 'v3';\n});\n```\n\nAnother useful example of a reply transformer is one that changes `hgetall` to return array of arrays instead of objects which avoids a unwanted conversation of hash keys to strings when dealing with binary hash keys:\n\n```javascript\nRedis.Command.setReplyTransformer(\"hgetall\", function(result) {\n  var arr = [];\n  for (var i = 0; i < result.length; i += 2) {\n    arr.push([result[i], result[i + 1]]);\n  }\n  return arr;\n});\nredis.hset(\"h1\", Buffer.from([0x01]), Buffer.from([0x02]));\nredis.hset(\"h1\", Buffer.from([0x03]), Buffer.from([0x04]));\nredis.hgetallBuffer(\"h1\", function(err, result) {\n  // result === [ [ <Buffer 01>, <Buffer 02> ], [ <Buffer 03>, <Buffer 04> ] ];\n});\n```\n\n## Monitor\n\nRedis supports the MONITOR command,\nwhich lets you see all commands received by the Redis server across all client connections,\nincluding from other client libraries and other computers.\n\nThe `monitor` method returns a monitor instance.\nAfter you send the MONITOR command, no other commands are valid on that connection. ioredis will emit a monitor event for every new monitor message that comes across.\nThe callback for the monitor event takes a timestamp from the Redis server and an array of command arguments.\n\nHere is a simple example:\n\n```javascript\nredis.monitor(function(err, monitor) {\n  monitor.on(\"monitor\", function(time, args, source, database) {});\n});\n```\nHere is another example illustrating an `async` function and `monitor.disconnect()`:\n```javascript\nasync () => {\n  const monitor = await redis.monitor()\n  monitor.on('monitor', console.log)\n  // Any other tasks\n  monitor.disconnect()\n}\n```\n## Streamify Scanning\n\nRedis 2.8 added the `SCAN` command to incrementally iterate through the keys in the database. It's different from `KEYS` in that\n`SCAN` only returns a small number of elements each call, so it can be used in production without the downside\nof blocking the server for a long time. However, it requires recording the cursor on the client side each time\nthe `SCAN` command is called in order to iterate through all the keys correctly. Since it's a relatively common use case, ioredis\nprovides a streaming interface for the `SCAN` command to make things much easier. A readable stream can be created by calling `scanStream`:\n\n```javascript\nvar redis = new Redis();\n// Create a readable stream (object mode)\nvar stream = redis.scanStream();\nstream.on(\"data\", function(resultKeys) {\n  // `resultKeys` is an array of strings representing key names.\n  // Note that resultKeys may contain 0 keys, and that it will sometimes\n  // contain duplicates due to SCAN's implementation in Redis.\n  for (var i = 0; i < resultKeys.length; i++) {\n    console.log(resultKeys[i]);\n  }\n});\nstream.on(\"end\", function() {\n  console.log(\"all keys have been visited\");\n});\n```\n\n`scanStream` accepts an option, with which you can specify the `MATCH` pattern and the `COUNT` argument:\n\n```javascript\nvar stream = redis.scanStream({\n  // only returns keys following the pattern of `user:*`\n  match: \"user:*\",\n  // returns approximately 100 elements per call\n  count: 100\n});\n```\n\nJust like other commands, `scanStream` has a binary version `scanBufferStream`, which returns an array of buffers. It's useful when\nthe key names are not utf8 strings.\n\nThere are also `hscanStream`, `zscanStream` and `sscanStream` to iterate through elements in a hash, zset and set. The interface of each is\nsimilar to `scanStream` except the first argument is the key name:\n\n```javascript\nvar stream = redis.hscanStream(\"myhash\", {\n  match: \"age:??\"\n});\n```\n\nYou can learn more from the [Redis documentation](http://redis.io/commands/scan).\n\n**Useful Tips**\nIt's pretty common that doing an async task in the `data` handler. We'd like the scanning process to be paused until the async task to be finished. `Stream#pause()` and `Stream.resume()` do the trick. For example if we want to migrate data in Redis to MySQL:\n\n```javascript\nvar stream = redis.scanStream();\nstream.on(\"data\", function(resultKeys) {\n  // Pause the stream from scanning more keys until we've migrated the current keys.\n  stream.pause();\n\n  Promise.all(resultKeys.map(migrateKeyToMySQL)).then(() => {\n    // Resume the stream here.\n    stream.resume();\n  });\n});\n\nstream.on(\"end\", function() {\n  console.log(\"done migration\");\n});\n```\n\n## Auto-reconnect\n\nBy default, ioredis will try to reconnect when the connection to Redis is lost\nexcept when the connection is closed manually by `redis.disconnect()` or `redis.quit()`.\n\nIt's very flexible to control how long to wait to reconnect after disconnection\nusing the `retryStrategy` option:\n\n```javascript\nvar redis = new Redis({\n  // This is the default value of `retryStrategy`\n  retryStrategy: function(times) {\n    var delay = Math.min(times * 50, 2000);\n    return delay;\n  }\n});\n```\n\n`retryStrategy` is a function that will be called when the connection is lost.\nThe argument `times` means this is the nth reconnection being made and\nthe return value represents how long (in ms) to wait to reconnect. When the\nreturn value isn't a number, ioredis will stop trying to reconnect, and the connection\nwill be lost forever if the user doesn't call `redis.connect()` manually.\n\nWhen reconnected, the client will auto subscribe to channels that the previous connection subscribed to.\nThis behavior can be disabled by setting the `autoResubscribe` option to `false`.\n\nAnd if the previous connection has some unfulfilled commands (most likely blocking commands such as `brpop` and `blpop`),\nthe client will resend them when reconnected. This behavior can be disabled by setting the `autoResendUnfulfilledCommands` option to `false`.\n\nBy default, all pending commands will be flushed with an error every 20 retry attempts. That makes sure commands won't wait forever when the connection is down. You can change this behavior by setting `maxRetriesPerRequest`:\n\n```javascript\nvar redis = new Redis({\n  maxRetriesPerRequest: 1\n});\n```\n\nSet maxRetriesPerRequest to `null` to disable this behavior, and every command will wait forever until the connection is alive again (which is the default behavior before ioredis v4).\n\n### Reconnect on error\n\nBesides auto-reconnect when the connection is closed, ioredis supports reconnecting on the specified errors by the `reconnectOnError` option. Here's an example that will reconnect when receiving `READONLY` error:\n\n```javascript\nvar redis = new Redis({\n  reconnectOnError: function(err) {\n    var targetError = \"READONLY\";\n    if (err.message.slice(0, targetError.length) === targetError) {\n      // Only reconnect when the error starts with \"READONLY\"\n      return true; // or `return 1;`\n    }\n  }\n});\n```\n\nThis feature is useful when using Amazon ElastiCache. Once failover happens, Amazon ElastiCache will switch the master we currently connected with to a slave, leading to the following writes fails with the error `READONLY`. Using `reconnectOnError`, we can force the connection to reconnect on this error in order to connect to the new master.\n\nFurthermore, if the `reconnectOnError` returns `2`, ioredis will resend the failed command after reconnecting.\n\n## Connection Events\n\nThe Redis instance will emit some events about the state of the connection to the Redis server.\n\n| Event        | Description                                                                                                                                                                                                                                     |\n| :----------- | :---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| connect      | emits when a connection is established to the Redis server.                                                                                                                                                                                     |\n| ready        | If `enableReadyCheck` is `true`, client will emit `ready` when the server reports that it is ready to receive commands (e.g. finish loading data from disk).<br>Otherwise, `ready` will be emitted immediately right after the `connect` event. |\n| error        | emits when an error occurs while connecting.<br>However, ioredis emits all `error` events silently (only emits when there's at least one listener) so that your application won't crash if you're not listening to the `error` event.           |\n| close        | emits when an established Redis server connection has closed.                                                                                                                                                                                   |\n| reconnecting | emits after `close` when a reconnection will be made. The argument of the event is the time (in ms) before reconnecting.                                                                                                                        |\n| end          | emits after `close` when no more reconnections will be made, or the connection is failed to establish.                                                                                                                                          |\n\nYou can also check out the `Redis#status` property to get the current connection status.\n\nBesides the above connection events, there are several other custom events:\n\n| Event  | Description                                                         |\n| :----- | :------------------------------------------------------------------ |\n| select | emits when the database changed. The argument is the new db number. |\n\n## Offline Queue\n\nWhen a command can't be processed by Redis (being sent before the `ready` event), by default, it's added to the offline queue and will be\nexecuted when it can be processed. You can disable this feature by setting the `enableOfflineQueue`\noption to `false`:\n\n```javascript\nvar redis = new Redis({ enableOfflineQueue: false });\n```\n\n## TLS Options\n\nRedis doesn't support TLS natively, however if the redis server you want to connect to is hosted behind a TLS proxy (e.g. [stunnel](https://www.stunnel.org/)) or is offered by a PaaS service that supports TLS connection (e.g. [Redis Labs](https://redislabs.com/)), you can set the `tls` option:\n\n```javascript\nvar redis = new Redis({\n  host: \"localhost\",\n  tls: {\n    // Refer to `tls.connect()` section in\n    // https://nodejs.org/api/tls.html\n    // for all supported options\n    ca: fs.readFileSync(\"cert.pem\")\n  }\n});\n```\n\nAlternatively, specify the connection through a [`rediss://` URL](https://www.iana.org/assignments/uri-schemes/prov/rediss).\n\n```javascript\nvar redis = new Redis(\"rediss://redis.my-service.com\");\n```\n\n<hr>\n\n## Sentinel\n\nioredis supports Sentinel out of the box. It works transparently as all features that work when\nyou connect to a single node also work when you connect to a sentinel group. Make sure to run Redis >= 2.8.12 if you want to use this feature. Sentinels have a default port of 26379.\n\nTo connect using Sentinel, use:\n\n```javascript\nvar redis = new Redis({\n  sentinels: [\n    { host: \"localhost\", port: 26379 },\n    { host: \"localhost\", port: 26380 }\n  ],\n  name: \"mymaster\"\n});\n\nredis.set(\"foo\", \"bar\");\n```\n\nThe arguments passed to the constructor are different from the ones you use to connect to a single node, where:\n\n- `name` identifies a group of Redis instances composed of a master and one or more slaves (`mymaster` in the example);\n- `sentinelPassword` (optional) password for Sentinel instances.\n- `sentinels` are a list of sentinels to connect to. The list does not need to enumerate all your sentinel instances, but a few so that if one is down the client will try the next one.\n- `role` (optional) with a value of `slave` will return a random slave from the Sentinel group.\n- `preferredSlaves` (optional) can be used to prefer a particular slave or set of slaves based on priority. It accepts a function or array.\n\nioredis **guarantees** that the node you connected to is always a master even after a failover. When a failover happens, instead of trying to reconnect to the failed node (which will be demoted to slave when it's available again), ioredis will ask sentinels for the new master node and connect to it. All commands sent during the failover are queued and will be executed when the new connection is established so that none of the commands will be lost.\n\nIt's possible to connect to a slave instead of a master by specifying the option `role` with the value of `slave` and ioredis will try to connect to a random slave of the specified master, with the guarantee that the connected node is always a slave. If the current node is promoted to master due to a failover, ioredis will disconnect from it and ask the sentinels for another slave node to connect to.\n\nIf you specify the option `preferredSlaves` along with `role: 'slave'` ioredis will attempt to use this value when selecting the slave from the pool of available slaves. The value of `preferredSlaves` should either be a function that accepts an array of available slaves and returns a single result, or an array of slave values priorities by the lowest `prio` value first with a default value of `1`.\n\n```javascript\n// available slaves format\nvar availableSlaves = [{ ip: \"127.0.0.1\", port: \"31231\", flags: \"slave\" }];\n\n// preferredSlaves array format\nvar preferredSlaves = [\n  { ip: \"127.0.0.1\", port: \"31231\", prio: 1 },\n  { ip: \"127.0.0.1\", port: \"31232\", prio: 2 }\n];\n\n// preferredSlaves function format\npreferredSlaves = function(availableSlaves) {\n  for (var i = 0; i < availableSlaves.length; i++) {\n    var slave = availableSlaves[i];\n    if (slave.ip === \"127.0.0.1\") {\n      if (slave.port === \"31234\") {\n        return slave;\n      }\n    }\n  }\n  // if no preferred slaves are available a random one is used\n  return false;\n};\n\nvar redis = new Redis({\n  sentinels: [\n    { host: \"127.0.0.1\", port: 26379 },\n    { host: \"127.0.0.1\", port: 26380 }\n  ],\n  name: \"mymaster\",\n  role: \"slave\",\n  preferredSlaves: preferredSlaves\n});\n```\n\nBesides the `retryStrategy` option, there's also a `sentinelRetryStrategy` in Sentinel mode which will be invoked when all the sentinel nodes are unreachable during connecting. If `sentinelRetryStrategy` returns a valid delay time, ioredis will try to reconnect from scratch. The default value of `sentinelRetryStrategy` is:\n\n```javascript\nfunction (times) {\n  var delay = Math.min(times * 10, 1000);\n  return delay;\n}\n```\n\n## Cluster\n\nRedis Cluster provides a way to run a Redis installation where data is automatically sharded across multiple Redis nodes.\nYou can connect to a Redis Cluster like this:\n\n```javascript\nvar Redis = require(\"ioredis\");\n\nvar cluster = new Redis.Cluster([\n  {\n    port: 6380,\n    host: \"127.0.0.1\"\n  },\n  {\n    port: 6381,\n    host: \"127.0.0.1\"\n  }\n]);\n\ncluster.set(\"foo\", \"bar\");\ncluster.get(\"foo\", function(err, res) {\n  // res === 'bar'\n});\n```\n\n`Cluster` constructor accepts two arguments, where:\n\n0.  The first argument is a list of nodes of the cluster you want to connect to.\n    Just like Sentinel, the list does not need to enumerate all your cluster nodes,\n    but a few so that if one is unreachable the client will try the next one, and the client will discover other nodes automatically when at least one node is connected.\n1.  The second argument is the options, where:\n\n    - `clusterRetryStrategy`: When none of the startup nodes are reachable, `clusterRetryStrategy` will be invoked. When a number is returned,\n      ioredis will try to reconnect to the startup nodes from scratch after the specified delay (in ms). Otherwise, an error of \"None of startup nodes is available\" will be returned.\n      The default value of this option is:\n\n      ```javascript\n      function (times) {\n        var delay = Math.min(100 + times * 2, 2000);\n        return delay;\n      }\n      ```\n\n      It's possible to modify the `startupNodes` property in order to switch to another set of nodes here:\n\n      ```javascript\n      function (times) {\n        this.startupNodes = [{ port: 6790, host: '127.0.0.1' }];\n        return Math.min(100 + times * 2, 2000);\n      }\n      ```\n\n    - `dnsLookup`: Alternative DNS lookup function (`dns.lookup()` is used by default). It may be useful to override this in special cases, such as when AWS ElastiCache used with TLS enabled.\n    - `enableOfflineQueue`: Similar to the `enableOfflineQueue` option of `Redis` class.\n    - `enableReadyCheck`: When enabled, \"ready\" event will only be emitted when `CLUSTER INFO` command\n      reporting the cluster is ready for handling commands. Otherwise, it will be emitted immediately after \"connect\" is emitted.\n    - `scaleReads`: Config where to send the read queries. See below for more details.\n    - `maxRedirections`: When a cluster related error (e.g. `MOVED`, `ASK` and `CLUSTERDOWN` etc.) is received, the client will redirect the\n      command to another node. This option limits the max redirections allowed when sending a command. The default value is `16`.\n    - `retryDelayOnFailover`: If the target node is disconnected when sending a command,\n      ioredis will retry after the specified delay. The default value is `100`. You should make sure `retryDelayOnFailover * maxRedirections > cluster-node-timeout`\n      to insure that no command will fail during a failover.\n    - `retryDelayOnClusterDown`: When a cluster is down, all commands will be rejected with the error of `CLUSTERDOWN`. If this option is a number (by default, it is `100`), the client\n      will resend the commands after the specified time (in ms).\n    - `retryDelayOnTryAgain`: If this option is a number (by default, it is `100`), the client\n      will resend the commands rejected with `TRYAGAIN` error after the specified time (in ms).\n    - `redisOptions`: Default options passed to the constructor of `Redis` when connecting to a node.\n    - `slotsRefreshTimeout`: Milliseconds before a timeout occurs while refreshing slots from the cluster (default `1000`)\n    - `slotsRefreshInterval`: Milliseconds between every automatic slots refresh (default `5000`)\n\n### Read-write splitting\n\nA typical redis cluster contains three or more masters and several slaves for each master. It's possible to scale out redis cluster by sending read queries to slaves and write queries to masters by setting the `scaleReads` option.\n\n`scaleReads` is \"master\" by default, which means ioredis will never send any queries to slaves. There are other three available options:\n\n1. \"all\": Send write queries to masters and read queries to masters or slaves randomly.\n2. \"slave\": Send write queries to masters and read queries to slaves.\n3. a custom `function(nodes, command): node`: Will choose the custom function to select to which node to send read queries (write queries keep being sent to master). The first node in `nodes` is always the master serving the relevant slots. If the function returns an array of nodes, a random node of that list will be selected.\n\nFor example:\n\n```javascript\nvar cluster = new Redis.Cluster(\n  [\n    /* nodes */\n  ],\n  {\n    scaleReads: \"slave\"\n  }\n);\ncluster.set(\"foo\", \"bar\"); // This query will be sent to one of the masters.\ncluster.get(\"foo\", function(err, res) {\n  // This query will be sent to one of the slaves.\n});\n```\n\n**NB** In the code snippet above, the `res` may not be equal to \"bar\" because of the lag of replication between the master and slaves.\n\n### Running commands to multiple nodes\n\nEvery command will be sent to exactly one node. For commands containing keys, (e.g. `GET`, `SET` and `HGETALL`), ioredis sends them to the node that serving the keys, and for other commands not containing keys, (e.g. `INFO`, `KEYS` and `FLUSHDB`), ioredis sends them to a random node.\n\nSometimes you may want to send a command to multiple nodes (masters or slaves) of the cluster, you can get the nodes via `Cluster#nodes()` method.\n\n`Cluster#nodes()` accepts a parameter role, which can be \"master\", \"slave\" and \"all\" (default), and returns an array of `Redis` instance. For example:\n\n```javascript\n// Send `FLUSHDB` command to all slaves:\nvar slaves = cluster.nodes(\"slave\");\nPromise.all(\n  slaves.map(function(node) {\n    return node.flushdb();\n  })\n);\n\n// Get keys of all the masters:\nvar masters = cluster.nodes(\"master\");\nPromise.all(\n  masters.map(function(node) {\n    return node.keys();\n  })\n).then(function(keys) {\n  // keys: [['key1', 'key2'], ['key3', 'key4']]\n});\n```\n\n### NAT Mapping\n\nSometimes the cluster is hosted within a internal network that can only be accessed via a NAT (Network Address Translation) instance. See [Accessing ElastiCache from outside AWS](https://docs.aws.amazon.com/AmazonElastiCache/latest/red-ug/accessing-elasticache.html) as an example.\n\nYou can specify nat mapping rules via `natMap` option:\n\n```javascript\nconst cluster = new Redis.Cluster(\n  [\n    {\n      host: \"203.0.113.73\",\n      port: 30001\n    }\n  ],\n  {\n    natMap: {\n      \"10.0.1.230:30001\": { host: \"203.0.113.73\", port: 30001 },\n      \"10.0.1.231:30001\": { host: \"203.0.113.73\", port: 30002 },\n      \"10.0.1.232:30001\": { host: \"203.0.113.73\", port: 30003 }\n    }\n  }\n);\n```\n\nThis option is also useful when the cluster is running inside a Docker container.\n\n### Transaction and pipeline in Cluster mode\n\nAlmost all features that are supported by `Redis` are also supported by `Redis.Cluster`, e.g. custom commands, transaction and pipeline.\nHowever there are some differences when using transaction and pipeline in Cluster mode:\n\n0. All keys in a pipeline should belong to the same slot since ioredis sends all commands in a pipeline to the same node.\n1. You can't use `multi` without pipeline (aka `cluster.multi({ pipeline: false })`). This is because when you call `cluster.multi({ pipeline: false })`, ioredis doesn't know which node the `multi` command should be sent to.\n2. Chaining custom commands in the pipeline is not supported in Cluster mode.\n\nWhen any commands in a pipeline receives a `MOVED` or `ASK` error, ioredis will resend the whole pipeline to the specified node automatically if all of the following conditions are satisfied:\n\n0. All errors received in the pipeline are the same. For example, we won't resend the pipeline if we got two `MOVED` errors pointing to different nodes.\n1. All commands executed successfully are readonly commands. This makes sure that resending the pipeline won't have side effects.\n\n### Pub/Sub\n\nPub/Sub in cluster mode works exactly as the same as in standalone mode. Internally, when a node of the cluster receives a message, it will broadcast the message to the other nodes. ioredis makes sure that each message will only be received once by strictly subscribing one node at the same time.\n\n```javascript\nvar nodes = [\n  /* nodes */\n];\nvar pub = new Redis.Cluster(nodes);\nvar sub = new Redis.Cluster(nodes);\nsub.on(\"message\", function(channel, message) {\n  console.log(channel, message);\n});\n\nsub.subscribe(\"news\", function() {\n  pub.publish(\"news\", \"highlights\");\n});\n```\n\n### Events\n\n| Event        | Description                                                                                                                                                                                                |\n| :----------- | :--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| connect      | emits when a connection is established to the Redis server.                                                                                                                                                |\n| ready        | emits when `CLUSTER INFO` reporting the cluster is able to receive commands (if `enableReadyCheck` is `true`) or immediately after `connect` event (if `enableReadyCheck` is false).                       |\n| error        | emits when an error occurs while connecting with a property of `lastNodeError` representing the last node error received. This event is emitted silently (only emitting if there's at least one listener). |\n| close        | emits when an established Redis server connection has closed.                                                                                                                                              |\n| reconnecting | emits after `close` when a reconnection will be made. The argument of the event is the time (in ms) before reconnecting.                                                                                   |\n| end          | emits after `close` when no more reconnections will be made.                                                                                                                                               |\n| +node        | emits when a new node is connected.                                                                                                                                                                        |\n| -node        | emits when a node is disconnected.                                                                                                                                                                         |\n| node error   | emits when an error occurs when connecting to a node. The second argument indicates the address of the node.                                                                                               |\n\n### Password\n\nSetting the `password` option to access password-protected clusters:\n\n```javascript\nvar Redis = require(\"ioredis\");\nvar cluster = new Redis.Cluster(nodes, {\n  redisOptions: {\n    password: \"your-cluster-password\"\n  }\n});\n```\n\nIf some of nodes in the cluster using a different password, you should specify them in the first parameter:\n\n```javascript\nvar Redis = require(\"ioredis\");\nvar cluster = new Redis.Cluster(\n  [\n    // Use password \"password-for-30001\" for 30001\n    { port: 30001, password: \"password-for-30001\" },\n    // Don't use password when accessing 30002\n    { port: 30002, password: null }\n    // Other nodes will use \"fallback-password\"\n  ],\n  {\n    redisOptions: {\n      password: \"fallback-password\"\n    }\n  }\n);\n```\n\n### Special note: AWS ElastiCache Clusters with TLS\n\nAWS ElastiCache for Redis (Clustered Mode) supports TLS encryption. If you use\nthis, you may encounter errors with invalid certificates. To resolve this\nissue, construct the `Cluster` with the `dnsLookup` option as follows:\n\n```javascript\nvar cluster = new Redis.Cluster(\n  [{\n    host: 'clustercfg.myCluster.abcdefg.xyz.cache.amazonaws.com',\n    port: 6379\n  }],\n  {\n    dnsLookup: (address, callback) => callback(null, address),\n    redisOptions: {\n      tls: {}\n    },\n  }\n);\n```\n\n<hr>\n\n# Error Handling\n\nAll the errors returned by the Redis server are instances of `ReplyError`, which can be accessed via `Redis`:\n\n```javascript\nvar Redis = require(\"ioredis\");\nvar redis = new Redis();\n// This command causes a reply error since the SET command requires two arguments.\nredis.set(\"foo\", function(err) {\n  err instanceof Redis.ReplyError;\n});\n```\n\nThis is the error stack of the `ReplyError`:\n\n```\nReplyError: ERR wrong number of arguments for 'set' command\n    at ReplyParser._parseResult (/app/node_modules/ioredis/lib/parsers/javascript.js:60:14)\n    at ReplyParser.execute (/app/node_modules/ioredis/lib/parsers/javascript.js:178:20)\n    at Socket.<anonymous> (/app/node_modules/ioredis/lib/redis/event_handler.js:99:22)\n    at Socket.emit (events.js:97:17)\n    at readableAddChunk (_stream_readable.js:143:16)\n    at Socket.Readable.push (_stream_readable.js:106:10)\n    at TCP.onread (net.js:509:20)\n```\n\nBy default, the error stack doesn't make any sense because the whole stack happens in the ioredis\nmodule itself, not in your code. So it's not easy to find out where the error happens in your code.\nioredis provides an option `showFriendlyErrorStack` to solve the problem. When you enable\n`showFriendlyErrorStack`, ioredis will optimize the error stack for you:\n\n```javascript\nvar Redis = require(\"ioredis\");\nvar redis = new Redis({ showFriendlyErrorStack: true });\nredis.set(\"foo\");\n```\n\nAnd the output will be:\n\n```\nReplyError: ERR wrong number of arguments for 'set' command\n    at Object.<anonymous> (/app/index.js:3:7)\n    at Module._compile (module.js:446:26)\n    at Object.Module._extensions..js (module.js:464:10)\n    at Module.load (module.js:341:32)\n    at Function.Module._load (module.js:296:12)\n    at Function.Module.runMain (module.js:487:10)\n    at startup (node.js:111:16)\n    at node.js:799:3\n```\n\nThis time the stack tells you that the error happens on the third line in your code. Pretty sweet!\nHowever, it would decrease the performance significantly to optimize the error stack. So by\ndefault, this option is disabled and can only be used for debugging purposes. You **shouldn't** use this feature in a production environment.\n\n# Plugging in your own Promises Library\n\nIf you're an advanced user, you may want to plug in your own promise library like [bluebird](https://www.npmjs.com/package/bluebird). Just set Redis.Promise to your favorite ES6-style promise constructor and ioredis will use it.\n\n```javascript\nconst Redis = require(\"ioredis\");\nRedis.Promise = require(\"bluebird\");\n\nconst redis = new Redis();\n\n// Use bluebird\nassert.equal(redis.get().constructor, require(\"bluebird\"));\n\n// You can change the Promise implementation at any time:\nRedis.Promise = global.Promise;\nassert.equal(redis.get().constructor, global.Promise);\n```\n\n# Running tests\n\nStart a Redis server on 127.0.0.1:6379, and then:\n\n```shell\n$ npm test\n```\n\n`FLUSH ALL` will be invoked after each test, so make sure there's no valuable data in it before running tests.\n\nIf your testing environment does not let you spin up a Redis server [ioredis-mock](https://github.com/stipsan/ioredis-mock) is a drop-in replacement you can use in your tests. It aims to behave identically to ioredis connected to a Redis server so that your integration tests is easier to write and of better quality.\n\n# Debug\n\nYou can set the `DEBUG` env to `ioredis:*` to print debug info:\n\n```shell\n$ DEBUG=ioredis:* node app.js\n```\n\n# Join in!\n\nI'm happy to receive bug reports, fixes, documentation enhancements, and any other improvements.\n\nAnd since I'm not a native English speaker, if you find any grammar mistakes in the documentation, please also let me know. :)\n\n# Become a Sponsor\n\nOpen source is hard and time-consuming. If you want to invest in ioredis's future you can become a sponsor and make us spend more time on this library's improvements and new features.\n\n<a href=\"https://opencollective.com/ioredis\"><img src=\"https://opencollective.com/ioredis/tiers/sponsor.svg?avatarHeight=36\"></a>\n\nThank you for using ioredis :-)\n\n# Contributors\n\nThis project exists thanks to all the people who contribute:\n\n<a href=\"https://github.com/luin/ioredis/graphs/contributors\"><img src=\"https://opencollective.com/ioredis/contributors.svg?width=890&showBtn=false\" /></a>\n\n# License\n\nMIT\n\n[![FOSSA Status](https://app.fossa.io/api/projects/git%2Bgithub.com%2Fluin%2Fioredis.svg?type=large)](https://app.fossa.io/projects/git%2Bgithub.com%2Fluin%2Fioredis?ref=badge_large)\n","maintainers":[{"email":"ioredis-robot@zihua.li","name":"ioredis-robot"},{"email":"i@zihua.li","name":"luin"}],"time":{"modified":"2020-03-28T10:15:56.503Z","created":"2015-03-28T09:30:59.403Z","1.0.0":"2015-03-28T09:30:59.403Z","0.0.1":"2015-04-02T06:53:40.331Z","0.0.2":"2015-04-02T15:59:05.491Z","0.0.3":"2015-04-03T14:40:10.732Z","0.0.4":"2015-04-04T10:34:40.366Z","0.1.2":"2015-04-09T17:05:13.361Z","0.2.0":"2015-04-12T10:53:54.285Z","0.3.0":"2015-04-13T12:53:11.309Z","0.5.0":"2015-04-19T13:29:25.497Z","1.0.1":"2015-04-19T13:58:17.393Z","1.0.2":"2015-04-20T18:01:38.288Z","1.0.3":"2015-04-21T07:39:03.805Z","1.0.4":"2015-04-24T09:01:31.966Z","1.0.5":"2015-04-24T11:55:24.452Z","1.0.6":"2015-04-24T13:26:56.512Z","1.0.7":"2015-04-25T05:03:30.556Z","1.0.8":"2015-04-25T08:57:54.215Z","1.0.9":"2015-04-25T12:37:48.953Z","1.0.10":"2015-04-25T13:02:38.354Z","1.0.11":"2015-04-26T12:33:54.972Z","1.0.12":"2015-04-26T15:11:52.543Z","1.0.13":"2015-04-27T15:05:01.393Z","1.1.0":"2015-05-01T09:38:26.729Z","1.1.1":"2015-05-01T19:41:45.849Z","1.1.2":"2015-05-02T03:19:18.211Z","1.1.3":"2015-05-02T07:40:29.260Z","1.1.4":"2015-05-02T16:39:23.537Z","1.2.0":"2015-05-04T14:34:23.906Z","1.2.1":"2015-05-07T15:13:13.629Z","1.2.2":"2015-05-08T15:17:00.293Z","1.2.3":"2015-05-09T00:29:02.544Z","1.2.4":"2015-05-09T14:59:06.219Z","1.2.5":"2015-05-12T15:45:37.856Z","1.2.6":"2015-05-13T09:07:37.975Z","1.2.7":"2015-05-15T05:42:46.824Z","1.3.0":"2015-05-15T12:53:15.379Z","1.3.1":"2015-05-16T02:08:31.848Z","1.3.2":"2015-05-18T15:07:03.713Z","1.3.3":"2015-05-19T03:08:06.203Z","1.3.4":"2015-05-21T05:16:20.836Z","1.3.5":"2015-05-21T06:33:52.096Z","1.3.6":"2015-05-21T16:46:30.402Z","1.4.0":"2015-06-03T07:47:16.797Z","1.5.0":"2015-06-13T03:55:26.695Z","1.5.1":"2015-06-16T14:20:09.131Z","1.5.2":"2015-06-23T16:03:47.317Z","1.5.3":"2015-06-23T17:27:55.033Z","1.5.4":"2015-06-24T04:09:26.405Z","1.5.5":"2015-06-25T04:39:59.380Z","1.5.6":"2015-06-28T04:16:57.250Z","1.5.7":"2015-06-30T17:16:24.463Z","1.5.8":"2015-07-03T03:31:23.585Z","1.5.9":"2015-07-03T17:12:54.625Z","1.5.10":"2015-07-06T05:31:56.733Z","1.5.11":"2015-07-06T16:52:56.573Z","1.5.12":"2015-07-07T06:15:00.751Z","1.6.0":"2015-07-11T14:07:12.719Z","1.6.1":"2015-07-12T14:12:53.877Z","1.7.0":"2015-07-23T12:19:28.801Z","1.7.1":"2015-07-26T04:42:24.943Z","1.7.2":"2015-07-30T02:10:30.342Z","1.7.3":"2015-08-03T12:16:45.680Z","1.7.4":"2015-08-13T03:35:59.720Z","1.7.5":"2015-08-16T15:51:10.453Z","1.7.6":"2015-09-01T02:55:25.197Z","1.8.0":"2015-09-09T08:50:33.486Z","1.9.0":"2015-09-18T04:26:57.649Z","1.9.1":"2015-10-02T12:02:34.091Z","1.10.0":"2015-10-24T04:55:39.409Z","1.11.0":"2015-11-19T05:39:47.030Z","1.11.1":"2015-11-25T16:09:11.498Z","1.12.1":"2015-12-05T06:01:51.468Z","1.12.2":"2015-12-06T15:11:36.878Z","1.13.0":"2015-12-13T05:24:01.539Z","1.13.1":"2015-12-20T03:59:05.750Z","1.13.2":"2015-12-30T04:27:01.793Z","1.14.0":"2016-01-04T13:18:42.729Z","1.15.0":"2016-01-31T10:25:15.957Z","2.0.0-alpha1":"2016-02-10T07:27:01.225Z","1.15.1":"2016-02-19T04:56:53.336Z","2.0.0-alpha2":"2016-02-29T16:01:27.808Z","2.0.0-alpha3":"2016-03-13T07:27:57.487Z","2.0.0-rc1":"2016-03-18T03:03:44.873Z","2.0.0-rc2":"2016-04-10T15:55:29.285Z","2.0.0-rc3":"2016-05-02T15:11:35.420Z","2.0.0-rc4":"2016-05-08T17:03:55.854Z","2.0.0":"2016-05-29T10:53:16.281Z","2.0.1":"2016-06-01T01:14:59.427Z","2.1.0":"2016-06-22T04:05:52.288Z","2.2.0":"2016-06-28T14:42:48.561Z","2.3.0":"2016-08-11T15:07:41.357Z","2.3.1":"2016-09-24T16:34:14.145Z","2.4.0":"2016-09-24T17:59:45.373Z","2.4.1":"2016-12-04T01:21:52.929Z","2.4.2":"2016-12-04T04:05:37.308Z","2.4.3":"2016-12-15T16:33:11.176Z","2.5.0":"2017-01-06T02:44:33.386Z","3.0.0-0":"2017-01-26T05:24:56.889Z","3.0.0-1":"2017-04-16T07:04:36.972Z","3.0.0-2":"2017-05-03T15:42:58.438Z","3.0.0":"2017-05-18T16:32:28.179Z","3.1.0":"2017-05-30T05:57:39.996Z","3.1.1":"2017-05-31T05:45:12.464Z","3.1.2":"2017-07-26T01:43:28.168Z","3.1.3":"2017-08-13T13:45:40.846Z","3.1.4":"2017-08-13T14:08:37.819Z","3.2.0":"2017-10-23T16:28:32.137Z","3.2.1":"2017-10-23T16:28:56.271Z","3.2.2":"2017-11-30T05:04:37.500Z","4.0.0-0":"2018-07-01T17:16:54.849Z","4.0.0-1":"2018-07-02T03:35:58.057Z","4.0.0-2":"2018-07-07T08:40:52.716Z","4.0.0-3":"2018-07-22T15:05:47.404Z","4.0.0":"2018-08-14T15:44:09.464Z","4.0.1":"2018-10-08T05:12:47.010Z","4.0.2":"2018-10-09T07:39:34.306Z","4.1.0":"2018-10-15T17:38:15.833Z","4.2.0":"2018-10-17T11:59:30.304Z","4.2.1":"2018-10-19T15:10:50.540Z","4.2.2":"2018-10-20T05:00:47.371Z","4.2.3":"2018-11-24T14:20:41.490Z","4.3.0":"2018-12-09T04:58:51.725Z","4.3.1":"2018-12-16T14:33:03.073Z","4.4.0":"2019-01-04T15:51:09.129Z","4.5.0":"2019-01-07T16:54:32.137Z","4.5.1":"2019-01-13T17:46:20.352Z","4.6.0":"2019-01-21T03:01:59.072Z","4.6.1":"2019-01-29T17:55:45.926Z","4.6.2":"2019-02-02T15:15:41.011Z","4.6.3":"2019-02-03T05:53:28.755Z","4.7.0":"2019-03-12T08:56:11.422Z","4.8.0":"2019-03-12T15:40:00.050Z","4.9.0":"2019-03-18T04:27:56.289Z","4.9.1":"2019-03-22T14:53:53.765Z","4.9.2":"2019-05-03T17:46:59.144Z","4.9.3":"2019-05-07T08:03:19.802Z","4.9.4":"2019-05-13T14:58:45.377Z","4.9.5":"2019-05-15T04:37:46.451Z","4.10.0":"2019-05-23T15:34:44.654Z","4.10.1":"2019-06-08T08:16:15.122Z","4.10.2":"2019-06-08T13:34:03.841Z","4.10.3":"2019-06-08T20:25:08.030Z","4.10.4":"2019-06-11T08:58:12.644Z","4.11.0":"2019-06-25T15:09:31.519Z","4.11.1":"2019-06-26T03:43:31.636Z","4.11.2":"2019-07-13T16:49:58.779Z","4.12.0":"2019-07-14T19:26:49.061Z","4.12.1":"2019-07-15T07:18:41.431Z","4.12.2":"2019-07-16T15:16:37.834Z","4.13.0":"2019-07-19T06:32:37.474Z","4.13.1":"2019-07-22T05:07:47.044Z","4.14.0":"2019-07-31T04:29:46.629Z","4.14.1":"2019-08-27T02:43:55.121Z","4.14.2":"2019-10-23T08:25:59.815Z","4.14.3":"2019-11-07T06:54:10.474Z","4.14.4":"2019-11-22T17:33:19.272Z","4.15.0":"2019-11-29T08:02:57.872Z","4.15.1":"2019-12-25T04:13:57.051Z","4.16.0":"2020-02-19T17:15:35.450Z","4.16.1":"2020-03-28T10:15:53.998Z"},"keywords":["redis","cluster","sentinel","pipelining"],"author":{"name":"luin","email":"i@zihua.li","url":"http://zihua.li"},"license":"MIT","readmeFilename":"README.md","homepage":"https://github.com/luin/ioredis#readme","repository":{"type":"git","url":"git://github.com/luin/ioredis.git"},"bugs":{"url":"https://github.com/luin/ioredis/issues"},"users":{"421925268":true,"maximilianschmitt":true,"bransorem":true,"specone":true,"damianof":true,"buzuli":true,"hengkiardo":true,"jonatasnona":true,"nex":true,"ctd1500":true,"lpinca":true,"ekstergans":true,"nickeltobias":true,"fedor":true,"deryk":true,"pensierinmusica":true,"456wyc":true,"hema":true,"anthonyringoet":true,"clanfei":true,"zoomyzoom":true,"52u":true,"meta-d":true,"holly":true,"belirafon":true,"aliem":true,"tapmodo":true,"goliatone":true,"omnijeff":true,"antixrist":true,"joshuadavidson":true,"craigpatten":true,"abuelwafa":true,"mobeicaoyuan":true,"kankungyip":true,"quafoo":true,"sharper":true,"alvinl":true,"royxun":true,"nfrigus":true,"jbpionnier":true,"anlibraly":true,"largepuma":true,"miloc":true,"uncledick":true,"mfaraday":true,"coolhanddev":true,"leonzhao":true,"kodekracker":true,"kael":true,"rocket0191":true,"shaomingquan":true,"federico-garcia":true,"xinwangwang":true,"bmunoz89":true,"sopepos":true,"l3au":true,"bianlongting":true,"dburdese":true,"italoacasas":true,"shreyawhiz":true,"gzg1500521074":true,"bigp":true,"jacky3399":true,"jcottam":true,"nuwaio":true,"smituk":true,"kanreisa":true,"lgatica":true,"princetoad":true,"maxwelldu":true,"sopov":true,"iceriver2":true,"selenasong":true,"jeffyan":true,"lgh06":true,"method76":true,"gqxqd":true,"bikai":true,"yogeshkoli":true,"donecharlton":true,"morsellif":true,"edosrecki":true,"daizch":true,"yanghcc":true}}